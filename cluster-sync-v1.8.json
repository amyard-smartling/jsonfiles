{
    "url": "http://mongodb.com/docs/cluster-to-cluster-sync/v1.8",
    "includeInGlobalSearch": false,
    "documents": [
        {
            "slug": "release-notes",
            "title": "Release Notes",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "connecting",
            "title": "Connecting mongosync",
            "headings": [],
            "paragraphs": "To configure a connection with  mongosync , refer\nto the connection documentation that matches your environment: The  mongosync  utility creates a connection\nbetween MongoDB clusters.  mongosync  can make a connection between: self-managed clusters , MongoDB Atlas  hosted clusters, or a self-managed cluster and an Atlas hosted cluster. Connect Two Atlas Clusters Connect Two Self-Managed Clusters Connect a Self-Managed Cluster to Atlas",
            "code": [],
            "preview": "To configure a connection with mongosync, refer\nto the connection documentation that matches your environment:",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "",
            "title": "Cluster-to-Cluster Sync",
            "headings": [],
            "paragraphs": "Cluster-to-Cluster Sync provides continuous data synchronization or a\none-time data migration between two MongoDB clusters. You can enable\nCluster-to-Cluster Sync with the  mongosync  utility. mongosync  can continuously synchronize data between two clusters.\nYou can use  mongosync  to create dedicated analytics, development,\nor testing clusters that mirror your production environment.\nSynchronized clusters can also support locality requirements for audit\nand data residency compliance. In addition to continuous data synchronization,  mongosync  can also\nfacilitate a one time data migration between clusters. To get started with  mongosync , refer to the  Quick Start Guide . For more detailed information, refer to the\n Installation  or  Connecting  mongosync  page that best fits your\nsituation. See also the  Limitations  page for important\nrestrictions. The  Frequently Asked Questions (FAQ)  page addresses\ncommon questions users have asked about  mongosync . MongoDB Cluster-to-Cluster Sync 1.8 is not yet\navailable. This version of the documentation is for an upcoming release and\nis currently a work in progress. mongosync  does not check for compliance with the\n documented limitations . Please ensure that\nyour application is not affected by the limitations. Running  mongosync  in the presence of one of  these\nlimitations  could lead to undefined behavior on\nthe destination cluster.",
            "code": [],
            "preview": "Cluster-to-Cluster Sync provides continuous data synchronization or a\none-time data migration between two MongoDB clusters. You can enable\nCluster-to-Cluster Sync with the mongosync utility.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "installation",
            "title": "Installation",
            "headings": [],
            "paragraphs": "These documents provide instructions to install MongoDB Cluster-to-Cluster Sync. Install the official builds of Cluster-to-Cluster Sync on Linux-based operating systems. Install the official build of Cluster-to-Cluster Sync on macOS.",
            "code": [],
            "preview": "These documents provide instructions to install MongoDB Cluster-to-Cluster Sync.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "using-mongosync",
            "title": "Using mongosync",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference",
            "title": "Reference",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "faq",
            "title": "Frequently Asked Questions",
            "headings": [
                "Can I perform reads or writes to my destination cluster while mongosync is syncing?",
                "Can mongosync run on its own hardware?",
                "Should I increase the size of the oplog in the source cluster?",
                "Which connection string options does mongosync allow?",
                "Which security and authentication options are supported?",
                "Can I configure mongosync for high availability?",
                "Can the source or destination be a replica set with arbiters?",
                "What if I see a Slow Operation Warning?",
                "Should I stop a migration if the logs contain the word \"error\" or \"failure\"?",
                "Does mongosync Support TTL Indexes?"
            ],
            "paragraphs": "This page provides answers to some frequently asked questions we have\nencountered. If you have additional questions please contact MongoDB\nSupport. You can perform reads during synchronization if  canCommit  is  true .\nHowever, the data that you read is\n eventually consistent , meaning that you might not\nalways read the latest writes. During an ongoing sync, you can write to any non-synced namespaces in the\ndestination cluster as long as the source cluster doesn\u2019t include a namespace\nwith the same name. If you write to a synced namespace before issuing a\n commit  and while  canWrite  is  false , the behavior\nis undefined. To avoid this undefined behavior, you can enable\n write blocking . To check the value of  canCommit  or  canWrite , call the  progress  API endpoint. Yes,  mongosync  can run on its own hardware.  mongosync  does not\nhave to run on the servers that host your MongoDB instances. When\n mongosync  runs on its own hardware, it can use an operating system\n(OS) that is different than the OS on the source or destination\nclusters. mongosync  applies operations in the  oplog  on the source cluster\nto the data on the destination cluster.  When operations\nthat  mongosync  has not applied roll off the  oplog \non the source cluster, the sync fails and  mongosync  exits. Starting in version 1.5.0,  mongosync  enables Oplog Rollover\nResilience (ORR).  With ORR,   mongosync  applies changes on the\nsource cluster to the destination cluster during the initial sync. ORR\nincreases the resilience of  mongosync  to oplog rollover but does not\nprevent rollover entirely. You might exceed the oplog window if you: To increase the size of the  oplog  on the source cluster, use\n oplogSizeMB . For more information, see\n Change Oplog Size  and\n Workloads that Might Requre a Large Oplog Size . mongosync  does not replicate  applyOps  operations made on\nthe source cluster during sync to the destination cluster. Sync from a high write rate source cluster for an extended\nperiod. Pause sync for an extended period. mongosync  requires  readConcern: \"majority\" \nand  writeConcern: \"majority\" . If the  readConcern  is not  majority ,  mongosync  returns an\nerror: If the  writeConcern  is not  majority ,  mongosync  returns an\nerror: mongosync  accepts all other  connection string options . mongosync  uses a standard MongoDB  connection string  to connect to the source and destination clusters. LDAP  and  X509  are supported. For available\nauthentication options, see  Authentication . There is no automatic failover built into  mongosync . However you\ncan write a script or use your operating system's process managers,\n systemd  for example, to restart the  mongosync  process. The  mongosync  binary is stateless. The metadata for restarting is\nstored on the destination cluster. A  mongosync  operation can be resumed if  mongosync  becomes\nunavailable during synchronization. When  mongosync  becomes\navailable again, restart the  mongosync  process with the same\nparameters.  mongosync  resumes the operation from where it stopped\nwhen  mongosync  became unavailable. Yes, the replica set can have arbiters. The source replica set must\nhave more than 2 non-arbiter nodes and you must sync from a non-arbiter\nnode. Use the source cluster's connection string to specify a\n read preference  for a non-arbiter, data-bearing\nnode. Slow operation warnings can occur during the initial sync or the application\nof a change event when there is a slow read operation on the source cluster\nor a slow write operation on the destination cluster.  The warning may\nindicate network congestion or resource strain on the source or destination\ncluster. While these warnings do not indicate failures in themselves, slow operations\ncan cause operation timeout errors in  mongosync  and migration failures. If you see slow operation warnings, check CPU, memory, and network usage on the\nsource and destination clusters.  If the clusters are underprovisioned for your\nneeds, consider upgrading the cluster hardware. No, logs that contain the word \"error\" or \"failure\" show non-fatal\nerrors and do not signal that you need to stop  mongosync  early.\nThese logs do not indicate that  mongosync  is failing or corrupting\ndata. If a fatal error occurs,  mongosync  stops the sync and writes a\nfatal log entry. Cluster-to-Cluster Sync supports syncing  TTL Indexes  from the source\nto the destination cluster.",
            "code": [
                {
                    "lang": "shell",
                    "value": "Invalid URI option, read concern must be majority"
                },
                {
                    "lang": "shell",
                    "value": "Invalid URI option, write concern must be majority"
                }
            ],
            "preview": "This page provides answers to some frequently asked questions we have\nencountered. If you have additional questions please contact MongoDB\nSupport.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "multiple-mongosyncs",
            "title": "Use mongosync on Sharded Clusters",
            "headings": [
                "Configure a Single mongosync Instance",
                "Configure Multiple mongosync Instances",
                "Verify cluster configuration",
                "Determine the shard IDs",
                "Connect the mongosync instances",
                "Start Multiple mongosync Instances",
                "Performance",
                "Check Progress",
                "Pause a mongosync Instance",
                "Resume Synchronization",
                "Commit Synchronization From  Multiple mongosync Instances",
                "Data Verification",
                "Reverse the Synchronization Direction"
            ],
            "paragraphs": "There are two ways to synchronize  sharded clusters . You can use either one  mongosync  or several\n mongosync  instances. For best performance with large or heavily\nloaded clusters, use one  mongosync  instance for each shard on the\nsource cluster. To configure a single  mongosync , follow the  connection\ninstructions  for your cluster architecture to\nconnect to the  mongos  instance in your cluster. When you connect a single  mongosync  to a sharded cluster do not use\nthe  replicaSet  option or the  id \noption. The rest of this page addresses cluster to cluster synchronization\nusing multiple  mongosync  instances. The number of  mongosync  instances must match the number of shards on\nthe source cluster. You must use the same version of  mongosync \nbetween all instances. For a replica set source, you can only use one\n mongosync  instance. To configure multiple  mongosync  instances: When you configure multiple  mongosync  instances to sync between\nsharded clusters, you must send identical API endpoint commands to each\n mongosync  instance. Verify cluster configuration Determine the shard IDs Connect the instances Starting in  mongosync  1.1, you can sync between clusters with\ndifferent numbers of shards. However, if you want to reverse the\nsync, the source cluster and destination cluster must have the\nsame number of shards. To get the shard IDs, connect to the source cluster\n mongos  and run the  listShards  command. The information is in the  shards  array. These instructions use a generic connection string. To modify the\nconnection string for your cluster architecture, refer to the\narchitecture specific  connection details . Run the first  mongosync  instance: When running multiple  mongosync  instances, the number of instances\nmust equal the number of shards.  Each  mongosync  instance must be\nstarted with the  --id  option or  id  setting to\nspecify the shard it replicates. Run a new  mongosync  instance for each shard in the source cluster.\nEdit the  --id  and  --port  fields for each additional\n mongosync  instance. The connection strings for the  --cluster0  and\n --cluster1  options should point to  mongos  instances.\nIn the example, they use the same  mongos  instance. Each  mongosync  instance: A single host server can run multiple  mongosync  instances. To\nimprove performance, run  mongosync  on multiple host servers. Connects to  mongos  instances in the source cluster. Connects to  mongos  instances in the destination cluster. Replicates a single shard from the source cluster,\nidentified by the  --id  option. Specifies a unique port to use during synchronization.\nConsider designating a range of ports to simplify scripting\nCluster-to-Cluster Sync operations. Use  curl  or another HTTP client to issue the  start  command to each of the  mongosync  instances. The  start  command options must be the same for all of the  mongosync \ninstances. If the destination is a sharded cluster with the balancer enabled, write\nperformance of the destination cluster may degrade during  mongosync 's\nCollection Copy phase. To warn of this potential performance impact,\n mongosync  runs the  sh.getBalancerState()  command during\ninitialization. If  getBalancerState()  returns  true ,  mongosync \nlogs a warning. If write performance during migration is impacted, consider disabling the\nbalancer on the destination cluster. You stop the balancer with the\n balancerStop  command, and restart it with the\n balancerStart  command. To review synchronization progress for a particular\nshard, use  curl  or another HTTP client to issue the\n progress  command to the  mongosync \ninstance syncing that shard. This command checks the progress of the  mongosync  instance that is\nrunning on  mongosync02Host  and using  port 27602  for\nsynchronization. To check progress on other shards, update the host and\nport number then repeat the API call to each  mongosync  instance. The  pause  command will temporarily halt the\nsynchronization process on a single shard. It does not pause any other\n mongosync  instances that may be running. Use  curl  or another\nHTTP client to issue the  pause  command to a  mongosync  instance. This command pauses the  mongosync  instance that is running on\n mongosync01Host  and using  port 27601  for synchronization. To\npause synchronization on other shards, update the host and port number\nthen repeat the API call to each  mongosync  instance. If one or more  mongosync  instances are paused, you can use the\n resume  command to resume syncing. Run a\nseparate  resume  command against each paused  mongosync  instance\nto continue syncing. Use  curl  or another HTTP client to issue the  resume  command to each  mongosync  instance. This command resumes synchronization on the  mongosync  instance that\nis running on  mongosync01Host  and using  port 27601 .  To\nresume synchronization on other shards, update the host and port number\nthen repeat the API call to each  mongosync  instance. When you want to complete synchronization, issue the  progress  command and check the values for  canCommit \nand  lagTimeSeconds . To minimize write blocking on the source cluster, you should only run\nthe  commit  command when the  lagTimeSeconds  value is small enough for your application. If the  lagTimeSeconds  value is small enough, and  canCommit  is\n true , issue the  commit  command to commit\nsynchronization. Repeat the process on all of the  mongosync \ninstances. The  commit  operation is blocking. The  commit  command will not\nreturn until  commit  has been called on every  mongosync \ninstance. These commands only check progress and commit synchronization for the\n mongosync  instance that is running on  mongosync01Host  and using\n port 27601 . To synchronize all of the shards, make additional calls\nto  progress  and   commit  on any other  mongosync  instances\nthat may be running. Before transferring your application load from the source cluster to the\ndestination, check your data to ensure that the sync was successful. For more information, see  Verify Data Transfer . To reverse synchronization so that the original destination cluster\nacts as the source cluster: The  reverse  operation is blocking. The  reverse  command will not\nreturn until  reverse  has been called on every  mongosync \ninstance. This command reverses synchronization on the  mongosync \ninstance that is running on  mongosync01Host  and using  port\n27601 . Make additional calls to  reverse  on any other\n mongosync  instances that may be running. If you have not already done so, issue the  commit  command to each  mongosync  instance and wait\nuntil all of the commits to finish. To check if the sync process has been\ncommitted, issue the  progress  command to all\n mongosync  instances and see if each response's  state  field contains\nthe value  COMMITTED . Issue the  reverse  command to each\n mongosync  instance. Reverse synchronization is only possible if  reversible  and\n enableUserWriteBlocking  are both set to  true  when the\n start API  initiates  mongosync .",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.adminCommand( { listShards: 1 } )"
                },
                {
                    "lang": "javascript",
                    "value": "  shards: [\n    {\n      _id: 'shard01',\n      host: 'shard01/localhost:27501,localhost:27502,localhost:27503',\n      state: 1,\n      topologyTime: Timestamp({ t: 1656612236, i: 2 })\n    },\n    {\n      _id: 'shard02',\n      host: 'shard02/localhost:27504,localhost:27505,localhost:27506',\n      state: 1,\n      topologyTime: Timestamp({ t: 1656612240, i: 4 })\n    }\n  ]"
                },
                {
                    "lang": "javascript",
                    "value": "mongosync \\\n  --cluster0 \"mongodb://user:password@cluster0host:27500\" \\\n  --cluster1 \"mongodb://user:password@cluster1host:27500\" \\\n  --id shard01 --port 27601"
                },
                {
                    "lang": "javascript",
                    "value": " mongosync \\\n   --cluster0 \"mongodb://user:password@cluster0host:27500\" \\\n   --cluster1 \"mongodb://user:password@cluster1host:27500\" \\\n   --id shard02 --port 27602"
                },
                {
                    "lang": "shell",
                    "value": "curl mongosync01Host:27601/api/v1/start -XPOST --data \\\n     '{ \"source\": \"cluster0\", \"destination\": \"cluster1\", \\\n        \"reversible\": false, \"enableUserWriteBlocking\": false }'\n\ncurl mongosync02Host:27602/api/v1/start -XPOST --data \\\n     '{ \"source\": \"cluster0\", \"destination\": \"cluster1\", \\\n        \"reversible\": false, \"enableUserWriteBlocking\": false }'"
                },
                {
                    "lang": "shell",
                    "value": "curl mongosync02Host:27602/api/v1/progress -XGET"
                },
                {
                    "lang": "shell",
                    "value": "curl mongosync01Host:27601/api/v1/pause -XPOST --data '{}'"
                },
                {
                    "lang": "shell",
                    "value": "curl mongosync01Host:27601/api/v1/resume -XPOST --data '{}'"
                },
                {
                    "lang": "shell",
                    "value": "// Check progress\ncurl mongosync01Host:27601/api/v1/progress -XGET\n\n// Commit\ncurl mongosync01Host:27601/api/v1/commit -XPOST --data '{}'"
                },
                {
                    "lang": "shell",
                    "value": "curl mongosync01Host:27601/api/v1/reverse -XPOST --data '{}'"
                }
            ],
            "preview": "There are two ways to synchronize sharded clusters. You can use either one mongosync or several\nmongosync instances. For best performance with large or heavily\nloaded clusters, use one mongosync instance for each shard on the\nsource cluster.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "quickstart",
            "title": "Quickstart",
            "headings": [
                "Overview",
                "Setup",
                "Define a source and a destination cluster",
                "Define administrative users",
                "Source Cluster Authentication Requirements",
                "Destination Cluster Authentication Requirements",
                "Cluster Authentication Notes",
                "Download and install mongosync",
                "Connect the Clusters",
                "Format your connection strings",
                "Initialize mongosync",
                "Initialization Notes",
                "Synchronize Data Between Clusters",
                "One-Time Sync",
                "Data Verification",
                "Synchronization Notes"
            ],
            "paragraphs": "MongoDB Cluster-to-Cluster Sync connects MongoDB clusters and provides a way\nto synchronize data between them. The tool that makes the connection is\n mongosync . This page provides a short introduction to help\nyou get started with Cluster-to-Cluster Sync. For more details, please see\nthe rest of the Cluster-to-Cluster Sync documentation. mongosync  syncs data between two clusters. Follow the instructions below to set up Cluster-to-Cluster Sync, connect\nyour clusters, and synchronize your data. Each cluster can be a replica set or a sharded cluster.  If either\nis a sharded cluster, consult the  sharded cluster limitations  for  mongosync . Sharded clusters are not required to have the same number of shards. The destination cluster must be the same version or up to two versions ahead\nof the source cluster. The patch version is not important, so long as they\nmeets the minimum patch  version requirements . If you already have a MongoDB cluster, either self-managed or\nhosted in  MongoDB Atlas ,\nuse that cluster as the source cluster. If you don't have a\ncluster to work with, you will need to create one. This Quickstart works when the destination cluster and the source\ncluster are both replica sets. To sync from a replica set to a\nsharded cluster, or between sharded clusters, see:\n Use  mongosync  on Sharded Clusters . The number of nodes in the destination replica set does not have\nto equal the number of nodes in the source replica set. If your clusters are self-managed, they must be MongoDB\nEnterprise clusters. Cluster-to-Cluster Sync is only supported on\nMongoDB Community Edition in a limited number of cases. For more\ninformation on using Cluster-to-Cluster Sync with MongoDB Community\nEdition, contact a MongoDB sales representative. Creating a cluster is beyond the scope of this guide. If you need\nhelp, refer to the documentation to create an  Atlas cluster  or to create a  self-managed cluster . You can migrate between clusters on the same or different\nMongoDB versions. For more information on MongoDB server\nversion compatibility or cross-version migrations, see\n MongoDB Server Version Compatibility . If either cluster is hosted in Atlas, or if either of them\nrequires authentication, you must create a database user that has\npermissions in both clusters. The source user must have the following roles: In addition, the source user must be able to: If the source cluster is hosted in Atlas, the user must have the\n Atlas admin  role. The user must\nalso be able to read the  change stream  for\nthe cluster. readAnyDatabase  role clusterMonitor  role backup  role Run the  getParameter  command If the destination cluster is hosted in Atlas, the user must have\nthe  Atlas admin  role. To add an Atlas user, see:  Configure Database Users . To add a user to a self-managed cluster, see:  Create a User . To verify user permissions, run  db.getUser() . mongosync  is the tool that connects the source and\ndestination clusters. You can host  mongosync  on its own\nhardware,  mongosync  does not have to run on the hardware that\nhosts your MongodDB clusters. To install  mongosync : For operating system specific installation instructions, see\n Installation . Locate a host server for the  mongosync  executable that has\nnetwork connectivity to your source and destination clusters. Go to the  MongoDB Download Center . Download the  mongosync  package for your host system. Unpack the  mongosync  package. The  mongosync  executable\nis in the  bin  directory. A connection string contains the network and authentication\ndetails that  mongosync  needs to connect to the source and\ndestination clusters. Determine the hostname or IP address and port for your source and\ndestination clusters. You will use this information and the user\nauthentication details to construct the connection strings. The standard URI connection scheme has the form: Your connections strings will resemble: For more details, see  Connecting  mongosync . mongosync  must create an initial connection to the source and\ndestination clusters before it can start to sync data. To create the initial\nconnection, issue the following command with your connection\nstrings on a single line (the command is\nreformatted here for clarity): When  mongosync  first connects to the source and destination\nclusters it is in the  IDLE  state. mongosync  does not synchronize data until it receives the\n start  command. Designate the source and destination clusters with the  start  command. \"cluster0\" and \"cluster1\" are just labels,\neither cluster can be  cluster0  or  cluster1 . The  start  endpoint initiates data synchronization.\nTo start syncing, use  curl  or a similar program to issue the\n start  request: If the  start  request is successful,  mongosync \nreturns  { \"success\": true }  and starts to synchronize existing data on\nthe source cluster with the destination cluster. At this point,\n mongosync  enters the  RUNNING  state and applies subsequent source\ncluster writes to the destination cluster. To check the status of the sync, call the  progress  endpoint: If the  progress  response includes the\nfield  canCommit: true , the clusters are in sync and the destination\ncluster continuously replicates data from the source cluster. The command interface for  mongosync  is an HTTP server that publishes\nan HTTP API. To control  mongosync , use the API endpoints. The API\ndocumentation provides details on using the following endpoints: Endpoint Description start Starts the synchronization between a source and destination\ncluster. progress Returns the status of the synchronization process. pause Pauses the current synchronization operation. resume Resumes a paused synchronization session based on data stored on\nthe destination cluster. commit Commits the synchronization operation to the destination\ncluster. reverse Reverses the direction of a committed sync operation. After initializing data synchronization, call the  progress  endpoint to see the status of the synchronization\nprocess: For a one time sync, verify that the  progress  response includes the\nfollowing field values: Then, call the  commit  endpoint to commit the\nsynchronization operation to the destination cluster and stop continuous\nreplication: If the  commit  request is successful,  mongosync  returns\n { \"success\": true }  and enters the  COMMITTING  state. After the sync\nis complete,  mongosync  enters the  COMMITTED  state and the\nclusters are no longer in continuous sync. state: \"RUNNING\" canCommit: true lagTimeSeconds  is near  0  ( Recommended, but not required ) Before transferring your application load from the source cluster to the\ndestination, check your data to ensure that the sync was successful. For more information, see  Verify Data Transfer . The default port for the HTTP API is  27182 .  Use the  --port \noption with  mongosync  to  configure another port mongosync  can swap the source and destination clusters to enable\n reverse synchronization . For more information, see the  reverse  endpoint. To determine the correct the user permissions for your use case, see\n User Permissions . The user specified in the  mongosync  connection string must have the\nrequired permissions on the source and destination clusters. The\npermissions vary depending on your environment and if you want to run a\nwrite-blocking or reverse sync. You may need to increase the file descriptor  ulimits  on the host\nthat is running  mongosync . This applies to any UNIX-like system,\nbut macOS in particular has low defaults. See  UNIX ulimit\nsettings . To estimate the size of  oplog  needed for initial synchronization,\nsee  oplog Sizing .",
            "code": [
                {
                    "lang": "shell",
                    "value": "mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]"
                },
                {
                    "lang": "shell",
                    "value": "cluster0:\nmongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020\ncluster1:\nmongodb://clusterAdmin:superSecret@clusterTwo01.fancyCorp.com:20020,clusterTwo02.fancyCorp.com:20020,clusterTwo03.fancyCorp.com:20020"
                },
                {
                    "lang": "shell",
                    "value": "./bin/mongosync \\\n      --logPath /var/log/mongosync \\\n      --cluster0 \"mongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020\" \\\n      --cluster1 \"mongodb://clusterAdmin:superSecret@clusterTwo01.fancyCorp.com:20020,clusterTwo02.fancyCorp.com:20020,clusterTwo03.fancyCorp.com:20020\""
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/start -XPOST \\\n--data '\n   {\n      \"source\": \"cluster0\",\n      \"destination\": \"cluster1\"\n   } '\n"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/progress -XGET\n"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/progress -XGET\n"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/commit -XPOST --data '{ }'\n"
                }
            ],
            "preview": "MongoDB Cluster-to-Cluster Sync connects MongoDB clusters and provides a way\nto synchronize data between them. The tool that makes the connection is\nmongosync. This page provides a short introduction to help\nyou get started with Cluster-to-Cluster Sync. For more details, please see\nthe rest of the Cluster-to-Cluster Sync documentation.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "connecting/onprem-to-onprem",
            "title": "Connect Two Self-Managed Clusters",
            "headings": [
                "Connection Strings",
                "Authentication",
                "Roles",
                "Behavior",
                "Hosting",
                "Initial State",
                "Example",
                "Gather Connection Information",
                "Connect the Source and Destination Clusters with mongosync"
            ],
            "paragraphs": "This page provides instructions to connect self-managed clusters using\nMongoDB Cluster-to-Cluster Sync. The  mongosync  utility creates a connection\nbetween MongoDB clusters.  mongosync  can make a connection between: self-managed clusters , MongoDB Atlas  hosted clusters, or a self-managed cluster and an Atlas hosted cluster. mongosync  uses a  MongoDB URI\nconnection string  to connect clusters: Specify the hostnames of the  mongod  instances the same way\nthat they are listed in your replica set configuration. For  sharded clusters , specify the\nhostnames of the  mongos  instances instead of the\n mongod  instances. The SRV connection scheme has the form: The standard URI connection scheme has the form: mongosync  does not require the  replicaSet  option. You can also specify read preference on a per-connection basis in the\nconnection string. By default,  mongosync  sets the source cluster\nread preference to  nearest  to distribute reads evenly across\nnodes. For more information on setting read preference in connection\nstrings, see  Read Preference Options . If either the source or destination cluster requires authentication,\nyou must give the correct credentials when calling  mongosync . The self-managed permissions are: The user specified in the  mongosync  connection string must have the\nrequired permissions on the source and destination clusters. The\npermissions vary depending on your environment and if you want to run a\nwrite-blocking or reverse sync. For details on server roles, see:  Role-Based Access Control . To update user permissions, see:  grantRolesToUser . Sync Type Required Source Permissions Required Destination Permissions Default backup clusterMonitor readAnyDatabase clusterManager clusterMonitor readWriteAnyDatabase restore Write-blocking backup clusterManager clusterMonitor readWriteAnyDatabase restore backup clusterManager clusterMonitor readWriteAnyDatabase restore Reversing backup clusterManager clusterMonitor readWriteAnyDatabase restore backup clusterManager clusterMonitor dbAdmin readWriteAnyDatabase restore The  mongosync  utility can be hosted on its own hardware close to\neither the source or destination cluster. It does not have to be hosted\non the same server as one of the  mongod  or  mongos \ninstances in the cluster. This flexibility allows you to push, or pull,\ndata to the destination cluster with minimal impact on the\n mongod  or  mongos  instances running there. When  mongosync  connects, it is in the  IDLE  state. You must\nissue the  start  command to begin syncing. The source cluster,  cluster0 , is hosted on the following servers\nand ports: The destination cluster,  cluster1 , is hosted on the following\nservers and ports: There is an administrative user,  clusterAdmin  configured on each\ncluster with password,  superSecret . clusterOne01.fancyCorp.com:20020 clusterOne02.fancyCorp.com:20020 clusterOne03.fancyCorp.com:20020 clusterTwo01.fancyCorp.com:20020 clusterTwo02.fancyCorp.com:20020 clusterTwo03.fancyCorp.com:20020 The generic connection string format is: Use the connection information you gathered to create the connection\nstrings for  cluster0  and  cluster1 : The  mongosync  command layout below is modified for display. To\nconnect  cluster0  to  cluster1  with  mongosync , enter the\nfollowing command on one line: You can also use  mongodb+srv  connection strings with  mongosync .\nYou do not need to add the  tls=true  option to a\n mongodb+srv  connection string. For example: For more details about  mongodb+srv  connection strings, see\n SRV Connection Format .",
            "code": [
                {
                    "lang": "none",
                    "value": "mongodb+srv://[username:password@][host.domain.TLD][:port][/defaultauthdb][?options]"
                },
                {
                    "lang": "none",
                    "value": "mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]"
                },
                {
                    "lang": "shell",
                    "value": "mongodb://<user>:<password>@<ip-address>:<port>,<ip-address>:<port>,<ip-address>:<port>"
                },
                {
                    "lang": "shell",
                    "value": "cluster0:\nmongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020\ncluster1:\nmongodb://clusterAdmin:superSecret@clusterTwo01.fancyCorp.com:20020,clusterTwo02.fancyCorp.com:20020,clusterTwo03.fancyCorp.com:20020"
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n      --cluster0 \"mongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020\" \\\n      --cluster1 \"mongodb://clusterAdmin:superSecret@clusterTwo01.fancyCorp.com:20020,clusterTwo02.fancyCorp.com:20020,clusterTwo03.fancyCorp.com:20020\""
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n   --cluster0 \"mongodb+srv://clusterAdmin:superSecret@clusterOne01.fancyCorp.com/\" \\\n   --cluster1 \"mongodb+srv://clusterAdmin:superSecret@clusterTwo01.fancyCorp.com/\""
                }
            ],
            "preview": "This page provides instructions to connect self-managed clusters using\nMongoDB Cluster-to-Cluster Sync.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "installation/install-on-linux",
            "title": "Install on Linux",
            "headings": [
                "Overview",
                "Cluster-to-Cluster Sync Version",
                "Considerations",
                "Platform Support",
                "Version Requirements",
                "Install Cluster-to-Cluster Sync",
                "Download the tarball.",
                "Extract the files from the downloaded archive.",
                "Ensure the binary is in a directory listed in your PATH environment variable.",
                "Run Cluster-to-Cluster Sync"
            ],
            "paragraphs": "To configure MongoDB Cluster-to-Cluster Sync on Linux using a downloaded\n .tgz  tarball, follow the steps on this page. Cluster-to-Cluster Sync is available on select platforms. This tutorial installs the latest version of  mongosync . Cluster-to-Cluster Sync is available on the following Linux operating\nsystems: Amazon Linux 2 Red Hat Enterprise Linux (RHEL) 7 Red Hat Enterprise Linux (RHEL) 8 Ubuntu 18.04 Ubuntu 20.04 Cluster-to-Cluster Sync supports synchronization between clusters. For information\non MongoDB server version compatibility, see\n MongoDB Server Version Compatibility . Follow these steps to manually install Cluster-to-Cluster Sync from\nthe  .tgz . Download the Cluster-to-Cluster Sync  .tgz  tarball from the\nfollowing link: \u27a4   MongoDB Download Center In the  Version  dropdown, select the version of\nCluster-to-Cluster Sync to download. In the  Platform  dropdown, select your\n Linux  platform. In the  Package  dropdown, select\n shell (tgz) . Click  Download . To extract  mongosync , use the  tar  command in a system\nshell: The  mongosync  binary is in the  bin/  directory of the\nunpacked tarball. To add the location of the  mongosync  binary to\nyour  PATH , do one of the following: Copy the binary into a directory listed in your  PATH \nvariable, such as  /usr/local/bin . (Update\n /path/to/mongosync/bin  to reflect the location where you\nextracted the  tar  file.) Create symbolic links to the  mongosync  binary from a\ndirectory such as  /usr/local/bin  that is already in your\n PATH . (Update  /path/to/mongosync/bin  to reflect the\nlocation where you extracted the  tar  file.) To run and administer  mongosync , see  Using  mongosync .",
            "code": [
                {
                    "lang": "bash",
                    "value": "tar -zxvf mongosync-*.tgz"
                },
                {
                    "lang": "bash",
                    "value": "sudo cp /path/to/mongosync/bin/mongosync /usr/local/bin/"
                },
                {
                    "lang": "bash",
                    "value": "sudo ln -s  /path/to/mongosync/bin/mongosync /usr/local/bin/mongosync"
                }
            ],
            "preview": "To configure MongoDB Cluster-to-Cluster Sync on Linux using a downloaded\n.tgz tarball, follow the steps on this page.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "installation/install-on-macos",
            "title": "Install on macOS",
            "headings": [
                "Overview",
                "Cluster-to-Cluster Sync Version",
                "Considerations",
                "Platform Support",
                "Version Requirements",
                "Install Cluster-to-Cluster Sync",
                "Download the ZIP file.",
                "Unzip the files from the downloaded archive.",
                "Ensure the binary is in a directory listed in your PATH environment variable.",
                "Run Cluster-to-Cluster Sync"
            ],
            "paragraphs": "To configure MongoDB Cluster-to-Cluster Sync on macOS using a downloaded\nZIP file, follow the steps on this page. This tutorial installs the latest version of  mongosync . MongoDB Cluster-to-Cluster Sync 1.7 supports macOS 10.14 or later. Cluster-to-Cluster Sync supports synchronization between clusters. For information\non MongoDB server version compatibility, see\n MongoDB Server Version Compatibility . Follow these steps to manually install Cluster-to-Cluster Sync from\nthe ZIP file. Download the Cluster-to-Cluster Sync ZIP file from the following\nlink: \u27a4   MongoDB Download Center In the  Version  dropdown, select the version of\nCluster-to-Cluster Sync to download. In the  Platform  dropdown, select your  macOS \nplatform. In the  Package  dropdown, select  zip . Click  Download . To unzip  mongosync , use the  unzip  command in a system\nshell: The  mongosync  binary is in the  bin/  directory of the\nunpacked tarball. To add the location of the  mongosync  binary to\nyour  PATH , do one of the following: Copy the binary into a directory listed in your  PATH \nvariable, such as  /usr/local/bin . (Update\n /path/to/mongosync/bin  to reflect the location where you\nextracted the  tar  file.) Create symbolic links to the  mongosync  binary from a\ndirectory such as  /usr/local/bin  that is already in your\n PATH . (Update  /path/to/mongosync/bin  to reflect the\nlocation where you extracted the  tar  file.) To run and administer  mongosync , see  Using  mongosync .",
            "code": [
                {
                    "lang": "bash",
                    "value": "unzip mongosync-*.zip"
                },
                {
                    "lang": "bash",
                    "value": "sudo cp /path/to/mongosync/bin/mongosync /usr/local/bin/"
                },
                {
                    "lang": "bash",
                    "value": "sudo ln -s  /path/to/mongosync/bin/mongosync /usr/local/bin/mongosync"
                }
            ],
            "preview": "To configure MongoDB Cluster-to-Cluster Sync on macOS using a downloaded\nZIP file, follow the steps on this page.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "connecting/onprem-to-atlas",
            "title": "Connect a Self-Managed Cluster to Atlas",
            "headings": [
                "Connection Strings",
                "Authentication",
                "Roles",
                "Behavior",
                "Hosting",
                "Initial State",
                "Limitations",
                "Example",
                "Gather Connection Information",
                "Connect the Source and Destination Clusters with mongosync"
            ],
            "paragraphs": "This page provides instructions to connect a self-managed cluster to an\nAtlas cluster using MongoDB Cluster-to-Cluster Sync. For additional details on connecting to an Atlas cluster, see\n Connect to a Database Deployment The  mongosync  utility creates a connection\nbetween MongoDB clusters.  mongosync  can make a connection between: self-managed clusters , MongoDB Atlas  hosted clusters, or a self-managed cluster and an Atlas hosted cluster. mongosync  uses a  MongoDB URI\nconnection string  to connect self-managed clusters: Specify the hostnames of the  mongod  instances the same way\nthat they are listed in your replica set configuration. For  sharded clusters , specify the\nhostnames of the  mongos  instances instead of the\n mongod  instances. The SRV connection scheme has the form: The standard URI connection scheme has the form: mongosync  does not require the  replicaSet  option. You can also specify read preference on a per-connection basis in the\nconnection string. By default,  mongosync  sets the source cluster\nread preference to  nearest  to distribute reads evenly across\nnodes. For more information on setting read preference in connection\nstrings, see  Read Preference Options . mongosync  uses a  MongoDB URI\nconnection string  to connect Atlas clusters: The SRV connection scheme has the form: For information on how to find your SRV connection\nstring in Atlas, see  Connect to Your Cluster . The standard URI connection scheme has the form: You can also specify read preference on a per-connection basis in the\nconnection string. By default,  mongosync  sets the source cluster\nread preference to  nearest  to distribute reads evenly across\nnodes. For more information on setting read preference in connection\nstrings, see  Read Preference Options . Provide valid authentication to connect to a  MongoDB Atlas  cluster. If you do not already have an Atlas database user,\nyou must  create a user . If either the source or destination cluster requires authentication,\nyou must give the correct credentials when calling  mongosync . The self-managed permissions are: The Atlas permissions are: The user specified in the  mongosync  connection string must have the\nrequired permissions on the source and destination clusters. The\npermissions vary depending on your environment and if you want to run a\nwrite-blocking or reverse sync. For details on server roles, see:  Role-Based Access Control . To update user permissions, see:  grantRolesToUser . Sync Type Required Source Permissions Required Destination Permissions Default backup clusterMonitor readAnyDatabase clusterManager clusterMonitor readWriteAnyDatabase restore Write-blocking backup clusterManager clusterMonitor readWriteAnyDatabase restore backup clusterManager clusterMonitor readWriteAnyDatabase restore Reversing backup clusterManager clusterMonitor readWriteAnyDatabase restore backup clusterManager clusterMonitor dbAdmin readWriteAnyDatabase restore For details on Atlas roles, see:  Atlas User Roles . To update Atlas user permissions, see:\n Manage Access to a Project . Sync Type Target Required Permissions default source cluster atlasAdmin backup default destination cluster atlasAdmin write-blocking or reversing source cluster atlasAdmin backup bypassWriteBlockMode privilege write-blocking or reversing destination cluster atlasAdmin backup bypassWriteBlockMode privilege The  mongosync  utility can be hosted on its own hardware close to\neither the source or destination cluster. It does not have to be hosted\non the same server as one of the  mongod  or  mongos \ninstances in the cluster. This flexibility allows you to push, or pull,\ndata to the destination cluster with minimal impact on the\n mongod  or  mongos  instances running there. When  mongosync  connects, it is in the  IDLE  state. You must\nissue the  start  command to begin syncing. Before you attempt to run  mongosync  with an  M10+  Atlas cluster, disable\nthe  Require Indexes for All Queries  option. The source cluster,  cluster0 , is hosted on the following\nservers and ports: The destination Atlas cluster,  cluster1 , is hosted on the\nfollowing servers and ports: There is an administrative user,  clusterAdmin  configured on each\ncluster with password,  superSecret . clusterOne01.fancyCorp.com:20020 clusterOne02.fancyCorp.com:20020 clusterOne03.fancyCorp.com:20020 cluster2Name-01.abc123.com:27017 cluster2Name-02.abc123.com:27017 cluster2Name-03.abc123.com:27017 The generic connection string format for the self-managed cluster is: The generic connection string format for the Atlas cluster is: Use the connection information you gathered for the self-managed cluster\nto create the connection strings for  cluster0 : You can get the connection string for the Atlas cluster from the Atlas\nUI. To learn more, see  Connect to a Database Deployment . The  mongosync  command layout below is modified for display. To\nconnect  cluster0  to  cluster1  with  mongosync , enter the\nfollowing command on one line: Atlas clusters require TLS connections. To use  mongosync  with Atlas\nclusters, you add the  tls=true  option. For example,\nto connect to the  admin  database on  cluster0  and  cluster1 : You can also use  mongodb+srv  connection strings with  mongosync .\nYou do not need to add the  tls=true  option to a\n mongodb+srv  connection string. For example: For more details about  mongodb+srv  connection strings, see\n SRV Connection Format .",
            "code": [
                {
                    "lang": "none",
                    "value": "mongodb+srv://[username:password@][host.domain.TLD][/defaultauthdb][?options]"
                },
                {
                    "lang": "none",
                    "value": "mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]"
                },
                {
                    "lang": "none",
                    "value": "mongodb+srv://[username:password]@[clusterName].[host].mongodb.net/"
                },
                {
                    "lang": "none",
                    "value": "mongodb://[username:password]@[clusterName].[host].mongodb.net/"
                },
                {
                    "lang": "shell",
                    "value": "mongodb://<user>:<password>@<ip-address>:<port>,<ip-address>:<port>,<ip-address>:<port>"
                },
                {
                    "lang": "shell",
                    "value": "mongodb://<user>:<password>@<clusterName>.<hostname>.mongodb.net/"
                },
                {
                    "lang": "text",
                    "value": "cluster0:\nmongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020"
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n      --cluster0 \"mongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020\" \\\n      --cluster1 \"mongodb://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net\""
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n   --cluster0 \"mongodb://clusterAdmin:superSecret@clusterOne01.fancyCorp.com:20020,clusterOne02.fancyCorp.com:20020,clusterOne03.fancyCorp.com:20020/admin?tls=true\" \\\n   --cluster1 \"mongodb://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net/admin?tls=true\""
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n   --cluster0 \"mongodb+srv://clusterAdmin:superSecret@clusterOne01.fancyCorp.com/\" \\\n   --cluster1 \"mongodb+srv://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net/\""
                }
            ],
            "preview": "This page provides instructions to connect a self-managed cluster to an\nAtlas cluster using MongoDB Cluster-to-Cluster Sync.",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.3",
            "title": "Release Notes for mongosync 1.3",
            "headings": [
                "New Features",
                "Capped Collections",
                "Disable Index Builds",
                "Progress Output",
                "Bug Fixes",
                "Minimum Supported Version"
            ],
            "paragraphs": "Version 1.3 Released April 13, 2023 Starting in 1.3.0, Cluster-to-Cluster Sync supports  capped\ncollections . For more information, see\n Capped Collections . Starting in 1.3.0, Cluster-to-Cluster Sync supports disabling non-essential\nindex builds on the destination cluster.  This can improve migration\nperformance, especially with index heavy workloads. For more information, see  start . Starting in 1.3.0, Cluster-to-Cluster Sync includes the  mongosyncID  and\n coordinatorID  in the  progress  response documents.  This\nhelps determine whether the  mongosync  instance is serving as a coordinator. Fixes a bug that could cause  mongosync  to not copy some documents to the\ndestination cluster for clustered collections on replica sets. Starting in 1.3.0, the minimum supported version of MongoDB is 6.0.5.",
            "code": [],
            "preview": "Version 1.3 Released April 13, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "connecting/atlas-to-atlas",
            "title": "Connect Two Atlas Clusters",
            "headings": [
                "Considerations",
                "Connection Strings",
                "Authentication",
                "Roles",
                "Behavior",
                "Hosting",
                "Initial State",
                "Limitations",
                "Example",
                "Gather Connection Information",
                "Connect the Source and Destination Clusters with mongosync"
            ],
            "paragraphs": "This page provides instructions to connect Atlas clusters using\nMongoDB Cluster-to-Cluster Sync. For additional details on connecting to an\nAtlas cluster, see  Connect to a Database Deployment The  mongosync  utility creates a connection\nbetween MongoDB clusters.  mongosync  can make a connection between: self-managed clusters , MongoDB Atlas  hosted clusters, or a self-managed cluster and an Atlas hosted cluster. Both the source and destination Atlas clusters must use MongoDB 6.0 or\nlater. mongosync  supports replica sets and sharded clusters. mongosync   doesn't  support Atlas shared clusters or serverless\ninstances. You can use  mongosync  only with M10 or higher Atlas\nclusters. mongosync  uses a  MongoDB URI\nconnection string  to connect Atlas clusters: The SRV connection scheme has the form: For information on how to find your SRV connection\nstring in Atlas, see  Connect to Your Cluster . The standard URI connection scheme has the form: You can also specify read preference on a per-connection basis in the\nconnection string. By default,  mongosync  sets the source cluster\nread preference to  nearest  to distribute reads evenly across\nnodes. For more information on setting read preference in connection\nstrings, see  Read Preference Options . Provide valid authentication to connect to a  MongoDB Atlas  cluster. If you do not already have an Atlas database user,\nyou must  create a user . The Atlas permissions are: The user specified in the  mongosync  connection string must have the\nrequired permissions on the source and destination clusters. The\npermissions vary depending on your environment and if you want to run a\nwrite-blocking or reverse sync. For details on Atlas roles, see:  Atlas User Roles . To update Atlas user permissions, see:\n Manage Access to a Project . Sync Type Target Required Permissions default source cluster atlasAdmin backup default destination cluster atlasAdmin write-blocking or reversing source cluster atlasAdmin backup bypassWriteBlockMode privilege write-blocking or reversing destination cluster atlasAdmin backup bypassWriteBlockMode privilege The  mongosync  utility can be hosted on its own hardware close to\neither the source or destination cluster. It does not have to be hosted\non the same server as one of the  mongod  or  mongos \ninstances in the cluster. This flexibility allows you to push, or pull,\ndata to the destination cluster with minimal impact on the\n mongod  or  mongos  instances running there. When  mongosync  connects, it is in the  IDLE  state. You must\nissue the  start  command to begin syncing. Before you attempt to run  mongosync  with an  M10+  Atlas cluster, disable\nthe  Require Indexes for All Queries  option. The generic connection string format is: You can get the connection string for the Atlas clusters from the Atlas\nUI. To learn more, see  Connect to a Database Deployment . The connection strings you gathered for  cluster0  and  cluster1 \nshould resemble the following: There is an database administrative user  clusterAdmin  with the\npassword  superSecret  in the project that contains the clusters. The  mongosync  command layout below is modified for display. To\nconnect  cluster0  to  cluster1  with  mongosync , enter the\nfollowing command on one line: Atlas clusters require TLS connections. To use  mongosync  with Atlas\nclusters, you add the  tls=true  option. For example,\nto connect to the  admin  database on  cluster0  and  cluster1 : You can also use  mongodb+srv  connection strings with  mongosync .\nYou do not need to add the  tls=true  option to a\n mongodb+srv  connection string. For example: For more details about  mongodb+srv  connection strings, see\n SRV Connection Format .",
            "code": [
                {
                    "lang": "none",
                    "value": "mongodb+srv://[username:password]@[clusterName].[host].mongodb.net/"
                },
                {
                    "lang": "none",
                    "value": "mongodb://[username:password]@[clusterName].[host].mongodb.net/"
                },
                {
                    "lang": "shell",
                    "value": "mongodb://<user>:<password>@<clusterName>.<hostname>.mongodb.net/"
                },
                {
                    "lang": "shell",
                    "value": "cluster0:\nmongodb+srv://clusterAdmin:superSecret@cluster1Name.abc123.mongodb.net\ncluster1:\nmongodb+srv://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net"
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n      --cluster0 \"mongodb+srv://clusterAdmin:superSecret@cluster1Name.abc123.mongodb.net\" \\\n      --cluster1 \"mongodb+srv://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net\""
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n   --cluster0 \"mongodb+srv://clusterAdmin:superSecret@cluster1Name.abc123.mongodb.net/admin?tls=true\" \\\n   --cluster1 \"mongodb+srv://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net/admin?tls=true\""
                },
                {
                    "lang": "shell",
                    "value": "mongosync \\\n   --cluster0 \"mongodb+srv://clusterAdmin:superSecret@cluster1Name.abc123.mongodb.net/\" \\\n   --cluster1 \"mongodb+srv://clusterAdmin:superSecret@cluster2Name.abc123.mongodb.net/\""
                }
            ],
            "preview": "This page provides instructions to connect Atlas clusters using\nMongoDB Cluster-to-Cluster Sync. For additional details on connecting to an\nAtlas cluster, see Connect to a Database Deployment",
            "tags": null,
            "facets": {
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.5",
            "title": "Release Notes for mongosync 1.5",
            "headings": [
                "1.5.0 Release",
                "Oplog Rollover Resilience",
                "Logging Level",
                "Bug Fixes",
                "Minimum Supported Version"
            ],
            "paragraphs": "July 25, 2023 Starting in 1.5.0,  mongosync  begins to apply changes while the\ninitial sync is still in progress. By starting to apply changes earlier,\n mongosync  maintains a more recent position in the  oplog .\nThis adds resilience to long-running operations, mitigates the risk\nof  oplog  rollover, and significantly lowers the risk of restarting\nthe sync. Starting in 1.5.0, the default logging level is  DEBUG .  To change\nthe logging level, see the  verbosity  setting. Fixes an issue where very large collections could timeout during\n mongosync  initialization. Fixes an issue where  mongosync  could incorrectly report indexes\nas mismatched. Fixes an issue where the  /start  endpoint would not return\nan error when passed a  sharding  object without the  shardingEntries \nkey. Changes telemetry to send less metadata to Segment. In 1.5, the minimum supported version of MongoDB is 6.0.8.",
            "code": [],
            "preview": "July 25, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/0.9",
            "title": "Release Notes for mongosync 0.9",
            "headings": [
                "Preview Software"
            ],
            "paragraphs": "mongosync  does not check for compliance with the\n documented limitations . Please ensure that\nyour application is not affected by the limitations. Running  mongosync  in the presence of one of  these\nlimitations  could lead to undefined behavior on\nthe destination cluster.",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.2",
            "title": "Release Notes for mongosync 1.2",
            "headings": [
                "Migrating Older Versions of MongoDB",
                "Guardrails for Unsupported Versions of MongoDB",
                "Collated Collections Issue"
            ],
            "paragraphs": "Version 1.2 Released February 16, 2023 Starting in version 1.2,  mongosync  can sync between MongoDB clusters\n(source or destination) with versions lower than 6.0 for one time\nmigration onto Atlas. This feature requires additional preparation and\nconfiguration in clusters with versions lower than 6.0. If you would like to use  mongosync  to migrate clusters with versions\nof MongoDB lower than 6.0, please  contact  your account team to inquire about\nProfessional Services. mongosync  does not support continuous sync between clusters\n(source or destination) with versions lower than 6.0. mongosync  now returns an error if you call  start \nto sync clusters running unsupported releases of MongoDB Server. Fixes bug that could cause  mongosync  to crash when replicating\ncollated collections.",
            "code": [],
            "preview": "Version 1.2 Released February 16, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.0",
            "title": "Release Notes for mongosync 1.0",
            "headings": [
                "Multiple Instances",
                "DDL Operations",
                "Collation",
                "API Improvements"
            ],
            "paragraphs": "Version 1.0 released July 22, 2022 mongosync  1.0 supports the use of multiple  mongosync \ninstances to synchronize sharded clusters. Each  mongosync  instance must connect to  mongos  and start with\nthe  --id  option or the  id  setting, specifying the\nshard you want it to synchronize. For more information, see  Use mongosync on Sharded Clusters . mongosync  1.0 supports the synchronization of DDL operations. mongosync  1.0 supports synchronization of collections with collation. mongosync  1.0 includes improvements to the  progress  command. The response to  progress  commands now includes a  canWrite  field,\nindicating whether it is possible to perform writes on the destination cluster.",
            "code": [],
            "preview": "Version 1.0 released July 22, 2022",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.7",
            "title": "Release Notes for mongosync 1.7",
            "headings": [
                "Patch Releases",
                "1.7.1 Release",
                "1.7.0 Release",
                "Live Upgrade",
                "Synchronize Data Between Clusters with Different MongoDB Server Major Versions",
                "Other Notes",
                "Minimum Supported Version"
            ],
            "paragraphs": "November 9, 2023 Issues Fixed: Fixed a bug that caused mongosync to crash when attempting to live\nupgrade from version 1.6. The bug does not result in modified user data\nand doesn't preclude the sync from being continued using version 1.7.1. October 18, 2023 For details, see  Live Upgrade . Starting in  mongosync  1.7.0, you can upgrade  mongosync  without\nrestarting data synchronization operations from the beginning. You can\nonly live upgrade from  mongosync  1.6.0 or later to  mongosync \n1.7.0 or later. Starting in 1.7.0,  mongosync  can perform version migration from\ncertain lower major version source clusters to certain higher major\nversion destination clusters. Cross-version migration requires additional preparation and\nconfiguration when migrating from a pre-6.0 release. To perform a cross-version\nmigration from a pre-6.0 version of the MongoDB Server using\n mongosync , please  contact  your\naccount team to inquire about Professional Services. New Features: Issues Fixed: mongosync  now truncates logged fields that contain more than 1,024\ncharacters. Fixed bug introduced in  mongosync  1.5.0 that may cause ORR to insert\ncapped collection documents out of order. That is, documents on the source\nand destination cluster may not be deleted from the capped collection in the\nsame order. This bug is only triggered if documents are inserted into a\ncapped collection during migration, before or while the Collection Copy phase\nis working on the same capped collection. Fixed bug introduced in 1.6 that caused  mongosync  to fail during\ninitialization if the user specified only an exclusion filter and there were\nno fully excluded databases. In 1.7.0, the minimum supported version of MongoDB is 6.0.8 and 7.0.0.",
            "code": [],
            "preview": "October 18, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.6",
            "title": "Release Notes for mongosync 1.6",
            "headings": [
                "Patch Releases",
                "1.6.1 Release",
                "1.6.0 Release",
                "Exclusion Filters",
                "Regular Expression Filters",
                "7.0 Support",
                "Other Notes",
                "Minimum Supported Version"
            ],
            "paragraphs": "October 3, 2023 Issues Fixed: Fixed a bug that can cause long running  mongosync  operations to\nprematurely timeout. Now,  mongosync  produces\nfewer  MaxTimeMSExpired  errors during the collection copy phase. September 22, 2023 Starting in 1.6.0, the  start  API endpoint now supports the\nuse of exclusion filters through the  excludeNamespaces  parameter. For more information, see  Filtered Sync . Both inclusion and exclusion filters in  Filtered Sync  now\nsupport matching databases and collections using Regular Expressions\nwith the  databaseRegex  and  collectionsRegex  fields. For more information, see  Regular Expressions in Filters . Starting in 1.6.0,  mongosync  supports sync with MongoDB 7.0. New Features: Issues Fixed: Sped up the commit process by parallelizing metadata cleanup. Reduced memory allocation during change event application by approximately\n30% for pre-6.0 releases of MongoDB Server versions. Changed telemetry to also send error messages to Segment when  mongosync \nexits with a fatal error. Added support for  mongosync  to sync between source and destination\nclusters that have the same major and minor versions, but different\npatch versions. Upgraded build to use Go 1.20. mongosync  now periodically logs when server operations take a longer\nthan expected time. Fixed a bug introduced in  mongosync  v1.5.0 and discovered by our internal\ntesting where in an unlikely edge case  mongosync  can miss a change event\nto be applied during the Collection Copy phase. In order for this bug to occur, the change event must fall between a specific\n _id  range that  mongosync  is in the process of copying, must occur and\nbe processed while that specific  _id  range is being copied, and must not\nbe followed by another change event for the same  _id  throughout the rest\nof the migration. This bug only occurs when  mongosync  is processing change events with near\nzero replication lag during Collection Copy. Fixed a bug where  mongosync  could crash due to the source cluster\ncontaining legacy indexes with unknown index options. Fixed a bug where  mongosync  could crash with an error during change event\napplication, if the application fails to read 500 documents within 5 minutes\nor reaches the end of the oplog when reading from change streams on the\nsource cluster. Fixed a bug where  mongosync  could crash when indexes apply constraints to\ncollection documents. This crash occured when such an index was added or dropped at nearly the same\ntime as an index that violated these constrains was deleted or inserted.  It\nwould manifest with an error like: or a similar error. This fix makes this crash less likely, but it does not\nelimiate the possibility that it will occur. Fixed a bug where  mongosync  can fail to copy certain documents if the\ninsertion of documents causes duplicate key errors at the same time as a\nwrite concern error. This bug has been present in mongosync since its first\nrelease and may have arisen if the destination cluster logs reported a write\nconcern error alongside a duplicate key error. Fixed a bug introduced in  mongosync  1.5 where change events may be\nskipped during the Collection Copy phase when there is little write activity\non the source cluster. Fixed a rare bug introduced in  mongosync  v1.5.0 and discovered by our\ninternal testing where there may be a small continuity gap between Oplog\nRollover Resilience (ORR) cycles in a specific situation, causing the ORR\nmechanism to potentially miss a change event to be applied during the\nCollection Copy phase. This is an extreme case as it requires consistently\nlittle write activity on the source cluster (i.e.  mongosync  replication\nlag is consistently near zero during Collection Copy) as well as the change\nevent to fall in specific  _id  ranges between ORR cycles. Fixed a bug introduced in v1.5.0 where  mongosync  could cause data\nconsistency errors in collections with non-default collation. This issue only affects collections with non-simple collation that are\npresent during  mongosync  initialization and contain documents with string\n _id  values. Any collections with non-simple collation created after\n mongosync  initialization or whose documents have all non-string  _id \nvalues are unaffected. In order to mitigate this issue,  mongosync  v1.6.0 automatically\ndisables Oplog Rollover Resilience if it finds at least one collection\nwith non-simple collation during Mongosync initialization. We will investigate a more permanent solution for future releases. In 1.6, the minimum supported versions of MongoDB are 6.0.8 and 7.0.0.",
            "code": [
                {
                    "lang": "text",
                    "value": "Ambiguous field name found in array (do not use numeric field names in embedded elements in an array)"
                }
            ],
            "preview": "September 22, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.8",
            "title": "Release Notes for mongosync 1.8",
            "headings": [
                "1.8.0 Release",
                "Minimum Supported Version"
            ],
            "paragraphs": "MongoDB Cluster-to-Cluster Sync 1.8 is not yet\navailable. This version of the documentation is for an upcoming release and\nis currently a work in progress. Upcoming New Features:",
            "code": [],
            "preview": "Upcoming",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.1",
            "title": "Release Notes for mongosync 1.1",
            "headings": [
                "Filtered Sync",
                "Unlike Topologies",
                "Minimum Supported Server Version"
            ],
            "paragraphs": "Version 1.1 Released January 13, 2023 For more information, see:  Filtered Sync . Cluster-to-Cluster Sync provides continuous data synchronization or a\none-time data migration between two MongoDB clusters. You can use\nfiltered sync to specify which databases and collections the\n mongosync  utility transfers between the source\nand destination clusters. Cluster-to-Cluster Sync 1.1 supports sync between clusters with different\nsharding configurations. You can sync: You cannot sync from a sharded cluster to a replica set. For more information, see:  Sharding Parameters . Between two sharded clusters Between two sharded clusters with a different number of shards in each\ncluster From a replica set to a sharded cluster Cluster-to-Cluster Sync requires at least MongoDB server version 6.0.4 on\nboth the source and target clusters.",
            "code": [],
            "preview": "Version 1.1 Released January 13, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "release-notes/1.4",
            "title": "Release Notes for mongosync 1.4",
            "headings": [
                "Patch Releases",
                "1.4.1 - June 23, 2023",
                "1.4.0 Release",
                "Set Cluster Workload Level",
                "Faster Processing",
                "Improved Memory Handling",
                "Telemetry",
                "Bug Fixes",
                "Additional Considerations",
                "Minimum Supported Version"
            ],
            "paragraphs": "Issues fixed: Fixes a build misconfiguration so that telemetry information is sent\ncorrectly. June 21, 2023 Starting in 1.4.0, you can set the workload level that\nCluster-to-Cluster Sync uses to sync data between the source and\ndestination clusters. For more information, see the\n --loadLevel  option. Version 1.4.0 improves  change event application  speeds for improved\nperformance. In version 1.4.0,  mongosync  uses less memory to buffer change\nevents. Improved memory handling alleviates some out-of-memory (OOM)\nissues. Starting in 1.4.0,  mongosync  collects anonymous, aggregated usage\ndata to improve MongoDB products. You can disable collection of this\n telemetry  data when you start  mongosync . Fixes an issue so documents with  _id  values that evaluate to the\nsame string replicate correctly. Fixes a collection naming issue. Prior to version 1.4.0,  mongosync \ncrashes when a new collection reuses a dropped collection's name with\nletter case changes. For example, previous versions of  mongosync  crash if a new\n SampleName  collection replaces the dropped  samplename \ncollection. The MongoDB server's  validate  command may report data\ncorruption on destination clusters that run MongoDB version 6.0 through\n6.0.6. The data on the destination server is not corrupt. A bug in the\n WiredTiger  database engine,\n WT-11051 , causes the false report. In 1.4.0, the minimum supported version of MongoDB is 6.0.5.",
            "code": [],
            "preview": "June 21, 2023",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/oplog-sizing",
            "title": "oplog Sizing",
            "headings": [
                "Monitor oplog Size Needed for Initial Sync",
                "Determine oplog Window",
                "Determine mongosync Replication Lag",
                "Validate oplog Size"
            ],
            "paragraphs": "The  mongosync  program uses  change streams  to synchronize data between source and destination\nclusters.  mongosync  does not access the  oplog  directly,\nbut when a change stream returns events from the past, the events must\nbe within the  oplog  time range. mongosync  applies operations in the  oplog  on the source cluster\nto the data on the destination cluster.  When operations\nthat  mongosync  has not applied roll off the  oplog \non the source cluster, the sync fails and  mongosync  exits. Starting in version 1.5.0,  mongosync  enables Oplog Rollover\nResilience (ORR).  With ORR,   mongosync  applies changes on the\nsource cluster to the destination cluster during the initial sync. ORR\nincreases the resilience of  mongosync  to oplog rollover but does not\nprevent rollover entirely. You might exceed the oplog window if you: To increase the size of the  oplog  on the source cluster, use\n oplogSizeMB . For more information, see\n Change Oplog Size  and\n Workloads that Might Requre a Large Oplog Size . mongosync  does not replicate  applyOps  operations made on\nthe source cluster during sync to the destination cluster. Sync from a high write rate source cluster for an extended\nperiod. Pause sync for an extended period. To get the difference in seconds between the first and last entry\nin the  oplog  run  db.getReplicationInfo() . If you\nare replicating a sharded cluster, run the command on each shard. The value returned is the minimum  oplog  window of the\ncluster. If there are multiple shards, the smallest number is the\nminimum  oplog  window. To get the  lagTimeSeconds  value, run the\n /progress  command.\nThe lag time is the time in seconds between the\nlast event applied by  mongosync  and time of the current\nlatest event on the source cluster. It is a measure of how far behind the source cluster  mongosync  is. If the lag time approaches the minimum  oplog  window, make\none of the following changes: Increase the  oplog  window. Use  replSetResizeOplog \nto set  minRetentionHours  greater than the current  oplog \nwindow. Scale up the  mongosync  instance. Add CPU or memory to scale\nup the  mongosync  node so that it has a higher copy rate. The  oplog  window and rate of change for replication lag may vary\nduring synchronization. Repeat these steps during a migration to monitor the\nprogress.",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.getReplicationInfo().timeDiff"
                }
            ],
            "preview": "The mongosync program uses change streams to synchronize data between source and destination\nclusters. mongosync does not access the oplog directly,\nbut when a change stream returns events from the past, the events must\nbe within the oplog time range.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/verification",
            "title": "Verify Data Transfer",
            "headings": [
                "Use Cases",
                "Tasks",
                "Document Counts",
                "Hash Comparison",
                "Document Comparison",
                "Migration Verifier",
                "Learn More"
            ],
            "paragraphs": "When  mongosync  has fully committed, verify the successful transfer\nof your data before you switch your application to using the destination\ncluster. You can verify your data transfer using document counts, hash\ncomparison, document comparison, or the Migration Verifier. You should verify your data after every sync. This is important in\ncases where you plan to move your application load from the source to the\ndestination cluster. Verification methods: The specific method you use to verify your data depends on your application\nworkload and the complexity of the data. Document Counts Hash Comparison Document Comparison Migration Verifier The most basic method of verification is to compare the number of documents\nin each synced collection on the source cluster to the number on the\ndestination cluster. This method only verifies a successful sync when run against clusters with\ninsert-only workloads. For more information, see  Verify with Document Counts . You can verify sync by comparing MD5 hashes of collections synced from the\nsource cluster to the destination cluster. While hash comparison ensures that the destination cluster has received all\nchanges from the source, the  dbHash  command locks the cluster,\npreventing additional writes until it completes. For more information, see  Verify with Hash Comparison . Hash comparison is not possible with sharded clusters. It also does not\nwork for standalone servers and replica sets that use MongoDB 4.4 or earlier\nreleases, since the document field order can vary. You can verify sync by comparing documents on the source and destination\nclusters. Write a script that queries collections on the source cluster and\nthen checks that the document exists with the same values on the destination\ncluster. Migration Verifier connects to the source and destination clusters and performs\na series of verification checks, comparing documents, views, and indexes to\nconfirm the sync was successful. Unlike other verification methods, Migration Verifier can run concurrent\nwith  mongosync , checking documents on the destination cluster as they\nsync. For more information, see  Verify with Migration Verifier . Migration Verifier is an experimental and unsupported tool. For installation instructions, see\n GitHub . For more information, see: db.collection.countDocuments() dbHash",
            "code": [],
            "preview": "When mongosync has fully committed, verify the successful transfer\nof your data before you switch your application to using the destination\ncluster. You can verify your data transfer using document counts, hash\ncomparison, document comparison, or the Migration Verifier.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api",
            "title": "mongosync API Endpoints",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/versioning",
            "title": "mongosync Versioning",
            "headings": [
                "Currently Supported Versions",
                "Version-Related Considerations",
                "Support Lifecycle",
                "Patch Releases",
                "Live Upgrade",
                "(Optional) Pause the mongosync processes",
                "Stop the mongosync processes",
                "Download and install the new mongosync binaries",
                "Initialize the mongosync processes",
                "Resume the mongosync processes",
                "Non-Live Upgrade or Downgrade",
                "Persistent Metadata",
                "Log Messages",
                "Examples",
                "Major Releases",
                "Minor Releases",
                "Patch Releases"
            ],
            "paragraphs": "Cluster-to-Cluster Sync uses  Semantic Versioning 2.0.0 . Version numbers have the form  X.Y.Z , where\n X  is the major version,  Y  is the minor version, and  Z  is the\npatch version. MongoDB uses the following guidelines to determine when to increment the\nversion number for Cluster-to-Cluster Sync: Major number: The release breaks backwards compatibility. Minor number: The release includes significant new features that are\nbackwards compatible. Patch number: This release only includes small, backwards compatible\nchanges. MongoDB only supports the latest patch release of each major\nversion.  For example,  mongosync  1.7.1 is the\nlatest patch release of 1.7. If you are using an\nunsupported version of  mongosync , you might be asked to\nupgrade in order to receive support. Cluster-to-Cluster Sync has the following version related considerations: Major releases are supported for at least one year from the first\nrelease in that series. If a version of Cluster-to-Cluster Sync only works with an unsupported\nversion of MongoDB Server, that version of Cluster-to-Cluster Sync is\nalso unsupported. Only the latest version in each major release series receives new patch\nreleases. For example, when version Cluster-to-Cluster Sync 2.1.0 is\nreleased, version 2.0 would no longer receive patch releases. At the\nsame time, version 1.3 would continue to receive patches until version\n1.4 was released. After the live upgrade,  mongosync  continues operations that were in\nprogress before the upgrade. To live upgrade  mongosync , perform these steps: If a data synchronization operation was already in progress before the\nlive upgrade, new features added in the latest  mongosync  version may\nnot all be supported after the live upgrade. Performance improvements\nand bug fixes are always supported after the live upgrade. For more\ninformation on the new features that might be supported after a live\nupgrade, see the  1.7.0 Release . Starting in  mongosync  1.7.0, you can upgrade  mongosync  without\nrestarting data synchronization operations from the beginning. You can\nonly live upgrade from  mongosync  1.6.0 or later to  mongosync \n1.7.0 or later. To pause  mongosync , run  pause  on each running\n mongosync  process. You can resume the  mongosync  processes later from the paused\nstate, as shown in the final step. If you don't want to immediately resume data synchronization\noperations after live upgrade, consider pausing the\n mongosync  processes. This is useful if you're coordinating\noperations from multiple  mongosync  processes. Use your operating system to stop each running  mongosync \nprocess. To stop a process, see your operating system\ndocumentation for the specific steps. To download and install the new  mongosync  binaries, see\n download and install mongosync . To initialize the  mongosync  processes, see the  mongosync\nexamples . During initialization after a\nlive upgrade,  mongosync  updates the persistent metadata. If you paused any  mongosync  processes earlier in the optional\nfirst step, run  resume  on all  mongosync \nprocesses. If you're using an earlier  mongosync  version not supported by the\nlive upgrade procedure, or you need to downgrade  mongosync , perform\nthese steps: Stop all currently running  mongosync  processes. Drop all non-system databases in the destination cluster. Install  new  mongosync  binaries. Start  the  mongosync  processes using the new\nbinaries. The new  mongosync  processes do not resume any work that may have\nbeen in progress. Syncing operations restart from the beginning when\nyou start the new processes. During normal operation,  mongosync  creates metadata that is\npersisted to disk in the destination database. This metadata is not\nversioned and may change at any time. Log message formats are not versioned and may change at any time. This\nincludes changes to the message text, as well as the presence, absence,\nor contents of other fields in the message. User scripts and applications should not rely on logging output. Scripts\nand applications should use the  monitoring API \nto determine the current state of  mongosync . The following examples illustrate the kinds of changes that would result\nin each type of version number update. Changes that make the new and old versions of  mongosync  produce\ndifferent results on the  destination cluster for the same set of\ninputs. Except: Bug fixes for cases where the older version of  mongosync  fails\nto replicate data. When the earlier behavior is explicitly documented as unsupported. Changes to documented CLI parameters or configuration keys such that\n mongosync  rejects formerly valid input. Except: Bug fixes such as parsing or type errors. Even though CLI parameters or configuration keys may be deprecated,\nthe meaning of documented CLI parameters or configuration keys will\nnever change. If needed, new parameters or keys will replace the\nolder, deprecated entities. Changes that break compatibility with a supported version of MongoDB\nServer. Dropping a version of the REST API.  mongosync  may drop all\nolder endpoints in favor of a new version of the API. There will never\nbe any other types of backwards incompatible changes in the REST API. Removing support for a previously supported MongoDB Server feature if\n mongosync  still supports a version of MongoDB Server that supports\nthe feature. If  mongosync  already supports a major version of MongoDB Server,\nchanges that require new access privileges in order to continue\nsupporting that version of MongoDB Server. Adding support for a previously incompatible MongoDB Server version. Requiring new access privileges for a previously unsupported major\nrelease of MongoDB Server. Adding support for previously unsupported collection types. Adding support for previously unsupported index types. Adding new endpoints, new fields, or new accepted inputs in the REST API. Adding new documented CLI options. Adding new configuration keys or accepted values. Backwards compatible bug fixes. Performance regression fixes. Performance improvements. Changes to help text strings. Changes to log text strings. Changes to informational text in API responses, but not changes to\nenum-style string fields like \"state\". Typo fixes.",
            "code": [],
            "preview": "Cluster-to-Cluster Sync uses Semantic Versioning 2.0.0. Version numbers have the form X.Y.Z, where\nX is the major version, Y is the minor version, and Z is the\npatch version.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/permissions",
            "title": "User Permissions",
            "headings": [
                "Self-Managed Clusters",
                "Atlas Clusters"
            ],
            "paragraphs": "The user specified in the  mongosync  connection string must have the\nrequired permissions on the source and destination clusters. The\npermissions vary depending on your environment and if you want to run a\nwrite-blocking or reverse sync. The self-managed permissions are: For details on server roles, see:  Role-Based Access Control . To update user permissions, see:  grantRolesToUser . Sync Type Required Source Permissions Required Destination Permissions Default backup clusterMonitor readAnyDatabase clusterManager clusterMonitor readWriteAnyDatabase restore Write-blocking backup clusterManager clusterMonitor readWriteAnyDatabase restore backup clusterManager clusterMonitor readWriteAnyDatabase restore Reversing backup clusterManager clusterMonitor readWriteAnyDatabase restore backup clusterManager clusterMonitor dbAdmin readWriteAnyDatabase restore The Atlas permissions are: For details on Atlas roles, see:  Atlas User Roles . To update Atlas user permissions, see:\n Manage Access to a Project . Sync Type Target Required Permissions default source cluster atlasAdmin backup default destination cluster atlasAdmin write-blocking or reversing source cluster atlasAdmin backup bypassWriteBlockMode privilege write-blocking or reversing destination cluster atlasAdmin backup bypassWriteBlockMode privilege",
            "code": [],
            "preview": "The self-managed permissions are:",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/logging",
            "title": "Logging",
            "headings": [
                "Destination",
                "Standard Output",
                "Log to File",
                "Verbosity",
                "Format",
                "Examples"
            ],
            "paragraphs": "mongosync  maintains a running log of events, including entries\nsuch as the copying collections and indexes, change stream events, and API\ncalls. mongosync  can write log messages to stdout or to file. By default,  mongosync  outputs log messages to stdout: Example output: To output log messages to file, start  mongosync  with the\n --logPath  option or set the  logPath  setting\nin the configuration file. When logging to file,  mongosync  writes logs to a file in the configured\ndirectory.  The directory is created if it does not exist.  If a  mongosync.log \nfile already exists in the directory,  mongosync  rotates the log files to\npreserve the old logs as it begins a new file. For example: The currently active log file is  mongosync.log .  The other files are older\nlogs that  mongosync  has rotated. mongosync  supports user-defined verbosity to increase or decrease\nthe level of log messages  mongosync  outputs. The verbosity level can be set using the  --verbosity  option from the\ncommand-line or the  verbosity  setting in the configuration file. mongosync  outputs log messages in structured JSON format.\nEach log message is a document that holds the key-value pairs for that entry.\nThe keys label the log message elements, the values are the reported events. For example: To view log messages, check the  mongosync.log  file in the log directory.\nYou can format the log by piping its contents to  jq  or a similar command: Example output:",
            "code": [
                {
                    "lang": "console",
                    "value": "$ mongosync --config /etc/mongosync.conf"
                },
                {
                    "lang": "json",
                    "value": "{\"level\":\"info\",\"mongosyncID\":\"shard02\",\"verbosity\":\"INFO\",\"id\":\"shard02\",\"port\":27301,\"time\":\"2022-06-21T11:15:33-04:00\",\"message\":\"Mongosync Options\"}\n{\"level\":\"info\",\"mongosyncID\":\"shard02\",\"time\":\"2022-06-21T11:15:33-04:00\",\"message\":\"Initialized client0 with URI: mongodb://192.0.2.1:27130 and client1 with URI: mongodb://192.0.2.2:27140.\"}\n{\"level\":\"info\",\"mongosyncID\":\"shard02\",\"time\":\"2022-06-21T11:15:33-04:00\",\"message\":\"Preflight checks completed.\"}\n{\"level\":\"info\",\"mongosyncID\":\"shard02\",\"time\":\"2022-06-21T11:15:33-04:00\",\"message\":\"Launch replication thread\"}"
                },
                {
                    "lang": "console",
                    "value": "$ ls /var/log/mongosync"
                },
                {
                    "lang": "none",
                    "value": "mongosync-2022-06-17T16-27-58.187.log  mongosync.log\nmongosync-2022-06-21T13-31-42.668.log"
                },
                {
                    "lang": "json",
                    "value": "{\n     \"level\": \"info\",\n     \"mongosyncID\": \"shard01\",\n     \"componentName\": \"Change Event Application\",\n     \"time\": \"2022-06-21T09:31:42-04:00\",\n     \"message\": \"Starting change stream reader.\"\n}"
                },
                {
                    "lang": "console",
                    "value": "$ cat /var/log/mongosync/mongosync.log | jq"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"level\": \"info\",\n   \"mongosyncID\": \"shard02\",\n   \"verbosity\": \"INFO\",\n   \"id\": \"shard02\",\n   \"port\":27301,\n   \"time\": \"2022-06-21T11:15:33-04:00\",\n   \"message\": \"Mongosync Options\"\n}\n{\n   \"level\": \"info\",\n   \"mongosyncID\": \"shard02\",\n   \"time\": \"2022-06-21T11:15:33-04:00\",\n   \"message\": \"Initialized client0 with URI: mongodb://192.0.2.1:27130 and client1 with URI: mongodb://192.0.2.2:27140.\"\n}\n{\n   \"level\": \"info\",\n   \"mongosyncID\": \"shard02\",\n   \"time\": \"2022-06-21T11:15:33-04:00\",\n   \"message\": \"Preflight checks completed.\"\n}\n{\n   \"level\": \"info\",\n   \"mongosyncID\": \"shard02\",\n   \"time\": \"2022-06-21T11:15:33-04:00\",\n   \"message\": \"Launch replication thread\"\n}"
                }
            ],
            "preview": "mongosync maintains a running log of events, including entries\nsuch as the copying collections and indexes, change stream events, and API\ncalls.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/collection-level-filtering",
            "title": "Filtered Sync",
            "headings": [
                "Filter Syntax",
                "Configure a Filter",
                "Identify Databases and Collections.",
                "Create a Filter.",
                "Use the Filter.",
                "Replace an Existing Filter",
                "Remove mongosync_reserved_for_internal_use.",
                "Remove user databases.",
                "Configure a new filter.",
                "Adding and Renaming Collections",
                "Adding and Renaming Within a Single Database",
                "Renaming Across Different Databases",
                "Filtering with mapReduce and $out",
                "Limitations",
                "Examples",
                "Start mongosync with a Filter",
                "Adding and Renaming Collections While Syncing",
                "Adding a Collection",
                "Renaming a Collection"
            ],
            "paragraphs": "Starting in 1.1,  mongosync  supports inclusion filters to specify which\ndatabases and collections to include in sync.  Starting in 1.6,  mongosync \nalso supports exclusion filters and regular expressions. Cluster-to-Cluster Sync provides continuous data synchronization or a\none-time data migration between two MongoDB clusters. You can use\nfiltered sync to specify which databases and collections the\n mongosync  utility transfers between the source\nand destination clusters. With inclusion filters,  mongosync  syncs matching\ndatabases and collections. With exclusion filters,  mongosync  syncs all databases\nand collections, except for those that match the filters. With both inclusion and exclusion filters,  mongosync  only syncs\ndatabases and collections that match the inclusion filters then excludes\nany that also match the exclusion filters. With no filters,  mongosync  syncs all databases and collections. The  start  API endpoint accepts two fields that configure\nfiltered sync:  includeNamespaces  and  excludeNamespaces .\nEach field takes an array of filters that specify the databases and collections\nto include or exclude from sync. Filters have the following syntax: Filters must include either the  database  field or the  databaseRegex  field. If you need the filter to match specific collections, you can use either\nthe  collections  array to specify collections individually or define\na regular expression using the  collectionsRegex  field. If the  start  call uses both  includeNamespaces  and\n excludeNamespaces  parameters,  mongosync  first matches databases\nand collections from the inclusion filters, then excludes those that\nalso match an exclusion filter. For an example configuration, see:  Start  mongosync  with a Filter . Once you start  mongosync  with a filter in place, the filter\ncannot be modified. If you do need to create a new filter,\nsee:  Replace an Existing Filter . Identify the databases and collections that you want to sync to\nthe destination cluster. When you add a set of databases to the filter, you also exclude any\nother databases in the cluster. When you specify a collection in your filter, you also exclude any\nother collections that are in the same database. The  start  API accepts two parameters that configure\noptional filters: If you don't specify a filter,  mongosync  performs a full cluster\nsync. Create inclusion and/or exclusion filters to identify the databases and\ncollections you want to sync. For example, this inclusion filter would configure  mongosync  to only\nsync collections whose names begin with  accounts_  from the  sales \ndatabase, except for the  accounts_old  collection: For more information on filters, see  Filter Syntax . The  includeNamespaces  parameter takes an array of filters, which\nare used to determines which databases and collections  mongosync \nshould include in the sync. The  excludeNamespaces  parameter takes an array of filters, which\nare used to determine which databases and collections  mongosync \nshould exclude from the sync. To use the filter, attach the filter json when you make the\n /start  API call to begin syncing. You cannot update an existing filter. You must stop the ongoing sync\nprocess, prepare the destination cluster, and restart  mongosync  with\na new filter. When  mongosync  ran your original filter, it created databases with\nyour data (\"user databases\") and the\n mongosync_reserved_for_internal_use  system database on the\ndestination cluster. You must remove those databases before restarting\n mongosync  with your new filter. Follow these steps to prepare the destination cluster for a new filter. Stop the  mongosync  process. Connect to the destination cluster with  mongosh . If\nthe destination is a sharded cluster, connect to the\n mongos  instance. If the destination is a replica set,\nconnect to the primary  mongod  instance. Drop the  mongosync_reserved_for_internal_use  system\ndatabase. List the databases in the cluster Remove user databases. The  admin ,  local , and  config \ndatabases are system databases. You should not edit these\nsystem databases without instructions from MongoDB support. If the  show databases  command lists any user databases on\nthe destination cluster, you must remove them. Repeat this step for each user database list: Note: After the first  db.dropDatabase()  operation\ncompletes, you may need to run it a second time to remove the\ndatabase. Decide which databases and collections you want to filter on.\nAdd the databases and collections to the  includeNamespaces \narray. For configuration details, see\n Configure a Filter . Run  mongosync  to  reconnect  to\nthe source and destination clusters. Use the  /start  API end point to start syncing. Be sure to\nattach your new filter when you call  /start . You can, with some restrictions, add or  rename a collection  during a filtered sync. If your renaming operation violates the renaming restrictions,\n mongosync  stops syncing and reports an error. To clean up and restart after an error, follow the steps to\n replace an existing filter . You can add new collections or rename an existing collection if the\nentire database is part of the filter. You can also rename a collection if the old name and the new name are\nboth specified in the filter. See the  renaming examples . You can only rename a collection across databases if the entire target\ndatabase is part of a filter. If the filter specifies individual\ncollections in the target database, renaming across databases does not\nwork. See the  renaming examples . To use the  $out  aggregation stage or\nthe  mapReduce  command (when set to create\nor replace a collection) with filtering, you must\nfilter the whole database and not just\nthe specified collection. For example, consider this aggregation pipeline: The  $out  stage creates the  authors  collection in the  library \ndatabase. If you want to sync the  authors  collection, you must\nspecify the entire  library  database in your filter. The filter will\nnot work if you only specify the  authors  collection. This filter works: This filter does not work: Filtering is not supported with  reversible sync . The destination cluster must not contain user data prior to starting. The destination cluster must not contain the\n mongosync_reserved_for_internal_use  system database prior to\nstarting. You cannot modify a filter that is in use. To create a new filter,\nsee:  Replace an Existing Filter . You can only rename collections in certain situations. For more\ndetails see:  Adding and Renaming Collections . If a filter includes a  view  but not the\nbase collection, only the view is replicated. You cannot specify system collections or system databases in a filter. To use the  $out  aggregation stage or the  mapReduce \ncommand (when set to create or replace a collection) with filtering,\nyou must configure the filter to use the entire database.\nYou cannot limit the filter to collections within the database. For more information, see  Filtering with mapReduce and $out . cluster0  contains the  sales ,  marketing , and\n engineering  databases. The  sales  database contains the  EMEA ,  APAC , and  AMER \ncollections. The  includeNamespaces  array in this example defines a filter on two\nof the databases,  sales  and  marketing . The  sales  database also filters on the  EMEA  and  APAC \ncollections. After you call the  /start  API with this filter in place,\n mongosync : The following example starts a sync job between  cluster0  and\n cluster1 .  The source cluster is  cluster0  and the destination\ncluster is  cluster1 . Syncs all of the collections in the  marketing  database Filters out the  engineering  database Syncs the  EMEA  and  APAC  collections from the  sales \ndatabase Filters out the  AMER  collection cluster0  contains the  students ,  staff , and  prospects \ndatabases. The  includeNamespaces  array in this example defines a filter on two\nof the databases: With this filter in place,  mongosync  syncs: mongosync  does not sync any information from the  prospects \ndatabase. The following example starts a sync job between  cluster0  and\n cluster1 .  The source cluster is  cluster0  and the destination\ncluster is  cluster1 . The  students  database contains the  undergrad  and  graduate \ncollections. The  staff  database contains the  employees  and  contractors \ncollections. The entire  staff  database The  undergrad ,  graduate , and  adjuncts  collections in the\n students  database mongosync  syncs the entire  staff  database. If you add new\ncollections to the  staff  database,  mongosync  syncs them too. mongosync  does not sync new collections that are added to\nthe  students  database unless the collection is a part of the filter. For example,  mongosync  does not sync the new collection if you add\nthe  postdocs  collection to the  students  database. If you add the\n adjuncts  collection,  mongosync  syncs it since  adjuncts  is\npart of the filter. You can rename any collection in the  staff  database. You can only rename a collection within the  students  database if the\nnew and old names are both in the filter. If either of the names is not\nin the filter,  monogsync  reports an error and exists. If a collection is specified in the filter, you can drop it, but you\ncannot rename it to remove it from the filter. When the whole target database is included in the filter, you can rename\ncollections to add them to the filter: You can also rename collections in the source database when the whole\ntarget database is in the filter: Source collection is specified in the filter Source collection is not specified in the filter If you anticipate renaming collections, consider adding the entire\ndatabase to the filter rather than specifying individual collections.",
            "code": [
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\": [\n    {\n       \"database\": \"<database-name>\",\n       \"collections\": [\n          \"<collection-name>\"\n       ]\n       \"databaseRegex\": {\n          \"pattern\": \"<regex-pattern>\",\n          \"options\": \"<options>\"\n       },\n       \"collectionsRegex\": {\n          \"pattern\": \"<regex-pattern>\",\n          \"options\": \"<options>\"\n       }\n    }\n ],\n \"excludeNamespaces\": [\n    {\n       \"database\": \"<database-name>\",\n       \"collections\": [\n          \"<collection-name>\"\n       ]\n       \"databaseRegex\": {\n          \"pattern\": \"<regex-pattern>\",\n          \"options\": \"<options>\"\n       },\n       \"collectionsRegex\": {\n          \"pattern\": \"<regex-pattern>\",\n          \"options\": \"<options>\"\n       }\n    }\n ]"
                },
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\": [\n   {\n      \"database\": \"sales\",\n      \"collectionsRegex\": {\n         \"pattern\": \"^accounts_.+?$\",\n         \"options\": \"ms\"\n      }\n],\n\"excludeNamespaces\": [\n    {\n        \"database\": \"sales\",\n        \"collections\": [\n            \"accounts_old\"\n        ]\n    }\n]"
                },
                {
                    "lang": "bash",
                    "value": "curl -X POST \"http://localhost:27182/api/v1/start\" --data '\n   {\n      \"source\": \"cluster0\",\n      \"destination\": \"cluster1\",\n      \"includeNamespaces\": [\n         {\n             \"database\": \"sales\",\n             \"collectionsRegex\": {\n                \"pattern\": \"^accounts_.+$\",\n                \"options\": \"i\"\n             }\n         }, {\n            \"database\": \"marketing\"\n         }\n      ]\n   } '\n"
                },
                {
                    "lang": "javascript",
                    "value": "use mongosync_reserved_for_internal_use\ndb.dropDatabase()"
                },
                {
                    "lang": "javascript",
                    "value": "show databases"
                },
                {
                    "lang": "javascript",
                    "value": "use <user database name>\ndb.dropDatabase()"
                },
                {
                    "lang": "javascript",
                    "value": "use library\ndb.books.aggregate( [\n   { $group : { _id : \"$author\", titles: { $push: \"$title\" } } },\n   { $out : \"authors\" }\n] )"
                },
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\": [\n  {\n    \"database\": \"library\"\n  }\n]"
                },
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\": [\n  {\n    \"database\": \"library\",\n    \"collections\": [ \"authors\", \"books\" ]  // DOES NOT WORK WITH $OUT\n  }\n]"
                },
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\" : [\n      {\n          \"database\" : \"sales\",\n          \"collections\": [ \"EMEA\", \"APAC\" ]\n      },\n      {\n          \"database\" : \"marketing\"\n      }\n   ]"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"source\": \"cluster0\",\n   \"destination\": \"cluster1\",\n   \"includeNamespaces\":\n      [\n         { \"database\" : \"students\", \"collections\": [\"undergrad\", \"graduate\", \"adjuncts\"] },\n         { \"database\" : \"staff\" }\n      ]\n}"
                },
                {
                    "lang": "javascript",
                    "value": "// This code works\nuse admin\ndb.runCommand( { renameCollection: \"staff.employees\", to: \"staff.salaried\" } )"
                },
                {
                    "lang": "javascript",
                    "value": "// This code works\nuse admin\ndb.runCommand( { renameCollection: \"students.graduate\", to: \"students.adjuncts\" } )"
                },
                {
                    "lang": "javascript",
                    "value": "// This code produces an error and mongosync stops syncing\nuse admin\ndb.runCommand( { renameCollection: \"students.graduate\", to: \"students.notAFilteredCollection\" } )"
                },
                {
                    "lang": "javascript",
                    "value": "use admin\ndb.runCommand( { renameCollection: \"staff.employees\", to: \"staff.onPayroll\" } )"
                },
                {
                    "lang": "javascript",
                    "value": "use admin\ndb.runCommand( { renameCollection: \"students.adjuncts\", to: \"staff.adjuncts\" } )"
                },
                {
                    "lang": "javascript",
                    "value": "use admin\ndb.runCommand( { renameCollection: \"prospects.current\", to: \"staff.newHires\" } )"
                }
            ],
            "preview": "Starting in 1.1, mongosync supports inclusion filters to specify which\ndatabases and collections to include in sync.  Starting in 1.6, mongosync\nalso supports exclusion filters and regular expressions.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/mongosync-states",
            "title": "mongosync States",
            "headings": [
                "View the Current State",
                "State Descriptions"
            ],
            "paragraphs": "mongosync  enters different states depending on the requests it\nreceives.  mongosync  can only be in a single state at a given time.\nThe current  mongosync  states determines which API operations you can\nrun. This page describes  mongosync  states. To view the current state of  mongosync , use the  /progress . endpoint. The  /progress \nendpoint returns the state in the  state  field. The following table describes each state and lists the permitted\noperations in that state. State Description Possible API Operations IDLE mongosync  is initialized and ready for a sync job to\nbegin. POST   /start GET   /progress RUNNING The sync process is currently running. In this state, data is\ninitially synced to the destination cluster. Subsequent writes to\nthe source cluster are applied to the destination cluster. POST   /pause POST   /commit GET   /progress PAUSED The sync process is paused. To resume the sync process, send a\nrequest to the  /resume  endpoint. POST   /resume GET   /progress COMMITTING The cutover for the sync process has started. The time it takes\nto transition to the  COMMITTED  phase depends on\n lagTimeSeconds . To monitor  lagTimeSeconds  or to see if\n mongosync  has finished committing, use the  /progress  endpoint. GET   /progress COMMITTED The cutover for the sync process is complete. GET   /progress POST   /reverse REVERSING The sync process copies metadata from the destination\ncluster to the source cluster. Then, MongoDB swaps the\nsource and destination clusters and resumes applying\nchange events. GET   /progress",
            "code": [],
            "preview": "mongosync enters different states depending on the requests it\nreceives. mongosync can only be in a single state at a given time.\nThe current mongosync states determines which API operations you can\nrun.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/limitations",
            "title": "Limitations",
            "headings": [
                "General Limitations",
                "MongoDB Community Edition",
                "Unsupported Collection Types",
                "Sharded Clusters",
                "Reversing",
                "Multiple Clusters",
                "Filtered Sync",
                "Capped Collections",
                "System Collections"
            ],
            "paragraphs": "mongosync  does not check for compliance with the documented\nlimitations. Please ensure that your application is not affected by\nthe limitations. Running  mongosync  in the presence of one of\nthese limitations could lead to undefined behavior on the destination\ncluster. For information on MongoDB server compatility, see\n MongoDB Server Version Compatibility . The destination cluster must be empty. mongosync  doesn't validate that the clusters or the environment\nare properly configured. Other clients must not write to the destination cluster while\n mongosync  is running. If write blocking is disabled, the client must  prevent writes  to the source cluster before starting the commit\nprocess. system.* collections  aren't\nreplicated. Documents that have dollar ( $ ) prefixed field names aren't\nsupported. See  Field Names with Periods and Dollar Signs . Serverless clusters aren't supported. A MongoDB Shared Tier isn't supported. Queryable Encryption \nisn't supported. You cannot sync a collection that has a unique index and a non-unique\nindex defined on the same field(s). Before you attempt to run  mongosync  with an  M10+  Atlas cluster, disable\nthe  Require Indexes for All Queries  option. mongosync  doesn't sync users or roles. mongosync  does not replicate  applyOps  operations made on\nthe source cluster during sync to the destination cluster. MongoDB does not test Cluster-to-Cluster Sync with Community builds and in\nmost cases, MongoDB does not offer support for Cluster-to-Cluster Sync with\nCommunity deployments. If you would like to use Cluster-to-Cluster Sync\nwith MongoDB Community Edition, contact a MongoDB sales representative\nto discuss requirements and individualized options. Time-series collections aren't supported. Clustered collections with  expireAfterSeconds  set aren't supported. mongosync  doesn't support sync from a sharded cluster\nto a replica set. Sync from a replica set to a sharded cluster has the following\nlimitations: mongosync  allows users to rename collections that the\n sharding.shardingEntries  option for the  start \ncommand includes during sync. To see limitations on renaming\ncollections while  mongosync  is running, see  Renaming\nDuring Sync . When using the  sharding.createSupportingIndexes  option to create\nindexes supporting shard keys on the destination cluster during\nsync, you cannot create these indexes afterwards on the source\ncluster. The index must either exist before  mongosync  starts or be\ncreated after the migration is complete and  mongosync  has\nstopped. Within a collection, the  _id  field must be unique across all of\nthe shards in the cluster. See  Sharded Clusters and Unique Indexes \nfor more details. The  movePrimary  command cannot be used to reassign the\nprimary shard while syncing. There is no replication for zone configuration.  mongosync \nreplicates data, it doesn't inherit zones. Shards cannot be added or removed while syncing. mongosync  only syncs indexes that exist on all shards. mongosync  only syncs indexes that have consistent index\nspecifications on all shards. To check for index inconsistencies, see  Find Inconsistent\nIndexes Across Shards . The shard key cannot be  refined  while\nsyncing. The shard key cannot be modified using  reshardCollection \nduring syncing. The maximum number of indexes per sharded collection is 63, which is\none less than the  default limit  of 64. mongosync  only supports syncing sharded collections that have\ndefault  collation  settings. If the old source has  unique indexes  which\nare partially distributed across shards, reversing may cause failures.\nEnsure that unique indexes exist on all shards before reversing. The source and destination clusters must have the same number of shards.\nYou cannot reverse sync when the clusters have different topologies or\nmajor versions. mongosync  does not support syncing multiple source clusters to one\ndestination cluster. One cluster cannot simultaneously be a source cluster in one\n mongosync  instance and a destination cluster in another\n mongosync  instance. Filtering is not supported with  reversible sync . The destination cluster must not contain user data prior to starting. The destination cluster must not contain the\n mongosync_reserved_for_internal_use  system database prior to\nstarting. You cannot modify a filter that is in use. To create a new filter,\nsee:  Replace an Existing Filter . You can only rename collections in certain situations. For more\ndetails see:  Adding and Renaming Collections . If a filter includes a  view  but not the\nbase collection, only the view is replicated. You cannot specify system collections or system databases in a filter. To use the  $out  aggregation stage or the  mapReduce \ncommand (when set to create or replace a collection) with filtering,\nyou must configure the filter to use the entire database.\nYou cannot limit the filter to collections within the database. For more information, see  Filtering with mapReduce and $out . Starting in 1.3.0, Cluster-to-Cluster Sync supports  capped\ncollections  with some limitations. Capped collections on the source cluster work normally during sync. Capped collections on the destination cluster have temporary changes\nduring sync: mongosync  restores the original values for maximum number of\ndocuments and maximum document size during commit. convertToCapped  is not supported. If you run\n convertToCapped ,  mongosync  exits with an error. cloneCollectionAsCapped  is not supported. There is no maximum number of documents. The maximum collection size is 1PB. Cluster-to-Cluster Sync does not replicate  system collections  to the destination cluster. If you issue a  dropDatabase  command on the source cluster,\nthis change is not directly applied on the destination cluster. Instead,\nCluster-to-Cluster Sync drops user collections and views in the database\non the destination cluster, but it does not drop system collections\non that database. For example, on the destination cluster: In these cases, the replication of  dropDatabase  removes all user-created\ncollections from the database, but leaves its system collections on the\ndestination cluster. The drop operation does not affect a user-created\n system.js  collection. If you enable profiling, the  system.profile  collection remains. If you create views on the source cluster and then drop the database,\nreplicating the drop removes the views, but leaves an empty\n system.views  collection.",
            "code": [],
            "preview": "MongoDB does not test Cluster-to-Cluster Sync with Community builds and in\nmost cases, MongoDB does not offer support for Cluster-to-Cluster Sync with\nCommunity deployments. If you would like to use Cluster-to-Cluster Sync\nwith MongoDB Community Edition, contact a MongoDB sales representative\nto discuss requirements and individualized options.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/configuration",
            "title": "Configuration",
            "headings": [
                "Configuration File",
                "Options"
            ],
            "paragraphs": "You can configure  mongosync  instances at startup using a\nconfiguration file.  The configuration file contains settings that are\nthe equivalent of  mongosync  command line options. Most  mongosync  command line options can be written to a YAML\nfile. The configuration file specifies values for each setting using\nYAML format. For example: To use a configuration file, start  mongosync  with the\n --config  option to set the path to the file: The  start  command provides additional options for features like\n reversibility  and  user write blocking . For more details, see\nthe  start  API documentation. Type : string To set the  cluster0  setting from the command line, see the\n --cluster0  option. Sets the  connection URI  for the first cluster.\nThe first cluster can serve as either the source or the destination\nin the sync process. Designate the source and destination clusters\nin the call to the  start  API endpoint. For more information on connecting  mongosync , see\n Connections . Type : string To set the  cluster1  setting from the command line,\nsee the  --cluster1  option. Sets the  connection URI  for the second cluster.\nThe second cluster can serve as either the source or the destination\nin the sync process. Designate the source and destination clusters\nin the call to the  start  API endpoint. For more information on connecting  mongosync , see\n Connections . Type : boolean To set the  disableTelemetry  setting from the command line,\nsee the  --disableTelemetry  option. For more information, see  User Data Collection . Disables the collection of  telemetry data  for\n mongosync . By default,  mongosync  collects anonymous, aggregated usage data to\nimprove MongoDB products. When you run  mongosync  you can disable\ncollection of this telemetry data. Type : string To set the  id  setting from the command line, see the\n --id  option. Sets an identifier for the  mongosync  instance. Use this  setting  when running multiple instances of  mongosync  on a sharded\ncluster, to synchronize the shards individually. The identifier value for this  setting  must correspond to the shard ID of the\nshard it syncs.  To find the shard ID, use the  listShards  command. Type : integer To set the  loadLevel  setting from the command line, see the\n --loadLevel  option. Default :  3 Sets the cluster workload level for syncing data between the source and\ndestination clusters: 4 , the highest setting, maximizes cluster workload and syncs data\nthe fastest. 1 , the lowest setting, minimizes cluster workload and syncs data\nthe slowest. Setting  loadLevel  higher than the default of  3  may negatively\nimpact the destination cluster performance. Type : string To set the  logPath  setting from the command line, see the\n --logPath  option. Sets the path to the log directory. Cluster-to-Cluster Sync writes logs\nto files in this directory. For more information, see  Logging . Type : integer To set the  port  setting from the command line, see the\n --port  option. Default :  27182 Sets the port used by the HTTP server for the Cluster-to-Cluster Sync\nHTTP API. Type : string To set the  verbosity  setting from the command line, see the\n --verbosity  option. Default :  DEBUG Sets the verbosity level to use in log messages.\nCluster-to-Cluster Sync logs all messages at the specified level and\nany messages at lower levels. The  verbosity   setting  supports the following values: TRACE DEBUG INFO WARN ERROR FATAL PANIC",
            "code": [
                {
                    "lang": "yaml",
                    "value": "cluster0: \"mongodb://192.0.2.10:27017\"\ncluster1: \"mongodb://192.0.2.20:27017\"\nlogPath: \"/var/log/mongosync\"\nverbosity: \"WARN\""
                },
                {
                    "lang": "console",
                    "value": "$ mongosync --config mongosync.conf"
                }
            ],
            "preview": "Type: string",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/supported-server-version",
            "title": "MongoDB Server Version Compatibility",
            "headings": [
                "Synchronize Data Between Clusters Running Older MongoDB Server Versions",
                "Synchronize Data Between Clusters with Different MongoDB Server Major Versions"
            ],
            "paragraphs": "Before you run Cluster-to-Cluster Sync, consider the following MongoDB server\nversion limitations and requirements: The minimum supported server versions of MongoDB are 6.0.8 and 7.0.0. mongosync  doesn't support MongoDB rapid releases, such as 6.1 or 6.2. The minimum supported server  feature compatibility version \nis 6.0. Starting in version 1.2,  mongosync  can sync between clusters running\nsome older (pre-6.0) releases of MongoDB Server. This feature requires\nadditional preparation and configuration in pre-6.0 releases. If you would like to migrate pre-6.0 versions of MongoDB Server using\n mongosync , please  contact  your\naccount team to inquire about Professional Services. mongosync  supports syncs between the following source and\ndestination MongoDB server versions. Starting in 1.7.0,  mongosync  can perform version migration from\ncertain lower major version source clusters to certain higher major\nversion destination clusters. Cross-version migration requires additional preparation and\nconfiguration when migrating from a pre-6.0 release. To perform a cross-version\nmigration from a pre-6.0 version of the MongoDB Server using\n mongosync , please  contact  your\naccount team to inquire about Professional Services. 6.0  Destination 7.0  Destination 6.0  Source \u221a \u221a 7.0  Source \u221a",
            "code": [],
            "preview": "Before you run Cluster-to-Cluster Sync, consider the following MongoDB server\nversion limitations and requirements:",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/telemetry",
            "title": "Telemetry",
            "headings": [
                "Data Collection",
                "Disable Telemetry Collection"
            ],
            "paragraphs": "By default,  mongosync  collects anonymous, aggregated usage data to\nimprove MongoDB products. When you run  mongosync  you can disable\ncollection of this telemetry data. The data  mongosync  reports includes: mongosync  does not track: For more information, see MongoDB's  Privacy Policy . State information when  mongosync  starts, starts committing, or\npasses through intermediate states Information about the source and destination clusters and the hardware\nthat hosts the  mongosync  instance Initialization arguments The number of source and destination writes The estimated number of bytes  mongosync  copies The estimated number of events  mongosync  applies The request body sent to  start  calls IP addresses Hostnames Usernames Login credentials Connection strings Data stored in MongoDB deployments Personally identifiable information (PII) To disable telemetry collection when you start  mongosync , set one of\nthe following: disableTelemetry  in the  configuration file --disableTelemetry  on the  command line",
            "code": [],
            "preview": "The data mongosync reports includes:",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api/resume",
            "title": "resume",
            "headings": [
                "Description",
                "Requirement",
                "Request",
                "Request Body Parameters",
                "Response",
                "Example",
                "Request",
                "Response",
                "Behavior"
            ],
            "paragraphs": "Resumes a paused synchronization session based on data stored on the\ndestination cluster. To use the  resume  endpoint,  mongosync  must be in the  PAUSED  state. For more information, see  Resume Multiple Mongosyncs . When you configure multiple  mongosync  instances to sync between\nsharded clusters, you must send identical API endpoint commands to each\n mongosync  instance. This endpoint does not use HTTP request body parameters. However, you\n must  specify the  --data  option with an empty object  { } . Field Type Description success boolean When the request is successful, this value is  true . error string If an error occurred, indicates the name of the error. This field\nis omitted from the response when  success  is  true . errorDescription string Detailed description of the error that occurred. This field is\nomitted from the response when  success  is  true . The following example resumes a paused synchronization operation. If the  resume  request is successful,  mongosync  enters the\n RUNNING  state.",
            "code": [
                {
                    "lang": "http",
                    "value": "POST /api/v1/resume"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/resume -XPOST --data '{ }'\n"
                },
                {
                    "lang": "shell",
                    "value": "{\"success\":true}\n"
                }
            ],
            "preview": "Resumes a paused synchronization session based on data stored on the\ndestination cluster.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api/progress",
            "title": "progress",
            "headings": [
                "Description",
                "Request",
                "Response",
                "Successful Response",
                "Error Response",
                "Behavior",
                "Example",
                "Request",
                "Response"
            ],
            "paragraphs": "Returns either an updated status of the synchronization process or an error. The  progress  endpoint returns either an updated status or an error. If  mongosync  successfully gets the status of the sync process,\nall response fields are wrapped in a top-level  progress  object\nwith the following fields: Field Type Description state string The current state of  mongosync . For information on the\npossible states, see  State Descriptions . canCommit boolean If  true , indicates that a  commit \nrequest will succeed. This also means that the initial sync has\ncompleted and is applying change events. canWrite boolean If  true , indicates that writes are permitted on the\ndestination cluster. Do not write to the destination cluster\nwhile  canWrite  is  false . Index validation continues until the  commit  is complete. info string Provides extra information on the synchronization progress.\nPossible  info  values include: \"collection copy\" \"change event application\" \"waiting for commit to complete\" \"commit completed\" lagTimeSeconds integer Time difference in seconds between the latest event timestamp that\n mongosync  applied to the destination cluster and the latest\ntimestamp on the source cluster for this instance of  mongosync . Due to constant no-ops on the source cluster, the time difference\nis often a few seconds above zero, even if there are no real\nwrites on the source cluster. The time difference becomes zero\nwhen  mongosync  commits the migration. mongosync  performs periodic no-op writes on the source cluster,\nwhich may prevent the value of the  lagTimeSeconds  field from\nreaching zero until  mongosync  commits the migration. collectionCopy object Estimates the total amount of data being copied from collections and the\namount that has already been copied to the destination cluster collectionCopy \n .estimatedTotalBytes integer Estimated total number of bytes to be copied globally by all\n mongosync  instances during the initial copying of\ncollections. mongosync  approximates the estimated total number of bytes\nprior to migration and does not update this value during the\nsynchronization process. This value does not reflect changes\nmade to the source cluster during sync and is not an accurate\nindicator of migration progress. collectionCopy \n .estimatedCopiedBytes integer Estimated number of bytes which have been copied to the destination\ncluster by this  mongosync  instance during the initial copying of\ncollections. To calculate the total estimated progress as a percentage, add the value\nof the  estimatedCopiedBytes  field for each  mongosync  instance\nand divide the result by the value of the  estimatedTotalBytes  field\n. Then, multiply the result by 100. The value of  estimatedCopiedBytes  may be larger than the\nvalue of the  estimatedTotalBytes  due to retried operations.\nA comparison of  estimatedTotalBytes  and\n estimatedCopiedBytes  is not an accurate indicator of\nmigration progress. directionMapping object Describes the mapping direction for the synchronization, namely\nthe source and destination clusters. directionMapping \n .Source string Source cluster. Returned in the form\n <cluster name>: <host>:<port> . directionMapping \n .Destination string Destination cluster. Returned in the form\n <cluster name>: <host>:<port> . mongosyncID string The identifier string for the  mongosync  instance. coordinatorID string The identifier string for the coordinator instance. When  mongosync  is coordinated by another instance, this field shows\nthe identifier string for the coordinator instance. When  mongosync  is a coordinator or runs alone, this field returns\nthe same value as its  mongosyncID  field. When  mongosync  starts up, this field returns  null  until\n mongosync  identifies the coordinator. If  mongosync  encounters an error, the  progress  endpoint returns\nthe following field: Field Type Description error string If an error occurred, gives a detailed description of the error.\nThis field is omitted when the call to the endpoint is successful When  mongosync  is in the  IDLE  state, all output\nfields except  state  and  canCommit  are  null . When  mongosync  is in the  PAUSED  state, the\n lagTimeSeconds  field is  null . The endpoint does not auto-refresh. To get updated status, call the\n progress  endpoint again. The following example returns the status of the synchronization process.",
            "code": [
                {
                    "lang": "http",
                    "value": "GET /api/v1/progress"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/progress -XGET\n"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"progress\":\n      {\n         \"state\":\"RUNNING\",\n         \"canCommit\":true,\n         \"canWrite\":false,\n         \"info\":\"change event application\",\n         \"lagTimeSeconds\":0,\n         \"collectionCopy\":\n            {\n               \"estimatedTotalBytes\":694,\n               \"estimatedCopiedBytes\":694\n            },\n         \"directionMapping\":\n            {\n               \"Source\":\"cluster0: localhost:27017\",\n               \"Destination\":\"cluster1: localhost:27018\"\n            }\n      }\n}\n"
                }
            ],
            "preview": "Returns either an updated status of the synchronization process or an error.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/disaster-recovery",
            "title": "Use mongosync for Disaster Recovery",
            "headings": [
                "Unique Indexes",
                "Prepare the Index for Conversion",
                "Resolve Uniqueness Violations",
                "TTL Indexes",
                "Hidden Indexes",
                "Write blocking",
                "Capped Collections"
            ],
            "paragraphs": "Setting up Cluster-to-Cluster Sync to prepare for disaster recovery follows the\nsame procedure as other  connections  between clusters.\nSynchronization keeps the destination cluster up to date with the source\ncluster and ready as a backup. In the event that the source cluster fails or\nbecomes otherwise unavailable, the destination cluster can replace it as the\nprimary cluster. mongosync  temporarily alters some collection characteristics\nduring synchronization. The original values are restored during the\n commit process . If synchronization ends prematurely,\nyou must manually reset these collection characteristics on the destination\ncluster before you can use it as the primary cluster. To prepare the destination cluster to replace the source cluster, make\nthe following changes that mimic the sync finalization process of the\n commit  endpoint. Change Description Unique Indexes Unique indexes on the source cluster synchronize as non-unique indexes\non the destination cluster. Indexes that should be unique must be manually set to unique. TTL Indexes Synchronization sets  expireAfterSeconds  to the value of  MAX_INT \non the destination cluster. Use the  collMod  command to set  expireAfterSeconds \nto the desired value. Hidden Indexes Synchronization replicates hidden indexes as non-hidden. Use the  collMod  command to hide any indexes that should\nbe hidden. Write Blocking mongosync  can disable writes on the destination cluster. If synchronization was started with write blocking, disable the Write\nBlock Mode. Capped Collections Synchronization sets capped collections to the maximum allowable\nsize. To set your required maximum size, use the\n collMod  command. mongosync  replicates writes in parallel, which can cause\ntransient uniqueness violations on the destination cluster. To avoid\nthese errors, unique indexes are replicated as non-unique. If\nsynchronization ends early, manually resolve any uniqueness violations\nand convert any non-unique indexes that should be unique into unique indexes. For each non-unique index on the destination cluster that should be\nunique, run  collMod  with  prepareUnique  set to\n true . After running  collMod , the index rejects any new writes that\nwould introduce duplicate keys. There may still be uniqueness conflicts in the index after you run\n prepareUnique . To find conflicts and convert the index to a unique\nindex, run  collMod  with  unique  set to  true  on each of the\nnon-unique indexes that you want to set as unique. If the call to  collMod  succeeds, there are no uniqueness violations\non that index and the index is converted to an unique index. If the call to  collMod  fails with a  CannotConvertIndexToUnique \nerror, correct the uniqueness violations and rerun  collMod . See:  Convert an Existing Index During synchronization,  expireAfterSeconds  is set\nto  MAX_INT  for  TTL indexes . To reset  expireAfterSeconds , use the\n collMod  command to change the expiration value. During synchronization,  hidden indexes  are\nnot hidden on the destination cluster. Use the  collMod  command to\nhide indexes that should be hidden. When write blocking is enabled as part of the  /start  command,  mongosync  blocks user writes on the\ndestination cluster during replication. If replication ends\nprematurely, you must manually unblock writing on the destination. After writing is enabled, you can redirect writes from your client\napplication to the destination cluster. To enable writes, update  setUserWriteBlockMode : During synchronization, capped collections are set to the maximum\nallowable size. To set your required maximum size, use the  collMod \ncommand. For details, see  Resize a Capped Collection .",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.adminCommand(\n    {\n        setUserWriteBlockMode: 1,\n        global: false\n    }\n)"
                }
            ],
            "preview": "Setting up Cluster-to-Cluster Sync to prepare for disaster recovery follows the\nsame procedure as other connections between clusters.\nSynchronization keeps the destination cluster up to date with the source\ncluster and ready as a backup. In the event that the source cluster fails or\nbecomes otherwise unavailable, the destination cluster can replace it as the\nprimary cluster.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api/pause",
            "title": "pause",
            "headings": [
                "Description",
                "Requirement",
                "Request",
                "Request Body Parameters",
                "Response",
                "Example",
                "Request",
                "Response",
                "Behavior"
            ],
            "paragraphs": "Pauses the current synchronization operation. To use the  pause  endpoint,  mongosync  must be in the  RUNNING  state. For more information, see  Pause Multiple Mongosyncs . When you configure multiple  mongosync  instances to sync between\nsharded clusters, you must send identical API endpoint commands to each\n mongosync  instance. This endpoint does not use HTTP request body parameters. However, you\n must  specify the  --data  option with an empty object  { } . Field Type Description success boolean When the request is successful, this value is  true . error string If an error occurred, indicates the name of the error. This field\nis omitted from the response when  success  is  true . errorDescription string Detailed description of the error that occurred. This field is\nomitted from the response when  success  is  true . The following example pauses the current synchronization operation. If the  pause  request is successful,  mongosync  enters the\n PAUSED  state. If you plan to pause synchronization for an extended period of time,\nincrease the size of the replica set  oplog  in the source\ncluster. To learn more, see  Frequently Asked Questions .",
            "code": [
                {
                    "lang": "http",
                    "value": "POST /api/v1/pause"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/pause -XPOST --data '{ }'\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                }
            ],
            "preview": "Pauses the current synchronization operation.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api/reverse",
            "title": "reverse",
            "headings": [
                "Description",
                "Requirements",
                "Validate Unique Indexes",
                "Resync all secondaries, one by one.",
                "Step down the primary node and step up one of the secondary nodes.",
                "Resync the old primary node from the new primary node.",
                "Request",
                "Request Body Parameters",
                "Response",
                "Example",
                "Request",
                "Response",
                "Behavior"
            ],
            "paragraphs": "Reverses the direction of a committed sync operation. For example: In this scenario, you can use the  reverse  endpoint to sync writes\nfrom  cluster1  to  cluster0 . You have a  COMMITTED  sync operation. cluster0  is the source and  cluster1  is the destination. After the sync operation is  COMMITTED , new writes occur only on\nthe destination cluster. The source cluster will not accept new\nwrites. To use the  reverse  endpoint: mongosync  must be configured when the initial sync begins. The\ncall to the  /start  API endpoint must set: You cannot update these options after the sync starts. reversible  to  true enableUserWriteBlocking  to  true mongosync  must be in the  COMMITTED  state. The destination cluster oplog must not roll over between\n mongosync  reaching the  COMMITTED  state and receiving\nthe  /reverse  request. Unique Indexes  require proper formatting.  Collections with indexes\ninitially created on MongoDB 4.2 may not have the proper formatting. To validate that collection indexes use the proper formatting, see\n Validate Unique Indexes . The source and destination clusters must have the same number of shards.\nYou cannot reverse sync when the clusters have different topologies or\nmajor versions. The user specified in the  mongosync  connection string must have the\nrequired permissions on the source and destination clusters. The\npermissions vary depending on your environment and if you want to run a\nwrite-blocking or reverse sync. For more information, see  Reverse Multiple Mongosyncs . When you configure multiple  mongosync  instances to sync between\nsharded clusters, you must send identical API endpoint commands to each\n mongosync  instance. In order to reverse direction,  mongosync  requires that all\n unique  indexes use the correct formatting.\nClusters that began with MongoDB 4.2 or older and were since\nupgraded may include unique indexes that are not properly formatted. To correct indexes, you can  resync  all nodes\nin the original source cluster.  To resync all nodes: Alternatively, to avoid resyncing, you can use the\n db.collection.validate()  method with  full = false  on each\ncollection with unique indexes on all nodes to determine whether each\ncollection contains improperly formatted unique indexes. If\n db.collection.validate()  does not return a warning about a\nunique index, you can skip resyncing. For a tutorial on resyncing nodes, see  Resync a Member of a\nReplica Set . This endpoint does not use HTTP request body parameters. However, you\n must  specify the  --data  option with an empty object  { } . Field Type Description success boolean When the request is successful, this value is  true . error string If an error occurred, indicates the name of the error. This field\nis omitted from the response when  success  is  true . errorDescription string Detailed description of the error that occurred. This field is\nomitted from the response when  success  is  true . The following example reverses the direction of a committed sync operation. If the  reverse  request is successful,  mongosync  enters the\n RUNNING  state. The synchronization continues in the reverse\ndirection from the original sync job. You do not need to restart the\nentire sync process to copy the original data. To view the mapping direction for the synchronization of the source and\ndestination clusters, use the  progress \nendpoint and check the  directionMapping  object.",
            "code": [
                {
                    "lang": "http",
                    "value": "POST /api/v1/reverse"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/reverse -XPOST --data '{ }'\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                }
            ],
            "preview": "Reverses the direction of a committed sync operation.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/mongosync",
            "title": "mongosync",
            "headings": [
                "Description",
                "Options",
                "Global Options",
                "Behavior",
                "Cluster Independence",
                "Configuration File",
                "Consistency",
                "Profiling",
                "Sharded Clusters",
                "Views",
                "Write Blocking",
                "User Permissions",
                "Permissible Reads",
                "Permissible Writes",
                "Commit",
                "Read and Write Concern",
                "Read Preference",
                "Capped Collections",
                "System Collections",
                "Resilience",
                "UUIDs",
                "Sorting",
                "Multiple Clusters",
                "Examples"
            ],
            "paragraphs": "The  mongosync  binary is the primary process used in\nCluster-to-Cluster Sync.  mongosync  migrates data from one cluster to\nanother and can keep the clusters in continuous sync. This document provides a complete overview of the  mongosync  command\nline options. Both the source cluster and destination cluster must use MongoDB\n6.0 or later. mongosync  supports replica sets and sharded clusters. Standalone MongoDB instances are not supported.  Convert the\nstandalone instance  to a\nreplica set before using Cluster-to-Cluster Sync. mongosync  does not support Atlas shared clusters or serverless\ninstances. For a full list of limitations, see  Cluster-to-Cluster Sync\nLimitations . To set the  --cluster0  option from a configuration file,\nsee the  cluster0  setting. Sets the  connection URI  for the first cluster.\nThe first cluster can serve as either the source or the destination\nin the sync process. Designate the source and destination clusters\nin the call to the  start  API endpoint. For more information on connecting  mongosync , see\n Connections . To set the  --cluster1  option from a configuration file,\nsee the  cluster1  setting. Sets the  connection URI  for the second cluster.\nThe second cluster can serve as either the source or the destination\nin the sync process. Designate the source and destination clusters\nin the call to the  start  API endpoint. For more information on connecting  mongosync , see\n Connections . Sets the path to the configuration file. For more information, see  Cluster Independence . To set the  --disableTelemetry  option from a configuration file,\nsee the  disableTelemetry  setting. For more information, see  User Data Collection . Disables the collection of  telemetry data  for\n mongosync . By default,  mongosync  collects anonymous, aggregated usage data to\nimprove MongoDB products. When you run  mongosync  you can disable\ncollection of this telemetry data. Prints usage information to stdout. To set the  --id  option from a configuration file,\nsee the  id  setting. Sets an identifier for the  mongosync  instance. Use this  option  when running multiple instances of  mongosync  on a sharded\ncluster, to synchronize the shards individually. The identifier value for this  option  must correspond to the shard ID of the\nshard it syncs.  To find the shard ID, use the  listShards  command. Type : integer To set the  --loadLevel  option from a configuration file, see the\n loadLevel  setting. Default :  3 Sets the cluster workload level for syncing data between the source and\ndestination clusters: 4 , the highest setting, maximizes cluster workload and syncs data\nthe fastest. 1 , the lowest setting, minimizes cluster workload and syncs data\nthe slowest. Setting  loadLevel  higher than the default of  3  may negatively\nimpact the destination cluster performance. To set the  --logPath  option from a configuration file,\nsee the  logPath  setting. Sets the path to the log directory. Cluster-to-Cluster Sync writes logs\nto files in this directory. For more information, see  Logging . To set the  --port  option from a configuration file,\nsee the  port  setting. Default :  27182 Sets the port used by the HTTP server for the Cluster-to-Cluster Sync\nHTTP API. To set the  --verbosity  option from a configuration file,\nsee the  verbosity  setting. Default :  DEBUG Sets the verbosity level to use in log messages.\nCluster-to-Cluster Sync logs all messages at the specified level and\nany messages at lower levels. The  --verbosity   option  supports the following values: TRACE DEBUG INFO WARN ERROR FATAL PANIC Prints  mongosync  version information to stdout. mongosync  syncs collection data between a source cluster and\ndestination cluster.  mongosync  does not synchronize  users  or  roles . As a result, you can create\nusers with different access permissions on each cluster. Options for  mongosync  can be set in a YAML configuration file. Use\nthe  --config  option. For example: For information on available settings, see  Configuration . mongosync  supports  eventual consistency  on the destination\ncluster. Read Consistency is not guaranteed on the destination cluster,\nthe source and destination clusters may differ at a given point in\ntime. However, if new writes are halted on the source cluster, the\nsource and destination clusters will eventually hold the same data. Individual writes may be reordered or combined as they are relayed from\nsource to destination. For a given document, the total number of writes\nmay differ between source and destination. Transactions may appear non-atomically on the destination cluster.\nRetryable writes may not be retryable on the destination cluster. If profiling is enabled on a source database, MongoDB creates a special\ncollection named  <db>.system.profile . After synchronization is\ncomplete, Cluster-to-Cluster Sync will not drop the\n <db>.system.profile  collection from the destination even if the\nsource database is dropped at a later time. The  <db>.system.profile \ncollection will not change the accuracy of user data on the\ndestination. Cluster-to-Cluster Sync supports replication between sharded clusters.\nIndividual shards are replicated in parallel from the source cluster to\nthe destination cluster, however a  chunk migration  or similar source update could move\ndocuments to a new source shard during replication. Even if documents move between source shards during replication,\nCluster-to-Cluster Sync maintains the  eventual consistency \nguarantee on the destination cluster. If a database with views is dropped on the source, the destination may\nshow an empty  system.views  collection in that database. The empty\n system.views  collection will not change the accuracy of user\ndata on the destination. You must enable write-blocking when you start  mongosync  if you want\nto use  reverse synchronization  later. mongosync  does not enable write-blocking by default. If you enable\nwrite-blocking,  mongosync  blocks writes: To enable write-blocking, use the  start API \nto set  enableUserWriteBlocking  to  true . You cannot enable\nwrite-blocking after the sync starts. On the destination cluster during sync. On the source cluster while  commit  is running. To set  enableUserWriteBlocking , the  mongosync  user must have a\nrole that includes the  setUserWriteBlockMode  and\n bypassWriteBlockingMode  ActionTypes. When using  enableUserWriteBlocking , writes are only blocked for users\nthat do not have the  bypassWriteBlockingMode  ActionType. Users\nwho have this ActionType are able to perform writes. Read operations on the source cluster are always permitted. When the  /progress  endpoint reports  canWrite  is\n true , the data on the source and destination clusters is consistent. To see what state  mongosync  is in, call the  /progress  API endpoint. The  /progress  output includes a\nboolean value,  canWrite . When  canWrite  is  true , it is safe to write to the destination\ncluster. When  canWrite  is  false , do not write to the destination\ncluster. You can safely write to the source cluster while  mongosync  is\nsyncing. Do not write to the destination cluster unless  canWrite  is\n true . To stop syncing, use the  commit  command on the\ndestination cluster to convert indexes and finalize the changes. If you\nenable  write-blocking : To monitor the  commit  process, use the  progress  command: commit  blocks writes on the source cluster. commit  blocks writes on the destination cluster until\n mongosync  begins index validation. The destination cluster is writable when  canWrite  is true. Index conversion is complete when  mongosync  enters the\n COMMITTED  state. By default,  mongosync  sets the read concern level to\n \"majority\"  for reads on the source cluster. For writes on\nthe destination cluster,  mongosync  sets the write concern level to\n \"majority\"  with  j: true . For more information on read and write concern configuration and\nbehavior, see  Read Concern  and  Write Concern . By default,  mongosync  sets the source cluster read preference to\n nearest  to distribute reads evenly across nodes. To change\nthe read preference of the source cluster, specify the read preference\nmode in the URI of the connection string. For details, see\n Read Preference Options . Starting in 1.3.0, Cluster-to-Cluster Sync supports  capped\ncollections  with some limitations. Capped collections on the source cluster work normally during sync. Capped collections on the destination cluster have temporary changes\nduring sync: mongosync  restores the original values for maximum number of\ndocuments and maximum document size during commit. convertToCapped  is not supported. If you run\n convertToCapped ,  mongosync  exits with an error. cloneCollectionAsCapped  is not supported. There is no maximum number of documents. The maximum collection size is 1PB. Cluster-to-Cluster Sync does not replicate  system collections  to the destination cluster. If you issue a  dropDatabase  command on the source cluster,\nthis change is not directly applied on the destination cluster. Instead,\nCluster-to-Cluster Sync drops user collections and views in the database\non the destination cluster, but it does not drop system collections\non that database. For example, on the destination cluster: In these cases, the replication of  dropDatabase  removes all user-created\ncollections from the database, but leaves its system collections on the\ndestination cluster. The drop operation does not affect a user-created\n system.js  collection. If you enable profiling, the  system.profile  collection remains. If you create views on the source cluster and then drop the database,\nreplicating the drop removes the views, but leaves an empty\n system.views  collection. mongosync  is resilient and able to handle non-fatal errors. Logs\nthat contain the word \"error\" or \"failure\" do not indicate that\n mongosync  is failing or corrupting data. For example, if a network\nerror occurs, the  mongosync  log may contain the word \"error' but\n mongosync  is still able to complete the sync. In the case that a\nsync does not complete,  mongosync  writes a fatal log entry. mongosync  creates collections with new  UUIDs (universally\nunique identifiers)  on the destination cluster. There is no\nrelationship between UUIDs on the source cluster and the destination\ncluster. If applications contain hard-coded UUIDs (which MongoDB does\nnot recommend), you may need to update those applications before they\nwork properly with the migrated cluster. mongosync  inserts documents on the destination cluster in an\nundefined order which does not preserve natural sort order from the\nsource cluster. If applications depend on document order but don't have\na defined sort method, you may need to update those applications to\nspecify the expected sort order before the applications work properly\nwith the migrated cluster. To sync a source cluster to multiple destination clusters, use one\n mongosync  instance for each destination cluster. For more\ninformation, see  Multiple Clusters Limitations . Deploy a source and a destination cluster. Initialize Cluster-to-Cluster Sync: Use the appropriate connection strings for the  --cluster0 \nand  --cluster1  options so that they can connect to your\nreplica sets. To start the synchronization process, use an HTTP client such as\ncURL to send the  start  command to  mongosync : Example Output:",
            "code": [
                {
                    "lang": "console",
                    "value": "$ mongosync --config /etc/mongosync.conf"
                },
                {
                    "lang": "bash",
                    "value": "mongosync \\\n     --cluster0 \"mongodb://192.0.2.10:27017,192.0.2.11:27017,192.0.2.12:27017\" \\\n     --cluster1 \"mongodb://192.0.2.20:27017,192.0.2.21:27017,192.0.2.22:27017\""
                },
                {
                    "lang": "bash",
                    "value": "curl localhost:27182/api/v1/start -X POST \\\n      --data '{ \"source\": \"cluster0\", \"destination\": \"cluster1\" }'"
                },
                {
                    "lang": "json",
                    "value": "{ \"success\": true }"
                }
            ],
            "preview": "To set the --cluster0 option from a configuration file,\nsee the cluster0 setting.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/verification/hash",
            "title": "Verify with Hash Comparison",
            "headings": [
                "About This Task",
                "Steps",
                "Retrieve the Source Hash",
                "Retrieve the Destination Hash",
                "Compare the Hashes",
                "Learn More"
            ],
            "paragraphs": "You can verify sync by comparing MD5 hashes of collections synced from the\nsource cluster to the destination cluster. While hash comparison ensures\nthat the destination cluster has received all changes from the source, the\n dbHash  command locks the cluster, preventing additional writes\nuntil it completes.  This process can also be much slower than verification\nusing  document counts . Hash comparison is not possible with sharded clusters. It also does not\nwork for standalone servers and replica sets that use MongoDB 4.4 or earlier\nreleases, since the document field order can vary. If you need to sync a sharded cluster or an older release of MongoDB, or\nif the locks are unacceptable for your application workload, use a different\n verification method . Run the  dbHash  command on the source cluster.\nIn the  collections  field, list each collection included\nin the sync. Then, return the  md5  output field: While running this command, retrieve the destination hash. Run the  dbHash  command on the destination cluster.\nIn the  collections  field, list each collection included\nin the sync. Then, return the  md5  output field: Note the hash. Compare the  md5  values from each cluster. If both clusters return\nthe same MD5 value, the sync was successful. Verify with Document Counts Verify with Migration Verifier",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.runCommand({\n   dbHash: 1,\n   collections: [\n      \"accounts.us_accounts\",\n      \"accounts.eu_accounts\",\n      ...\n   ]}).md5"
                },
                {
                    "lang": "text",
                    "value": "d41d8cd98f00b204e9800998ecf8427e"
                },
                {
                    "lang": "javascript",
                    "value": "db.runCommand({\n   dbHash: 1,\n   collections: [\n      \"accounts.us_accounts\",\n      \"accounts.eu_accounts\",\n      ...\n   ]}).md5"
                },
                {
                    "lang": "text",
                    "value": "d41d8cd98f00b204e9800998ecf8427e"
                }
            ],
            "preview": "You can verify sync by comparing MD5 hashes of collections synced from the\nsource cluster to the destination cluster. While hash comparison ensures\nthat the destination cluster has received all changes from the source, the\ndbHash command locks the cluster, preventing additional writes\nuntil it completes.  This process can also be much slower than verification\nusing document counts.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/verification/count",
            "title": "Verify with Document Counts",
            "headings": [
                "Steps",
                "Count Source Documents",
                "Count Destination Documents",
                "Compare Counts",
                "Learn More"
            ],
            "paragraphs": "The most basic method of verification is to compare the number of documents\nin each synced collection on the source cluster to the number on the\ndestination cluster. This method only verifies a successful sync when run against clusters with\ninsert-only workloads. If you do not have an insert-only workload for the\ncluster, use a different  verification method . Run the  countDocuments()  method on each synced\ncollection on the source cluster: Note the number of documents. Run the  countDocuments()  method on each synced\ncollection on the destination cluster: Note the number of documents. Compare the results of each document count: If the document count is different, not all changes synced to the\ndestination cluster. If the document count is the same  and  your cluster has an insert-only\nworkload, the sync was successful. If your source cluster does  not  have an insert-only workload, use a\ndifferent method to verify sync. Verify with Hash Comparison Verify with Migration Verifier",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.us_accounts.countDocuments()"
                },
                {
                    "lang": "javascript",
                    "value": "345"
                },
                {
                    "lang": "javascript",
                    "value": "db.us_accounts.countDocuments()"
                },
                {
                    "lang": "javascript",
                    "value": "345"
                }
            ],
            "preview": "The most basic method of verification is to compare the number of documents\nin each synced collection on the source cluster to the number on the\ndestination cluster.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api/commit",
            "title": "commit",
            "headings": [
                "Description",
                "Requirements",
                "Request",
                "Request Body Parameters",
                "Response",
                "Example",
                "Confirm that the Synchronization is Ready",
                "Request",
                "Response",
                "Send the Commit Request",
                "Request",
                "Response",
                "Behavior",
                "State",
                "Data Verification"
            ],
            "paragraphs": "Finalizes the sync between the source cluster and the destination\ncluster and stops continuous sync between clusters.  commit  also\nrestores collection characteristics that  mongosync  temporarily\nalters during synchronization. The following table illustrates the impact of  commit  on collection\ncharacteristics that  mongosync  alters during the synchronization process. Collection Characteristic Impact of  commit Unique Indexes commit  resets unique indexes that  mongosync  replicated as\nnon-unique on the destination cluster. TTL Indexes commit  resets  expireAfterSeconds  which  mongosync  set\nto the value of  MAX_INT  on the destination cluster. Hidden Indexes commit  resets hidden indexes that  mongosync \nreplicated as non-hidden on the destination cluster. Write Blocking If  mongosync  disabled writes on the destination cluster,\n commit  disables the Write Block Mode. Capped Collections commit  resets the required maximum size of capped collections\nwhich  mongosync  set to the maximum allowable size on the\ndestination cluster. Before using the  commit  endpoint: Stop your application. This ensures that no additional writes occur on\nthe source cluster. Use the  progress  endpoint to confirm the\nfollowing values: lagTimeSeconds  is near  0  ( Recommended, but not required ) lagTimeSeconds  indicates the time between the last applied\nevent and time of the current latest event. When you send a\n commit  request,  mongosync  enters the  COMMITTING  state\nfor the amount of seconds reported by  lagTimeSeconds , and\nthen transitions to the  COMMITTED  state. When  lagTimeSeconds  is  0 , the source and destination\nclusters are in a consistent state. state: \"RUNNING\" canCommit: true For more information, see  Commit Synchronization From  Multiple  mongosync  Instances . When you configure multiple  mongosync  instances to sync between\nsharded clusters, you must send identical API endpoint commands to each\n mongosync  instance. This endpoint does not use HTTP request body parameters. However, you\n must  specify the  --data  option with an empty object  { } . Field Type Description success boolean When the request is successful, this value is  true . error string If an error occurred, indicates the name of the error. This field\nis omitted from the response when  success  is  true . errorDescription string Detailed description of the error that occurred. This field is\nomitted from the response when  success  is  true . The following example commits the synchronization operation to the\ndestination cluster. Before sending a request to the  commit  endpoint, use the\n progress  endpoint to confirm that the\nsynchronization is ready to be committed. The  progress  endpoint returned  \"canCommit\":true , which means\nthat the  commit  request can run successfully. The following command sends a request to the  commit  endpoint: If the  commit  request is successful,  mongosync  enters the\n COMMITTING  state, then automatically transitions to the\n COMMITTED  state. Once  mongosync  enters the  COMMITTED  state,\ncontinuous sync between the clusters stops. Before transferring your application load from the source cluster to the\ndestination, check your data to ensure that the sync was successful. For more information, see  Verify Data Transfer .",
            "code": [
                {
                    "lang": "http",
                    "value": "POST /api/v1/commit"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/progress -XGET\n"
                },
                {
                    "lang": "shell",
                    "value": "{\n   \"progress\":\n      {\n         \"state\":\"RUNNING\",\n         \"canCommit\":true,\n         \"canWrite\":false,\n         \"info\":\"change event application\",\n         \"lagTimeSeconds\":0,\n         \"collectionCopy\":\n            {\n               \"estimatedTotalBytes\":694,\n               \"estimatedCopiedBytes\":694\n            },\n         \"directionMapping\":\n            {\n               \"Source\":\"cluster0: localhost:27017\",\n               \"Destination\":\"cluster1: localhost:27018\"\n            }\n      }\n}\n"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/commit -XPOST --data '{ }'\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                }
            ],
            "preview": "Finalizes the sync between the source cluster and the destination\ncluster and stops continuous sync between clusters. commit also\nrestores collection characteristics that mongosync temporarily\nalters during synchronization.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/verification/verifier",
            "title": "Verify with Migration Verifier",
            "headings": [
                "About This Task",
                "Steps",
                "Sync Clusters",
                "Wait for mongosync to reach CEA",
                "Start Migration Verifier",
                "Start the Verification Checks",
                "Signal Sync Completion",
                "Check Progress",
                "Learn More"
            ],
            "paragraphs": "Migration Verifier connects to the source and destination clusters and performs\na series of verification checks, comparing documents, views, and indexes to\nconfirm the sync was successful. Unlike other verification methods, Migration Verifier can run concurrently with\n mongosync , checking documents on the destination cluster as they sync. This\ncan reduce the amount of time needed to verify the success of the sync before\ntransferring your application load from the source to the destination cluster. Migration Verifier is an experimental and unsupported tool. For installation instructions, see\n GitHub . Run  mongosync  to sync the source and destination clusters. Before you can start verification checks with Migration Verifier,\nyou must wait until  mongosync  reaches the Change Event Application\n(CEA) phase. To check that  mongosync  has reached the CEA phase, send the\n /progress  command and check that the\n progress.info  field returns  change event application . Start the  migration-verifier  process: To start the verification checks, use cURL to send the  check  command to\nMigration Verifier: When the sync is complete and  mongosync  has reached the\n COMMITTED  state, use cURL to send the  writesOff  command to\nMigration Verifier: To view the results, use cURL to send the  progress  command to\nMigration Verifier. When the  phase  field is  idle , the verification checks are\ncomplete. If the  failedTasks  field returns 0, the sync was successful. Verify with Document Counts Verify with Hash Comparison Migration Verifier on GitHub .",
            "code": [
                {
                    "lang": "bash",
                    "value": "curl localhost:27182/api/v1/progress -XGET"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"progress\":\n      {\n         \"state\":\"RUNNING\",\n         \"canCommit\":true,\n         \"canWrite\":false,\n         \"info\":\"change event application\",\n         \"lagTimeSeconds\":0,\n         \"collectionCopy\":\n            {\n               \"estimatedTotalBytes\":694,\n               \"estimatedCopiedBytes\":694\n            },\n         \"directionMapping\":\n            {\n               \"Source\":\"cluster0: localhost:27017\",\n               \"Destination\":\"cluster1: localhost:27018\"\n            }\n      }\n}"
                },
                {
                    "lang": "bash",
                    "value": "migration-verifier --verifyAll \\\n   --srcURI example.net:27020 \\\n   --destURI example.net:27021 \\\n   --metaURI example.net:27017"
                },
                {
                    "lang": "bash",
                    "value": "curl -H \"Content-Type: application/json\" \\\n    -X POST -d '{}' http://127.0.0.1:27020/api/v1/check"
                },
                {
                    "lang": "bash",
                    "value": "curl -H \"Content-Type: application/json\" \\\n    -X POST -d '{}' http://127.0.0.1:27020/api/v1/writesOff"
                },
                {
                    "lang": "bash",
                    "value": "curl -H \"Content-Type: application/json\" \\\n   -X GET http://127.0.0.1:27020/api/v1/progress"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"progress\": {\n      \"phase\": \"idle\",\n      \"error\": null,\n      \"verificationStatus\": {\n         \"totalTasks\": 1,\n         \"addedTasks\": 0,\n         \"processingTasks\": 0,\n         \"failedTasks\": 0,\n         \"completedTasks\": 0,\n         \"metadataMismatchTasks\": 0,\n         \"recheckTasks\": 0\n      }\n   }\n}"
                }
            ],
            "preview": "Migration Verifier connects to the source and destination clusters and performs\na series of verification checks, comparing documents, views, and indexes to\nconfirm the sync was successful.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/collection-level-filtering/filter-regex",
            "title": "Regular Expressions in Filters",
            "headings": [
                "Syntax",
                "Use Cases",
                "Details",
                "Regular Expression Options",
                "Learn More"
            ],
            "paragraphs": "Starting in 1.6, the  start  API now supports the use of\nRegular Expressions to configure filters for the  includeNamespaces \nand  excludeNamespaces  parameters used in  Filtered Sync . To match databases and collections for  mongosync  to use  Filtered Sync ,\nyou can use regular expressions: Regular expressions in filter documents use the following fields: These options are available to use with both the  includeNamespaces \nand  excludeNamespaces  parameters. Option Type Description collectionsRegex document Specifies which collections you want the filter\nto match. collectionsRegex.options string Regular expression options to use in the match. collectionsRegex.pattern string Regular expression pattern to match. databaseRegex document Specifies which databases you want the filter\nto match. databaseRegex.options string Regular expression options to use in the match. databaseRegex.pattern string Regular expression pattern to match. Regular expressions allow you match multiple databases or collections with a\nsingle pattern.  If you want to match multiple similarly named\ndatabases or collections, a regular expression may be easier to match than\ncreating a series of filters for individual databases or groups of collections. databaseRegex  and  collectionsRegex  each supports an  options  field,\nwhich you can use to configure regular expression options.\nInternally,  mongosync  passes the filter and options to the\n $regex  operator. Options available to that operator can be used\nwith Filtred Sync. For example, this filter would match collections in the  sales  database\nthat begin start with the  accounts_  string: Filtered Sync",
            "code": [
                {
                    "lang": "json",
                    "value": "{\n   \"databaseRegex\": {\n      \"pattern\": \"<string>\",\n      \"options\": \"<string>\"\n   },\n   \"collectionsRegex\": {\n      \"pattern\": \"<string>\",\n      \"options\": \"<string>\"\n   }\n}"
                },
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\": [\n   {\n      \"database\": \"sales\",\n      \"collectionsRegex\": {\n         \"pattern\": \"^accounts_.+?$\",\n         \"options\": \"ms\"\n      }\n   }\n]"
                }
            ],
            "preview": "To match databases and collections for mongosync to use Filtered Sync,\nyou can use regular expressions:",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        },
        {
            "slug": "reference/api/start",
            "title": "start",
            "headings": [
                "Description",
                "Requirements",
                "State",
                "User Write Blocking",
                "Request",
                "Request Body Parameters",
                "Sharding Parameters",
                "Response",
                "Example: Start a Sync Job",
                "Request",
                "Response",
                "Example: Start a Reversible Sync Job",
                "Request",
                "Response",
                "Example: Start a Filtered Sync Job",
                "Request",
                "Response",
                "Example: Start Sync from Replica Set to Sharded Cluster",
                "Request",
                "Response",
                "Behavior",
                "State",
                "Pre-Split Chunks",
                "Shard Replica Sets",
                "Supporting Indexes",
                "Rename During Sync",
                "Required Indexes"
            ],
            "paragraphs": "Starts the synchronization between a source and destination cluster. To use the  start  endpoint,  mongosync  must be in the  IDLE \nstate. To set a custom role for the  mongosync  user: Ensure that you use this configured  mongosync  user in the connection\nstrings for the  cluster0  or  cluster1  settings when\nyou start  mongosync . To set  enableUserWriteBlocking , the  mongosync  user must have a\nrole that includes the  setUserWriteBlockMode  and\n bypassWriteBlockingMode  ActionTypes. When using  enableUserWriteBlocking , writes are only blocked for users\nthat do not have the  bypassWriteBlockingMode  ActionType. Users\nwho have this ActionType are able to perform writes. To create a custom role, use the  createRole  command: To grant the custom role to the  mongosync  user, use the  grantRolesToUser  command: For more information, see  Start Multiple Mongosyncs . When you configure multiple  mongosync  instances to sync between\nsharded clusters, you must send identical API endpoint commands to each\n mongosync  instance. Parameter Type Necessity Description source string Required Name of the source cluster. destination string Required Name of the destination cluster. buildIndexes string Optional Configures index builds during sync. Supported Options: /start  returns an error when  buildIndexes  is set to  never \nand  reversible  is set to  true . If you call  /start  without specifying the  buildIndexes  option,\n mongosync  builds indexes on the destination cluster. beforeDataCopy  (the default) causes  mongosync  to build indexes\non the destination cluster. These include both existing indexes and\nany indexes created during migration on the source cluster. never  causes  mongosync  to skip building unnecessary indexes\nduring sync.  This can improve migration performance, especially with\nindex heavy workloads. For more information on the indexes it does build, see\n Required Indexes . Do  not  manually build indexes while  mongosync  is\nperforming a migration.  Wait until the migration is fully\ncommitted. enableUserWriteBlocking boolean Optional If set to  true , blocks writes on the destination cluster\nwhile the synchronization is in progress. After the\nsynchronization is committed to the destination cluster, the\noriginal source cluster blocks writes and the destination cluster\naccepts writes. To reverse sync, the  enableUserWriteBlocking  field must be set\nto  true . Default value is  false . includeNamespaces array Optional Filters the databases or collections to include in sync. If you configure a filter on a source cluster that has multiple\ndatabases,  mongosync  only syncs the databases specified in\nthe filter definition.  mongosync  will not sync the other\nexisting databases. If you want to modify the filter to add a newly created database,\nyou have to  restart the filtered sync \nfrom the beginning. For more details, see  Filtered Sync . For current limitations, see  Filtered Sync . excludeNamespaces array Optional Filters the databases or collections to exclude from sync. If you configure a filter on a source cluster that has multiple\ndatabases,  mongosync  only syncs the databases specified in\nthe filter definition.  mongosync  will not sync the other\nexisting databases. If you want to modify the filter to add a newly created database,\nyou have to  restart the filtered sync \nfrom the beginning. For more details, see  Filtered Sync . For current limitations, see  Filtered Sync . reversible boolean Optional If set to  true , enables the sync operation to be\nreversed. To reverse sync, the  enableUserWriteBlocking  field must be set\nto  true . This option is not supported for the following configurations: For more information, see the  reverse  endpoint. Default value is  false . Sync from a replica set to a sharded cluster Sync sharded clusters that have different numbers of shards Reversible sync when  buildIndexes  is set to  never . sharding document Optional Configures sync between a replica set and sharded cluster.\nSync from a replica set to a sharded cluster requires this\noption. For more information, see  Sharding Parameters . To sync from a replica set to a sharded cluster, set the\n sharding  option to shard collections on the destination cluster. The  sharding  option has the following parameters: mongosync  throws an error if the  sharding  option is not set when\nsyncing from a replica set to a sharded cluster.   mongosync  also\nthrows an error if the  sharding  option is set with any other\nconfiguration. Parameter Type Description createSupportingIndexes boolean Optional. Sets whether sync creates a supporting index\nfor the shard key, if none exists.  Defaults to  false . shardingEntries array of documents Required. Sets the namespace and key of collections to shard\nduring sync. Collections not included in this array sync to unsharded\ncollections on the destination cluster.  If set with an empty\narray, no collections are sharded. string Sets the collection to shard. string Sets the database of the collection to shard. document Sets the shard key to generate on the destination cluster. array Sets the fields to use for the shard key. For more information, see  Shard Keys . Field Type Description success boolean When the request is successful, this value is  true . error string If an error occurred, indicates the name of the error. This field\nis omitted from the response when  success  is  true . errorDescription string Detailed description of the error that occurred. This field is\nomitted from the response when  success  is  true . The following example starts a sync job between  cluster0  and\n cluster1 .  The source cluster is  cluster0  and the destination\ncluster is  cluster1 . The  reversible  and  enableUserWriteBlocking  fields allow the sync\nto be reversed. To reverse the sync direction, see:  reverse . The following example starts a sync job between  cluster0  and\n cluster1 .  The source cluster is  cluster0  and the destination\ncluster is  cluster1 . The  includeNamespaces  option creates a filter. To filter the sync,\nsee:  Filtered Sync cluster0  contains the  sales ,  marketing , and\n engineering  databases. The  sales  database contains the  EMEA ,  APAC , and  AMER \ncollections. The  includeNamespaces  array in this example defines a filter on two\nof the databases,  sales  and  marketing . The  sales  database also filters on the  EMEA  and  APAC \ncollections. After you call the  /start  API with this filter in place,\n mongosync : The following example starts a sync job between  cluster0  and\n cluster1 .  The source cluster is  cluster0  and the destination\ncluster is  cluster1 . Syncs all of the collections in the  marketing  database Filters out the  engineering  database Syncs the  EMEA  and  APAC  collections from the  sales \ndatabase Filters out the  AMER  collection If the  start  request is successful,  mongosync  enters the\n RUNNING  state. When  mongosync  syncs to a sharded cluster, it pre-splits chunks for\nsharded collections on the destination cluster.  This is supported in the\nfollowing configurations: Sync from a replica set to a sharded cluster. Sync between sharded clusters that differ in the number of shards. Sync from a replica set to a sharded cluster requires the\n sharding  option. This option configures how  mongosync  shards\ncollections. The  sharding.shardEntries  array specifies the collections to shard.\nCollections that are not listed in this array replicate as unsharded. mongosync  syncs indexes from the source cluster to the destination\ncluster.  But, when syncing from a replica set to a sharded cluster,\n mongosync  may require an additional index to support the shard key,\nwhich may not exist on the source cluster. mongosync  can create supporting indexes for sharded collections during sync.\nThis is done by setting the  sharding.createSupportingIndexes  option. When  sharding.createSupportingIndexes  is  false  (the default): When  sharding.createSupportingIndexes  is  true : The  sharding.createSupportingIndexes  option affects all sharded\ncollections. Each shard key you provide for the  sharding.shardEntries  option\nmust have an existing index on the source cluster. One of the indexes used for the shard key must have simple collation if the\ncollection uses any other collation. To use a unique index in the shard key, you must specify its uniqueness when\nyou create the index on the source cluster. Unique indexes on the source cluster that are incompatible with the requested\nshard key on the destination cluster, such as a unique index on the source\nthat does not contain the requested shard key as a prefix on the destination,\ncan cause  mongosync  to fail. If the supporting indexes exist on the source cluster,  mongosync \nsyncs the indexes to the destination cluster and uses them\nas shard keys. If the supporting indexes don't exist,  mongosync  creates them on the\ndestination cluster. Collections listed in the  sharding.shardEntries  array\nwhen synced from a replica set to a sharded cluster\nbecome sharded collections on the destination cluster. Renaming a collection (such as with the  renameCollection  command)\non the source cluster after calling  start  but before  mongosync  begins\nto copy the collection can block the collection from sharding on the destination. To check whether it is safe to rename collections, call the\n progress  endpoint and check the value of the\n collectionCopy.estimatedCopiedBytes  field in the return document. Renaming collections to use a different database while syncing from a\nreplica set to a sharded cluster is not supported. A value of 0 indicates that  mongosync  has not started to copy the\ncollection. Renaming a collection at this point may result in an unsharded collection\non the destination cluster, as the transition to copying can happen before\nthe rename takes effect on the source. A value greater than 0 indicates that  mongosync  has started the copy.\nRenaming the collection from this point on does not block\nits sharding on the destination cluster, even in the event  of a crash. When you call  /start  with the  buildIndexes  option set to  never ,\n mongosync  skips building unnecessary indexes. Indexes that are always built include: mongosync  builds an index on the  _id  field of every\ncollection it copies. mongosync  builds dummy indexes that support the shard key for each\nsharded collection, which are removed after commit. When  buildIndexes  is\nset to  never ,  mongosync  retains this index after commit.",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.adminCommand( {\n   createRole: \"reverseSync\",\n   privileges: [ {\n       resource: { db: \"\", collection: \"\" },\n       actions: [ \"setUserWriteBlockMode\", \"bypassWriteBlockingMode\" ]\n   } ],\n   roles: []\n} )"
                },
                {
                    "lang": "javascript",
                    "value": "db.adminCommand( {\n   grantRolesToUser: \"mongosync-user\",\n   roles: [ { role: \"reverseSync\", db: \"admin\" } ]\n} )"
                },
                {
                    "lang": "http",
                    "value": "POST /api/v1/start"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/start -XPOST \\\n--data '\n   {\n      \"source\": \"cluster0\",\n      \"destination\": \"cluster1\"\n   } '\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                },
                {
                    "lang": "shell",
                    "value": "curl localhost:27182/api/v1/start -XPOST \\\n--data '\n   {\n      \"source\": \"cluster0\",\n      \"destination\": \"cluster1\",\n      \"reversible\": true,\n      \"enableUserWriteBlocking\": true\n   } '\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                },
                {
                    "lang": "json",
                    "value": "\"includeNamespaces\" : [\n      {\n          \"database\" : \"sales\",\n          \"collections\": [ \"EMEA\", \"APAC\" ]\n      },\n      {\n          \"database\" : \"marketing\"\n      }\n   ]"
                },
                {
                    "lang": "shell",
                    "value": "curl -X POST \"http://localhost:27182/api/v1/start\" --data '\n   {\n      \"source\": \"cluster0\",\n      \"destination\": \"cluster1\",\n      \"includeNamespaces\": [\n         {\n             \"database\": \"sales\",\n             \"collectionsRegex\": {\n                \"pattern\": \"^accounts_.+$\",\n                \"options\": \"i\"\n             }\n         }, {\n            \"database\": \"marketing\"\n         }\n      ]\n   } '\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                },
                {
                    "lang": "",
                    "value": "curl localhost:27182/api/v1/start -XPOST \\\n--data '\n   {\n      \"source\": \"cluster0\",\n      \"destination\": \"cluster1\",\n      \"sharding\": {\n         \"createSupportingIndexes\": true,\n         \"shardingEntries\": [\n            {\n                \"database\": \"accounts\",\n                \"collection\": \"us_east\",\n                \"shardCollection\": {\n                   \"key\": [\n                      { \"location\": 1 },\n                      { \"region\": 1 },\n                   ]\n                }\n            }\n         ]\n      }\n   } '\n"
                },
                {
                    "lang": "json",
                    "value": "{\"success\":true}\n"
                }
            ],
            "preview": "Starts the synchronization between a source and destination cluster.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "c2c"
                ]
            }
        }
    ]
}