{
    "url": "http://mongodb.com/docs/drivers/java/sync/v4.6",
    "includeInGlobalSearch": false,
    "documents": [
        {
            "slug": "api-documentation",
            "title": "API Documentation",
            "headings": [],
            "paragraphs": "BSON  - classes for working with the\nBSON data format. BSON Record Codec  -\nclasses for encoding and decoding between Java records and the BSON data\nformat. Core  - classes that\ncontain essential driver functionality. Java Driver (modern API)  -\nclasses for the current driver API. Java Driver (legacy API)  -\nclasses that support the legacy driver API. To learn how to upgrade from the\nlegacy API to the modern API from the  Migrate from the Legacy API  documentation.",
            "code": [],
            "preview": "Read the API documentation for the MongoDB Java Driver and related packages.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "quick-start",
            "title": "Quick Start",
            "headings": [
                "Introduction",
                "Set up Your Project",
                "Install the Java Development Kit (JDK)",
                "Create the Project",
                "Add MongoDB as a Dependency",
                "Create a MongoDB Cluster",
                "Set up a Free Tier Cluster in Atlas",
                "Connect to your Cluster",
                "Query Your MongoDB Cluster from Your Application",
                "Working with POJOs (Optional)",
                "Next steps"
            ],
            "paragraphs": "This guide shows you how to create an application that uses the  Java driver \nto connect to a  MongoDB Atlas cluster . If you prefer to connect to MongoDB\nusing a different driver or programming language, see our\n list of official MongoDB drivers . The Java driver lets you connect to and communicate with MongoDB clusters\nfrom a Java application. MongoDB Atlas is a fully-managed cloud database service that hosts your data\non MongoDB clusters. In this guide, we show you how to get started with your\nown free (no credit card required) cluster. Consult the following steps to connect your Java application with a MongoDB Atlas\ncluster. Make sure that your system has JDK 8 or later installed. For more information\non how to check your version of Java and install the JDK, see the\n Oracle Overview of JDK Installation documentation . This guide shows you how to add the MongoDB Java driver dependencies using\nMaven or Gradle. We recommend that you use an integrated development\nenvironment (IDE) such as Intellij IDEA or Eclipse IDE make it more convenient\nto configure Maven or Gradle to build and run your project. If you are not using an IDE, see\n Building Maven \nor\n Creating New Gradle Builds \nfor more information on how to set up your project. If you are using  Maven , add the following to\nyour  pom.xml  dependencies list: If you are using  Gradle , add the following to your\n build.gradle  dependencies list: Once you configure your dependencies, ensure they are available to your\nproject which may require running your dependency manager and refreshing\nthe project in your IDE. After setting up your Java project dependencies, create a MongoDB cluster\nwhere you can store and manage your data. Complete the\n Get Started with Atlas  guide\nto set up a new Atlas account, create and launch a free tier MongoDB cluster,\nload datasets, and interact with the data. After completing the steps in the Atlas guide, you should have a new MongoDB\ncluster deployed in Atlas, a new database user, and sample datasets loaded\ninto your cluster. In this step, we create and run an application that uses the MongoDB Java\ndriver to connect to your MongoDB cluster and run a query on the sample\ndata. We pass instructions to the driver on how to connect to your\nMongoDB cluster in a string called the  connection string . This string\nincludes information on the hostname or IP address and port of your\ncluster, authentication mechanism, user credentials when applicable, and\nother connection options. If you are connecting to an instance or cluster that is not hosted by Atlas,\nsee  Other Ways to Connect to MongoDB  for\ninstructions on how to format your connection string. To retrieve your connection string for the cluster and user you created in\nthe previous step, log into your Atlas account and navigate to the\n Database  section and click  Connect  for the cluster that you\nwant to connect to as shown below. Proceed to the  Connect Your Application  step and select the Java driver.\nSelect \"4.3 or Later\" for the version.\nClick the  Copy  icon to copy the  connection string  to your clipboard as\nshown below. Save your Atlas connection string in a safe location that you can access\nfor the next step. Next, create a file to contain your application called  QuickStart.java \nin the base package directory of your project. Use the following sample\ncode to run a query on your sample dataset in MongoDB Atlas, replacing the\nvalue of the  uri  variable with your MongoDB Atlas connection string. After completing this step, you should have a working application that uses\nthe Java driver to connect to your MongoDB cluster, run a query on the\nsample data, and print out the result. When you run the  QuickStart  class, it should output the details of the\nmovie from the sample dataset which will look something like this: If you receive no output or an error, check whether you included the proper\nconnection string in your Java class, and whether you loaded the sample dataset\ninto your MongoDB Atlas cluster. If you encounter an error connecting to your MongoDB instance or cluster\nthat resembles the following while running your application, you may need\nto update your JDK to the latest patch release: This exception is a known issue when using the TLS 1.3 protocol with\nspecific versions of JDK, but was fixed for the following releases: To resolve this error, update your JDK to one of the preceding patch\nversions or a newer one. JDK 11.0.7 JDK 13.0.3 JDK 14.0.2 In the previous section, you ran a query on a sample collection to retrieve\ndata in the map-like class  Document . In this section, you can learn to\nuse your own Plain Old Java Object (POJO) to store and retrieve data from\nMongoDB. Create a file called  Movie.java  in the base package directory of your\nproject and add the following code for a class that includes the following\nfields, setters, and getters: Create a new file  QuickStartPojoExample.java  in the same package\ndirectory as your  Movie  file in your project. Use the following sample\ncode to run a query on your sample dataset in MongoDB Atlas, replacing the\nvalue of the  uri  variable with your MongoDB Atlas connection string.\nEnsure you replace the \"<password>\" section of the connection string with\nthe password you created for your user that has  atlasAdmin  permissions: See the following links for more information on using POJOs to store and\nretrieve data: When you run the  QuickStartPojoExample  class, it should output the details of the\nmovie from the sample dataset which should look something like this: If you receive no output or an error, check whether you included the proper\nconnection string in your Java class, and whether you loaded the sample dataset\ninto your MongoDB Atlas cluster. Guide on using POJOs to store and retrieve data Guide on custom serialization of POJOs Learn how to read and modify data using the Java driver in our Fundamentals\nCRUD guide or how to perform common operations from our\n Usage Examples .",
            "code": [
                {
                    "lang": "xml",
                    "value": "<dependencies>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>mongodb-driver-sync</artifactId>\n        <version>4.6.1</version>\n    </dependency>\n</dependencies>"
                },
                {
                    "lang": "groovy",
                    "value": "dependencies {\n  implementation 'org.mongodb:mongodb-driver-sync:4.6.1'\n}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Filters.eq;\n\nimport org.bson.Document;\n\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\n\npublic class QuickStart {\n    public static void main( String[] args ) {\n\n        // Replace the placeholder with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Document doc = collection.find(eq(\"title\", \"Back to the Future\")).first();\n            if (doc != null) {\n                System.out.println(doc.toJson());\n            } else {\n                System.out.println(\"No matching documents found.\");\n            }\n        }\n    }\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  _id: ...,\n  plot: 'A young man is accidentally sent 30 years into the past...',\n  genres: [ 'Adventure', 'Comedy', 'Sci-Fi' ],\n  ...\n  title: 'Back to the Future',\n  ...\n}"
                },
                {
                    "lang": "none",
                    "value": "javax.net.ssl.SSLHandshakeException: extension (5) should not be presented in certificate_request"
                },
                {
                    "lang": "java",
                    "value": "public class Movie {\n    String plot;\n    List<String> genres;\n    String title;\n\n    public String getPlot() {\n        return plot;\n    }\n    public void setPlot(String plot) {\n        this.plot = plot;\n    }\n    public List<String> getGenres() {\n        return genres;\n    }\n    public void setGenres(List<String> genres) {\n        this.genres = genres;\n    }\n    public String getTitle() {\n        return title;\n    }\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    @Override\n    public String toString() {\n        return \"Movie [\\n  plot=\" + plot + \",\\n  genres=\" + genres + \",\\n  title=\" + title + \"\\n]\";\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.MongoClientSettings.getDefaultCodecRegistry;\nimport static com.mongodb.client.model.Filters.eq;\nimport static org.bson.codecs.configuration.CodecRegistries.fromProviders;\nimport static org.bson.codecs.configuration.CodecRegistries.fromRegistries;\n\nimport org.bson.codecs.configuration.CodecProvider;\nimport org.bson.codecs.configuration.CodecRegistry;\nimport org.bson.codecs.pojo.PojoCodecProvider;\n\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\n\npublic class QuickStartPojoExample {\n\n    public static void main(String[] args) {\n        CodecProvider pojoCodecProvider = PojoCodecProvider.builder().automatic(true).build();\n        CodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider));\n\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\").withCodecRegistry(pojoCodecRegistry);\n            MongoCollection<Movie> collection = database.getCollection(\"movies\", Movie.class);\n\n            Movie movie = collection.find(eq(\"title\", \"Back to the Future\")).first();\n            System.out.println(movie);\n        }\n    }\n}"
                },
                {
                    "lang": "none",
                    "value": "Movie [\n  plot=A young man is accidentally sent 30 years into the past...,\n  genres=[Adventure, Comedy, Sci-Fi],\n  title=Back to the Future\n]"
                }
            ],
            "preview": "If you are using Maven, add the following to\nyour pom.xml dependencies list:",
            "tags": "java sync, set up, runnable app",
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "issues-and-help",
            "title": "Issues & Help",
            "headings": [
                "Bugs / Feature Requests",
                "Pull Requests"
            ],
            "paragraphs": "We are lucky to have a vibrant MongoDB Java community that includes users\nwith varying levels of experience using the Java driver. We find the quickest\nway to get support for general questions is through the  MongoDB Community Forums . Refer to our  support channels \ndocumentation for more information. If you think you've found a bug or want to see a new feature in the Java\ndriver, please open a case in our issue management tool, JIRA: Bug reports in JIRA for the Java driver and the Core Server (i.e. SERVER) project are  public . If you\u2019ve identified a security vulnerability in a driver or any other\nMongoDB project, please report it according to the instructions found in the\n Create a Vulnerability Report page . Create an account and login . Navigate to  the JAVA project . Click  Create . Please provide as much information as possible\nabout the issue and the steps to reproduce it. We are happy to accept contributions to help improve the driver. We will guide\nuser contributions to ensure they meet the standards of the codebase. Please\nensure that any pull requests include documentation, tests, and pass the\n gradle  checks. To get started check out the source and work on a branch: Finally, ensure that the code passes gradle checks.",
            "code": [
                {
                    "lang": "bash",
                    "value": "$ git clone https://github.com/mongodb/mongo-java-driver.git\n$ cd mongo-java-driver\n$ git checkout -b myNewFeature"
                },
                {
                    "lang": "bash",
                    "value": "$ ./gradlew check"
                }
            ],
            "preview": "We are lucky to have a vibrant MongoDB Java community that includes users\nwith varying levels of experience using the Java driver. We find the quickest\nway to get support for general questions is through the MongoDB Community Forums.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "whats-new",
            "title": "What's New",
            "headings": [
                "Upcoming Breaking Changes",
                "What's New in 4.6",
                "What's New in 4.5.1",
                "What's New in 4.5",
                "What's New in 4.4",
                "What's New in 4.3",
                "What's New in 4.2",
                "What's New in 4.1",
                "What's New in 4.0"
            ],
            "paragraphs": "Learn what's new in: Version 4.6 Version 4.5.1 Version 4.5 Version 4.4 Version 4.3 Version 4.2 Version 4.1 Version 4.0 MapReduceIterable \nand map-reduce methods on  MongoCollection \nare deprecated in MongoDB v4.2 and later. They will be replaced by the\naggregation framework and removed in a future release. New features of the 4.6 Java driver release include: The buffer pool is now shared across all  MongoClient  instances. The\nbuffer pool prunes buffers that have been idle for one minute. Added an API to specify suppliers for AWS KMS credentials for\nClient-Side Field Level Encryption (CSFLE). See the\n AutoEncryptionSettings.Builder.kmsProviderPropertySuppliers() \nand the  ClientEncryptionSettings.Builder.kmsProviderPropertySuppliers() \nAPI documentation for more information. Added compatibility to  org.mongodb:mongodb-crypt , a dependency for\nCSFLE, for Apple M1 ARM-based hardware. Added a service provider interface (SPI) to allow the driver to specify\na custom DNS client. See the  DnsClient \nand the  DnsClientProvider \ninterface API documentation for more information. Added driver support for encoding and decoding between  Java records \nand BSON documents, which is enabled by default. See  Document Data Format: Records \nfor more information. If the DNS server returns an NXDomain error,\nindicating a non-existent domain, the 4.5.1\ndriver no longer throws an exception. New features of the 4.5 Java driver release include: Added support for specifying custom service names of SRV resource\nrecords. See the  srvServiceName  setting in the  Connection\nOptions  guide for more information. Added support to customize UUID representation in a codec registry using\nthe  CodecRegistries.withUuidRepresentation()  method. Added support for overriding listener settings in  ClusterSettings ,\n ServerSettings  and  ConnectionPoolSettings  builders. All events received by  ClusterListener ,  ServerListener , and\n ServerMonitorListener  are now totally ordered using\na happens-before relationship when the listeners are not shared by\ndifferent MongoClient instances. To learn more about the happens-before\nordering, see  Happens-before Order \nin the Java Language Specification. Added  EnumCodec  and  EnumCodecProvider  classes to separate codec\nsupport for  enum  types from the  PojoCodec  class. The default\ncodec registries, accessible from the  MongoClientSettings  and the  Bson \ninterfaces, now include the  enum  codec classes. If your application uses\na custom enumeration codec and one of the default registries, ensure\nyou order them as described in the section on  overriding codecs . Resolved performance issues that impacted versions 4.4 and 4.3 of the\ndriver. Performance in this version should be similar to performance in 4.2. Resolved an issue in which errors originating from retrieving the cluster\ndescription weren't passed to the  onError  Subscriber callback Resolved an issue with releasing  ByteBuf  instances when you connect\nwith compression enabled. Removed an unnecessary dependency on the  javax.annotation.*  packages\nfrom the  org.mongodb.driver-core  OSGi bundle. New features of the 4.4 Java driver release include: Compatibility with MongoDB 5.1 and support for Java 17 Added support for index hints in an  AggregateIterable Added support for the  $merge  and  $out  aggregation stages on secondaries Use of the  mergeObjects()  method in the  Updates  builder DocumentCodec  does not ignore a  CodecRegistry  when writing to an  Iterable  or a  Map  instance New features of the 4.3 Java driver release include: The following table shows the restriction status on allowed characters\nin the field names of documents: Added support for the MongoDB Stable API. For more information, see our\n Stable API guide . Starting from February 2022, the  Versioned API  is known the\n Stable API . All concepts and features remain the same with this\nnaming change. Added support for connection to\n MongoDB Atlas Serverless Instances .\nFor more information on setup, see our documentation on how to\n Create a New Serverless Instance Added a builder API for the  setWindowFields  pipeline stage to allow the use of window operators Added support for setting Netty  io.netty.handler.ssl.SslContext Added support for snapshot reads to  ClientSession Limited the rate of establishing new connections per connection pool Removed most restrictions on allowed characters in the field names of documents you insert or replace. This is a behavioral change for any application that is relying on client-side enforcement of these restrictions. Character Operation Description . Insert and Replace Removed restrictions on field names containing this character. $ Insert Removed restrictions on field names starting with this character. $ Replace Removed restrictions in nested documents on field names containing this character. $ Replace Kept restrictions in top-level documents on field names starting with this character. This prevents accidental use of a replace operation when the intention was to use an update operation. Unacknowledged writes using dollar-prefixed or dotted keys may\nbe silently rejected by pre-5.0 servers, where some restrictions on\nfield names are still enforced in the server. New features of the 4.2 Java driver release include: The v4.2 driver contains breaking changes. See  Version 4.2 Breaking Changes \nfor more information. Added Azure and GCP key stores to client-side field level encryption Added Kerberos caching tickets for reuse in multiple authentication requests Added  MongoClients  instances with  MongoClientSettings  or  ConnectionString  as the configuration Use of the  explain()  method on  find  and  aggregate  commands Added a  JsonObject  class to make encoding from and decoding to JSON more efficient by avoiding an intermediate Map representation Added a  BsonRepresentation  annotation that allows you to represent the  ObjectId  BSON values as a  String  in  POJO  classes Added a  Filters.empty()  method New features of the 4.1 Java driver release include: Significant reduction in client-perceived failover times during planned maintenance events The  update()  and  delete()  methods now support index hints The  find()  method supports  allowDiskUse()  for sorts that require too much memory to execute in RAM Added support for the MONGODB-AWS authentication mechanism using Amazon Web Services (AWS) Identity and Access Management (IAM) credentials Authentication requires fewer round trips to the server, resulting in faster connection setup This release adds no new features. The v4.0 driver contains breaking changes. See  Version 4.0 Breaking Changes \nfor more information.",
            "code": [],
            "preview": "Learn what's new in:",
            "tags": null,
            "facets": null
        },
        {
            "slug": "faq",
            "title": "FAQ",
            "headings": [
                "General",
                "Why are there two types of MongoClient in the Java driver?",
                "Which type of MongoClient should I use?",
                "How do I use the MongoClientSettings class?",
                "How do I fix: \"javax.net.ssl.SSLHandshakeException: extension (5) should not be presented in certificate_request\"?",
                "How Does Connection Pooling Work in the Java Driver?",
                "How do I prevent the \"java.lang.NoClassDefFoundError: com/mongodb/MongoClient\" error?",
                "How do I prevent the \"com.mongodb.MongoSecurityException\" error?",
                "How do I prevent the \"IllegalArgumentException: Invalid BSON field name\" error?",
                "How do I prevent the \"IllegalStateException: state should be: open\" error?",
                "POJOs",
                "Do I have to specify an ID field value myself?",
                "Can the ID field be a compound key?",
                "Can I use polymorphism in a POJO accessor?",
                "What is a discriminator?",
                "Can I control serialization of LocalDate?",
                "Can I serialize a java.util.Date as a string in format yyyy-mm-dd?",
                "Can I make POJOs read/write directly to the field and not use the getters/setters at all?",
                "Can I mix private, protected, and public setters and getters?",
                "How do I fix: \"org.bson.codecs.configuration.CodecConfigurationException: Can't find a codec for class X.\"?",
                "How do I specify the collection name for a particular POJO class? Is there an annotation?",
                "Legacy API",
                "How do I connect to my MongoDB instance with the legacy API?",
                "How do I use the legacy MongoClientOptions and MongoClientURI Classes?",
                "Support"
            ],
            "paragraphs": "There are two types of  MongoClient  because we wanted a cleaner API\nfor new users that didn't have the confusion of including multiple CRUD\nAPIs. We wanted to ensure that the new CRUD API was available in a Java\npackage structure that would work well with Java module support\nintroduced in Java 9. New applications should generally use the\n com.mongodb.client.MongoClient  interface, which supports: You should use the  com.mongodb.MongoClient  class if you require support for the legacy API, which supports: For applications that require a mix of the new and legacy APIs,  com.mongodb.MongoClient  also supports: Configuration with  MongoClientSettings  and  ConnectionString .  You can create instances of this interface via factory methods defined in the  com.mongodb.client.MongoClients  class. CRUD API using  MongoDatabase , and from there,  MongoCollection Configuration with  MongoClientOptions  and  MongoClientURI CRUD API using  DB , and from there,  DBCollection .  You can access this API via the  getDB()  method. Configuration with  MongoClientSettings  and  ConnectionString , the only difference being that you create instances via constructors instead of a factory class. CRUD API using  MongoDatabase , and from there,  MongoCollection .  You can access this API via the  getDatabase()  method. You can use the  MongoClientSettings  class to specify configurations for\n MongoClient  instances. To construct  MongoClientSettings  instances, use the\n MongoClientSettings.Builder  class. Here are the sections of our documentation that show how to perform different\ntasks with the  MongoClientSettings  class: For more information on the  MongoClientSettings  class, see the\n API Documentation for MongoClientSettings . Specify Multiple Hosts Enable TLS/SSL Authenticate with Credentials Enable Compression Add Listeners For Driver and Database Events Get the Default Codec Registry This is a  known error  that can occur\nwhen using the TLS 1.3 protocol with specific versions of the JDK. If\nyou encounter this error when connecting to your MongoDB instance or\ncluster, update your JDK to one of the following patch versions or\nnewer: JDK 11.0.7 JDK 13.0.3 JDK 14.0.2 Every  MongoClient  instance has a built-in connection pool for each server\nin your MongoDB topology. Connection pools open sockets on demand to\nsupport concurrent MongoDB operations in your multithreaded application. The maximum size of each connection pool is set by the  maxPoolSize  option, which\ndefaults to  100 . If the number of in-use connections to a server reaches\nthe value of  maxPoolSize , the next request to that server will wait\nuntil a connection becomes available. Each  MongoClient  instance opens two additional sockets per server in your\nMongoDB topology for monitoring the server's state. For example, a client connected to a 3-node replica set opens 6\nmonitoring sockets. It also opens as many sockets as needed to support\nan application's threads on each server, up to\nthe value of  maxPoolSize . If  maxPoolSize  is  100  and the\napplication only uses the primary (the default), then only the primary\nconnection pool grows and there can be at most  106  total connections. If the\napplication uses a  read preference  to query the\nsecondary nodes, their pools also grow and there can be  306  total connections. Additionally, connection pools are rate-limited such that each connection pool\ncan only create, at maximum, the value of  maxConnecting  connections\nin parallel at any time. Any additional thread stops waiting in the\nfollowing cases: You can set the minimum number of concurrent connections to\neach server with the  minPoolSize  option, which defaults to  0 .\nThe connection pool will be initialized with this number of sockets. If\nsockets are closed due to any network errors, causing the total number\nof sockets (both in use and idle) to drop below the minimum, more\nsockets are opened until the minimum is reached. You can set the maximum number of milliseconds that a connection can\nremain idle in the pool before being removed and replaced with\nthe  maxIdleTimeMS  option, which defaults to  0  (no limit). The following default configuration for a  MongoClient  works for most\napplications: Create a client once for each process, and reuse it for all\noperations. It is a common mistake to create a new client for each\nrequest, which is very inefficient. To support high numbers of concurrent MongoDB operations\nwithin one process, you can increase  maxPoolSize . Once the pool\nreaches its maximum size, additional threads wait for sockets\nto become available. The driver does not limit the number of threads that\ncan wait for sockets to become available and it is the application's\nresponsibility to limit the size of its pool to bound queuing\nduring a load spike. Threads wait for the amount of time specified in\nthe  waitQueueTimeoutMS  option, which defaults to  120000 , or 120 seconds. A thread that waits more than the length of time defined by\n waitQueueTimeoutMS  for a socket raises a connection error. Use this\noption if it is more important to bound the duration of operations\nduring a load spike than it is to complete every operation. When  MongoClient.close()  is called by any thread, the driver\ncloses all idle sockets and closes all sockets that are in\nuse as they are returned to the pool. One of the existing threads finishes creating a connection, or\nan existing connection is checked back into the pool. The driver's ability to reuse existing connections improves due to\nrate-limits on connection creation. You may encounter a  java.lang.NoClassDefFoundError  exception when your\nJava runtime environment cannot locate a class file at runtime. When you\nattempt to run application code that uses the MongoDB Java Driver, you must include\nthe appropriate driver JAR files on the classpath. If you receive this error after adding the Java Driver JAR files to\nyour classpath, check the following items in your environment: The JAR files exist in the locations specified by the classpath. The classpath syntax is correct. If you define the classpath in an environment variable, the Java runtime\nenvironment uses that variable. If you use a dependency manager, it does not report any unresolvable conflicts. This error contains the package and class name, which can help you identify\nwhich driver JAR may be missing from your classpath. To locate the\ndriver JAR that the error refers to, check each of the entries in the\n API documentation . Your application might throw this exception if you specify invalid or\nincorrectly formatted credentials when connecting to a MongoDB deployment. If you receive this error when you attempt to connect to a MongoDB deployment,\ncheck the following items in your code: The connection URI corresponds to the correct MongoDB deployment.\nTo learn more about setting your connection URI, see  Connection URI . The credentials for the authentication mechanism that you specified are\ncorrect. To learn how to specify your credentials, see the\n Authentication Mechanisms  and  Enterprise Authentication Mechanisms \nguides. The name of the authentication database that you specified is correct. To\nlearn how to set up the users and roles for your MongoDB deployment, see\n Manage Users and Roles \nin the Server documentation. Your application might throw this exception if you pass an incorrectly formatted\ndocument to an operation and you are using a driver version v4.7 or earlier. For example, the driver throws this error when you call an update operation\nand incorrectly omit the update operator as shown in the following code\nexample: To avoid this error, use the builder class for the appropriate operation.\nThe driver offers builder classes to create syntactically correct BSON for\nMongoDB operations. The prior example can be correctly expressed using\nthe builder classes as shown in the following code example: To learn more about the available builders classes, see the  Builders  documentation. In driver versions v4.8 and later, this error message was replaced by one\nthat includes more specific details on what was incorrectly formatted. You may encounter this exception if you call an operation on a  MongoClient \ninstance that closed its connections to MongoDB. Once the  close()  method\nis called on the  MongoClient , any further operation calls on that instance\nthrow this exception. To avoid this exception, do not call operations on  MongoClient  instance\nafter any code that calls  close()  on it. The code that closes the  MongoClient  instance may be difficult to\nlocate in certain cases. To locate potential sources of this exception,\nsearch for the following cases: If your application uses a framework to manage the  MongoClient \nsuch as Spring Boot, check the documentation of the framework to locate the\nbest practices for managing the connection behavior. To learn more about accessing MongoDB from Spring Boot, see\n Spring Boot and MongoDB . Calls to  close()  on a  MongoClient  instance Operation calls on a  MongoClient  instance that are outside the scope\nof the try-with-resources statement in which the  MongoClient  is\ndeclared No, the  PojoCodecProvider  automatically generates an ObjectId. Yes. For an example of this, see  our implementation Yes, by using a discriminator. A discriminator is a property that identifies a specific document\nschema. You can use it for inheritance and storing multiple types of\ndocuments within the same collection or parent document (if you embed\nsubdocuments). For example, if you have an  Event  class that you extend in Java (e.g.\n MachineEvent  or  NetworkEvent ), using a discriminator identifies\nwhich class the  PojoCodecProvider  should use to serialize/deserialize the\ndocument. For more information, see our  POJO Customization guide . Yes, the 3.7 Java driver adds native support for  JSR-310 Instant ,\n LocalDate  &  LocalDateTime . Yes, you can build your own codec for this class and add it to the registry. Add the codec to the first in the list of providers, before the default codec\nregistry and before the  PojoCodecProvider : You can configure the  PojoCodecProvider  to use the\n SET_PRIVATE_FIELDS_CONVENTION , which sets a private field through\nreflection if no public setter is available. No. The native POJO codec assumes that getters/setters have the same\nmodifiers for each field. For example, the following methods throws an exception during encoding: This exception means you need to register a codec for the class since\nthere is none at the moment. There is no annotation. We recommend adding a static string in your class as shown: The following snippet specifies the collection name for a particular\nPOJO class: The following example shows how to connect to a MongoDB instance with the\nlegacy API and the current API. Imagine we are connecting to a collection that contains only this document: The output of the preceding code snippet should look like this: For more information on the legacy classes and methods used in the preceding example,\nsee the following API documentation pages: See the  Migrate from the Legacy API  page\nfor a list of differences between the legacy and current API. MongoClient DB DBCollection DBObject getDB() getCollection() find() one() Here is an example showing how to use the legacy  MongoClientOptions  and\n MongoClientURI  classes to set your write concern: For more information on the legacy classes and methods used in the preceding example,\nsee the following API Documentation pages: See the  Migrate from the Legacy API  page for a list\nof differences between the legacy and current API. Legacy API documentation MongoClient MongoClientOptions MongoClientURI If you are unable to find the answer to your question here, try our forums and\nsupport channels listed in the  Issues and Help \nsection.",
            "code": [
                {
                    "lang": "java",
                    "value": "MongoClient client = new MongoClient(\"<connection string>\")"
                },
                {
                    "lang": "java",
                    "value": "// incorrectly formatted update document\ncollection.updateOne(\n    new Document().append(\"name\", \"fizz\"),\n    new Document().append(\"name\", \"buzz\")\n);"
                },
                {
                    "lang": "java",
                    "value": "// Builder class imports\nimport static com.mongodb.client.model.Filters.*;\nimport static com.mongodb.client.model.Updates.*;\n\n// ...\n\ncollection.updateOne(eq(\"name\", \"fizz\"), set(\"name\", \"buzz\"));"
                },
                {
                    "lang": "java",
                    "value": "CodecRegistry registry = CodecRegistries.fromRegistries(\n        CodecRegistries.fromCodecs(\n                new MyDateAsStringCodec()),\n        MongoClientSettings.getDefaultCodecRegistry(),\n        fromProviders(pojoCodecProvider));"
                },
                {
                    "lang": "java",
                    "value": "private String getField();\npublic String setField(String x);"
                },
                {
                    "lang": "java",
                    "value": "public class Person {\n   public static final String COLLECTION_NAME = \"people\";\n}"
                },
                {
                    "lang": "java",
                    "value": "database.getCollection(Person.COLLECTION_NAME, Person.class);"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"val\": 1}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"val\": 1}"
                },
                {
                    "lang": "java",
                    "value": "MongoClient client = new MongoClient(URI);\nDB db = client.getDB(DATABASE);\nDBCollection col = db.getCollection(COLLECTION);\nDBObject doc = col.find().one();\nSystem.out.println(doc.toString());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient client = MongoClients.create(URI);\nMongoDatabase db = client.getDatabase(DATABASE);\nMongoCollection<Document> col = db.getCollection(COLLECTION);\n\n// Prints the first document retrieved from the collection as JSON \nDocument doc = col.find().first();\nSystem.out.println(doc.toJson());"
                },
                {
                    "lang": "java",
                    "value": "MongoClientURI mongoURI = new MongoClientURI(URI,\n        MongoClientOptions.builder()\n                .writeConcern(WriteConcern.W1));\nMongoClient client = new MongoClient(mongoURI);"
                },
                {
                    "lang": "java",
                    "value": "MongoClientSettings options = MongoClientSettings.builder()\n        .applyConnectionString(new ConnectionString(URI))\n        .writeConcern(WriteConcern.W1).build();\nMongoClient client = MongoClients.create(options);"
                }
            ],
            "preview": "If you are unable to find the answer to your question here, try our forums and\nsupport channels listed in the Issues and Help\nsection.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "upgrade",
            "title": "Upgrade Driver Versions",
            "headings": [
                "Overview",
                "Breaking Changes",
                "Version 4.2 Breaking Changes",
                "Version 4.0 Breaking Changes"
            ],
            "paragraphs": "In this section, you can identify the changes you need to make to your\napplication to upgrade your driver to a new version. Before you upgrade, perform the following actions: Ensure the new version is compatible with the MongoDB Server versions\nyour application connects to and the Java Runtime Environment (JRE) your\napplication runs on. See the  Java Compatibility \npage for this information. Address any breaking changes between the current version of the driver\nyour application is using and your planned upgrade version in the\nsection on  Breaking Changes  below. To minimize the amount of changes your application may require when\nupgrading driver versions in the future, use the\n Stable API . A breaking change is a modification in a convention or behavior in\na specific version of the driver that may prevent your application from\nworking properly if not addressed before upgrading. The breaking changes in this section are categorized by the driver version that\nintroduced them. When upgrading driver versions, address all the breaking\nchanges between the current and upgrade versions. For example, if you\nare upgrading the driver from v4.0 to v4.5, address all breaking changes from\nthe version after v4.0 including any listed under v4.5. The  ObjectId  class and its  serialVersionUID  field were updated\nto use a new format that minimizes serialization compatibility issues\nacross different versions of the driver. If an application using this version or later of the driver attempts to\nperform Java Object Serialization on any objects that contain an\n ObjectId  and were serialized by a prior version of the driver, Java\nthrows an  InvalidClassException . To learn more about Java Object Serialization, see the Java\nDocumentation on  Serializable Objects . Several classes and methods marked as deprecated in the 3.12 release\nwere removed in this version. The insert helper methods return an insert result object instead of\n void . The  toJson()  methods on  BsonDocument ,  Document , and\n DbObject  return a relaxed JSON format instead of a strict JSON\nformat. This makes the JSON documents more readable, but can make it more\ndifficult to identify the BSON type information, such as the difference\nbetween a 32-bit and 64-bit integer. If your application relies on the\nstrict JSON format, use the strict mode when reading or writing data.\nLearn how to specify the JSON format in the current API in the\n Document Data Format: Extended JSON  guide. The default BSON representation of  java.util.UUID  value was changed\nfrom  JAVA_LEGACY  to  UNSPECIFIED . Applications that store or retrieve\nUUID values must explicitly specify which representation to use. You can\nspecify the representation in the  uuidRepresentation  property of\n MongoClientSettings . The UUID representation that you specify strictly controls how the driver\ndecodes UUIDs. In previous versions of the driver, if you specified the\n JAVA_LEGACY  representation, the driver would decode binary objects\nof subtypes 3 and 4 as UUIDs. In version 4.0, the  JAVA_LEGACY \nrepresentation works only with subtype 3. For a list of members in the  UuidRepresentation  enum, see the\n v4.0 API documentation . The connection pool no longer restricts the number of wait queue threads\nor asynchronous tasks that require a connection to MongoDB. The\napplication should throttle requests as necessary rather than depend on\nthe driver to throw a  MongoWaitQueueFullException . The driver no longer logs using the  java.util.logging  (JUL) package\nand only supports the SLF4J logging framework. The embedded and Android drivers were removed. If your application\nrelies on these drivers, you must continue to use a 3.x Java driver\nversion. The uber JARs,  mongo-java-driver  and  mongodb-driver , are no\nlonger published. If your application relies on one of these, you must\nswitch to either  mongodb-driver-sync  or  mongodb-driver-legacy \ndepending on which API the application uses. Make sure you remove the\nuber JARs from your dependencies. Updates to several classes introduced binary compatibility breaks, such\nas the method signature change to the insert helper methods. Recompile\nany classes that link to the driver against this version or later to ensure\nthat they continue to work.",
            "code": [],
            "preview": "In this section, you can identify the changes you need to make to your\napplication to upgrade your driver to a new version.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "usage-examples",
            "title": "Usage Examples",
            "headings": [
                "Overview",
                "How to Use the Usage Examples"
            ],
            "paragraphs": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following information: An explanation of the operation in the example showing the\npurpose and a sample use case for the method An explanation of how to use the operation, including parameters,\nreturn values, and common exceptions you might encounter A full Java class that you can copy and paste to run the example\nin your own environment These examples use the  sample datasets \nprovided by Atlas. You can load them into your database on the free tier of\nMongoDB Atlas by following the\n Get Started with Atlas Guide \nor you can\n import the sample dataset into a local MongoDB instance . Once you have imported the dataset, you can copy and paste a usage\nexample into your development environment of choice. You can follow the\n quick start guide  to learn more about getting\nstarted with the MongoDB Java driver. Once you've copied a usage example,\nyou need to edit the connection URI to get the example connected to\nyour MongoDB instance: You can use the  Atlas Connectivity Guide \nto learn how to allow connections to your instance of Atlas and to find the\n connection string  you use to replace the\n uri  variable in usage examples. If your instance uses\n SCRAM authentication , you can replace\n <user>  with your username,  <password>  with your password, and\n <cluster-url>  with the IP address or URL of your instance. For more information about connecting to your MongoDB instance, see our\n Connection Guide .",
            "code": [
                {
                    "lang": "java",
                    "value": "// Replace the following with your MongoDB deployment's connection string.\nString uri = \"<connection string uri>\";"
                }
            ],
            "preview": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following information:",
            "tags": null,
            "facets": null
        },
        {
            "slug": "fundamentals",
            "title": "Fundamentals",
            "headings": [],
            "paragraphs": "Learn how to perform the following tasks using the Java driver in the\nFundamentals section: Connect to MongoDB Use the Stable API Authenticate with MongoDB Convert between MongoDB Data Formats and Java Objects Read from and Write to MongoDB Simplify your Code with Builders Transform your Data Create Indexes to Speed Up Queries Sort Using Collations Log Events in the Driver Monitor Driver Events Store and Retrieve Large Files in MongoDB Encrypt Fields in a Document Use a Time Series Collection",
            "code": [],
            "preview": "Learn how to use the (+driver-long+} to run commands on MongoDB.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "",
            "title": "MongoDB Java Driver",
            "headings": [
                "Introduction",
                "Compatibility",
                "Quick Start",
                "Quick Reference",
                "What's New",
                "Usage Examples",
                "Fundamentals",
                "API Documentation",
                "FAQ",
                "Issues & Help",
                "Compatibility",
                "Upgrade Driver Versions",
                "Migrate from the Legacy API",
                "Learn",
                "Developer Hub",
                "MongoDB University",
                "Take the free online course taught by MongoDB instructors"
            ],
            "paragraphs": "Welcome to the documentation site for the Java Driver, the official\nMongoDB driver for synchronous Java applications.\nFollow the  Quick Start  guide to learn how\nto add the driver to your project by using  Maven  or\n Gradle  and how to set up a runnable app. If your Java application requires asynchronous stream processing, use the\n Reactive Streams Driver  which uses Reactive\nStreams to make non-blocking calls to MongoDB. You can use the Java Driver to connect to deployments hosted in the\nfollowing environments: MongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud MongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB MongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB Learn how to establish a connection to MongoDB Atlas and begin\nworking with data in the  Quick Start  section. See driver syntax examples for common MongoDB commands in the\n Quick Reference  section. For a list of new features and changes in each version, see the\n What's New  section. For fully runnable code snippets and explanations for common\nmethods, see the  Usage Examples  section. Learn how to perform the following tasks using the Java driver in the\nFundamentals section: Connect to MongoDB Use the Stable API Authenticate with MongoDB Convert between MongoDB Data Formats and Java Objects Read from and Write to MongoDB Simplify your Code with Builders Transform your Data Create Indexes to Speed Up Queries Sort Using Collations Log Events in the Driver Monitor Driver Events Store and Retrieve Large Files in MongoDB Encrypt Fields in a Document Use a Time Series Collection The MongoDB Java driver API documentation contains several libraries\norganized by functionality. For detailed information about classes and\nmethods in each library, see the following table for their descriptions\nand links to the API documentation. Library Description BSON Base BSON classes BSON Record Codec Classes that support records Core Shared core classes Java Driver Modern API Legacy Java Driver Legacy API For answers to commonly asked questions about the MongoDB\nJava Driver, see the  Frequently Asked Questions (FAQ) \nsection. Learn how to report bugs, contribute to the driver, and find\nadditional resources for asking questions and receiving help in the\n Issues & Help  section. For the compatibility charts that show the recommended Java\nDriver version for each MongoDB Server version, see the\n Compatibility  section. Learn what changes you may need to make to your application to upgrade\ndriver versions in the  Upgrade Driver Versions \nsection. Learn what changes you may need to make to your application to migrate\nfrom the legacy API to the current API in the  Migrate from the\nLegacy API  section. Visit the Developer Hub and MongoDB University to learn more about the\nMongoDB Java driver. The Developer Hub provides tutorials and social engagement for\ndevelopers. To learn how to use MongoDB features with the Java driver, see the  How\nTo's and Articles page . To ask questions and engage in discussions with fellow developers using\nthe Java Driver, see the  forums page . MongoDB University provides free courses to teach everyone how to use\nMongoDB. Using MongoDB with Java Learn the essentials of Java application development with MongoDB.",
            "code": [],
            "preview": "Welcome to the documentation site for the Java Driver, the official\nMongoDB driver for synchronous Java applications.\nFollow the Quick Start guide to learn how\nto add the driver to your project by using Maven or\nGradle and how to set up a runnable app.",
            "tags": "java sync",
            "facets": {
                "programming_language": [
                    "java"
                ],
                "genre": [
                    "reference"
                ]
            }
        },
        {
            "slug": "legacy",
            "title": "Migrate from the Legacy API",
            "headings": [
                "Overview",
                "Current API Benefits",
                "API Changes"
            ],
            "paragraphs": "On this page, you can identify the changes you must make to migrate from the\nlegacy API to the current API. You can also learn about features unique to\nthe current Java Driver and the benefits of migrating to the new API. The legacy API, packaged as the  mongodb-driver-legacy  JAR, contains\nthe legacy synchronous Java driver and uses naming conventions used in earlier\nversions of the driver. The current API, packaged as the  mongodb-driver-sync  JAR, contains the\ncurrent synchronous Java driver. It features the  MongoCollection \ninterface as an entry point to CRUD operations. It does not contain the\nlegacy API. To perform a migration from the legacy API to the current API, ensure your\ncode no longer references the legacy API, updating your code when necessary.\nThen, replace the legacy API and any uber JAR that contains it with the\ncurrent API JAR in your application dependencies. In addition to updating your application to handle any necessary changes,\nalways check for any other differences in options and return values before\nmoving it to production. You can continue to use the legacy API with each new MongoDB Server release.\nHowever, the legacy API does not support any updates introduced in MongoDB Server\n3.0 or later. Additionally, the legacy API lacks support for certain features\nof the current Java Driver. Some features only available in the non-legacy\nAPI include: To learn about more features of the current API, see  What's New . Change streams , a MongoDB Server feature designed to monitor real-time\nchanges to a single collection, database, or deployment Multi-document ACID transactions , which ensure atomicity of reads and\nwrites to multiple documents and allow for transactions across multiple\noperations, collections, databases, documents, and shards Time series collections , which store sequences of measurements over a\nperiod of time and improve query efficiency for time series data Queryable Encryption , which allows you to encrypt sensitive workloads\nand to query the encrypted data Java records , or concise Java classes that separate business logic from\ndata representation and reduce boilerplate code Native POJO support , which provides automatic or custom mapping between\nMongoDB documents and Java objects The following table shows the majority of the changes in class and method\nnames between the legacy and current API. In addition to the preceding items, consider the following changes: Legacy Current MongoClientOptions MongoClientSettings new MongoClient() MongoClients.create() MongoClient.getDB() MongoClient.getDatabase() DB MongoDatabase DBCollection MongoCollection<> DBCursor MongoCursor DBCollection.findOne() find() first() DBCollection.insert() Use one of the following methods: MongoCollection.insertOne() MongoCollection.insertMany() DBCollection.update() Use one of the following methods: MongoCollection.updateOne() MongoCollection.updateMany() MongoCollection.replaceOne() DBCollection.remove() Use one of the following methods: MongoCollection.deleteOne() MongoCollection.deleteMany() DBCollection.count() Use one of the following methods: MongoCollection.countDocuments() MongoCollection.estimatedDocumentCount() DBCollection.findAndModify() Use one of the following methods: MongoCollection.findOneAndUpdate() MongoCollection.findOneAndReplace() MongoCollection.findOneAndDelete() QueryBuilder Filters The current API uses  Options  classes and method chaining rather than\noverloaded methods. The current API uses relaxed JSON format by default in driver versions 4.0\nand later. If your application relies on the strict JSON format, use the\nstrict mode when reading or writing data. Learn how to specify the JSON\nformat in the current API in the  Document Data Format: Extended JSON \nguide. The default generic type for  MongoCollection  in the current API is\n org.bson.Document .\nYou can specify  BasicDBObject \nas a type parameter if it eases your migration. In the current API, the aggregation pipeline you pass to the  aggregate() \nmethod accepts a list of objects that extend the  Bson  interface\nwhereas in the legacy API, it accepts a list of objects that extend the\n DBObject  interface. The method signatures also differ between the APIs. See the following API\ndocumentation for more information: aggregate()  method in the current API aggregate()  method in the legacy API Bson  interface DBObject  interface",
            "code": [],
            "preview": "On this page, you can identify the changes you must make to migrate from the\nlegacy API to the current API. You can also learn about features unique to\nthe current Java Driver and the benefits of migrating to the new API.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "usage-examples/find-operations",
            "title": "Find Operations",
            "headings": [],
            "paragraphs": "Find a Document Find Multiple Documents",
            "code": [],
            "preview": "Learn by example: how to create queries and retrieve data from MongoDB by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/insert-operations",
            "title": "Insert Operations",
            "headings": [],
            "paragraphs": "Insert a Document Insert Multiple Documents",
            "code": [],
            "preview": "Learn by example: how to insert data into MongoDB by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "quick-reference",
            "title": "Quick Reference",
            "headings": [],
            "paragraphs": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation. Command Syntax",
            "code": [
                {
                    "lang": "java",
                    "value": "coll.find(Filters.eq(\"title\", \"Hamlet\")).first();"
                },
                {
                    "lang": "json",
                    "value": "{ title: 'Hamlet', type: 'movie', ... }"
                },
                {
                    "lang": "java",
                    "value": "coll.find(Filters.eq(\"year\", 2005))"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: 'Christmas in Boston', year: 2005, ... },\n  { title: 'Chicken Little', year: 2005, ... },\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.insertOne(new Document(\"title\", \"Jackie Robinson\"));"
                },
                {
                    "lang": "java",
                    "value": "coll.insertMany(\n    Arrays.asList(\n            new Document(\"title\", \"Dangal\").append(\"rating\", \"Not Rated\"),\n            new Document(\"title\", \"The Boss Baby\").append(\"rating\", \"PG\")));"
                },
                {
                    "lang": "java",
                    "value": "coll.updateOne(\n        Filters.eq(\"title\", \"Amadeus\"),\n        Updates.set(\"imdb.rating\", 9.5));"
                },
                {
                    "lang": "json",
                    "value": "{ title: 'Amadeus', imdb: { rating: 9.5, ... } }"
                },
                {
                    "lang": "java",
                    "value": "coll.updateMany(\n        Filters.eq(\"year\", 2001),\n        Updates.inc(\"imdb.votes\", 100));"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: 'A Beautiful Mind', year: 2001, imdb: { votes: 826257, ... },\n  { title: 'Shaolin Soccer', year: 2001, imdb: { votes: 65442, ... },\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.updateOne(\n        Filters.eq(\"title\", \"Cosmos\"),\n        Updates.push(\"genres\", \"Educational\"));"
                },
                {
                    "lang": "json",
                    "value": "{ title: 'Cosmos', genres: [ 'Documentary', 'Educational' ], ...}"
                },
                {
                    "lang": "java",
                    "value": "coll.replaceOne(\n        Filters.and(Filters.eq(\"name\", \"Deli Llama\"), Filters.eq(\"address\", \"2 Nassau St\")),\n        new Document(\"name\", \"Lord of the Wings\").append(\"zipcode\", 10001));"
                },
                {
                    "lang": "json",
                    "value": "{ name: 'Lord of the Wings', zipcode: 10001 }"
                },
                {
                    "lang": "java",
                    "value": "coll.deleteOne(Filters.eq(\"title\", \"Congo\"));"
                },
                {
                    "lang": "java",
                    "value": "coll.deleteMany(Filters.regex(\"title\", \"^Shark.*\"));"
                },
                {
                    "lang": "java",
                    "value": "coll.bulkWrite(\n        Arrays.asList(\n               new InsertOneModel<Document>(\n                       new Document().append(\"title\", \"A New Movie\").append(\"year\", 2022)),\n               new DeleteManyModel<Document>(\n                       Filters.lt(\"year\", 1970))));"
                },
                {
                    "lang": "java",
                    "value": "coll.watch(Arrays.asList(\n        Aggregates.match(Filters.gte(\"year\", 2022))));"
                },
                {
                    "lang": "java",
                    "value": "MongoCursor<Document> cursor = coll.find().cursor();\nwhile (cursor.hasNext()) {\n    System.out.println(cursor.next().toJson());\n}"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: '2001: A Space Odyssey', ... },\n  { title: 'The Sound of Music', ... },\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "List<Document> resultList = new ArrayList<Document>();\ncoll.find().into(resultList);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: '2001: A Space Odyssey', ... },\n  { title: 'The Sound of Music', ... },\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.countDocuments(Filters.eq(\"year\", 2000));"
                },
                {
                    "lang": "none",
                    "value": "618"
                },
                {
                    "lang": "java",
                    "value": "coll.distinct(\"year\", Integer.class);"
                },
                {
                    "lang": "none",
                    "value": "[ 1891, 1893, 1894, 1896, 1903, ... ]"
                },
                {
                    "lang": "java",
                    "value": "coll.find().limit(2);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: 'My Neighbor Totoro', ... },\n  { title: 'Am\u00e9lie', ... }\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.find(Filters.regex(\"title\", \"^Rocky\")).skip(2);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: 'Rocky III', ... },\n  { title: 'Rocky IV', ... },\n  { title: 'Rocky V', ... }\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.find().sort(Sorts.ascending(\"year\"));"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: 'Newark Athlete', year: 1891, ... },\n  { title: 'Blacksmith Scene', year: 1893, ...},\n  { title: 'Dickson Experimental Sound Film', year: 1894},\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.find().projection(Projections.fields(\n       Projections.excludeId(),\n       Projections.include(\"year\", \"imdb\")));"
                },
                {
                    "lang": "json",
                    "value": "[\n  { year: 2012, imdb: { rating: 5.8, votes: 230, id: 8256 }},\n  { year: 1985, imdb: { rating: 7.0, votes: 447, id: 1654 }},\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "coll.createIndex(\n        Indexes.compoundIndex(\n                Indexes.ascending(\"title\"),\n                Indexes.descending(\"year\")));"
                },
                {
                    "lang": "java",
                    "value": "// only searches fields with text indexes\ncoll.find(Filters.text(\"zissou\"));"
                },
                {
                    "lang": "json",
                    "value": "[\n  { title: 'The Life Aquatic with Steve Zissou', ... }\n]"
                },
                {
                    "lang": "xml",
                    "value": "<dependencies>\n  <dependency>\n    <groupId>org.mongodb</groupId>\n    <artifactId>mongodb-driver-sync</artifactId>\n    <version>4.6.1</version>\n  </dependency>\n</dependencies>"
                },
                {
                    "lang": "groovy",
                    "value": "dependencies {\n  implementation 'org.mongodb:mongodb-driver-sync:4.6.1'\n}"
                }
            ],
            "preview": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "usage-examples/deleteOne",
            "title": "Delete a Document",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can delete a single document from a collection using the  deleteOne() \nmethod on a  MongoCollection  object. The method accepts a query filter\nthat matches the document you want to delete. If you do not specify\na filter, MongoDB matches the first document in the collection. The\n deleteOne()  method only deletes the first document matched. This method returns an instance of  DeleteResult  which contains information\nincluding how many documents were deleted as a result of the operation. If your delete operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  deleteOne() , linked at the bottom of\nthis page. The following snippet deletes a single document from the  movies \ncollection of the  sample_mflix  database. The example uses the  eq() \nfilter to match movies with the  title  exactly matching the text\n 'The Garbage Pail Kids Movie' . When you run the example, if the query filter you passed in your call to\n deleteOne()  matches a document and removes it, you should see output\nthat looks something like this: If your query filter does not match a document in your collection,\nyour call to  deleteOne()  removes no documents and returns the following: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. deleteOne() DeleteResult eq()",
            "code": [
                {
                    "lang": "none",
                    "value": "Deleted document count: 1"
                },
                {
                    "lang": "none",
                    "value": "Deleted document count: 0"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.eq;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.result.DeleteResult;\n\npublic class DeleteOne {\n\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson query = eq(\"title\", \"The Garbage Pail Kids Movie\");\n\n            try {\n                DeleteResult result = collection.deleteOne(query);\n                System.out.println(\"Deleted document count: \" + result.getDeletedCount());\n            } catch (MongoException me) {\n                System.err.println(\"Unable to delete due to an error: \" + me);\n            }\n        }\n    }\n}\n\n"
                }
            ],
            "preview": "You can delete a single document from a collection using the deleteOne()\nmethod on a MongoCollection object. The method accepts a query filter\nthat matches the document you want to delete. If you do not specify\na filter, MongoDB matches the first document in the collection. The\ndeleteOne() method only deletes the first document matched.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/delete-operations",
            "title": "Delete Operations",
            "headings": [],
            "paragraphs": "Delete a Document Delete Multiple Documents",
            "code": [],
            "preview": "Learn by example: how to delete data from MongoDB by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/insertMany",
            "title": "Insert Multiple Documents",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can insert multiple documents into a collection in a single\noperation by calling the  insertMany()  method on a  MongoCollection \nobject. To insert them, add your  Document  objects to a  List  and pass\nthat  List  as an argument to  insertMany() . If you call the  insertMany()  method\non a collection that does not exist yet, the server creates it for you. Upon successful insertion,  insertMany()  returns an instance of\n InsertManyResult . You can retrieve information such as the  _id \nfields of the documents you inserted by calling the  getInsertedIds() \nmethod on the  InsertManyResult  instance. If your insert operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  insertMany() , linked at the bottom of\nthis page. The following snippet inserts multiple documents into the  movies \ncollection. When you run the example, you should see output that resembles the following\nwith the inserted documents'  ObjectId  values in each of the value fields: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. insertMany() Document InsertManyResult",
            "code": [
                {
                    "lang": "none",
                    "value": "Inserted document ids: {0=BsonObjectId{value=...}, 1=BsonObjectId{value=...}}"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.bson.Document;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.result.InsertManyResult;\n\npublic class InsertMany {\n\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            List<Document> movieList = Arrays.asList(\n                    new Document().append(\"title\", \"Short Circuit 3\"),\n                    new Document().append(\"title\", \"The Lego Frozen Movie\"));\n\n            try {\n                InsertManyResult result = collection.insertMany(movieList);\n\n                System.out.println(\"Inserted document ids: \" + result.getInsertedIds());\n            } catch (MongoException me) {\n                System.err.println(\"Unable to insert due to an error: \" + me);\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can insert multiple documents into a collection in a single\noperation by calling the insertMany() method on a MongoCollection\nobject. To insert them, add your Document objects to a List and pass\nthat List as an argument to insertMany(). If you call the insertMany() method\non a collection that does not exist yet, the server creates it for you.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/findOne",
            "title": "Find a Document",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can retrieve a single document in a collection by chaining together\nthe  find()  and  first()  methods on a  MongoCollection  object.\nYou can pass a query filter to the  find()  method to query for and\nreturn documents that match the filter in the collection. If you do not\ninclude a filter, MongoDB returns all the documents in the collection. The\n first()  method returns the first matching document. For more information on querying MongoDB with the Java driver, see our\n guide on Querying Documents . You can also chain other methods to the  find()  method\nsuch as  sort()  which organizes the matched documents in a specified order, and\n projection()  which configures the fields included in the returned documents. For more information on the  sort()  method, see our\n guide on Sorting .\nFor more information on the  projection()  method, see our\n guide on Projections The  find()  method returns an instance of  FindIterable , a class\nthat offers several methods to access, organize, and traverse the results.\n FindIterable  also inherits methods from its parent class,\n MongoIterable  such as  first() . The  first()  method returns the first document from the retrieved results\nor  null  if there are no results. The following snippet finds a single document from the  movies  collection.\nIt uses the following objects and methods: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: A  query filter  that is passed to the  find()  method. The  eq \nfilter matches only movies with the title exactly matching the text\n 'The Room' . A  sort  that organizes matched documents in descending order by\nrating, so if our query matches multiple documents the returned\ndocument is the one with the highest rating. A  projection  that includes the objects in the  title  and  imdb \nfields and excludes the  _id  field using the helper method\n excludeId() . This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. FindIterable MongoIterable find() first()",
            "code": [
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.eq;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Projections;\nimport com.mongodb.client.model.Sorts;\n\npublic class FindOne {\n\n    public static void main( String[] args ) {\n\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson projectionFields = Projections.fields(\n                    Projections.include(\"title\", \"imdb\"),\n                    Projections.excludeId());\n\n            Document doc = collection.find(eq(\"title\", \"The Room\"))\n                    .projection(projectionFields)\n                    .sort(Sorts.descending(\"imdb.rating\"))\n                    .first();\n\n            if (doc == null) {\n                System.out.println(\"No results found.\");\n            } else {\n                System.out.println(doc.toJson());\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can retrieve a single document in a collection by chaining together\nthe find() and first() methods on a MongoCollection object.\nYou can pass a query filter to the find() method to query for and\nreturn documents that match the filter in the collection. If you do not\ninclude a filter, MongoDB returns all the documents in the collection. The\nfirst() method returns the first matching document.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/updateOne",
            "title": "Update a Document",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can update a single document using the  updateOne()  method on\na  MongoCollection  object. The method accepts a  filter  that matches the\ndocument you want to update and an  update  statement that instructs the\ndriver how to change the matching document. The  updateOne()  method only\nupdates the first document that matches the filter. To perform an update with the  updateOne()  method, you must pass\na query filter and an update document. The query filter specifies the criteria\nfor which document to perform the update on and the update document provides\ninstructions on what changes to make to it. You can optionally pass an instance of  UpdateOptions  to the  updateOne()  method in\norder to specify the method's behavior. For example, if you set the  upsert  field of\nthe  UpdateOptions  object to  true , the operation inserts a new\ndocument from the fields in both the query and update document if no documents\nmatch the query filter. See the link to the  UpdateOptions  API\ndocumentation at the bottom of this page for more information. Upon successful execution, the  updateOne()  method returns an instance\nof  UpdateResult .  You can retrieve information such as the number of\ndocuments modified by calling the  getModifiedCount()  method, or the\nvalue of the  _id  field by calling the  getUpsertedId()  method if you\nspecified  upsert(true)  in an  UpdateOptions  instance. If your update operation fails, the driver raises an exception.\nFor example, if you try to set a value for the immutable field  _id  in\nyour update document, the method throws a  MongoWriteException  with the\nmessage: If your update document contains a change that violates unique index\nrules, the method throws a  MongoWriteException  with an error\nmessage that should look something like this: For more information on the types of exceptions raised under specific\nconditions, see the API documentation for  updateOne() , linked at the\nbottom of this page. In this example, we update the first match for our query in the  movies \ncollection of the  sample_mflix  database. We perform the following\nupdates to the matching document: We use the  Updates  builder, a factory class that contains static\nhelper methods, to construct the update document. While you can pass an update\ndocument instead of using the builder, the builder provides type checking and\nsimplified syntax. For more information on the  Updates  builder, see our\n guide on the Updates builder . After you run the example, you should see output that looks something like this: Or if the example resulted in an upsert: If you query the updated document, it should look something like this: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: Set the value of  runtime  to  99 Add  Sports  to the array of  genres  only if it does not already\nexist Set the value of  lastUpdated  to the current time. This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. UpdateOne UpdateOptions combine() set() addToSet() currentTimestamp() UpdateResult",
            "code": [
                {
                    "lang": "none",
                    "value": "Performing an update on the path '_id' would modify the immutable field '_id'"
                },
                {
                    "lang": "none",
                    "value": "E11000 duplicate key error collection: ..."
                },
                {
                    "lang": "none",
                    "value": "Modified document count: 1\nUpserted id: null"
                },
                {
                    "lang": "none",
                    "value": "Modified document count: 0\nUpserted id: BsonObjectId{value=...}"
                },
                {
                    "lang": "none",
                    "value": "Document {\n  { _id=...,\n    plot=...,\n    genres=[Adventure, Comedy, Family, Sports],\n    runtime=99,\n    ...\n    lastUpdated=Timestamp{...}\n  }\n}"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.UpdateOptions;\nimport com.mongodb.client.model.Updates;\nimport com.mongodb.client.result.UpdateResult;\n\npublic class UpdateOne {\n\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Document query = new Document().append(\"title\",  \"Cool Runnings 2\");\n\n            Bson updates = Updates.combine(\n                    Updates.set(\"runtime\", 99),\n                    Updates.addToSet(\"genres\", \"Sports\"),\n                    Updates.currentTimestamp(\"lastUpdated\"));\n\n            UpdateOptions options = new UpdateOptions().upsert(true);\n\n            try {\n                UpdateResult result = collection.updateOne(query, updates, options);\n\n                System.out.println(\"Modified document count: \" + result.getModifiedCount());\n\n                System.out.println(\"Upserted id: \" + result.getUpsertedId()); // only contains a value when an upsert is performed\n            } catch (MongoException me) {\n                System.err.println(\"Unable to update due to an error: \" + me);\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can update a single document using the updateOne() method on\na MongoCollection object. The method accepts a filter that matches the\ndocument you want to update and an update statement that instructs the\ndriver how to change the matching document. The updateOne() method only\nupdates the first document that matches the filter.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/distinct",
            "title": "Retrieve Distinct Values of a Field",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can retrieve a list of distinct values for a field across a\ncollection by calling the  distinct()  method on a  MongoCollection \nobject. Pass the document field name as the first parameter and the class\nyou want to cast the results to as the second parameter as shown below: You can specify a field on the document or one within an  embedded document \nusing  dot notation . The following method call returns each distinct\nvalue of the  wins  field in the  awards  embedded document: You can optionally pass a query filter to the method to limit\nthe set of documents from which your MongoDB instance retrieves distinct values as\nfollows: The  distinct()  method returns an object that implements the\n DistinctIterable  interface. This interface contains methods to access,\norganize, and traverse the results. It also inherits methods from its parent\ninterface,  MongoIterable , such as  first()  which returns the first\nresult and  cursor()  which returns an instance of a  MongoCursor . The following snippet retrieves a list of distinct values for the  year \ndocument field from the  movies  collection. It uses a query filter to\nmatch movies that include \"Carl Franklin\" as one of the values in the\n directors  array. When you run the example, you should see output that reports each distinct\nyear for all the movies that Carl Franklin was included as a director,\nwhich should look something like this: For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. distinct()  API Documentation DistinctIterable  API Documentation Dot Notation  Server Manual Entry MongoIterable  API Documentation",
            "code": [
                {
                    "lang": "java",
                    "value": "collection.distinct(\"countries\", String.class);"
                },
                {
                    "lang": "java",
                    "value": "collection.distinct(\"awards.wins\", Integer.class);"
                },
                {
                    "lang": "java",
                    "value": "collection.distinct(\"type\", Filters.eq(\"languages\", \"French\"), String.class);"
                },
                {
                    "lang": "none",
                    "value": "1992\n1995\n1998\n..."
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport org.bson.Document;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.DistinctIterable;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoCursor;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Filters;\n\npublic class Distinct {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            try {\n                DistinctIterable<Integer> docs = collection.distinct(\"year\", Filters.eq(\"directors\", \"Carl Franklin\"), Integer.class);\n                MongoCursor<Integer> results = docs.iterator();\n\n                while(results.hasNext()) {\n                    System.out.println(results.next());\n                }\n            } catch (MongoException me) {\n                System.err.println(\"An error occurred: \" + me);\n            }\n        }\n    }\n}\n\n"
                }
            ],
            "preview": "You can retrieve a list of distinct values for a field across a\ncollection by calling the distinct() method on a MongoCollection\nobject. Pass the document field name as the first parameter and the class\nyou want to cast the results to as the second parameter as shown below:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/count",
            "title": "Count Documents",
            "headings": [
                "Example"
            ],
            "paragraphs": "There are two instance methods in the  MongoCollection  class that you can\ncall to count the number of documents in a collection: The  estimatedDocumentCount()  method returns more quickly than the\n countDocuments()  method because it uses the collection's metadata rather\nthan scanning the entire collection. The  countDocuments()  method returns\nan  accurate  count of the number of documents and supports specifying\na filter. When you call the  countDocuments()  method, you can optionally pass a\n query filter  parameter. You cannot pass any parameters when you call\n estimatedDocumentCount() . You can also pass an optional parameter to either of these methods to\nspecify the behavior of the call: Both methods return the number of matching documents as a  long  primitive. countDocuments()  returns the number of documents in the collection\nthat match a specified query. If you specify an empty query filter,\nthe method returns the total number of documents in the collection. estimatedDocumentCount()  returns an  estimation  of the number of\ndocuments in the collection based on the collection metadata. You cannot\nspecify a query when using this method. When using  countDocuments()  to return the total number of documents in a\ncollection, you can improve performance by avoiding a collection scan. To do\nthis, use a  hint  to take advantage\nof the built-in index on the  _id  field. Use this technique only when\ncalling  countDocuments()  with an empty query parameter. If you are using the Stable API  V1  with the \"strict\" option and a\nMongoDB Server version between 5.0.0 and 5.0.8 inclusive, method calls to\n estimatedDocumentCount()  may error due to a server bug. Upgrade to MongoDB Server 5.0.9 or set the Stable API \"strict\" option to\n false  to avoid this issue. Method Optional Parameter Class Description countDocuments() CountOptions You can specify a maximum number of documents to count by using the\n limit()  method or the maximum amount of execution time using the\n maxTime()  method. estimatedDocumentCount() EstimatedDocumentCountOptions You can specify the maximum execution time using the  maxTime() \nmethod. The following example estimates the number of documents in the\n movies  collection in the  sample_mflix  database, and then returns\nan accurate count of the number of documents in the  movies \ncollection with  Canada  in the  countries  field. If you run the preceding sample code, you should see output that looks something\nlike this (exact numbers may vary depending on your data): For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. countDocuments() estimatedDocumentCount() CountOptions EstimatedDocumentCountOptions",
            "code": [
                {
                    "lang": "java",
                    "value": "CountOptions opts = new CountOptions().hintString(\"_id_\");\nlong numDocuments = collection.countDocuments(new BsonDocument(), opts);"
                },
                {
                    "lang": "none",
                    "value": "Estimated number of documents in the movies collection: 23541\nNumber of movies from Spain: 755"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.eq;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\n\npublic class CountDocuments {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson query = eq(\"countries\", \"Spain\");\n\n            try {\n                long estimatedCount = collection.estimatedDocumentCount();\n                System.out.println(\"Estimated number of documents in the movies collection: \" + estimatedCount);\n\n                long matchingCount = collection.countDocuments(query);\n                System.out.println(\"Number of movies from Spain: \" + matchingCount);\n            } catch (MongoException me) {\n                System.err.println(\"An error occurred: \" + me);\n            }\n        }\n    }\n}\n\n"
                }
            ],
            "preview": "There are two instance methods in the MongoCollection class that you can\ncall to count the number of documents in a collection:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/find",
            "title": "Find Multiple Documents",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can query for multiple documents in a collection by calling the  find() \nmethod on a  MongoCollection  object. Pass a query filter to the\n find()  method to query for and return documents that match the filter in\nthe collection. If you do not include a filter, MongoDB returns all the\ndocuments in the collection. For more information on querying MongoDB with the Java driver, see our\n guide on Querying Documents . You can also chain methods to the  find()  method such as  sort()  which\norganizes the matched documents in a specified order and\n projection()  which configures the included fields in the\nreturned documents. For more information on the  sort()  method, see our\n guide on Sorting .\nFor more information on the  projection()  method, see our\n guide on Projections The  find()  method returns an instance of  FindIterable , a class\nthat offers several methods to access, organize, and traverse the results.\n FindIterable  also inherits methods from its parent class,\n MongoIterable  which implements the core Java interface  Iterable . You can call the  iterator()  method on the  MongoIterable  which\nreturns a  MongoCursor  instance that you can use to traverse the results.\nYou can call methods on the  MongoCursor  such as  hasNext()  to check\nwhether additional results exist, or  next()  to return the next document\nin the collection. If no documents match the query, calling  hasNext() \nreturns  false  and therefore calling  next()  throws an exception. If you call  next()  on the iterator either after it has returned the final\nresult or when no results exist, it throws an exception of type\n java.util.NoSuchElementException . Always use  hasNext()  to check that\nadditional results exist before you call  next() . The following snippet finds and prints all documents that match a query on\nthe  movies  collection. It uses the following objects and methods: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: A  query filter  that is passed to the  find()  method. The  lt() \nfilter matches only movies with a runtime of less than 15 minutes. A  sort  that organizes returned documents in descending order by\ntitle (\"Z\" before \"A\"). A  projection  that includes the objects in the  title  and  imdb \nfields and excludes the  _id  field using the helper method\n excludeId() . This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. FindIterable MongoIterable MongoCursor find()",
            "code": [
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.lt;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoCursor;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Projections;\nimport com.mongodb.client.model.Sorts;\n\npublic class Find {\n    public static void main( String[] args ) {\n\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson projectionFields = Projections.fields(\n                    Projections.include(\"title\", \"imdb\"),\n                    Projections.excludeId());\n\n            MongoCursor<Document> cursor = collection.find(lt(\"runtime\", 15))\n                    .projection(projectionFields)\n                    .sort(Sorts.descending(\"title\")).iterator();\n\n            try {\n                while(cursor.hasNext()) {\n                    System.out.println(cursor.next().toJson());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can query for multiple documents in a collection by calling the find()\nmethod on a MongoCollection object. Pass a query filter to the\nfind() method to query for and return documents that match the filter in\nthe collection. If you do not include a filter, MongoDB returns all the\ndocuments in the collection.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/updateMany",
            "title": "Update Multiple Documents",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can update multiple documents using the  updateMany()  method on\na  MongoCollection  object. The method accepts a  filter  that matches the\ndocument you want to update and an  update  statement that instructs the\ndriver how to change the matching document. The  updateMany()  method updates\nall the documents in the collection that match the filter. To perform an update with the  updateMany()  method, you must pass\na query filter and an update document. The query filter specifies which\ndocuments in the collection to match and the update document provides\ninstructions on what changes to make to them. You can optionally pass an instance of  UpdateOptions  to the  updateMany()  method in\norder to modify the behavior of the call. For example, if you set the\n upsert  field of the  UpdateOptions  object to  true  and no documents\nmatch the specified query filter, the operation inserts a new document\ncomposed of the fields from both the query and update document. Upon successful execution, the  updateMany()  method returns an instance\nof  UpdateResult . You can retrieve information such as the number of\ndocuments modified by calling the  getModifiedCount()  method. If you\nspecified  upsert(true)  in an  UpdateOptions  object and the\noperation results in an insert, you can retrieve the  _id  field of the\nnew document by calling the  getUpsertedId()  method on the\n UpdateResult  instance. If your update operation fails, the driver raises an exception and does not update\nany of the documents matching the filter. For example, if you try to set\na value for the immutable field  _id  in your update document, the\n updateMany()  method does not update any documents and throws a\n MongoWriteException  with the message: If your update document contains a change that violates unique index\nrules, the method throws a  MongoWriteException  with an error\nmessage that should look something like this: For more information on the types of exceptions raised under specific\nconditions, see the API documentation for  updateMany() , linked at the\nbottom of this page. In this example, we update documents that match our query in the  movies \ncollection of the  sample_mflix  database. We perform the following\nupdates to the matching documents: We use the  Updates  builder, a factory class that contains static\nhelper methods to construct the update document. While you can pass an update\ndocument instead of using the builder, the builder provides type checking and\nsimplified syntax. Read our\n guide on Updates  in the Builders\nsection for more information. After you run the example, you should see output that looks something like\nthis: If you query the updated document or documents, they should look something like\nthis: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: Add  Frequently Discussed  to the array of  genres  only if it does not\nalready exist Set the value of  lastUpdated  to the current time. This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. UpdateMany UpdateOptions combine() addToSet() currentTimestamp() UpdateResult",
            "code": [
                {
                    "lang": "none",
                    "value": "Performing an update on the path '_id' would modify the immutable field '_id'"
                },
                {
                    "lang": "none",
                    "value": "E11000 duplicate key error collection: ..."
                },
                {
                    "lang": "none",
                    "value": "Modified document count: 53"
                },
                {
                    "lang": "none",
                    "value": "[\n  Document {\n    { _id=...,\n      plot=...,\n      genres=[..., Frequently Discussed, ...],\n      ...\n      lastUpdated=Timestamp{...}\n    }\n  },\n  ...\n]"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.gt;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Updates;\nimport com.mongodb.client.result.UpdateResult;\n\npublic class UpdateMany {\n\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson query = gt(\"num_mflix_comments\", 50);\n\n            Bson updates = Updates.combine(\n                    Updates.addToSet(\"genres\", \"Frequently Discussed\"),\n                    Updates.currentTimestamp(\"lastUpdated\"));\n\n            try {\n                UpdateResult result = collection.updateMany(query, updates);\n\n                System.out.println(\"Modified document count: \" + result.getModifiedCount());\n\n            } catch (MongoException me) {\n                System.err.println(\"Unable to update due to an error: \" + me);\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can update multiple documents using the updateMany() method on\na MongoCollection object. The method accepts a filter that matches the\ndocument you want to update and an update statement that instructs the\ndriver how to change the matching document. The updateMany() method updates\nall the documents in the collection that match the filter.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/command",
            "title": "Run a Command",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can run all raw database operations using the\n MongoDatabase.runCommand()  method. A raw database operation is a\ncommand you can execute directly on the MongoDB Server CLI. These\ncommands include administrative and diagnostic tasks, such as fetching\nserver stats or initializing a replica set. Call the  runCommand() \nmethod with a  Bson  command object on an instance of a  MongoDatabase \nto run your raw database operation. The  runCommand()  method accepts a command in the form of a  Bson  object.\nBy default,  runCommand  returns an object of type\n org.bson.Document  containing the output of the database command. You\ncan specify a return type for  runCommand()  as an optional second\nparameter. Use the  MongoDB Shell  for\nadministrative tasks instead of the Java driver whenever possible,\nsince these tasks are often quicker and easier to implement with the\nshell than in a Java application. In the following sample code, we send the  dbStats  command to request\nstatistics from a specific MongoDB database. When you run the preceding command, you should see output similar to the\nfollowing: For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. runCommand()  API Documentation Database Commands  Server Manual Entry dbStats  Server Manual Entry",
            "code": [
                {
                    "lang": "none",
                    "value": "dbStats: {\"db\": \"sample_mflix\", \"collections\": 5, \"views\": 0, \"objects\": 75595, \"avgObjSize\": 692.1003770090614, \"dataSize\": 52319328, \"storageSize\": 29831168, \"numExtents\": 0, \"indexes\": 9, \"indexSize\": 14430208, \"fileSize\": 0, \"nsSizeMB\": 0, \"ok\": 1}"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport org.bson.BsonDocument;\nimport org.bson.BsonInt64;\nimport org.bson.Document;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoDatabase;\nimport org.bson.conversions.Bson;\n\n\npublic class RunCommand {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n\n            try {\n                Bson command = new BsonDocument(\"dbStats\", new BsonInt64(1));\n                Document commandResult = database.runCommand(command);\n\n                // Prints the database statistics\n                System.out.println(\"dbStats: \" + commandResult.toJson());\n\n            } catch (MongoException me) {\n                // Prints a message if any exceptions occur during the command execution\n                System.err.println(\"An error occurred: \" + me);\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can run all raw database operations using the\nMongoDatabase.runCommand() method. A raw database operation is a\ncommand you can execute directly on the MongoDB Server CLI. These\ncommands include administrative and diagnostic tasks, such as fetching\nserver stats or initializing a replica set. Call the runCommand()\nmethod with a Bson command object on an instance of a MongoDatabase\nto run your raw database operation.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/replaceOne",
            "title": "Replace a Document",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can replace a single document using the  replaceOne()  method on\na  MongoCollection  object. This method removes all the existing fields\nand values from a document (except the  _id  field) and substitutes it\nwith your replacement document. The  replaceOne()  method accepts a query filter that matches the\ndocument you want to replace and a replacement document that contains the\ndata you want to save in place of the matched document. The  replaceOne() \nmethod only replaces the first document that matches the filter. You can optionally pass an instance of  ReplaceOptions  to the  replaceOne()  method in\norder to specify the method's behavior. For example, if you set the  upsert \nfield of the  ReplaceOptions  object to  true , the operation inserts\na new document from the fields in the replacement document if no documents\nmatch the query filter. See the link to the  ReplaceOptions  API\ndocumentation at the bottom of this page for more information. Upon successful execution, the  replaceOne()  method returns an instance\nof  UpdateResult .  You can retrieve information such as the number of\ndocuments modified by calling the  getModifiedCount()  method. You can also\nretrieve the value of the document's  _id  field by calling the\n getUpsertedId()  method if you set  upsert(true)  in the\n ReplaceOptions  instance and the operation resulted in the insertion of a new document. If your replacement operation fails, the driver raises an exception.\nFor example, if you try to specify a value for the immutable field\n _id  in your replacement document that differs from the original\ndocument, the method throws a  MongoWriteException  with the message: If your replacement document contains a change that violates unique index\nrules, the method throws a  MongoWriteException  with an error\nmessage that should look something like this: For more information on the types of exceptions raised under specific\nconditions, see the API documentation for  replaceOne() , linked at the\nbottom of this page. In this example, we replace the first match of our query filter in the\n movies  collection of the  sample_mflix  database with a replacement\ndocument. All the fields except for the  _id  field are deleted from the\noriginal document and are substituted by the replacement document. Before the  replaceOne()  operation runs, the original document contains\nseveral fields describing the movie. After the operation runs, the resulting\ndocument contains only the fields specified by the replacement document\n( title  and  fullplot ) and the  _id  field. The following snippet uses the following objects and methods: After you run the example, you should see output that looks something like\nthis: Or if the example resulted in an upsert: If you query the replaced document, it should look something like this: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: A  query filter  that is passed to the  replaceOne()  method. The  eq \nfilter matches only movies with the title exactly matching the text\n 'Music of the Heart' . A  replacement document  that contains the document that replaces the\nmatching document if it exists. A  ReplaceOptions  object with the  upsert  option set to  true .\nThis option specifies that the method should insert the data contained in\nthe replacement document if the query filter does not match any documents. This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. ReplaceOne ReplaceOptions UpdateResult eq()",
            "code": [
                {
                    "lang": "none",
                    "value": "After applying the update, the (immutable) field '_id' was found to have been altered to _id: ObjectId('...)"
                },
                {
                    "lang": "none",
                    "value": "E11000 duplicate key error collection: ..."
                },
                {
                    "lang": "none",
                    "value": "Modified document count: 1\nUpserted id: null"
                },
                {
                    "lang": "none",
                    "value": "Modified document count: 0\nUpserted id: BsonObjectId{value=...}"
                },
                {
                    "lang": "none",
                    "value": "Document {\n  { _id=...,\n    title=50 Violins,\n    fullplot=A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music\n  }\n}"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.eq;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.ReplaceOptions;\nimport com.mongodb.client.result.UpdateResult;\n\npublic class ReplaceOne {\n\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson query = eq(\"title\", \"Music of the Heart\");\n\n            Document replaceDocument = new Document().\n                    append(\"title\", \"50 Violins\").\n                    append(\"fullplot\", \" A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music\");\n\n            ReplaceOptions opts = new ReplaceOptions().upsert(true);\n\n            UpdateResult result = collection.replaceOne(query, replaceDocument, opts);\n\n            System.out.println(\"Modified document count: \" + result.getModifiedCount());\n            System.out.println(\"Upserted id: \" + result.getUpsertedId()); // only contains a value when an upsert is performed\n\n        } catch (MongoException me) {\n            System.err.println(\"Unable to replace due to an error: \" + me);\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can replace a single document using the replaceOne() method on\na MongoCollection object. This method removes all the existing fields\nand values from a document (except the _id field) and substitutes it\nwith your replacement document.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/deleteMany",
            "title": "Delete Multiple Documents",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can delete multiple documents from a collection in a single operation\nby calling the  deleteMany()  method on a  MongoCollection  object. To specify which documents to delete, pass a query filter that matches\nthe documents you want to delete. If you provide an empty document,\nMongoDB matches all documents in the collection and deletes them. While\nyou can use  deleteMany()  to delete all documents in a collection,\nconsider using the  drop()  method instead for better performance. Upon successful deletion, this method returns an instance of\n DeleteResult . You can retrieve information such as the number of\ndocuments deleted by calling the  getDeletedCount()  method on the\n DeleteResult  instance. If your delete operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  deleteMany() , linked at the bottom of\nthis page. The following snippet deletes multiple documents from the  movies \ncollection in the  sample_mflix  database. The query filter passed to the  deleteMany()  method matches all\nmovie documents that contain a  rating  of less than  1.9  in the  imdb \nsubdocument. When you run the example, you should see output that reports the number of\ndocuments deleted in your call to  deleteMany() . For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. deleteMany() DeleteResult drop()",
            "code": [
                {
                    "lang": "none",
                    "value": "Deleted document count: 4"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport static com.mongodb.client.model.Filters.lt;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.result.DeleteResult;\n\npublic class DeleteMany {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            Bson query = lt(\"imdb.rating\", 1.9);\n\n            try {\n                DeleteResult result = collection.deleteMany(query);\n                System.out.println(\"Deleted document count: \" + result.getDeletedCount());\n            } catch (MongoException me) {\n                System.err.println(\"Unable to delete due to an error: \" + me);\n            }\n        }\n    }\n}\n\n"
                }
            ],
            "preview": "You can delete multiple documents from a collection in a single operation\nby calling the deleteMany() method on a MongoCollection object.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/insertOne",
            "title": "Insert a Document",
            "headings": [
                "Example"
            ],
            "paragraphs": "You can insert a single document into a collection using the  insertOne() \nmethod on a  MongoCollection  object. To insert a document, construct a\n Document  object that contains the fields and values that you want to\nstore. If you call the  insertOne()  method on a collection that does\nnot exist yet, the server automatically creates it for you. Upon a successful insertion,  insertOne()  returns an instance of\n InsertOneResult . You can retrieve information such as the  _id \nfield of the document you inserted by calling the  getInsertedId() \nmethod on the  InsertOneResult  instance. If your insert operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  insertOne() , linked at the bottom of\nthis page. The following snippet inserts a single document into the  movies \ncollection. When you run the example, you should see output that resembles the following\nwith the inserted document's  ObjectId  in the value field: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. insertOne() Document InsertOneResult",
            "code": [
                {
                    "lang": "none",
                    "value": "Inserted document id: BsonObjectId{value=...}"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport java.util.Arrays;\n\nimport org.bson.Document;\nimport org.bson.types.ObjectId;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.result.InsertOneResult;\n\npublic class InsertOne {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            try {\n                InsertOneResult result = collection.insertOne(new Document()\n                        .append(\"_id\", new ObjectId())\n                        .append(\"title\", \"Ski Bloopers\")\n                        .append(\"genres\", Arrays.asList(\"Documentary\", \"Comedy\")));\n\n                System.out.println(\"Success! Inserted document id: \" + result.getInsertedId());\n            } catch (MongoException me) {\n                System.err.println(\"Unable to insert due to an error: \" + me);\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can insert a single document into a collection using the insertOne()\nmethod on a MongoCollection object. To insert a document, construct a\nDocument object that contains the fields and values that you want to\nstore. If you call the insertOne() method on a collection that does\nnot exist yet, the server automatically creates it for you.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/update-operations",
            "title": "Update & Replace Operations",
            "headings": [],
            "paragraphs": "Update a Document Update Multiple Documents Replace a Document",
            "code": [],
            "preview": "Learn by example: how to update and replace data in MongoDB by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/bulkWrite",
            "title": "Perform Bulk Operations",
            "headings": [
                "Example"
            ],
            "paragraphs": "The  bulkWrite()  method performs batch write operations against a\n single  collection. This method reduces the number of network round trips from\nyour application to your MongoDB instance which increases the performance of your\napplication. Since you only receive the success status after\nall the operations return, we recommend you use this if that meets the\nrequirements of your use case. You can specify one or more of the following write operations in\n bulkWrite() : The  bulkWrite()  method accepts the following parameters: The  bulkWrite()  method returns a  BulkWriteResult  object that\ncontains information about the write operation results including the number\nof documents inserted, modified, and deleted. If one or more of your operations attempts to set a value that violates a\nunique index on your collection, an exception is raised that should look\nsomething like this: Similarly, if you attempt to perform a bulk write against a collection\nthat uses schema validation and one or more of your write operations\nprovide an unexpected format, you may encounter exceptions. insertOne updateOne updateMany deleteOne deleteMany replaceOne A  List  of objects that implement  WriteModel : the classes that\nimplement  WriteModel  correspond to the aforementioned write\noperations. E.g. the  InsertOneModel  class wraps the  insertOne  write\noperation. See the links to the API documentation at the bottom of this page\nfor more information on each class. BulkWriteOptions :  optional  object that specifies settings such as\nwhether to ensure your MongoDB instance orders your write operations. Retryable writes run on MongoDB Server versions 3.6 or later in bulk\nwrite operations unless they include one or more instances of\n UpdateManyModel  or  DeleteManyModel . By default, MongoDB executes bulk write operations one-by-one in the\nspecified order (i.e. serially). During an ordered bulk write, if\nan error occurs during the processing of an operation, MongoDB returns\nwithout processing the remaining operations in the list. In contrast,\nwhen you set  ordered  to  false , MongoDB continues to process remaining\nwrite operations in the list in the event of an error. Unordered operations\nare theoretically faster since MongoDB can execute them in parallel, but\nyou should only use them if your writes do not depend on order. The following code sample performs an ordered bulk write operation on the\n movies  collection in the  sample_mflix  database. The example call\nto  bulkWrite()  includes examples of the  InsertOneModel ,\n UpdateOneModel , and  DeleteOneModel . The output should look something like this: For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. Unique Index  Server Manual Entry Schema Validation  Server Manual Entry bulkWrite()  API Documentation BulkWriteOptions  API Documentation BulkWriteResult  API Documentation InsertOneModel  API Documentation UpdateOneModel  API Documentation UpdateManyModel  API Documentation DeleteOneModel  API Documentation DeleteManyModel  API Documentation ReplaceOneModel  API Documentation",
            "code": [
                {
                    "lang": "sh",
                    "value": "The bulk write operation failed due to an error: Bulk write operation error on server <hostname>. Write errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key error collection: ... }]."
                },
                {
                    "lang": "none",
                    "value": "Result statistics:\ninserted: 3\nupdated: 2\ndeleted: 1"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport java.util.Arrays;\n\nimport org.bson.Document;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.bulk.BulkWriteResult;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.DeleteOneModel;\nimport com.mongodb.client.model.InsertOneModel;\nimport com.mongodb.client.model.ReplaceOneModel;\nimport com.mongodb.client.model.UpdateOneModel;\nimport com.mongodb.client.model.UpdateOptions;\n\npublic class BulkWrite {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            try {\n                BulkWriteResult result = collection.bulkWrite(\n                        Arrays.asList(\n                                new InsertOneModel<>(new Document(\"name\", \"A Sample Movie\")),\n                                new InsertOneModel<>(new Document(\"name\", \"Another Sample Movie\")),\n                                new InsertOneModel<>(new Document(\"name\", \"Yet Another Sample Movie\")),\n                                new UpdateOneModel<>(new Document(\"name\", \"A Sample Movie\"),\n                                        new Document(\"$set\", new Document(\"name\", \"An Old Sample Movie\")),\n                                        new UpdateOptions().upsert(true)),\n                                new DeleteOneModel<>(new Document(\"name\", \"Yet Another Sample Movie\")),\n                                new ReplaceOneModel<>(new Document(\"name\", \"Yet Another Sample Movie\"),\n                                        new Document(\"name\", \"The Other Sample Movie\").append(\"runtime\",  \"42\"))\n                                ));\n\n                System.out.println(\"Result statistics:\" +\n                        \"\\ninserted: \" + result.getInsertedCount() +\n                        \"\\nupdated: \" + result.getModifiedCount() +\n                        \"\\ndeleted: \" + result.getDeletedCount());\n\n            } catch (MongoException me) {\n                System.err.println(\"The bulk write operation failed due to an error: \" + me);\n            }\n        }\n    }\n}\n\n"
                }
            ],
            "preview": "The bulkWrite() method performs batch write operations against a\nsingle collection. This method reduces the number of network round trips from\nyour application to your MongoDB instance which increases the performance of your\napplication. Since you only receive the success status after\nall the operations return, we recommend you use this if that meets the\nrequirements of your use case.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection",
            "title": "Connection Guide",
            "headings": [
                "Overview"
            ],
            "paragraphs": "Learn how to set up a connection and specify connection behavior from your\napplication to a MongoDB deployment using the driver in the following\nsections: For information about authenticating with a MongoDB instance,\nsee  Authentication Mechanisms  and  Enterprise Authentication Mechanisms . Connect to MongoDB View a List of Connection Options Specify Connection Behavior with the MongoClient Class Enable Network Compression Enable TLS/SSL on a Connection Connect to MongoDB Using a JNDI Datasource Connect to MongoDB Atlas from AWS Lambda",
            "code": [],
            "preview": "Learn how to set up a connection and specify connection behavior from your\napplication to a MongoDB deployment using the driver in the following\nsections:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/csfle",
            "title": "Client-Side Field Level Encryption",
            "headings": [
                "Overview",
                "Installation",
                "mongodb-crypt",
                "mongocryptd",
                "Examples",
                "Automatic Encryption and Decryption",
                "Explicit Encryption and Decryption",
                "Explicit Encryption and Auto Decryption"
            ],
            "paragraphs": "In this guide, you can learn how to install and use  Client-Side Field\nLevel Encryption (CSFLE)  in the MongoDB Java driver. CSFLE allows you to encrypt specific data fields within a document with\nyour MongoDB client application before sending the data to the server.\nStarting in MongoDB 4.2 Enterprise, you can perform this client-side encryption automatically. With CSFLE, your client application encrypts fields client-side without requiring any server-side configuration or\ndirectives. CSFLE is useful for situations in which applications must guarantee that unauthorized parties, including\nserver administrators, cannot read the encrypted data. This guide is a quick introduction to CSFLE using the Java driver. For in-depth information on how CSFLE works, see\nthe  CSFLE reference  documentation. For a real-world scenario and\nimplementation, see our  CSFLE Guide . To get started with CSFLE in your client application, you need the MongoDB Java driver mongodb-crypt mongocryptd  if using automatic encryption (Enterprise or Atlas) The  mongodb-crypt  binding is available as a separate JAR. Add it to your project using your desired dependency\nmanagement tool. mongocryptd  is a binary run as a daemon / process that is used for automatic encryption.\n mongodb-crypt  communicates with  mongocryptd  to automatically encrypt the information specified by a user-provided\n JSON Schema . For more detailed information on  mongocryptd , see the\n mongocryptd reference documentation The examples on this page use a local key, but you can also use integrated support for cloud-based key management\nservices from AWS, Azure, and GCP. Each example program execution creates a new master key in memory and drops the\n test.coll  collection. In the examples, the in-memory master key is lost when the application finishes running. If you'd like to retain\nand decrypt documents from previous runs, you can save the local master key to a file for reuse and remove the logic\nto drop the collection. MongoDB recommends using local key management only for testing purposes, and using a remote key management service\nfor production. The following example shows how to configure the  AutoEncryptionSettings  instance to create a new key and set the\nJSON schema map. The data in the  encryptedField  field is automatically encrypted before insertion, and decrypted when calling  find() \non the client side. Querying this collection from a client that isn't configured for CSFLE will return the document in\nencrypted form. The full source is available at\n ClientSideEncryptionAutoEncryptionSettingsTour.java Auto encryption requires MongoDB  Enterprise  or  Atlas . The prior example demonstrated the automatic CSFLE feature. If your version of MongoDB does not offer automatic CSFLE,\nyou can perform manual client-side field level encryption, which we call  explicit  encryption. This method does not\nrequire or use  mongocryptd . The  ClientEncryption  class contains methods you can use to perform explicit\nencryption. This example prints out the document in encrypted form, and prints out the explicitly decrypted field value to demonstrate\nfunctionality. The full source is available from\n ClientSideEncryptionExplicitEncryptionAndDecryptionTour.java Although automatic encryption requires MongoDB Enterprise or MongoDB Atlas, automatic decryption is\navailable in all MongoDB versions greater than or equal to 4.2. To configure automatic decryption, set  bypassAutoEncryption(true)  in the  autoEncryptionSettings  builder. The following example prints the inserted document out in unencrypted form. The document is automatically decrypted\nbecause  autoEncryptionSettings  have been configured. The full source is available at\n ClientSideEncryptionExplicitEncryptionOnlyTour.java .",
            "code": [
                {
                    "lang": "xml",
                    "value": "<dependencies>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>mongodb-crypt</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n</dependencies>"
                },
                {
                    "lang": "groovy",
                    "value": "dependencies {\n    compile 'org.mongodb:mongodb-crypt:1.4.0'\n}"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.AutoEncryptionSettings;\nimport com.mongodb.ClientEncryptionSettings;\nimport com.mongodb.ConnectionString;\nimport com.mongodb.MongoClientSettings;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.model.vault.DataKeyOptions;\nimport com.mongodb.client.vault.ClientEncryption;\nimport com.mongodb.client.vault.ClientEncryptions;\nimport org.bson.BsonBinary;\nimport org.bson.BsonDocument;\nimport org.bson.Document;\n\nimport java.security.SecureRandom;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ClientSideEncryptionAutoEncryptionSettingsTour {\n\n    /**\n     * Run this main method to see the output of this quick example.\n     *\n     * Requires the mongodb-crypt library in the class path and mongocryptd on the system path.\n     * Assumes the schema has already been created in MongoDB.\n     *\n     * @param args ignored args\n     */\n    public static void main(final String[] args) {\n\n        // This would have to be the same master key as was used to create the encryption key\n        final byte[] localMasterKey = new byte[96];\n        new SecureRandom().nextBytes(localMasterKey);\n\n        Map<String, Map<String, Object>> kmsProviders = new HashMap<String, Map<String, Object>>() {{\n            put(\"local\", new HashMap<String, Object>() {{\n                put(\"key\", localMasterKey);\n            }});\n        }};\n\n        String keyVaultNamespace = \"encryption.__keyVault\";\n        ClientEncryptionSettings clientEncryptionSettings = ClientEncryptionSettings.builder()\n                .keyVaultMongoClientSettings(MongoClientSettings.builder()\n                        .applyConnectionString(new ConnectionString(\"mongodb://localhost\"))\n                        .build())\n                .keyVaultNamespace(keyVaultNamespace)\n                .kmsProviders(kmsProviders)\n                .build();\n\n        ClientEncryption clientEncryption = ClientEncryptions.create(clientEncryptionSettings);\n        BsonBinary dataKeyId = clientEncryption.createDataKey(\"local\", new DataKeyOptions());\n        final String base64DataKeyId = Base64.getEncoder().encodeToString(dataKeyId.getData());\n\n        final String dbName = \"test\";\n        final String collName = \"coll\";\n        AutoEncryptionSettings autoEncryptionSettings = AutoEncryptionSettings.builder()\n                .keyVaultNamespace(keyVaultNamespace)\n                .kmsProviders(kmsProviders)\n                .schemaMap(new HashMap<String, BsonDocument>() {{\n                    put(dbName + \".\" + collName,\n                            // Need a schema that references the new data key\n                            BsonDocument.parse(\"{\"\n                                    + \"  properties: {\"\n                                    + \"    encryptedField: {\"\n                                    + \"      encrypt: {\"\n                                    + \"        keyId: [{\"\n                                    + \"          \\\"$binary\\\": {\"\n                                    + \"            \\\"base64\\\": \\\"\" + base64DataKeyId + \"\\\",\"\n                                    + \"            \\\"subType\\\": \\\"04\\\"\"\n                                    + \"          }\"\n                                    + \"        }],\"\n                                    + \"        bsonType: \\\"string\\\",\"\n                                    + \"        algorithm: \\\"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\\\"\"\n                                    + \"      }\"\n                                    + \"    }\"\n                                    + \"  },\"\n                                    + \"  \\\"bsonType\\\": \\\"object\\\"\"\n                                    + \"}\"));\n                }}).build();\n\n        MongoClientSettings clientSettings = MongoClientSettings.builder()\n                .autoEncryptionSettings(autoEncryptionSettings)\n                .build();\n\n        MongoClient mongoClient = MongoClients.create(clientSettings);\n        MongoCollection<Document> collection = mongoClient.getDatabase(\"test\").getCollection(\"coll\");\n        collection.drop(); // Clear old data\n\n        collection.insertOne(new Document(\"encryptedField\", \"9876564321\"));\n\n        System.out.println(collection.find().first().toJson());\n\n        // release resources\n        mongoClient.close();\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "// This would have to be the same master key as was used to create the encryption key\nfinal byte[] localMasterKey = new byte[96];\nnew SecureRandom().nextBytes(localMasterKey);\n\nMap<String, Map<String, Object>> kmsProviders = new HashMap<String, Map<String, Object>>() {{\n    put(\"local\", new HashMap<String, Object>() {{\n        put(\"key\", localMasterKey);\n    }});\n}};\n\nMongoClientSettings clientSettings = MongoClientSettings.builder().build();\nMongoClient mongoClient = MongoClients.create(clientSettings);\n\n// Set up the key vault for this example\nMongoNamespace keyVaultNamespace = new MongoNamespace(\"encryption.testKeyVault\");\nMongoCollection<Document> keyVaultCollection = mongoClient\n    .getDatabase(keyVaultNamespace.getDatabaseName())\n    .getCollection(keyVaultNamespace.getCollectionName());\nkeyVaultCollection.drop();\n\n// Ensure that two data keys cannot share the same keyAltName.\nkeyVaultCollection.createIndex(Indexes.ascending(\"keyAltNames\"),\n        new IndexOptions().unique(true)\n           .partialFilterExpression(Filters.exists(\"keyAltNames\")));\n\nMongoCollection<Document> collection = mongoClient.getDatabase(\"test\").getCollection(\"coll\");\ncollection.drop(); // Clear old data\n\n// Create the ClientEncryption instance\nClientEncryptionSettings clientEncryptionSettings = ClientEncryptionSettings.builder()\n        .keyVaultMongoClientSettings(MongoClientSettings.builder()\n                .applyConnectionString(new ConnectionString(\"mongodb://localhost\"))\n                .build())\n        .keyVaultNamespace(keyVaultNamespace.getFullName())\n        .kmsProviders(kmsProviders)\n        .build();\n\nClientEncryption clientEncryption = ClientEncryptions.create(clientEncryptionSettings);\n\nBsonBinary dataKeyId = clientEncryption.createDataKey(\"local\", new DataKeyOptions());\n\n// Explicitly encrypt a field\nBsonBinary encryptedFieldValue = clientEncryption.encrypt(new BsonString(\"123456789\"),\n        new EncryptOptions(\"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\").keyId(dataKeyId));\n\ncollection.insertOne(new Document(\"encryptedField\", encryptedFieldValue));\n\nDocument doc = collection.find().first();\nSystem.out.println(doc.toJson());\n\n// Explicitly decrypt the field\nSystem.out.println(\n    clientEncryption.decrypt(new BsonBinary(doc.get(\"encryptedField\", Binary.class).getData()))\n);"
                },
                {
                    "lang": "java",
                    "value": "...\nMongoClientSettings clientSettings = MongoClientSettings.builder()\n    .autoEncryptionSettings(AutoEncryptionSettings.builder()\n            .keyVaultNamespace(keyVaultNamespace.getFullName())\n            .kmsProviders(kmsProviders)\n            .bypassAutoEncryption(true)\n            .build())\n    .build();\nMongoClient mongoClient = MongoClients.create(clientSettings);\n...\n\n// Explicitly encrypt a field\nBsonBinary encryptedFieldValue = clientEncryption.encrypt(new BsonString(\"123456789\"),\n        new EncryptOptions(\"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\").keyId(dataKeyId));\n\ncollection.insertOne(new Document(\"encryptedField\", encryptedFieldValue));\n\n// Automatically decrypts the encrypted field.\nSystem.out.println(collection.find().first().toJson());"
                }
            ],
            "preview": "In this guide, you can learn how to install and use Client-Side Field\nLevel Encryption (CSFLE) in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "usage-examples/watch",
            "title": "Watch for Changes",
            "headings": [
                "How to Process Change Stream Events with a Callback",
                "Example"
            ],
            "paragraphs": "You can keep track of changes to data in MongoDB, such as changes to a\ncollection, database, or deployment, by opening a  change stream . A change\nstream allows applications to watch for changes to data and react to them.\nThe change stream returns  change event  documents when changes occur.\nYou can open a change stream by calling the  watch()  method on\na  MongoCollection ,  MongoDatabase , or  MongoClient  object: The  watch()  method optionally takes an  aggregation pipeline   which\nconsists of an array of  stages  as the first parameter to filter and\ntransform the change event output as follows: The  watch()  method returns an instance of  ChangeStreamIterable , a class\nthat offers several methods to access, organize, and traverse the results.\n ChangeStreamIterable  also inherits methods from its parent class,\n MongoIterable  which implements the core Java interface  Iterable . You can call  forEach()  on the  ChangeStreamIterable  to handle\nevents as they occur, or you can use the  iterator()  method which\nreturns a  MongoCursor  instance that you can use to traverse the results. You can call methods on the  MongoCursor  such as  hasNext()  to check\nwhether additional results exist,  next()  to return the next document\nin the collection, or  tryNext() , to immediately return either\nthe next available element in the change stream or  null . Unlike the\n MongoCursor  returned by other queries, a  MongoCursor  associated\nwith a change stream waits until a change event arrives before\nreturning a result from  next() . As a result, calls to  next() \nusing a change stream's  MongoCursor  never throw a\n java.util.NoSuchElementException . To configure options for processing the documents returned from the change\nstream, use member methods of the  ChangeStreamIterable  object returned\nby  watch() . See the link to the  ChangeStreamIterable  API\ndocumentation at the bottom of this example for more details on the\navailable methods. To capture events from a change stream, call the  forEach()  method\nwith a callback function as shown below: The callback function triggers when a change event is emitted. You can\nspecify logic in the callback to process the event document when it is\nreceived. Calls to  forEach()  block the current thread as long as the\ncorresponding change stream listens for events. If your program\nneeds to continue executing other logic, such as processing requests or\nresponding to user input, consider creating and listening to your\nchange stream in a separate thread. For update operation change events, change streams only return the modified\nfields by default rather than the entire updated document. You can configure\nyour change stream to also return the most current version of the document\nby calling the  fullDocument()  member method of the  ChangeStreamIterable \nobject with the value  FullDocument.UPDATE_LOOKUP  as follows: The following example uses two separate applications to demonstrate how\nto listen for changes using a change stream: First, run  Watch  to open the change stream on the collection and\ndefine a callback on the change stream using the  forEach()  method.\nWhile  Watch  is running, run  WatchCompanion  to generate change\nevents by performing changes to the collection. Watch : WatchCompanion : If you run the preceding applications in sequence, you should see output from\nthe  Watch  application that is similar to the following. Only the\n insert  and  update  operations are printed, since the aggregation\npipeline filters out the  delete  operation: You should also see output from the  WatchCompanion  application that\nis similar to the following: For additional information on the classes and methods mentioned on this\npage, see the following resources: The first application, named  Watch , opens a change stream\non the  movies  collection in the  sample_mflix  database.\n Watch  uses an aggregation pipeline to filter changes based on\n operationType  so that it only receives insert and update\nevents (deletes are excluded by omission).  Watch  uses a callback\nto receive and print the filtered change events that occur on the\ncollection. The second application, named  WatchCompanion , inserts a\nsingle document into the  movies  collection in the  sample_mflix \ndatabase. Next,  WatchCompanion  updates the document with a new\nfield value. Finally,  WatchCompanion  deletes the document. This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . If you are using the legacy API,\n see our FAQ page \nto learn what changes you need to make to this code example. Change Streams  Server Manual Entry Change Events  Server Manual Entry Aggregation Pipeline  Server Manual Entry Aggregation Stages  Server Manual Entry ChangeStreamIterable  API Documentation MongoCollection.watch()  API Documentation MongoDatabase.watch()  API Documentation MongoClient.watch()  API Documentation",
            "code": [
                {
                    "lang": "java",
                    "value": "ChangeStreamIterable<Document> changeStream = database.watch();"
                },
                {
                    "lang": "java",
                    "value": "List<Bson> pipeline = Arrays.asList(\n                        Aggregates.match(\n                           Filters.lt(\"fullDocument.runtime\", 15)));\nChangeStreamIterable<Document> changeStream = database.watch(pipeline);"
                },
                {
                    "lang": "java",
                    "value": "changeStream.forEach(event -> System.out.println(\"Change observed: \" + event));"
                },
                {
                    "lang": "java",
                    "value": "ChangeStreamIterable<Document> changeStream = database.watch()\n          .fullDocument(FullDocument.UPDATE_LOOKUP);"
                },
                {
                    "lang": null,
                    "value": "Received a change to the collection: ChangeStreamDocument{\n  operationType=OperationType{value='insert'},\n  resumeToken={\"_data\": \"825EC...\"},\n  namespace=sample_mflix.movies,\n  destinationNamespace=null,\n  fullDocument=Document{{_id=5ec3..., test=sample movie document}},\n  documentKey={\"_id\": {\"$oid\": \"5ec3...\"}},\n  clusterTime=Timestamp{...},\n  updateDescription=null,\n  txnNumber=null,\n  lsid=null\n}\nReceived a change to the collection: ChangeStreamDocument{\n  operationType=OperationType{value='update'},\n  resumeToken={\"_data\": \"825EC...\"},\n  namespace=sample_mflix.movies,\n  destinationNamespace=null,\n  fullDocument=Document{{_id=5ec3..., test=sample movie document, field2=sample movie document update}},\n  documentKey={\"_id\": {\"$oid\": \"5ec3...\"}},\n  clusterTime=Timestamp{...},\n  updateDescription=UpdateDescription{removedFields=[], updatedFields={\"field2\": \"sample movie document update\"}},\n  txnNumber=null,\n  lsid=null\n}"
                },
                {
                    "lang": null,
                    "value": "Success! Inserted document id: BsonObjectId{value=5ec3...}\nUpdated 1 document.\nDeleted 1 document."
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.client.ChangeStreamIterable;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.changestream.FullDocument;\n\npublic class Watch {\n    public static void main( String[] args ) {\n\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            List<Bson> pipeline = Arrays.asList(\n                Aggregates.match(\n                        Filters.in(\"operationType\",\n                                Arrays.asList(\"insert\", \"update\"))));\n            ChangeStreamIterable<Document> changeStream = database.watch(pipeline)\n                .fullDocument(FullDocument.UPDATE_LOOKUP);\n            // variables referenced in a lambda must be final; final array gives us a mutable integer\n            final int[] numberOfEvents = {0};\n            changeStream.forEach(event -> {\n            System.out.println(\"Received a change to the collection: \" + event);\n                if (++numberOfEvents[0] >= 2) {\n                  System.exit(0);\n                }\n            });\n        }\n    }\n}\n"
                },
                {
                    "lang": "java",
                    "value": "package usage.examples;\n\nimport java.util.Arrays;\n\nimport org.bson.Document;\nimport org.bson.types.ObjectId;\n\nimport com.mongodb.MongoException;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.result.InsertOneResult;\n\npublic class WatchCompanion {\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n            MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n            MongoCollection<Document> collection = database.getCollection(\"movies\");\n\n            try {\n                InsertOneResult insertResult = collection.insertOne(new Document(\"test\", \"sample movie document\"));\n                System.out.println(\"Success! Inserted document id: \" + insertResult.getInsertedId());\n\n                UpdateResult updateResult = collection.updateOne(new Document(\"test\", \"sample movie document\"), Updates.set(\"field2\", \"sample movie document update\"));\n                System.out.println(\"Updated \" + updateResult.getModifiedCount() + \" document.\");\n\n                DeleteResult deleteResult = collection.deleteOne(new Document(\"field2\", \"sample movie document update\"));\n                System.out.println(\"Deleted \" + deleteResult.getDeletedCount() + \" document.\");\n            } catch (MongoException me) {\n                System.err.println(\"Unable to insert, update, or replace due to an error: \" + me);\n            }\n        }\n    }\n}\n"
                }
            ],
            "preview": "You can keep track of changes to data in MongoDB, such as changes to a\ncollection, database, or deployment, by opening a change stream. A change\nstream allows applications to watch for changes to data and react to them.\nThe change stream returns change event documents when changes occur.\nYou can open a change stream by calling the watch() method on\na MongoCollection, MongoDatabase, or MongoClient object:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/enterprise-auth",
            "title": "Enterprise Authentication Mechanisms",
            "headings": [
                "Overview",
                "Specify an Authentication Mechanism",
                "Mechanisms",
                "Kerberos (GSSAPI)",
                "LDAP (PLAIN)"
            ],
            "paragraphs": "In this guide, you can learn how to authenticate with MongoDB using each\n authentication mechanism  available exclusively in the MongoDB Enterprise\nEdition. You can use the following mechanisms with the latest version of MongoDB\nEnterprise Edition: To authenticate using another mechanism, see the\n Authentication Mechanisms guide . For more\ninformation on establishing a connection to your MongoDB cluster, read our\n Connection Guide . Kerberos (GSSAPI) LDAP (PLAIN) You can specify your authentication mechanism and credentials when connecting\nto MongoDB using either of the following: A  connection string  (also known as a  connection uri ) specifies how to\nconnect and authenticate to your MongoDB cluster. To authenticate using a connection string, include your settings in your\nconnection string and pass it to the  MongoClients.create()  method to\ninstantiate your  MongoClient . Select the  Connection String \ntab to see the syntax for authenticating using a  connection string . Alternatively, you can use the  MongoCredential  class to specify your\nauthentication details. The  MongoCredential  class contains static factory\nmethods that construct instances containing your authentication mechanism and\ncredentials. When you use the  MongoCredential  helper class, you need\nto use the  MongoClientSettings.Builder  class to configure your\nconnection settings when constructing your  MongoClient .  Select the\n MongoCredential  tab to see the syntax for authenticating using a\n MongoCredential . For more information on these classes and methods, refer to the following API\ndocumentation: A connection string A  MongoCredential  factory method MongoClients.create() MongoClient MongoClientSettings.Builder MongoCredential The Generic Security Services API ( GSSAPI ) authentication mechanism\nallows the user to authenticate to a Kerberos service using the user's\nprincipal name. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: In order to acquire a\n Kerberos ticket ,\nthe GSSAPI Java libraries require you to specify the realm and Key Distribution\nCenter (KDC) system properties. See the sample settings in the following example: You may need to specify one or more of the following additional\n MongoCredential  mechanism properties depending on your Kerberos setup: By default, the Java driver caches Kerberos tickets by  MongoClient  instance.\nIf your deployment needs to frequently create and destroy  MongoClient  instances,\nyou can change the default Kerberos ticket caching behavior to cache by process\nto improve performance. The method refers to the  GSSAPI  authentication mechanism instead\nof  Kerberos  because the driver authenticates using the\n GSSAPI RFC-4652   SASL\nmechanism. username  - your URL-encoded principal name, e.g. \"username%40REALM.ME\" hostname  - network address of your MongoDB deployment, accessible by your client port  - port number of your MongoDB deployment To specify the GSSAPI authentication mechanism using a connection\nstring: Your code to instantiate a  MongoClient  should look something like this: Assign the  authMechanism  URL parameter to the value  GSSAPI ( optional ) Assign the  authSource  URL parameter to the value  $external If you specify the  GSSAPI  mechanism, you cannot assign\n authSource  to any value other than  $external . To specify the GSSAPI authentication mechanism using the\n MongoCredential  class, use the  createGSSAPICredential() \nmethod. Your code to instantiate a  MongoClient  should look something like this: SERVICE_NAME CANONICALIZE_HOST_NAME JAVA_SUBJECT JAVA_SASL_CLIENT_PROPERTIES JAVA_SUBJECT_PROVIDER To specify one of the GSSAPI additional properties, include it in the\nconnection string as a URL parameter using the format:\n <PROPERTY_NAME>:<value> . Your code to instantiate a  MongoClient  using GSSAPI and additional\nproperties might look something like this: You can only specify the following GSSAPI properties using the\n MongoCredential : Select the  MongoCredential  tab to see how to specify\nthem. JAVA_SUBJECT JAVA_SASL_CLIENT_PROPERTIES JAVA_SUBJECT_PROVIDER To specify one of the GSSAPI additional properties, call the\n withMechanismProperty()  method on your  MongoCredential \ninstance and pass the property name and value as parameters. Use the\nproperty name constants defined in the  MongoCredential  class: Select the  SERVICE_NAME_KEY  or  JAVA_SUBJECT_KEY  tab to\nsee sample code to instantiate a  MongoCredential  that uses GSSAPI and\nthe selected property: SERVICE_NAME_KEY CANONICALIZE_HOST_NAME_KEY JAVA_SUBJECT_KEY JAVA_SASL_CLIENT_PROPERTIES_KEY JAVA_SUBJECT_PROVIDER_KEY To cache Kerberos tickets by process, you must use the  MongoCredential  authentication\nmechanism, as the connection string authentication mechanism does not support the  JAVA_SUBJECT_PROVIDER \nmechanism property. If you would like to cache Kerberos tickets by process, select the  MongoCredential \ntab to learn how to accomplish this. To cache Kerberos tickets by process, you must specify the  JAVA_SUBJECT_PROVIDER \nmechanism property and provide a\n KerberosSubjectProvider \nin your  MongoCredential  instance. The code to configure the Java driver to cache Kerberos tickets\nby process should resemble the following: On Windows, Oracle\u2019s JRE uses  LSA \nrather than  SSPI \nin its implementation of GSSAPI which limits interoperability with\nWindows Active Directory and implementations of single sign-on. See the\nfollowing articles for more information: JDK-8054026 JDK-6722928 SO 23427343 Available in MongoDB Enterprise Edition 3.4 and later. You can authenticate to a Lightweight Directory Access Protocol (LDAP)\nserver using your directory server username and password. You can specify this authentication mechanism by setting the  authMechanism \nparameter to  PLAIN  and including your LDAP username and password in the\n connection string . The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: The authentication mechanism is named  PLAIN  instead of  LDAP  since it\nauthenticates using the  PLAIN Simple Authentication and Security Layer\n(SASL) defined in RFC-4616 . username  - your LDAP username password  - your LDAP user's password hostname  - network address of your MongoDB deployment, accessible by your client port  - port number of your MongoDB deployment To specify the LDAP (PLAIN) authentication mechanism using a connection\nstring: Your code to instantiate a  MongoClient  should look something like this: Assign the  authMechanism  URL parameter to the value  PLAIN ( optional ) Assign the  authSource  URL parameter to the value  $external If you specify the  PLAIN  mechanism, you cannot assign\n authSource  to any value other than  $external . To specify the LDAP (PLAIN) authentication mechanism using the\n MongoCredential  class, use the  createPlainCredential() \nmethod. Your code to instantiate a  MongoClient  should look something like this:",
            "code": [
                {
                    "lang": "none",
                    "value": "java.security.krb5.realm=MYREALM.ME\njava.security.krb5.kdc=mykdc.myrealm.me"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"<username>@<hostname>:<port>/?authSource=$external&authMechanism=GSSAPI\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createGSSAPICredential(<username>);\n\nMongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n                builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\", <port>))))\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"<username>@<hostname>:<port>/?authSource=$external&authMechanism=GSSAPI&authMechanismProperties=SERVICE_NAME:myService\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createGSSAPICredential(<username>);\ncredential = credential.withMechanismProperty(MongoCredential.SERVICE_NAME_KEY, \"myService\");"
                },
                {
                    "lang": "java",
                    "value": "LoginContext loginContext = new LoginContext(<LoginModule implementation from JAAS config>);\nloginContext.login();\nSubject subject = loginContext.getSubject();\n\nMongoCredential credential = MongoCredential.createGSSAPICredential(<username>);\ncredential = credential.withMechanismProperty(MongoCredential.JAVA_SUBJECT_KEY, subject);"
                },
                {
                    "lang": "java",
                    "value": "/* all MongoClient instances sharing this instance of KerberosSubjectProvider\nwill share a Kerberos ticket cache */\nString myLoginContext = \"myContext\";\nMongoCredential credential = MongoCredential.createGSSAPICredential(<username>);\n/* login context defaults to \"com.sun.security.jgss.krb5.initiate\"\nif unspecified in KerberosSubjectProvider */\ncredential = credential.withMechanismProperty(MongoCredential.JAVA_SUBJECT_PROVIDER_KEY,\n                                              new KerberosSubjectProvider(myLoginContext));"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"<username>:<password>@<hostname>:<port>/?authSource=$external&authMechanism=PLAIN\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createPlainCredential(<username>, \"$external\", <password>);\n\nMongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n                builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\", <port>))))\n        .credential(credential)\n        .build());"
                }
            ],
            "preview": "In this guide, you can learn how to authenticate with MongoDB using each\nauthentication mechanism available exclusively in the MongoDB Enterprise\nEdition.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud",
            "title": "CRUD Operations",
            "headings": [],
            "paragraphs": "CRUD (Create, Read, Update, Delete) operations enable you to work with\ndata stored in MongoDB. Some operations combine aspects of read and write operations. See our\nguide on  compound operations \nto learn more about these hybrid methods. Read Operations  find and return\ndocuments stored in your database. Write Operations  insert, modify,\nor delete documents in your database.",
            "code": [],
            "preview": "CRUD (Create, Read, Update, Delete) operations enable you to work with\ndata stored in MongoDB.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/databases-collections",
            "title": "Databases and Collections",
            "headings": [
                "Overview",
                "Access a Database",
                "Access a Collection",
                "Create a Collection",
                "Document Validation",
                "Get a List of Collections",
                "Drop a Collection",
                "Specify Read Preferences, Read Concerns, and  Write Concerns"
            ],
            "paragraphs": "In this guide, you can learn how to use MongoDB databases and\ncollections with the MongoDB Java driver. MongoDB organizes data into a hierarchy of the following levels: Databases are the top level of data organization in a MongoDB instance.\nDatabases are organized into collections which contain  documents .\nDocuments\ncontain literal data such as strings, numbers, and dates as well as\nother (embedded) documents. For more information on document field\ntypes and structure, see the server documentation for\n documents . Databases Collections Documents Use the  getDatabase()  method of\na  MongoClient  instance to access a  MongoDatabase  in a MongoDB\ninstance. The following example accesses a database named \"testDatabase\": Use the  getCollection() \nmethod of a  MongoDatabase  instance to access a\n MongoCollection  in a database of your connected MongoDB instance. The following example accesses a collection named \"testCollection\" from\na  MongoDatabase : If the provided collection name does not already exist in the database,\nMongoDB implicitly creates the collection when you first insert data\ninto that collection. Use the  createCollection() \nmethod of a  MongoDatabase  instance to create a collection\nin a database of your connected MongoDB instance. The following example creates a collection called \"exampleCollection\": You can specify collection options like maximum size and document\nvalidation rules using the  CreateCollectionOptions \nclass. The  createCollection()  method accepts an instance of\n CreateCollectionOptions  as an optional second parameter. Document validation  provides the ability to validate documents\nagainst a series of filters during writes to a collection. You can\nspecify these filters using the  ValidationOptions \nclass, which accepts a series of  Filters \nthat specifies the validation rules and expressions: For more information, see the server documentation for  document\nvalidation . You can query for a list of collections in a database using the\n MongoDatabase.listCollectionNames()  method: You can remove a collection from the database using the\n MongoCollection.drop()  method: Dropping a collection from your database also permanently deletes all\ndocuments within that collection and all indexes on that collection.\nOnly drop collections that contain data that is no longer needed. Read preferences ,  read concerns , and  write concerns  control\nhow the driver routes read operations and waits for acknowledgment for\nread and write operations when connected to a MongoDB replica set.\nRead preferences and read concerns apply to all read operations;\nwrite concerns apply to all write operations. MongoDatabase  instances inherit their write concern, read concern,\nand write preference settings from the  MongoClient  used to create\nthem.  MongoCollection  instances inherit their write concern, read concern,\nand write preference settings from the  MongoDatabase  used to create\nthem. However, you can use the following methods to obtain an instance\nof a  MongoDatabase  or  MongoCollection  with a read preference,\nread concern, or write concern that differs from the setting they would\nnormally inherit: For more information, see the server documentation on\n read preferences ,\n read concerns , and\n write concerns . MongoDatabase.withReadConcern() MongoDatabase.withReadPreference() MongoDatabase.withWriteConcern() MongoCollection.withReadConcern() MongoCollection.withReadPreference() MongoCollection.withWriteConcern() The  withReadConcern() ,  withReadPreference() , and\n withWriteConcern  methods create a new instance of a\n MongoDatabase  or  MongoCollection  with the desired preference\nor concern. The  MongoDatabase  or  MongoCollection  upon which\nthe method is called retains its original preference and concern\nsettings.",
            "code": [
                {
                    "lang": "java",
                    "value": "MongoDatabase database = mongoClient.getDatabase(\"testDatabase\");"
                },
                {
                    "lang": "java",
                    "value": "MongoDatabase database = mongoClient.getDatabase(\"testDatabase\");\nMongoCollection<Document> collection = database.getCollection(\"testCollection\");"
                },
                {
                    "lang": "java",
                    "value": "database.createCollection(\"exampleCollection\");"
                },
                {
                    "lang": "java",
                    "value": "ValidationOptions collOptions = new ValidationOptions().validator(\n    Filters.or(Filters.exists(\"commander\"), Filters.exists(\"first officer\")));\ndatabase.createCollection(\"ships\",\n    new CreateCollectionOptions().validationOptions(collOptions));"
                },
                {
                    "lang": "java",
                    "value": "for (String name : database.listCollectionNames()) {\n    System.out.println(name);\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<Document> collection = database.getCollection(\"bass\");\ncollection.drop();"
                }
            ],
            "preview": "In this guide, you can learn how to use MongoDB databases and\ncollections with the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/auth",
            "title": "Authentication Mechanisms",
            "headings": [
                "Overview",
                "Specify an Authentication Mechanism",
                "Mechanisms",
                "Default",
                "SCRAM-SHA-256",
                "SCRAM-SHA-1",
                "MONGODB-CR",
                "MONGODB-AWS",
                "Refresh Credentials",
                "X.509"
            ],
            "paragraphs": "In this guide, you can learn how to authenticate with MongoDB using each\n authentication mechanism  available in the MongoDB Community Edition.\nAuthentication mechanisms are processes by which the driver and MongoDB deployment\nconfirm identity and establish trust to ensure security. The mechanisms that you can use with the latest version of MongoDB Community\nEdition are as follows: To authenticate using  Kerberos  or  LDAP , see the\n Enterprise Authentication Mechanisms guide .\nFor more information on establishing a connection to your MongoDB cluster,\nread our  Connection Guide . Default SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-CR MONGODB-AWS X.509 You can specify your authentication mechanism and credentials when connecting\nto MongoDB using either of the following: A  connection string  (also known as a  connection uri ) specifies how to\nconnect and authenticate to your MongoDB cluster. To authenticate using a connection string, include your settings in your\nconnection string and pass it to the  MongoClients.create()  method to\ninstantiate your  MongoClient . Select the  Connection String \ntab to see the syntax for authenticating using a  connection string . Alternatively, you can use the  MongoCredential  class to specify your\nauthentication details. The  MongoCredential  class contains static factory\nmethods that construct instances containing your authentication mechanism and\ncredentials. When you use the  MongoCredential  helper class, you need\nto use the  MongoClientSettings.Builder  class to configure your\nconnection settings when constructing your  MongoClient .  Select the\n MongoCredential  tab to see the syntax for authenticating using a\n MongoCredential . For more information on these classes and methods, refer to the following API\ndocumentation: A connection string A  MongoCredential  factory method MongoClients.create() MongoClient MongoClientSettings.Builder MongoCredential The default authentication mechanism setting uses one of the following\nauthentication mechanisms depending on what your version of MongoDB Server\nsupports: Server versions 3.6 and earlier use  MONGODB-CR  as the default\nmechanism. Newer versions of MongoDB Server use one of the mechanisms for\nwhich they advertise support. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: For more information on the challenge-response (CR) and salted\nchallenge-response authentication mechanisms (SCRAM) that MongoDB supports,\nsee the  SCRAM  section of the MongoDB Server\nmanual. SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-CR username  - your MongoDB username password  - your MongoDB user's password hostname  - network address of your MongoDB deployment, accessible by your client port  - port number of your MongoDB deployment authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the default authentication mechanism using a connection\nstring, omit the mechanism. Your code to instantiate a  MongoClient \nshould look something like this: To specify the default authentication mechanism using the\n MongoCredential  class, use the  createCredential()  method. Your\ncode to instantiate a  MongoClient  should look something like this: SCRAM-SHA-256  is a salted challenge-response authentication mechanism\n(SCRAM) that uses your username and password, encrypted with the  SHA-256 \nalgorithm, to authenticate your user. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: SCRAM-SHA-256  is the default authentication method for MongoDB starting\nin MongoDB 4.0. username  - your MongoDB username. password  - your MongoDB user's password. hostname  - network address of your MongoDB deployment, accessible by your client. port  - port number of your MongoDB deployment. authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the  SCRAM-SHA-256  authentication mechanism using a\nconnection string, assign the  authMechanism  parameter the value\n SCRAM-SHA-256  in your connection string. Your code to instantiate\na  MongoClient  should look something like this: To specify the default authentication mechanism using the\n MongoCredential  class, use the\n createScramSha256Credential() \nmethod. Your code to instantiate a  MongoClient  should look something like this: SCRAM-SHA-1  is a salted challenge-response mechanism (SCRAM) that uses your\nusername and password, encrypted with the  SHA-1  algorithm, to authenticate\nyour user. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: SCRAM-SHA-1  is the default authentication method for MongoDB versions\n3.0, 3.2, 3.4, and 3.6. username  - your MongoDB username. password  - your MongoDB user's password. hostname  - network address of your MongoDB deployment, accessible by your client. port  - port number of your MongoDB deployment. authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the  SCRAM-SHA-1  authentication mechanism using a\nconnection string, assign the  authMechanism  parameter the value\n SCRAM-SHA-1  in your connection string. Your code to instantiate\na  MongoClient  should look something like this: To specify the default authentication mechanism using the\n MongoCredential  class, use the\n createScramSha1Credential() \nmethod. Your code to instantiate a  MongoClient  should look something like this: MONGODB-CR  is a challenge-response authentication mechanism that uses your\nusername and password to authenticate your user. This authentication\nmechanism was deprecated starting in MongoDB 3.6 and is no longer\nsupported as of MongoDB 4.0. You cannot specify this method explicitly; refer to the fallback provided\nby the  default authentication mechanism  to\nconnect using  MONGODB-CR . The  MONGODB-AWS  authentication mechanism uses your Amazon Web Services\nIdentity and Access Management (AWS IAM) credentials to authenticate your\nuser. You can store your AWS credentials as environment variables, or insert\nthem inline like the examples below. The driver checks for your credentials\nin the following order: The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: The MONGODB-AWS authentication mechanism is available in MongoDB\nAtlas. Supplied values in a  MongoCredential  object or the provided connection string. Your environment variables. ( AWS_ACCESS_KEY_ID ,  AWS_SECRET_ACCESS_KEY ,\nand optionally  AWS_SESSION_TOKEN ) The AWS EC2 endpoint specified in the  AWS_CONTAINER_CREDENTIALS_RELATIVE_URI \nenvironment variable. The default AWS EC2 endpoint. For more information, see  IAM Roles for Tasks awsKeyId  - value of your  AWS_ACCESS_KEY_ID . awsSecretKey  - value of your  AWS_SECRET_ACCESS_KEY . atlasUri  - network address of your MongoDB Atlas instance. awsSessionToken  - value of your  AWS_SESSION_TOKEN .  (optional) Make sure to URL-encode your credentials to prevent backslash or other\ncharacters from causing parsing errors. The following code example\nshows you how to URL-encode a sample string, represented by the placeholder\n fieldValue : To specify the  MONGODB-AWS  authentication mechanism using a\nconnection string, assign the  authMechanism  parameter the value\n \"MONGODB-AWS\"  in your connection string. Your code to instantiate\na  MongoClient  should look something like this: If you need to specify an AWS session token, include it in the\n authMechanismProperties  parameter as follows using the format\n AWS_SESSION_TOKEN:<awsSessionToken> . Your code to instantiate\na  MongoClient  with a session token should look something like this: To specify the  MONGODB-AWS  authentication mechanism using the\n MongoCredential  class, use the\n createAwsCredential() \nmethod. Your code to instantiate a  MongoClient  should look something like this: If you need to specify an AWS session token, you can add it using\none of the following choices: Specify your AWS session token in a connection string. If you prefer to pass the AWS session token in the connection string\nalongside your  MongoCredential , specify your authentication mechanism\nin the  authMechanism  parameter and your session token in the\n authMechanismProperties  parameter. Then, add it to your\n MongoClientSettings  by calling the\n applyConnectionString() \nmethod as follows: Specify your AWS session token in a MongoCredential. You can include your AWS session token in your  MongoCredential \ninstance by specifying it in a call to the\n withMechanismProperty() \nmethod as shown below: Specify your AWS session token in an environment variable. In your client execution environment, set an environment variable\ncalled  AWS_SESSION_TOKEN  and assign your token to it. The value is\nautomatically picked up by your  MongoClient  when you specify the\n MONGODB-AWS  authentication mechanism. The driver supports refreshing credentials for cases such as assuming roles\nor using  Elastic Kubernetes Service . If you must provide AWS IAM credentials in a connection string, refer to\na previous release of the  MONGODB-AWS driver documentation . The  X.509  authentication mechanism uses\n TLS  with X.509 certificates to\nauthenticate your user, identified by the relative distinguished names\n(RDNs) of your client certificate. When you specify the  X.509 \nauthentication mechanism, the server authenticates the connection using\nthe subject name of the client certificate. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: For additional information on configuring your application to use\ncertificates as well as TLS/SSL options, see our\n TLS/SSL guide . hostname  - network address of your MongoDB deployment, accessible by your client. port  - port number of your MongoDB deployment. authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the  X.509  authentication mechanism using a connection\nstring, assign the  authMechanism  parameter the value  MONGODB-X509 \nand enable TLS by assigning the  tls \nparameter a  true  value. Your code to instantiate a  MongoClient \nshould look something like this: To specify the  X.509  authentication mechanism using the\n MongoCredential  class, use the\n createMongoX509Credential() \nmethod. Also, enable TLS by calling the\n applyToSslSettings() \nmethod and setting the  enabled  property to  true  in the\n SslSettings.Builder \nblock. Your code to instantiate a  MongoClient  should look something like this:",
            "code": [
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb://<username>:<password>@<hostname>:<port>/?authSource=<authenticationDb>\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createCredential(\"<username>\", \"<authenticationDb>\", \"<password>\");\n\nMongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n                builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\", <port>))))\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb://<username>:<password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=SCRAM-SHA-256\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createScramSha256Credential(\"<username>\", \"<authenticationDb>\", \"<password>\");\n\nMongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n                builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\", <port>))))\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb://<username>:<password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=SCRAM-SHA-1\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createScramSha1Credential(\"<username>\", \"<authenticationDb>\", \"<password>\");\n\nMongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n                builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\", <port>))))\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "String encodedField = java.net.URLEncoder.encode(\"<fieldValue>\".toString(), \"ISO-8859-1\");"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb://<awsKeyId>:<awsSecretKey>@<atlasUri>?authMechanism=MONGODB-AWS\");"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb://<awsKeyId>:<awsSecretKey>@<atlasUri>?authMechanism=MONGODB-AWS&authMechanismProperties=AWS_SESSION_TOKEN:<awsSessionToken>\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray());\n\nMongoClient mongoClient = MongoClients.create(\n        MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n        builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\"))))\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray());\nConnectionString connectionString = new ConnectionString(\"mongodb://<atlasUri>/?authMechanism=MONGODB-AWS&authMechanismProperties=AWS_SESSION_TOKEN:<awsSessionToken>\");\n\nMongoClient mongoClient = MongoClients.create(\n        MongoClientSettings.builder()\n        .applyConnectionString(connectionString)\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray()).withMechanismProperty(\"AWS_SESSION_TOKEN\",  \"<awsSessionToken>\");\nConnectionString connectionString = new ConnectionString(\"mongodb://<atlasUri>/?authMechanism=MONGODB-AWS\");\n\nMongoClient mongoClient = MongoClients.create(\n        MongoClientSettings.builder()\n        .applyConnectionString(connectionString)\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "Supplier<AwsCredential> awsFreshCredentialSupplier = () -> {\n    // Add your code to fetch new credentials, such as assuming a role using the AWS SDK.\n    \n    // Ensure you return the temporary credentials.\n    return new AwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\", \"<awsSessionToken>\");\n};\n\nMongoCredential credential = MongoCredential.createAwsCredential(null, null)\n        .withMechanismProperty(MongoCredential.AWS_CREDENTIAL_PROVIDER_KEY, awsFreshCredentialSupplier);\nMongoClient mongoClient = MongoClients.create(\n        MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n        builder.hosts(Collections.singletonList(new ServerAddress(\"<hostname>\", 27017))))\n        .credential(credential)\n        .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb://<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=MONGODB-X509&tls=true\");"
                },
                {
                    "lang": "java",
                    "value": "MongoCredential credential = MongoCredential.createMongoX509Credential();\n\nMongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n            builder.hosts(Arrays.asList(new ServerAddress(\"<hostname>\", <port>))))\n        .applyToSslSettings(builder ->\n            builder.enabled(true);\n            )\n        .credential(credential)\n        .build());"
                }
            ],
            "preview": "In this guide, you can learn how to authenticate with MongoDB using each\nauthentication mechanism available in the MongoDB Community Edition.\nAuthentication mechanisms are processes by which the driver and MongoDB deployment\nconfirm identity and establish trust to ensure security.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/monitoring",
            "title": "Monitoring",
            "headings": [
                "Overview",
                "Monitor Events",
                "Command Events",
                "Example",
                "Server Discovery and Monitoring Events",
                "Example",
                "Connection Pool Events",
                "Example",
                "Monitor Connection Pool Events with JMX",
                "JMX Support",
                "JMX and JConsole Example",
                "Include the Driver in Your Distributed Tracing System"
            ],
            "paragraphs": "In this guide, you can learn how to set up and configure  monitoring  in the\nMongoDB Java driver. Monitoring is the process of getting information about the activities a running\nprogram performs for use in an application or an application performance\nmanagement library. Monitoring the MongoDB Java driver lets you understand the\ndriver's resource usage and performance, and can help you make informed\ndecisions when designing and debugging your application. In this guide you will learn how to perform these tasks: This guide shows how to use information about the activity of the driver in code.\nIf you would like to learn how to record events in the driver,\nconsider reading our  guide on logging . Monitor different types of events in the MongoDB Java Driver Monitor connection pool events with Java Management Extensions (JMX) and JConsole To monitor an  event , you must register a  listener  on your  MongoClient \ninstance. An event is any action that happens in a running program. The driver includes functionality\nfor listening to a subset of the events that occur when the driver is running. A listener is a class that performs some action when certain events occur.\nA listener's API defines the events it can respond to. Each method of a listener class represents a response to a certain event. Each\nmethod receives one argument: an object representing the event the method\nresponds to. The MongoDB Java driver organizes the events it defines into three categories: The following sections show how to monitor each event category. For a full list of the events you can monitor,\n see the event package of the MongoDB Java Driver . Command Events Server Discovery and Monitoring Events Connection Pool Events A command event is an event related to a MongoDB database command. Some\nexamples of database commands that produce command events are  find ,\n insert ,  delete , and  count . To monitor command events, write a class that implements the\n CommandListener  interface and register an instance of that class with your\n MongoClient  instance. For more information on MongoDB database commands, see the\n MongoDB manual entry on database commands . The driver does not publish events for commands it calls internally. This\nincludes database commands the driver uses to monitor your cluster and\ncommands related to connection establishment (such as the initial  hello \ncommand). As a security measure, the driver redacts the contents of some command events. This\nprotects the sensitive information contained in these command events. For a\nfull list of redacted command events, see the\n MongoDB command logging and monitoring specification . This example shows how to make a counter for database commands. The counter\nkeeps track of the number of times the driver successfully executes each database\ncommand, and prints this information every time a database command finishes. To make a counter, do the following: The following code defines the  CommandCounter  class which implements the\n CommandListener  interface: The following code adds an instance of the  CommandCounter  class to a\n MongoClientSettings  object, and configures a  MongoClient  instance with the\n MongoClientSettings  object. The code then runs some database commands to test the\ncounter. The preceding code snippet should produce output that looks like this: For more information on the classes and methods mentioned in this section, see\nthe following API Documentation: Make a class with counter functionality that implements the  CommandListener  interface. Add an instance of the new class that implements  CommandListener  to a  MongoClientSettings  object. Configure a  MongoClient  instance with the  MongoClientSettings  object. CommandListener MongoClientSettings MongoClient CommandStartedEvent CommandSucceededEvent CommandFailedEvent A server discovery and monitoring (SDAM) event is an event related to a change\nin the state of the MongoDB instance or cluster you have connected the driver to. The driver defines nine SDAM events. The driver divides these nine events\nbetween three separate listener interfaces which each listen for three of the\nnine events. Here are the three interfaces and the events they listen for: To monitor a type of SDAM event, write a class that\nimplements one of the three preceding interfaces and register an instance of that\nclass with your  MongoClient  instance. For a detailed description of each SDAM event in the driver, see the\n MongoDB SDAM Logging and Monitoring Specification . ClusterListener :  topology \nrelated events ServerListener : events related to  mongod  or  mongos  processes ServerMonitorListener : heartbeat related events This example shows how to make a listener class that prints a message that lets\nyou know if the driver can write to your MongoDB instance. The following code defines the  IsWritable  class which implements the\n ClusterListener  interface. The following code adds an instance of the  IsWritable  class to a\n MongoClient  object. The code then runs a find operation to test the\n IsWritable  class. The preceding code snippet should produce output that looks like this: For more information on the classes and methods mentioned in this section, see\nthe following API Documentation: ClusterListener ServerListener ServerMonitorListener MongoClientSettings MongoClient ClusterDescriptionChangedEvent A connection pool event is an event related to a  connection pool  held by the driver.\nA connection pool is a set of open TCP connections your driver maintains with\na MongoDB instance. Connection pools help reduce the number of network handshakes\nyour application needs to perform with a MongoDB instance, and can help your\napplication run faster. To monitor connection pool events, write a class that implements the\n ConnectionPoolListener  interface and register an instance of that class with your\n MongoClient  instance. This example shows how to make a listener class that prints a message each time\nyou check out a connection from your connection pool. The following code defines the  ConnectionPoolLibrarian  class which implements the\n ConnectionPoolListener  interface. The following code adds an instance of the  ConnectionPoolLibrarian  class to a\n MongoClient  object. The code then runs a database command to test the\nlibrarian. The preceding code snippet should produce output that looks like this: For more information on the classes and methods mentioned in this section, see\nthe following API Documentation: ConnectionPoolListener MongoClientSettings MongoClient ConnectionCheckedOutEvent ConnectionCheckOutFailedEvent You can monitor connection pool events using  Java Management Extensions (JMX) .\nJMX provides tools to monitor applications and devices. For more information on JMX, see\n the official Oracle JMX documentation . To enable JMX connection pool monitoring, add an instance of the\n JMXConnectionPoolListener  class to your  MongoClient  object. The  JMXConnectionPoolListener  class performs the following actions: MXBeans registered on the platform MBean server have the following properties: All MXBean instances created by the driver are under the domain\n \"org.mongodb.driver\" . For more information on the topics discussed in this subsection, see the\nfollowing resources from Oracle: Creates MXBean instances for each  mongod  or  mongos  process the driver\nmaintains a connection pool with. Registers these MXBean instances with the platform MBean server. Property Description clusterId A client-generated unique identifier. This identifier ensures that\neach MXBean the driver makes has a unique name when an application has\nmultiple  MongoClient  instances connected to the same MongoDB deployment. host The hostname of the machine running the  mongod  or  mongos  process. port The port on which the  mongod  or  mongos  process is listening. minSize The minimum size of the connection pool, including idle and in-use connections. maxSize The maximum size of the connection pool, including idle and in-use connections. size The current size of the connection pool, including idle and in-use connections. checkedOutCount The current count of connections that are in use. Platform MBean Server Reference Documentation MXBean Documentation MBean Documentation This example shows how you can monitor the driver's connection pools using JMX\nand  JConsole . JConsole is a JMX compliant GUI monitoring tool that comes with\nthe Java Platform. The following code snippet adds a  JMXConnectionPoolListener  to a\n MongoClient  instance. The code then pauses execution so you can\nnavigate to JConsole and inspect your connection pools. The preceding code snippet should produce output that looks like this: Once you have started your server, open JConsole in your terminal using the\nfollowing command: Once JConsole is open, perform the following actions in the GUI: When you no longer want to inspect your connection pools in JConsole, do the\nfollowing: For more information on JMX and JConsole, see the following resources from\nOracle: For more information on the  JMXConnectionPoolListener  class, see\nthe API Documentation for\n JMXConnectionPoolListener . The descriptions of JMX and JConsole in this example are illustrative\nrather than a source of truth. For guaranteed up to date information, consult\nthe following official Oracle resources: JConsole documentation . JMX documentation Select the Java process running the preceding example code. Press  Insecure Connection  in the warning dialog box. Click on the  MBeans  tab. Inspect your connection pool events under the  \"org.mongodb.driver\"  domain. Exit JConsole by closing the JConsole window Stop the Java program running the preceding code snippet JConsole Documentation . Monitoring and Management Guide If you use a  distributed tracing system , you can include event data from the\ndriver. A distributed tracing system is an application that\ntracks requests as they propagate throughout different services in a\nservice-oriented architecture. If you use the driver in a  Spring Cloud \napplication, use\n Spring Cloud Sleuth  to\ninclude MongoDB event data in the\n Zipkin  distributed tracing system. If you do not use Spring Cloud or need to include driver event data in a distributed\ntracing system other than Zipkin, you must write a command event listener that\nmanages  spans \nfor your desired distributed tracing system. To see an implementation of such a\nlistener, see the\n TraceMongoCommandListener \nclass in the Spring Cloud Sleuth source code. To learn more about Spring Cloud Sleuth, see\n Getting Started \nin the Spring Cloud Sleuth documentation. To view a detailed description of a distributed tracing system, see\n Dapper  from Google Research.",
            "code": [
                {
                    "lang": "none",
                    "value": "{find=1}\n{find=2}\n{find=2, endSessions=1}"
                },
                {
                    "lang": "java",
                    "value": "class CommandCounter implements CommandListener {\n\n    private Map<String, Integer> commands = new HashMap<String, Integer>();\n\n    @Override\n    public synchronized void commandSucceeded(final CommandSucceededEvent event) {\n        String commandName = event.getCommandName();\n        int count = commands.containsKey(commandName) ? commands.get(commandName) : 0;\n        commands.put(commandName, count + 1);\n        System.out.println(commands.toString());\n    }\n\n    @Override\n    public void commandFailed(final CommandFailedEvent event) {\n        System.out.println(String.format(\"Failed execution of command '%s' with id %s\",\n                event.getCommandName(),\n                event.getRequestId()));\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoClientSettings settings =\n        MongoClientSettings.builder()\n                .applyConnectionString(URI)\n                .addCommandListener(new CommandCounter())\n                .build();\nMongoClient mongoClient = MongoClients.create(settings);\nMongoDatabase database = mongoClient.getDatabase(DATABASE);\nMongoCollection<Document> collection = database.getCollection(COLLECTION);\n// Run some commands to test the timer\ncollection.find().first();\ncollection.find().first();\nmongoClient.close();"
                },
                {
                    "lang": "none",
                    "value": "Able to write to server"
                },
                {
                    "lang": "java",
                    "value": "class IsWriteable implements ClusterListener {\n\n    private boolean isWritable;\n\n    @Override\n    public synchronized void clusterDescriptionChanged(final ClusterDescriptionChangedEvent event) {\n        if (!isWritable) {\n            if (event.getNewDescription().hasWritableServer()) {\n                isWritable = true;\n                System.out.println(\"Able to write to server\");\n            }\n        } else {\n            if (!event.getNewDescription().hasWritableServer()) {\n                isWritable = false;\n                System.out.println(\"Unable to write to server\");\n            }\n        }\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "IsWriteable clusterListener = new IsWriteable();\nMongoClientSettings settings =\n        MongoClientSettings.builder()\n                .applyConnectionString(URI)\n                .applyToClusterSettings(builder ->\n                        builder.addClusterListener(clusterListener))\n                .build();\nMongoClient mongoClient = MongoClients.create(settings);\nMongoDatabase database = mongoClient.getDatabase(DATABASE);\nMongoCollection<Document> collection = database.getCollection(COLLECTION);\n// Run a command to trigger a ClusterDescriptionChangedEvent event\ncollection.find().first();"
                },
                {
                    "lang": "none",
                    "value": "Let me get you the connection with id 21..."
                },
                {
                    "lang": "java",
                    "value": "class ConnectionPoolLibrarian implements ConnectionPoolListener {\n\n    @Override\n    public void connectionCheckedOut(final ConnectionCheckedOutEvent event) {\n        System.out.println(String.format(\"Let me get you the connection with id %s...\",\n                event.getConnectionId().getLocalValue()));\n    }\n\n    @Override\n    public void connectionCheckOutFailed(final ConnectionCheckOutFailedEvent event) {\n        System.out.println(\"Something went wrong! Failed to checkout connection.\");\n    }\n\n}"
                },
                {
                    "lang": "java",
                    "value": "ConnectionPoolLibrarian cpListener = new ConnectionPoolLibrarian();\nMongoClientSettings settings =\n        MongoClientSettings.builder()\n                .applyConnectionString(URI)\n                .applyToConnectionPoolSettings(builder ->\n                        builder.addConnectionPoolListener(cpListener))\n                .build();\nMongoClient mongoClient = MongoClients.create(settings);\nMongoDatabase database = mongoClient.getDatabase(DATABASE);\nMongoCollection<Document> collection = database.getCollection(COLLECTION);\n// Run a command to trigger connection pool events\ncollection.find().first();"
                },
                {
                    "lang": "none",
                    "value": "Navigate to JConsole to see your connection pools..."
                },
                {
                    "lang": "shell",
                    "value": "jconsole"
                },
                {
                    "lang": "java",
                    "value": "JMXConnectionPoolListener connectionPoolListener = new JMXConnectionPoolListener();\n\nMongoClientSettings settings =\n        MongoClientSettings.builder()\n                .applyConnectionString(URI)\n                .applyToConnectionPoolSettings(builder -> builder.addConnectionPoolListener(connectionPoolListener))\n                .build();\n\n// Creates a MongoClient instance that enables connection pool event monitoring with the JMX tool\nMongoClient mongoClient = MongoClients.create(settings);\n\ntry {\n    System.out.println(\"Navigate to JConsole to see your connection pools...\");\n\n    // Pauses the code execution so you can navigate to JConsole and inspect your connection pools\n    Thread.sleep(Long.MAX_VALUE);\n\n// Prints exception details if any exceptions occur during the code execution\n} catch (Exception e) {\n    e.printStackTrace();\n}"
                }
            ],
            "preview": "In this guide, you can learn how to set up and configure monitoring in the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/stable-api",
            "title": "Stable API",
            "headings": [
                "Overview",
                "Enable the Stable API on a MongoDB Client",
                "Stable API Options"
            ],
            "paragraphs": "The Stable API feature requires MongoDB Server 5.0 or later. You should only use the Stable API feature if all the MongoDB\nservers you are connecting to support this feature. In this guide, you can learn how to specify the  Stable API  when connecting to\na MongoDB instance or replica set. You can use the Stable API feature to\nforce the server to run operations with behavior compatible with the\nspecified  API version . An API version defines the expected behavior of the\noperations it covers and the format of server responses. If you change to\na different API version, the operations are not guaranteed to be\ncompatible and the server responses are not guaranteed to be similar. When you use the Stable API feature with an official MongoDB driver, you\ncan update your driver or server without worrying about backward compatibility\nissues of the commands covered by the Stable API. See the MongoDB reference page on the  Stable API \nfor more information including a list of commands it covers. The following sections describe how you can enable the Stable API for\nyour MongoDB client and the options that you can specify. To enable the Stable API, you must specify an API version in the settings\nof your MongoDB client. Once you instantiate a  MongoClient  instance with\na specified API version, all commands you run with that client use that\nversion of the Stable API. The following example shows how you can instantiate a  MongoClient  that\nsets the Stable API version and connects to a server by performing the\nfollowing operations: For more information on the methods and classes referenced in this\nsection, see the following API Documentation: If you need to run commands using more than one version of the\nStable API, instantiate a separate client with that version. If you need to run commands not covered by the Stable API, make sure the\n\"strict\" option is disabled. See the section on\n Stable API Options  for more information. Construct a  ServerApi  instance using the  ServerApi.Builder \nhelper class. Specify a Stable API version using a constant from the\n ServerApiVersion  class. Construct a  MongoClientSettings  instance using the\n MongoClientSettings.Builder  class. Specify a server to connect to using a  ServerAddress  instance. Instantiate a  MongoClient  using the  MongoClients.create()  method\nand pass your  MongoClientSettings  instance as a parameter. If you specify an API version and connect to a MongoDB deployment that does\nnot support the Stable API, your application may raise an exception when\nexecuting a command on your MongoDB deployment. If you use a  MongoClient \nthat specifies the API version to query a server that does not support it,\nyour query could fail with an exception message that includes the\nfollowing text: ServerApi ServerApi.Builder ServerApiVersion ServerAddress MongoClientSettings MongoClientSettings.Builder MongoClients.create() MongoClient You can enable or disable optional behavior related to the Stable API as\ndescribed in the following table. The following example shows how you can set the two options on an instance\nof  ServerApi  by chaining methods on the  ServerApi.Builder : For more information on the options in this section, see the following\nAPI Documentation: Option Name Description Strict DeprecationErrors strict() deprecationErrors()",
            "code": [
                {
                    "lang": "java",
                    "value": "ServerApi serverApi = ServerApi.builder()\n        .version(ServerApiVersion.V1)\n        .build();\n\n// Replace the uri string with your MongoDB deployment's connection string\nString uri = \"<connection string uri>\";\n\nMongoClientSettings settings = MongoClientSettings.builder()\n        .applyConnectionString(new ConnectionString(uri))\n        .serverApi(serverApi)\n        .build();\n\nMongoClient client = MongoClients.create(settings);"
                },
                {
                    "lang": "none",
                    "value": "'Unrecognized field 'apiVersion' on server..."
                },
                {
                    "lang": "java",
                    "value": "ServerApi serverApi = ServerApi.builder()\n        .version(ServerApiVersion.V1)\n        .strict(true)\n        .deprecationErrors(true)\n        .build();"
                }
            ],
            "preview": "In this guide, you can learn how to specify the Stable API when connecting to\na MongoDB instance or replica set. You can use the Stable API feature to\nforce the server to run operations with behavior compatible with the\nspecified API version. An API version defines the expected behavior of the\noperations it covers and the format of server responses. If you change to\na different API version, the operations are not guaranteed to be\ncompatible and the server responses are not guaranteed to be similar.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders",
            "title": "Builders",
            "headings": [
                "Overview",
                "Why Use Builders?",
                "Scenario",
                "Using the MongoDB Shell",
                "Without Using Builders",
                "Using Builders",
                "Available Builders"
            ],
            "paragraphs": "This section includes guides on how to use each of the available\nbuilders, and demonstrates the utility the MongoDB Java driver builder classes\nprovide. The Java driver provides classes to simplify the process for developers\nto use CRUD operations and the Aggregation API. The static utility methods allow you\nto build a query more efficiently. Using the builders class, you leverage the power of: When using builders, the Java compiler and the IDE catch errors such as misspelled\noperators early on. When using the MongoDB shell or plain Java, you\nwrite operators as strings and get no visual sign of a problem,\npushing these errors to runtime instead of compile time With the builder classes, you write operators as methods. The IDE\ninstantly underlines and gives you a red bar on the right indicating\nsomething is wrong. While developing, the IDE also shows you the\nmethods you can use. It automatically completes your code with\nplaceholder parameters once you select which method you want to use. The Java compiler and the IDE to find errors during development The IDE for discovery and code completion Imagine we want to send a marketing email to all users in our  users \ncollection with the following criteria: We only want their email address, so we want to ensure our query doesn't\nreturn data we pay bandwidth costs for but don't need. Users that identify as \"female\" gender Users that are older than \"29\" Filters  for building query filters. Projections  for building projections. Sorts  for building sort criteria. Updates  for building updates. Aggregates  for building aggregation pipelines. Indexes  for creating index keys.",
            "code": [
                {
                    "lang": "js",
                    "value": "collection.find({ \"gender\": \"female\", \"age\" : { \"$gt\": 29 }}, { \"_id\": 0, \"email\": 1 })"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = new Document().append(\"gender\", \"female\").append(\"age\", new Document().append(\"$gt\", 29));\nBson projection = new Document().append(\"_id\", 0).append(\"email\", 1);\ncollection.find(filter).projection(projection);"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Filters.*;\nimport static com.mongodb.client.model.Projections.*;\n...\n\nBson filter = and(eq(\"gender\", \"female\"), gt(\"age\", 29));\nBson projection = fields(excludeId(), include(\"email\"));\ncollection.find(filter).projection(projection);"
                }
            ],
            "preview": "This section includes guides on how to use each of the available\nbuilders, and demonstrates the utility the MongoDB Java driver builder classes\nprovide.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/indexes",
            "title": "Indexes",
            "headings": [
                "Overview",
                "Query Coverage and Performance",
                "Operational Considerations",
                "Index Types",
                "Single Field and Compound Indexes",
                "Single Field Indexes",
                "Compound Indexes",
                "Multikey Indexes (Indexes on Array Fields)",
                "Text Indexes",
                "Single Field",
                "Multiple Fields",
                "Geospatial Indexes",
                "Unique Indexes",
                "Wildcard Indexes",
                "Remove an Index",
                "Remove an Index Using an Index Specification Document",
                "Remove an Index Using a Name Field",
                "Remove an Index Using a Wildcard Character"
            ],
            "paragraphs": "In this guide, you can learn how to use  indexes  with the MongoDB Java driver. Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must scan  every  document in a\ncollection (a  collection scan ) to find the documents that match each query. These collection scans are slow and can\nnegatively affect the performance of your application. If an appropriate index exists for a query, MongoDB can use the\nindex to limit the number of documents it must inspect. Indexes also: Allow efficient sorting Enable special capabilities like  geospatial  search Allow adding constraints to ensure a field value is  unique And  more Indexes are also used by update operations when finding the documents to update, delete operations when finding the\ndocuments to delete, and by  certain stages  in\nthe aggregation pipeline. When you execute a query against MongoDB, your command can include various elements: When all the fields specified in the query, projection, and sort are in the same index, MongoDB returns results directly\nfrom the index, also called a  covered query . For additional information on how to ensure your index covers your query criteria and projection, see the MongoDB manual\narticles on  query coverage . Query criteria that specify fields and values you are looking for Options that affect the query's execution (e.g. read concern) Projection criteria to specify the fields MongoDB should return (optional) Sort criteria to specify the order documents will be returned from MongoDB (optional) Sort criteria must match or invert the order of the index. Consider an index on the field  name  in ascending order (A-Z) and  age  in descending order (9-0): MongoDB would use this index when you sort your data by either: Specifying a sort order of  name  and  age  ascending or  name  and  age \ndescending would require an in-memory sort. name  ascending,  age  descending name  descending,  age  ascending To improve query performance, build indexes on fields that appear often in your application's queries and operations\nthat return sorted results. Each index that you add consumes disk space and memory when active so you should track index\nmemory and disk usage for capacity planning. In addition, when a write operation updates an indexed field, MongoDB also\nhas to update the related index. Since MongoDB supports dynamic schemas, applications can query against fields whose names cannot be known in advance or\nare arbitrary. MongoDB 4.2 introduced  wildcard indexes  to help support these queries.\nWildcard indexes are not designed to replace workload-based index planning. For more information on designing your data model and choosing indexes appropriate for your application, see the MongoDB Server\n Data Modeling and Indexes . MongoDB supports a number of different index types to support querying your data. The following sections describe the\nmost common index types and provide sample code for creating each index type. For a full list of index types, see\n Indexes . The following examples use the\n createIndex() \nmethod to create various indexes, and the following setup: The MongoDB Java Driver provides the  Indexes  class that\nincludes static factory methods to create index specification documents for different MongoDB Index key types. Single field indexes  are indexes with a reference to a single field within a collection's\ndocuments. They improve single field query and sort performance, and support  TTL Indexes  that\nautomatically remove documents from a collection after a certain amount of time or at a specific clock time. The following example creates an index in ascending order on the  title  field: The following is an example of a query that would be covered by the index created in the preceding code snippet: For more information, see  Single Field Indexes  in the MongoDB Server manual. The  _id_  index is an example of a single field index. This index is automatically created on the  _id  field\nwhen a new collection is created. Compound  indexes hold references to multiple fields within a collection's documents,\nimproving query and sort performance. The following example creates a compound index on the  type  and  rated  fields: The following is an example of a query that would be covered by the index created in the preceding code snippet: For more information, see  Compound Indexes  in the MongoDB Server manual. Read more about compound indexes,  index prefixes , and sort order  here . Multikey indexes  are indexes that improve performance for queries that specify a field with an index that contains\nan array value. You can define a multikey index using the same syntax as a single field or compound index. The following example creates a compound, multikey index on the  rated ,  genres  (an array of\nStrings), and  title  fields: The following is an example of a query that would be covered by the index created in the preceding code snippet: Multikey indexes behave differently from other indexes in terms of query coverage, index bound computation, and\nsort behavior. For a full explanation of multikey indexes, including a discussion of their behavior and limitations,\nrefer to the  Multikey Indexes page  in the MongoDB manual. Text indexes  support text search queries on string content. These indexes can include any field whose value is a\nstring or an array of string elements. MongoDB supports text search for various languages. You can specify the default\nlanguage as an option when creating the index. Text indexes differ from the more powerful\n Atlas full text search indexes .\nAtlas users should use Atlas search. The following example creates a text index on the  plot  field: The following is an example of a query that would use the index created in the preceding code snippet. Note that the  sort  is\nomitted because text indexes do not contain sort order. A collection can only contain one text index. If you want to create a\ntext index for multiple text fields, you need to create a compound\nindex. A text search runs on all the text fields within the compound\nindex. The following snippet creates a compound text index for the  title  and  genre \nfields: For more information, see the following Server Manual Entries: Compound Text Index Restrictions Text Indexes MongoDB supports queries of geospatial coordinate data using  2dsphere indexes . With a  2dsphere  index, you can query\nthe geospatial data for inclusion, intersection, and proximity. For more information on querying geospatial data, see\n Geospatial Queries . To create a  2dsphere  index, you must specify a field that contains only  GeoJSON objects . For more details on this\ntype, see the MongoDB Server manual page on  GeoJSON objects . The  location.geo  field in the following sample document from the  theaters  collection in the  sample_mflix \ndatabase is a GeoJSON Point object that describes the coordinates of the theater: The following example creates a  2dsphere  index on the  location.geo  field: The following is an example of a geospatial query using the \"location.geo\" index. MongoDB also supports  2d  indexes for calculating distances on a Euclidean plane and for working with the \"legacy\ncoordinate pairs\" syntax used in MongoDB 2.2 and earlier. For more information, see the  Geospatial Queries page \nin the MongoDB Server manual. Attempting to create a geospatial index on a field that is covered by a geospatial index will result in an error. Unique indexes ensure that the indexed fields do not store duplicate values. By default, MongoDB creates a unique index\non the  _id  field during the creation of a collection. To create a unique index, specify the field or combination of\nfields that you want to prevent duplication on and set the  unique  option to  true . The following example creates a unique, descending index on the  theaterId  field: For more information, see the  Unique Indexes  page in the MongoDB Server manual. If you perform a write operation that stores a duplicate value that violates the unique index, the MongoDB\nJava driver will raise a  DuplicateKeyException , and MongoDB will throw an error resembling the following: Wildcard indexes enable queries against unknown or arbitrary fields.\nThese indexes can be beneficial if you are using a dynamic schema. The following example creates an ascending wildcard index on all\nvalues of the  location  field, including values nested in subdocuments and arrays: For more information, see the  Wildcard Indexes  page in the MongoDB Server manual. You can remove any unused index except the default unique index on the\n _id  field. The following sections show the ways to remove indexes: Using an index specification document Using an indexed name field Using a wildcard character to remove all indexes Pass an  index specification document  to the  dropIndex()  method to\nremove an index from a collection. An index specification document is\na  Bson  instance that specifies the type of index on a\nspecified field. The following snippet removes an ascending index on the  title  field\nin a collection: If you want to drop a text index, you must use the name of the index\ninstead. See the  Remove an Index Using a Name Field  section for details. Pass the  name  field of the index to the  dropIndex()  method to\nremove an index from a collection. If you need to find the name of your index, use the  listIndexes() \nmethod to see the value of the  name  fields in your indexes. The following snippet retrieves and prints all the indexes in a\ncollection: If you call  listIndex()  on a collection that contains a text index,\nthe output might resemble the following: This output tells us the names of the existing indexes are \"_id\" and\n\"title_text\". The following snippet removes the \"title_text\" index from the collection: You cannot remove a single field from a compound text index. You must\ndrop the entire index and create a new one to update the indexed\nfields. Starting with MongoDB 4.2, you can drop all indexes by calling the\n dropIndexes()  method on your collection: For prior versions of MongoDB, pass \"*\" as a parameter to your call to\n dropIndex()  on your collection: For more information on the methods in this section, see the following API Documentation: dropIndex() dropIndexes()",
            "code": [
                {
                    "lang": "none",
                    "value": "name_1_age_-1"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.DuplicateKeyException;\nimport com.mongodb.MongoCommandException;\nimport com.mongodb.client.*;\nimport com.mongodb.client.model.IndexOptions;\nimport com.mongodb.client.model.Indexes;\nimport com.mongodb.client.model.Sorts;\nimport com.mongodb.client.model.geojson.Point;\nimport com.mongodb.client.model.geojson.Position;\nimport org.apache.log4j.BasicConfigurator;\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport static com.mongodb.client.model.Filters.*;\nimport static com.mongodb.client.model.Projections.*;"
                },
                {
                    "lang": "java",
                    "value": "final String uri = \"mongodb+srv://<atlas-uri>/<dbname>?retryWrites=true&w=majority\";\n\nmongoClient = MongoClients.create(uri);\ndatabase = mongoClient.getDatabase(\"sample_mflix\");\ncollection = database.getCollection(\"movies\");"
                },
                {
                    "lang": "java",
                    "value": "String resultCreateIndex = collection.createIndex(Indexes.ascending(\"title\"));\nSystem.out.println(String.format(\"Index created: %s\", resultCreateIndex));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"title\", \"Batman\");\nBson sort = Sorts.ascending(\"title\");\nBson projection = fields(include(\"title\"), excludeId());\nFindIterable<Document> cursor = collection.find(filter).sort(sort).projection(projection);"
                },
                {
                    "lang": "java",
                    "value": "String resultCreateIndex = collection.createIndex(Indexes.ascending(\"type\", \"rated\"));\nSystem.out.println(String.format(\"Index created: %s\", resultCreateIndex));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = and(eq(\"type\", \"movie\"), eq(\"rated\", \"G\"));\nBson sort = Sorts.ascending(\"type\", \"rated\");\nBson projection = fields(include(\"type\", \"rated\"), excludeId());\nFindIterable<Document> cursor = collection.find(filter).sort(sort).projection(projection);"
                },
                {
                    "lang": "java",
                    "value": "String resultCreateIndex = collection.createIndex(Indexes.ascending(\"rated\", \"genres\", \"title\"));\nSystem.out.println(String.format(\"Index created: %s\", resultCreateIndex));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = and(eq(\"genres\", \"Animation\"), eq(\"rated\", \"G\"));\nBson sort = Sorts.ascending(\"title\");\nBson projection = fields(include(\"title\", \"rated\"), excludeId());\nFindIterable<Document> cursor = collection.find(filter).sort(sort).projection(projection);"
                },
                {
                    "lang": "java",
                    "value": "try {\n    String resultCreateIndex = collection.createIndex(Indexes.text(\"plot\"));\n    System.out.println(String.format(\"Index created: %s\", resultCreateIndex));\n\n// Prints a message if a text index already exists with a different configuration \n} catch (MongoCommandException e) {\n    if (e.getErrorCodeName().equals(\"IndexOptionsConflict\"))\n        System.out.println(\"there's an existing text index with different options\");\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = text(\"java coffee shop\");\nBson projection = fields(include(\"fullplot\"), excludeId());\nFindIterable<Document> cursor = collection.find(filter).projection(projection);"
                },
                {
                    "lang": "java",
                    "value": "collection.createIndex(Indexes.compoundIndex(Indexes.text(\"title\"), Indexes.text(\"genre\")));"
                },
                {
                    "lang": "javascript",
                    "value": "{\n   \"_id\" : ObjectId(\"59a47286cfa9a3a73e51e75c\"),\n   \"theaterId\" : 104,\n   \"location\" : {\n      \"address\" : {\n         \"street1\" : \"5000 W 147th St\",\n         \"city\" : \"Hawthorne\",\n         \"state\" : \"CA\",\n         \"zipcode\" : \"90250\"\n      },\n      \"geo\" : {\n         \"type\" : \"Point\",\n         \"coordinates\" : [\n            -118.36559,\n            33.897167\n         ]\n      }\n   }\n}"
                },
                {
                    "lang": "java",
                    "value": "try {\n    String resultCreateIndex = collection.createIndex(Indexes.geo2dsphere(\"location.geo\"));\n    System.out.println(String.format(\"Index created: %s\", resultCreateIndex));\n\n// Prints a message if a geospatial index already exists with a different configuration \n} catch (MongoCommandException e) {\n    if (e.getErrorCodeName().equals(\"IndexOptionsConflict\"))\n        System.out.println(\"there's an existing geospatial index with different options\");\n}"
                },
                {
                    "lang": "java",
                    "value": "// Stores the coordinates of the NY MongoDB headquarters\nPoint refPoint = new Point(new Position(-73.98456, 40.7612));\n\n// Retrieves documents that represent locations up to 1000 meters from the specified point directly from the geospatial index\n// Creates a filter to match a document \nBson filter = near(\"location.geo\", refPoint, 1000.0, 0.0);\nFindIterable<Document> cursor = collection.find(filter);"
                },
                {
                    "lang": "java",
                    "value": "try {\n    IndexOptions indexOptions = new IndexOptions().unique(true);\n    String resultCreateIndex = collection.createIndex(Indexes.descending(\"theaterId\"), indexOptions);\n    System.out.println(String.format(\"Index created: %s\", resultCreateIndex));\n\n// Prints a message if the \"theaterID\" field contains duplicate values\n} catch (DuplicateKeyException e) {\n    System.out.printf(\"duplicate field values encountered, couldn't create index: \\t%s\\n\", e);\n}"
                },
                {
                    "lang": "none",
                    "value": "E11000 duplicate key error index"
                },
                {
                    "lang": "java",
                    "value": "String resultCreateIndex = collection.createIndex(Indexes.ascending(\"location.$**\")); \nSystem.out.println(String.format(\"Index created: %s\", resultCreateIndex));"
                },
                {
                    "lang": "java",
                    "value": "collection.dropIndex(Indexes.ascending(\"title\"));"
                },
                {
                    "lang": "json",
                    "value": "{ \"v\": 2, \"key\": {\"_id\": 1}, \"name\": \"_id_\" }\n{ \"v\": 2, \"key\": {\"_fts\": \"text\", \"_ftsx\": 1}, \"name\": \"title_text\", \"weights\": {\"title\": 1},\n\"default_language\": \"english\", \"language_override\": \"language\", \"textIndexVersion\": 3 }"
                },
                {
                    "lang": "java",
                    "value": "collection.dropIndex(\"title_text\");"
                },
                {
                    "lang": "java",
                    "value": "collection.listIndexes().forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "collection.dropIndexes();"
                },
                {
                    "lang": "java",
                    "value": "collection.dropIndex(\"*\");"
                }
            ],
            "preview": "In this guide, you can learn how to use indexes with the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/time-series",
            "title": "Time Series Collections",
            "headings": [
                "Overview",
                "Create a Time Series Collection",
                "Query a Time Series Collection"
            ],
            "paragraphs": "In this guide, you can learn about  time series collections  in\nMongoDB, and how to interact with them in the MongoDB Java driver. Time series collections efficiently store sequences of measurements over\na period of time. Time series data consists of any data collected over\ntime, metadata that describes the measurement, and the time of the\nmeasurement. Example Measurement Metadata Sales Data Revenue Company Infection Rates Amount of People Infected Location To create a time series collection, pass the following parameters to the\n createCollection() \nmethod: To check if you successfully created the collection, send the\n \"listCollections\"  command to the  runCommand()  method. Your output should look similar to the following: The name of the new collection to create The  TimeSeriesOptions   for creating the collection in a  CreateCollectionOptions  object Versions prior to MongoDB 5.0 cannot create a time series collection. To query in a time series collection, use the same conventions as you\nwould for  retrieving \nand  aggregating data . MongoDB version 5.0 introduces window functions into the aggregation\npipeline. You can use window functions to perform operations on a\ncontiguous span of time series data. For more information, see our\n Aggregates Builders guide .",
            "code": [
                {
                    "lang": "json",
                    "value": "{\n \"id\": <some number>,\n \"ns\": \"<db name>.$cmd.listCollections\",\n \"firstBatch\": [\n  {\n    \"name\": \"<time series collection name>\",\n    \"type\": \"timeseries\",\n    \"options\": {\n     \"expireAfterSeconds\": <some number>,\n      \"timeseries\": { ... }\n     },\n     ...\n   },\n   ...\n ]\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoDatabase database = mongoClient.getDatabase(\"fall_weather\");\nTimeSeriesOptions tsOptions = new TimeSeriesOptions(\"temperature\");\nCreateCollectionOptions collOptions = new CreateCollectionOptions().timeSeriesOptions(tsOptions);\n\ndatabase.createCollection(\"september2021\", collOptions);"
                },
                {
                    "lang": "java",
                    "value": "Document commandResult = database.runCommand(new Document(\"listCollections\", new BsonInt64(1)));\n\nList<String> keys = Arrays.asList(\"cursor\");\nSystem.out.println(\"listCollections: \" + commandResult.getEmbedded(keys, Document.class).toJson());"
                }
            ],
            "preview": "In this guide, you can learn about time series collections in\nMongoDB, and how to interact with them in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/logging",
            "title": "Logging",
            "headings": [
                "Overview",
                "Set Up a Logger",
                "Background",
                "Example - Set Up",
                "Configure Your Logger",
                "Example - Configure",
                "Logger Names",
                "Example - Names"
            ],
            "paragraphs": "In this guide, you can learn how to set up and configure a logger in the\nMongoDB Java driver. You will learn how to: This guide shows how to record events in the driver.\nIf you would like to learn how to use information about the activity of the\ndriver in code, consider reading our\n guide on monitoring . Set up a logger using the Simple Logging Facade For Java (SLF4J) Configure the log level of your logger This section gives background on the dependencies necessary to set up a\nlogger and provides an example logger setup. The MongoDB Java driver uses the Simple Logging Facade For Java (SLF4J).\nSLF4J allows you to specify your logging framework of choice at deployment time.\nFor more information on SLF4J,\n see the SLF4J documentation . Setting up a logger is optional. When you start your application the MongoDB\nJava driver looks for the  slf4j-api  artifact in your classpath. If the driver\ncan't find the  slf4j-api  artifact, the driver logs the following warning with\n java.util.logging  and disables all further logging: To set up a logger, you must include the following in your project. A binding is a piece of code that connects the  slf4j-api  artifact with a\nlogging framework. The following example shows how to bind the  slf4j-api  artifact\nto the two most popular logging frameworks, Log4j2 and Logback. The  slf4j-api  artifact A logging framework A  binding For the most popular logging frameworks, there is often a single binding\nartifact that lists the  slf4j-api  and the logging framework as\ndependencies. This means that you can set up a logger by adding one artifact\nto your project's dependency list. You will see this in the example below. This example shows how to set up your logger. Click the\ntab corresponding to the logging framework you would like to use in your project. The following versions listed are illustrative rather than a\nsource of truth. You should check the official documentation for SLF4J and\nyour logging framework of choice for guaranteed up-to-date version\ninformation. SLF4J documentation Logback documentation Log4j2 documentation Select the build tool you are using in your project. Once you have included the preceding dependency, connect to your\nMongoDB instance and retrieve a document with the following code. You should see output that resembles the following: For more information on Logback, see the\n Logback manual . Add the following dependency to your  pom.xml  file. Add the following dependency to your  build.gradle  file. The default log level of Logback is DEBUG. To learn how to change your\nLogback logger's log level, see the\n example in the Configure Your Logger section of this page . Select the build tool you are using in your project. Once you have included the preceding dependency, log an error using the\nfollowing code. You should see output that resembles the following: For more information on Log4j2, see the\n Log4j2 manual . Add the following dependency to your  pom.xml  file. Add the following dependency to your  build.gradle  file. The default log level of Log4J2 is ERROR. This means that running\nstandard operations in the MongoDB Java driver will not produce output\nfrom Log4J2 without configuration. To learn how to change your Log4J2\nlogger's log level, see the\n example in the Configure Your Logger section of this page . To configure your logger, you must use the configuration system of the logging\nframework bound to SLF4J. In the following example we show how you can use your logging framework's\nconfiguration system to set your logger's  log level . A logger's log level specifies a lower bound for how urgent a message must be\nfor the logger to output that message. This example shows how to configure your logger's log level to INFO.\nSelect the tab corresponding to the logging framework you are using in your\nproject. Specify Logback configurations in a file named  logback.xml . Your\n logback.xml  file does not have to be in a specific location, but it must\nbe accessible from your classpath. The Logback framework defines the following log levels. The\nfollowing lists the log levels, ordered from most urgent to least\nurgent: Set your  logback.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. You should see output that resembles the following. For more information on configuring Logback, see the\n the Logback Manual . ERROR WARN INFO DEBUG TRACE Specify Log4j2 configurations in a file named  log4j2.xml . Your\n log4j2.xml  file does not have to be in a specific location, but it must\nbe accessible from your classpath. The Log4j2 framework defines the following log levels. The following lists the\nlog levels, ordered from most urgent to least urgent: Set your  log4j2.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. You should see output that resembles the following. For more information on configuring Log4j2, see the official\n Log4j2 configuration guide . FATAL ERROR WARN INFO DEBUG TRACE ALL Your logger uses logger names to help organize different logging events. Logger\nnames are strings that form a hierarchy. A logger is an ancestor of another logger if\nits name followed by a  \".\"  is a prefix of the other logger's name. For example,\n \"grandparent\"  is an ancestor of  \"grandparent.parent\"  which is an\nancestor of  \"grandparent.parent.child\" . For a concrete example, this is what a logger hierarchy looks like in code. A logger inherits the properties of its ancestor logger and can define\nits own. You can think of this as similar to class inheritance in Java. The MongoDB Java driver defines the following logger names to organize different\nlogging events in the driver. Here are the logger names defined in the driver\nand the logging events they correspond to. org.mongodb.driver.authenticator  : authentication org.mongodb.driver.client  : events related to  MongoClient  instances org.mongodb.driver.cluster  : monitoring of MongoDB deployments org.mongodb.driver.connection  : connections and connection pools org.mongodb.driver.connection.tls  : TLS/SSL org.mongodb.driver.operation  : operations, including logging related to automatic retries org.mongodb.driver.protocol  : commands sent to and replies received from MongoDB deployments org.mongodb.driver.uri  : connection string parsing org.mongodb.driver.management  : JMX (Java Management Extensions) This example shows how to change the log level for a specific driver logger.\nWe set the root logger to OFF and the  org.mongodb.driver.connection  logger to\nINFO. This will cause the application to only log messages related to connecting\nto a MongoDB instance. Select the tab corresponding to the logging framework you are using in your\nproject. Set your  logback.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. You should see output that resembles the following. For more information on configuring Logback, see the\n official Logback configuration guide . Set your  log4j2.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. You should see output that resembles the following. For more information on configuring Log4j2, see the\n official Log4J2 configuration guide .",
            "code": [
                {
                    "lang": "none",
                    "value": "WARNING: SLF4J not found on the classpath.  Logging is disabled for the 'org.mongodb.driver' component"
                },
                {
                    "lang": "none",
                    "value": "...\n16:03:59.468 [main] INFO org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<server value>}] to <connection uri>\n16:03:59.483 [main] DEBUG org.mongodb.driver.protocol.command - Sending command '{\"find\": \"<my collection>\", \"filter\": {}, \"limit\": 1, \"singleBatch\": true, \"$db\": \"<my database>\", \"lsid\": {\"id\": {\"$binary\": {\"base64\": \"<_id>\", \"subType\": \"04\"}}}}' with request id 13 to database <my database> on connection [connectionId{localValue:7, serverValue:<server value>}] to server <connection uri>\n16:03:59.502 [main] DEBUG org.mongodb.driver.protocol.command - Execution of command with request id 13 completed successfully in 27.79 ms on connection [connectionId{localValue:7, serverValue:<server value>}] to server <connection uri>"
                },
                {
                    "lang": "xml",
                    "value": "<dependency>\n  <groupId>ch.qos.logback</groupId>\n  <artifactId>logback-classic</artifactId>\n  <version>1.2.3</version>\n</dependency>"
                },
                {
                    "lang": "none",
                    "value": "dependencies {\n   implementation 'ch.qos.logback:logback-classic:1.2.3'\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(<my uri>);\nMongoDatabase database = mongoClient.getDatabase(<my database>);\nMongoCollection<Document> collection = database.getCollection(<my collection>);\ncollection.find().first();"
                },
                {
                    "lang": "java",
                    "value": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n...\n\nLogger logger = LoggerFactory.getLogger(\"MyApp\");\nlogger.error(\"Logging an Error\");"
                },
                {
                    "lang": "none",
                    "value": "12:35:00.438 [main] ERROR <my package path> - Logging an Error"
                },
                {
                    "lang": "xml",
                    "value": "<dependency>\n  <groupId>org.apache.logging.log4j</groupId>\n  <artifactId>log4j-slf4j-impl</artifactId>\n  <version>2.17.1</version>\n</dependency>"
                },
                {
                    "lang": "none",
                    "value": "dependencies {\n   implementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.17.1'\n}"
                },
                {
                    "lang": "xml",
                    "value": "<configuration>\n   <appender name=\"CONSOLE\"\n             class=\"ch.qos.logback.core.ConsoleAppender\">\n      <encoder>\n         <pattern>\n               %-4relative [%thread] %-5level %logger{30} - %msg%n\n         </pattern>\n      </encoder>\n   </appender>\n   <root level=\"INFO\">\n      <appender-ref ref=\"CONSOLE\" />\n   </root>\n</configuration>"
                },
                {
                    "lang": "none",
                    "value": "...\n1317 [cluster-ClusterId{value='<your cluster id>', description='null'}-<your connection uri>] INFO  org.mongodb.driver.cluster - Discovered replica set primary <your connection uri>\n1568 [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<server value>}] to <your connection uri>"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(<my uri>);\nMongoDatabase database = mongoClient.getDatabase(<my database>);\nMongoCollection<Document> collection = database.getCollection(<my collection>);\ncollection.find().first();"
                },
                {
                    "lang": "xml",
                    "value": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"INFO\">\n   <Appenders>\n      <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n      </Console>\n   </Appenders>\n   <Loggers>\n      <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n      </Root>\n   </Loggers>\n</Configuration>"
                },
                {
                    "lang": "none",
                    "value": "...\n10:14:57.633 [cluster-ClusterId{value=<your cluster id>, description='null'}-<your connection uri>] INFO  org.mongodb.driver.cluster - Discovered replica set primary <your connection uri>\n10:14:57.790 [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<your server value>}] to <your connection uri>"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(<my uri>);\nMongoDatabase database = mongoClient.getDatabase(<my database>);\nMongoCollection<Document> collection = database.getCollection(<my collection>);\ncollection.find().first();"
                },
                {
                    "lang": "java",
                    "value": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n...\n\nLogger logger_parent = LoggerFactory.getLogger(\"parent\");\nLogger logger_child = LoggerFactory.getLogger(\"parent.child\");"
                },
                {
                    "lang": "xml",
                    "value": "<configuration>\n   <appender name=\"CONSOLE\"\n             class=\"ch.qos.logback.core.ConsoleAppender\">\n      <encoder>\n         <pattern>\n               %-4relative [%thread] %-5level %logger{30} - %msg%n\n         </pattern>\n      </encoder>\n   </appender>\n   <logger name=\"org.mongodb.driver.connection\" level=\"INFO\" additivity=\"true\"/>\n   <root level=\"OFF\">\n      <appender-ref ref=\"CONSOLE\" />\n   </root>\n</configuration>"
                },
                {
                    "lang": "none",
                    "value": "...\n829  [cluster-rtt-ClusterId{value='<some value>', description='null'}-<your connection URI>] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:2, serverValue:<your server value>}] to <your connection uri>\n977  [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<your server value>}] to <your connection uri>"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(<my uri>);\nMongoDatabase database = mongoClient.getDatabase(<my database>);\nMongoCollection<Document> collection = database.getCollection(<my collection>);\ncollection.find().first();"
                },
                {
                    "lang": "xml",
                    "value": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"INFO\">\n   <Appenders>\n      <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n      </Console>\n   </Appenders>\n   <Loggers>\n      <Logger name=\"org.mongodb.driver.connection\" level=\"INFO\"/>\n      <Root level=\"OFF\">\n            <AppenderRef ref=\"Console\"/>\n      </Root>\n   </Loggers>\n</Configuration>"
                },
                {
                    "lang": "none",
                    "value": "...\n15:40:23.005 [cluster-ClusterId{value='<some value>', description='null'}-<your connection uri>] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:3, serverValue:<your server value>}] to <your connection uri>\n15:40:23.159 [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<your server value>}] to <your connection uri>"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(<my uri>);\nMongoDatabase database = mongoClient.getDatabase(<my database>);\nMongoCollection<Document> collection = database.getCollection(<my collection>);\ncollection.find().first();"
                }
            ],
            "preview": "In this guide, you can learn how to set up and configure a logger in the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats",
            "title": "Data Formats",
            "headings": [],
            "paragraphs": "Document Data Format: BSON Document Data Format: Extended JSON Documents Document Data Format: POJOs Document Data Format: Records POJO Customization Codecs",
            "code": [],
            "preview": "Learn how to convert between MongoDB and Java data formats by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/collations",
            "title": "Collations",
            "headings": [
                "Overview",
                "Collations in MongoDB",
                "How to Specify Collations",
                "Collection",
                "Index",
                "Operation",
                "Index Types That Do Not Support Collations",
                "Collation Options",
                "Collation Examples",
                "find() and sort() Example",
                "findOneAndUpdate() Example",
                "findOneAndDelete() Example",
                "Aggregation Example"
            ],
            "paragraphs": "In this guide, you can learn how to use  collations  with MongoDB to order your\nquery or aggregation operation results by string values. A collation is a set\nof character ordering and matching rules that apply to a specific language and\nlocale. You can learn more about collations in the following sections in this guide: Collations in MongoDB How to Specify Collations Collation Options Collation Code Examples MongoDB sorts strings using  binary collation  by default. The binary\ncollation uses the  ASCII standard  character values to\ncompare and order strings. Certain languages and locales have specific\ncharacter ordering conventions that differ from the ASCII character values. For example, in Canadian French, the right-most accented character\n(diacritic) determines the ordering for strings when all preceding characters\nare the same. Consider the following Canadian French words: When using binary collation, MongoDB sorts them in the following order: When using the Canadian French collation, MongoDB sorts them in a different\norder as shown below: cote cot\u00e9 c\u00f4te c\u00f4t\u00e9 MongoDB supports collations on most  CRUD operations \nand aggregations. For a complete list of supported operations, see the\n Operations that Support Collations \nserver manual page. You can specify the locale code and optional variant in the following string\nformat: The following example specifies the \"de\" locale code and \"phonebook\" variant\ncode: If you do not need to specify a variant, omit everything after the locale\ncode as follows: For a complete list of supported locales, see our server manual page on\n Supported Languages and Locales . The following sections show you different ways to apply collations in\nMongoDB: Collection Index Operation You can set a default collation when you create a collection. When you\ncreate a collection with a specified collation, all supported operations\nthat scan that collection apply the rules of the collation. You can only assign a default collation to a collection when you create that\ncollection. However, you can specify a collation in a new index on an existing\ncollection. See the  Index  section of this guide\nfor more information. The following snippet shows how to specify the \"en_US\" locale collation\nwhen creating a new collection called  items : To check whether you created the collation successfully, retrieve a list\nof the indexes on that collection as follows: The output of your code should contain the following: You can specify a collation when you create a new index on a collection.\nThe index stores an ordered representation of the documents in the\ncollection so your operation does not need to perform the ordering\nin-memory. To use the index, your operation must meet the following\ncriteria: The following code snippet shows how you can create an index on the \"name\"\nfield with the \"en_US\" locale collation in ascending order: To check whether you created the collation successfully, retrieve a list\nof the indexes on that collection as follows: The output of the preceding code should contain the following: The following code snippet shows an example operation that specifies the\nsame collation and is covered by the index we created in the preceding code snippet: The operation uses the same collation as the one specified in the index. The operation is covered by the index that contains the collation. You can override the default collation on a collection by passing the\nnew collation as a parameter to one of the supported operations. However,\nsince the operation does not use an index, the operation may not perform\nas well as one that is covered by an index. For more information on the\ndisadvantages of sorting operations not covered by an index, see the server\nmanual page on  Use Indexes to Sort Query Results . The following code snippet shows an example query operation with the\nfollowing characteristics: The referenced collection contains the default collation \"en_US\" similar to\nthe one specified in the  Collection  section. The query specifies the Icelandic (\"is\") collation which is not covered\nby the collection's default collation index. Since the specified collation is not covered by an index, the sort\noperation is performed in-memory. While most MongoDB index types support collation, the following types support\nonly binary comparison: text 2d geoHaystack This section covers various collation options and how to specify them to\nfurther refine the ordering and matching behavior. You can use the  Collation.Builder  class to specify values for the\npreceding collation options. You can call the  build()  method to construct a\n Collation  object as shown in the following code snippet: For more information on the corresponding methods and parameters they\ntake, see the API Documentation for  Collation.Builder . Collation Option Description Locale Backwards Case-sensitivity Alternate Case First Max Variable Strength Normalization Numeric Ordering This section contains examples that demonstrate how to use a selection of\nMongoDB operations that support collations. For each example, assume that\nyou start with the following collection of documents: In the following examples, we specify the \"de@collation=phonebook\" locale and\nvariant collation. The \"de\" part of the collation specifies the German\nlocale and the \"collation=phonebook\" part specifies a variant. The\n\"de\" locale collation contains rules for prioritizing proper nouns,\nidentified by capitalization of the first letter. In the\n\"collation=phonebook\" variant, characters with umlauts are ordered before\nthe same characters without them in an ascending sort. The following example demonstrates how you can apply a collation when\nretrieving sorted results from a collection. To perform this\noperation, call  find()  on the example collection and chain the\n collation()  and  sort()  methods to specify the order in which you want\nto receive the results. When we perform this operation on our  example collection ,\nthe output should resemble the following: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: The following code example uses imports from the\n import com.mongodb.client.model  package for convenience. find() sort() Sorts This section demonstrates how you can specify a collation in an\noperation that updates the first match from your query. To specify the\ncollation for this operation, instantiate a  FindOneAndUpdateOptions \nobject, set a collation on it, and pass it as a parameter to your call to\nthe  findOneAndUpdate()  method. In this example, we demonstrate the following: Since \"G\u00fcnter\" is lexically before \"Gunter\" using the\n de@collation=phonebook  collation in ascending order, the preceding operation\nreturns the following update document: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Retrieve the first document in our  example collection \nthat precedes \"Gunter\" in an ascending order. Set options for operation including the \"de@collation=phonebook\"\ncollation. Add a new field \"verified\" with the value \"true\". Retrieve and print the updated document. The following code example uses imports from the\n import com.mongodb.client.model  package for convenience. findOneAndUpdate findOneAndUpdateOptions Filters Updates Sorts This section demonstrates how you can specify a numerical ordering of\nstrings in a collation in an operation that deletes the first match from your\nquery. To specify the collation for this operation, instantiate\na  FindOneAndDeleteOptions  object, set a numeric ordering collation on\nit, and pass it as a parameter to your call to the  findOneAndDelete() \nmethod. This example calls the  findOneAndDelete()  operation on a collection that\ncontains the following documents: In the collation, we set the  locale  option to \"en\" and the\n numericOrdering  option to \"true\" in order to sort strings based on their\nnumerical order. After you run the preceding operation, your output should resemble the\nfollowing: The numeric value of the string \"179\" is greater than the number 100, so\nthe preceding document is the only match. If we perform the same operation without the numerical ordering collation\non the original collection of three documents, the filter matches all of\nour documents since \"100\" comes before \"16\", \"84\", and \"179\" when ordering\nby binary collation. For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: The following code example uses imports from the\n import com.mongodb.client.model  package for convenience. findOneAndDelete FindOneAndDeleteOptions Filters Sorts This section demonstrates how you can specify a collation in an aggregation\noperation. In an aggregation operation, you can specify a series of\naggregation stages which is collectively called the aggregation pipeline. To\nperform an aggregation, call the  aggregate()  method on a\n MongoCollection  object. To specify a collation for an aggregation operation, call the  collation() \nmethod on the  AggregateIterable  returned by the aggregation operation.\nMake sure to specify a sort aggregation stage on which to apply the\ncollation in your aggregation pipeline. The following example shows how we can construct an aggregation pipeline on\nthe  example collection  and apply\na collation by specifying the following: The preceding code outputs the following documents: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: A group aggregation stage using the  Aggregates.group()  helper to\nidentify each document by the  first_name  field and use that value as\nthe  _id  of the result. An accumulator in the group aggregation stage to sum the number of\ninstances of matching values in the  first_name  field. Apply an ascending sort to the  _id  field of the output documents of\nthe prior aggregation stage. Construct a collation object, specifying the German locale and\na collation strength that ignores accents and umlauts. aggregate() AggregateIterable CollationStrength Accumulators Aggregates Sorts",
            "code": [
                {
                    "lang": "none",
                    "value": "cote\ncot\u00e9\nc\u00f4te\nc\u00f4t\u00e9"
                },
                {
                    "lang": "none",
                    "value": "cote\nc\u00f4te\ncot\u00e9\nc\u00f4t\u00e9"
                },
                {
                    "lang": "none",
                    "value": "\"<locale code>@collation=<variant code>\""
                },
                {
                    "lang": "none",
                    "value": "\"de@collation=phonebook\""
                },
                {
                    "lang": "none",
                    "value": "\"de\""
                },
                {
                    "lang": "none",
                    "value": "{ ...\n  \"collation\": { \"locale\": \"en_US\", ... }\n  ...\n}"
                },
                {
                    "lang": "java",
                    "value": "database.createCollection(\n        \"items\",\n        new CreateCollectionOptions().collation(\n                Collation.builder().locale(\"en_US\").build()));"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<Document> collection = database.getCollection(\"items\");\nList<Document> indexes = new ArrayList<>();\n\ncollection.listIndexes().into(indexes);\n\n// Prints the collection's indexes and any default collations\nindexes.forEach(idx -> System.out.println(idx.toJson()));"
                },
                {
                    "lang": "none",
                    "value": "{ ...\n  \"collation\": { \"locale\": \"en_US\", ... }\n  ...\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<Document> collection = database.getCollection(\"items\");\nIndexOptions idxOptions = new IndexOptions();\n\n// Defines options that set a collation locale\nidxOptions.collation(Collation.builder().locale(\"en_US\").build());\n\n// Creates an index on the \"name\" field with the collation and ascending sort order\ncollection.createIndex(Indexes.ascending(\"name\"), idxOptions);"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<Document> collection = database.getCollection(\"items\");\nList<Document> indexes = new ArrayList<>();\n\ncollection.listIndexes().into(indexes);\n\n// Prints the collection's indexes and any default collations\nindexes.forEach(idx -> System.out.println(idx.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "FindIterable<Document> cursor = collection.find()\n        .collation(Collation.builder().locale(\"en_US\").build())\n        .sort(Sorts.ascending(\"name\"));"
                },
                {
                    "lang": "java",
                    "value": "FindIterable<Document> cursor = collection.find()\n        .collation(Collation.builder().locale(\"is\").build())\n        .sort(Sorts.ascending(\"name\"));"
                },
                {
                    "lang": "java",
                    "value": "Collation.builder()\n.caseLevel(true)\n.collationAlternate(CollationAlternate.SHIFTED)\n.collationCaseFirst(CollationCaseFirst.UPPER)\n.collationMaxVariable(CollationMaxVariable.SPACE)\n.collationStrength(CollationStrength.SECONDARY)\n.locale(\"en_US\")\n.normalization(false)\n.numericOrdering(true)\n.build();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"first_name\" : \"Klara\" }\n{ \"_id\" : 2, \"first_name\" : \"Gunter\" }\n{ \"_id\" : 3, \"first_name\" : \"G\u00fcnter\" }\n{ \"_id\" : 4, \"first_name\" : \"J\u00fcrgen\" }\n{ \"_id\" : 5, \"first_name\" : \"Hannah\" }"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 3, \"first_name\": \"G\u00fcnter\"}\n{\"_id\": 2, \"first_name\": \"Gunter\"}\n{\"_id\": 5, \"first_name\": \"Hannah\"}\n{\"_id\": 4, \"first_name\": \"J\u00fcrgen\"}\n{\"_id\": 1, \"first_name\": \"Klara\"}"
                },
                {
                    "lang": "java",
                    "value": "List<Document> results = new ArrayList<>();\n\n// Retrieves all documents and applies a \"de@collation-phonebook\" collation and ascending sort to the results\ncollection.find()\n        .collation(Collation.builder().locale(\"de@collation=phonebook\").build())\n        .sort(Sorts.ascending(\"first_name\")).into(results);\n\n// Prints the JSON representation of the results          \nif (results != null) {\n    results.forEach(doc -> System.out.println(doc.toJson()));\n}"
                },
                {
                    "lang": "none",
                    "value": "{\n  lastErrorObject: { updatedExisting: true, n: 1 },\n  value: { _id: 3, first_name: 'G\u00fcnter' },\n  ok: 1\n}"
                },
                {
                    "lang": "java",
                    "value": "Document result = collection.findOneAndUpdate(\n        Filters.gt(\"first_name\", \"Gunter\"),\n        Updates.set(\"verified\", true),\n        new FindOneAndUpdateOptions()\n                .collation(Collation.builder().locale(\"de@collation=phonebook\").build())\n                .sort(Sorts.ascending(\"first_name\"))\n                .returnDocument(ReturnDocument.AFTER));\n\n// Prints the JSON representation of the updated document if an update occurred           \nif (result != null) {\n    System.out.println(\"Updated document: \" + result.toJson());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"a\" : \"16 apples\" }\n{ \"_id\" : 2, \"a\" : \"84 oranges\" }\n{ \"_id\" : 3, \"a\" : \"179 bananas\" }"
                },
                {
                    "lang": "none",
                    "value": "Deleted document: {\"_id\": 3, \"a\": \"179 bananas\"}"
                },
                {
                    "lang": "java",
                    "value": "Document result = collection.findOneAndDelete(\n        Filters.gt(\"a\", \"100\"),\n        new FindOneAndDeleteOptions()\n                .collation(\n                        Collation.builder()\n                                .locale(\"en\")\n                                .numericOrdering(true)\n                                .build())\n                .sort(Sorts.ascending(\"a\")));\n\n// Prints the JSON representation of the deleted document  \nif (result != null) {\n    System.out.println(\"Deleted document: \" + result.toJson());\n}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": \"Gunter\", \"nameCount\": 2}\n{\"_id\": \"Hannah\", \"nameCount\": 1}\n{\"_id\": \"J\u00fcrgen\", \"nameCount\": 1}\n{\"_id\": \"Klara\", \"nameCount\": 1}"
                },
                {
                    "lang": "java",
                    "value": "Bson groupStage = Aggregates.group(\"$first_name\", Accumulators.sum(\"nameCount\", 1));\nBson sortStage = Aggregates.sort(Sorts.ascending(\"_id\"));\n\nAggregateIterable<Document> results = collection\n        // Runs the aggregation pipeline that includes tallying \"first_name\" frequencies\n        .aggregate(Arrays.asList(groupStage, sortStage))\n\n        // Applies a collation to sort documents alphabetically by using the German locale, ignoring accents\n        .collation(Collation.builder().locale(\"de\").collationStrength(CollationStrength.PRIMARY).build());\n\n// Prints the JSON representation of the results\nif (results != null) {\n    results.forEach(doc -> System.out.println(doc.toJson()));\n}"
                }
            ],
            "preview": "In this guide, you can learn how to use collations with MongoDB to order your\nquery or aggregation operation results by string values. A collation is a set\nof character ordering and matching rules that apply to a specific language and\nlocale.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/aggregation",
            "title": "Aggregation",
            "headings": [
                "Overview",
                "Aggregation and Find Operations Compared",
                "Useful References",
                "Runnable Examples",
                "Base Setup",
                "Connect to a MongoDB Deployment",
                "Insert the Data",
                "Basic Aggregation Example",
                "Explain Aggregation Example",
                "Aggregation Expression Example"
            ],
            "paragraphs": "In this guide, you can learn how to use  aggregation operations  in the MongoDB Java driver. Aggregation operations process data in your MongoDB collections and return computed results. MongoDB's Aggregation\npipeline, part of the Query API, is modeled on the concept of data processing pipelines. Documents enter a multi-staged pipeline that\ntransforms the documents into an aggregated result. Another way to think of aggregation is like a car factory. Within the car factory is an assembly line, along which\nare assembly stations with specialized tools to do a specific job, like drills and welders. Raw parts enter the factory,\nwhich are then transformed and assembled into a finished product. The  aggregation pipeline  is the assembly line,  aggregation stages  are the assembly stations, and\n operator expressions  are the specialized tools. Using  find  operations, you can: Using  aggregation  operations, you can: Aggregation operations have some  limitations  you must keep in mind: select  what  documents to return select  what  fields to return sort the results perform all  find  operations rename fields calculate fields summarize data group values Returned documents must not violate the  BSON document size limit \nof 16 megabytes. Pipeline stages have a memory limit of 100 megabytes by default. If required, you may exceed this limit by using\nthe  allowDiskUse \nmethod. The  $graphLookup  stage has a strict memory limit of 100 megabytes\nand will ignore  allowDiskUse . Aggregation pipeline Aggregation stages Operator expressions Aggregation Builders Create a new Java file called  AggTour.java  and include the following import statements: For information on connecting to MongoDB, see the  Connection Guide To perform an aggregation, pass a list of aggregation stages to the\n MongoCollection.aggregate()  method. The Java driver provides the\n Aggregates \nhelper class that contains builders for aggregation stages. In the following example, the aggregation pipeline: The preceding aggregation should produce the following results: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Uses a  $match  stage to filter for documents whose\n categories  array field contains the element  Bakery . The example uses\n Aggregates.match  to build the  $match  stage. Uses a  $group  stage to group the matching documents by the  stars \nfield, accumulating a count of documents for each distinct value of  stars . You can build the expressions used in this example using the  aggregation builders . MongoCollection.aggregate() Aggregates.match To view information about how MongoDB executes your operation, use the\n explain()  method of the  AggregateIterable  class. The  explain() \nmethod returns  execution plans  and performance statistics. An execution\nplan is a potential way MongoDB can complete an operation.\nThe  explain()  method provides both the winning plan (the plan MongoDB\nexecuted) and rejected plans. In the following example, we print the JSON representation of the\nwinning plans for aggregation stages that produce execution plans: The preceding code snippet should produce the following output: For more information about the topics mentioned in this section, see the\nfollowing resources: You can specify the level of detail of your explanation by passing a\nverbosity level to the  explain()  method. The following table shows all verbosity levels for explanations and\ntheir intended use cases: Verbosity Level Use Case ALL_PLANS_EXECUTIONS You want to know which plan MongoDB will choose to run your query. EXECUTION_STATS You want to know if your query is performing well. QUERY_PLANNER You have a problem with your query and you want as much information\nas possible to diagnose the issue. Explain Output  Server Manual Entry Query Plans  Server Manual Entry ExplainVerbosity  API Documentation explain()  API Documentation AggregateIterable  API Documentation The Java driver provides builders for accumulator expressions for use with\n $group . You must declare all other expressions in JSON format or\ncompatible document format. In the following example, the aggregation pipeline uses a\n $project  stage and various  Projections  to return the  name \nfield and the calculated field  firstCategory  whose value is the\nfirst element in the  categories  field. The preceding aggregation should produce the following results: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: The syntax in either of the following examples will define an  $arrayElemAt \nexpression. The  $  in front of \"categories\" tells MongoDB that this is a  field path ,\nusing the \"categories\" field from the input document. Accumulators $group $project Projections",
            "code": [
                {
                    "lang": "java",
                    "value": "\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.ExplainVerbosity;\nimport com.mongodb.client.model.Accumulators;\nimport com.mongodb.client.model.Aggregates;\nimport com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.Projections;\nimport org.bson.Document;\n\nimport java.util.Arrays;\nimport java.util.List;\n"
                },
                {
                    "lang": "java",
                    "value": "public class AggTour {\n\n    public static void main(String[] args) {\n        // Replace the uri string with your MongoDB deployment's connection string\n        String uri = \"<connection string uri>\";\n\n        MongoClient mongoClient = MongoClients.create(uri);\n        MongoDatabase database = mongoClient.getDatabase(\"aggregation\");\n        MongoCollection<Document> collection = database.getCollection(\"restaurants\");\n\n        // aggregation here\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "collection.insertMany(Arrays.asList(\n    new Document(\"name\", \"Sun Bakery Trattoria\").append(\"contact\", new Document().append(\"phone\", \"386-555-0189\").append(\"email\", \"SunBakeryTrattoria@example.org\").append(\"location\", Arrays.asList(-74.0056649, 40.7452371))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Pizza\", \"Pasta\", \"Italian\", \"Coffee\", \"Sandwiches\")),\n    new Document(\"name\", \"Blue Bagels Grill\").append(\"contact\", new Document().append(\"phone\", \"786-555-0102\").append(\"email\", \"BlueBagelsGrill@example.com\").append(\"location\", Arrays.asList(-73.92506, 40.8275556))).append(\"stars\", 3).append(\"categories\", Arrays.asList(\"Bagels\", \"Cookies\", \"Sandwiches\")),\n    new Document(\"name\", \"XYZ Bagels Restaurant\").append(\"contact\", new Document().append(\"phone\", \"435-555-0190\").append(\"email\", \"XYZBagelsRestaurant@example.net\").append(\"location\", Arrays.asList(-74.0707363, 40.59321569999999))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Bagels\", \"Sandwiches\", \"Coffee\")),\n    new Document(\"name\", \"Hot Bakery Cafe\").append(\"contact\", new Document().append(\"phone\", \"264-555-0171\").append(\"email\", \"HotBakeryCafe@example.net\").append(\"location\", Arrays.asList(-73.96485799999999, 40.761899))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Bakery\", \"Cafe\", \"Coffee\", \"Dessert\")),\n    new Document(\"name\", \"Green Feast Pizzeria\").append(\"contact\", new Document().append(\"phone\", \"840-555-0102\").append(\"email\", \"GreenFeastPizzeria@example.com\").append(\"location\", Arrays.asList(-74.1220973, 40.6129407))).append(\"stars\", 2).append(\"categories\", Arrays.asList(\"Pizza\", \"Italian\")),\n    new Document(\"name\", \"ZZZ Pasta Buffet\").append(\"contact\", new Document().append(\"phone\", \"769-555-0152\").append(\"email\", \"ZZZPastaBuffet@example.com\").append(\"location\", Arrays.asList(-73.9446421, 40.7253944))).append(\"stars\", 0).append(\"categories\", Arrays.asList(\"Pasta\", \"Italian\", \"Buffet\", \"Cafeteria\")),\n    new Document(\"name\", \"XYZ Coffee Bar\").append(\"contact\", new Document().append(\"phone\", \"644-555-0193\").append(\"email\", \"XYZCoffeeBar@example.net\").append(\"location\", Arrays.asList(-74.0166091, 40.6284767))).append(\"stars\", 5).append(\"categories\", Arrays.asList(\"Coffee\", \"Cafe\", \"Bakery\", \"Chocolates\")),\n    new Document(\"name\", \"456 Steak Restaurant\").append(\"contact\", new Document().append(\"phone\", \"990-555-0165\").append(\"email\", \"456SteakRestaurant@example.com\").append(\"location\", Arrays.asList(-73.9365108, 40.8497077))).append(\"stars\", 0).append(\"categories\", Arrays.asList(\"Steak\", \"Seafood\")),\n    new Document(\"name\", \"456 Cookies Shop\").append(\"contact\", new Document().append(\"phone\", \"604-555-0149\").append(\"email\", \"456CookiesShop@example.org\").append(\"location\", Arrays.asList(-73.8850023, 40.7494272))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Bakery\", \"Cookies\", \"Cake\", \"Coffee\")),\n    new Document(\"name\", \"XYZ Steak Buffet\").append(\"contact\", new Document().append(\"phone\", \"229-555-0197\").append(\"email\", \"XYZSteakBuffet@example.org\").append(\"location\", Arrays.asList(-73.9799932, 40.7660886))).append(\"stars\", 3).append(\"categories\", Arrays.asList(\"Steak\", \"Salad\", \"Chinese\"))\n));"
                },
                {
                    "lang": "none",
                    "value": "{\"_id\": 4, \"count\": 2}\n{\"_id\": 5, \"count\": 1}"
                },
                {
                    "lang": "java",
                    "value": "collection.aggregate(\n    Arrays.asList(\n        Aggregates.match(Filters.eq(\"categories\", \"Bakery\")),\n        Aggregates.group(\"$stars\", Accumulators.sum(\"count\", 1))\n    )\n// Prints the result of the aggregation operation as JSON\n).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "none",
                    "value": "{ \"stage\": \"PROJECTION_SIMPLE\",\n  \"transformBy\": {\"stars\": 1, \"_id\": 0},\n  \"inputStage\": {\n   \"stage\": \"COLLSCAN\",\n   \"filter\": {\n      \"categories\": {\"$eq\":\"bakery\"}},\n  \"direction\": \"forward\"}}"
                },
                {
                    "lang": "java",
                    "value": "Document explanation = collection.aggregate(\n    Arrays.asList(\n            Aggregates.match(Filters.eq(\"categories\", \"Bakery\")),\n            Aggregates.group(\"$stars\", Accumulators.sum(\"count\", 1))\n    )\n).explain(ExplainVerbosity.EXECUTION_STATS);\n\nList<Document> stages = explanation.get(\"stages\", List.class);\nList<String> keys = Arrays.asList(\"queryPlanner\", \"winningPlan\");\n\n// Prints the JSON representation of the winning execution plans\nfor (Document stage : stages) {\n    Document cursorStage = stage.get(\"$cursor\", Document.class);\n    if (cursorStage != null) {\n        System.out.println(cursorStage.getEmbedded(keys, Document.class).toJson());\n    }\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\": \"456 Cookies Shop\", \"firstCategory\": \"Bakery\"}\n{\"name\": \"Sun Bakery Trattoria\", \"firstCategory\": \"Pizza\"}\n{\"name\": \"456 Steak Restaurant\", \"firstCategory\": \"Steak\"}\n{\"name\": \"Blue Bagels Grill\", \"firstCategory\": \"Bagels\"}\n{\"name\": \"XYZ Steak Buffet\", \"firstCategory\": \"Steak\"}\n{\"name\": \"Hot Bakery Cafe\", \"firstCategory\": \"Bakery\"}\n{\"name\": \"Green Feast Pizzeria\", \"firstCategory\": \"Pizza\"}\n{\"name\": \"ZZZ Pasta Buffet\", \"firstCategory\": \"Pasta\"}\n{\"name\": \"XYZ Coffee Bar\", \"firstCategory\": \"Coffee\"}\n{\"name\": \"XYZ Bagels Restaurant\", \"firstCategory\": \"Bagels\"}"
                },
                {
                    "lang": "java",
                    "value": "new Document(\"$arrayElemAt\", Arrays.asList(\"$categories\", 0))"
                },
                {
                    "lang": "java",
                    "value": "Document.parse(\"{ $arrayElemAt: ['$categories', 0] }\")"
                },
                {
                    "lang": "java",
                    "value": "collection.aggregate(\n    Arrays.asList(\n        Aggregates.project(\n            Projections.fields(\n                Projections.excludeId(),\n                Projections.include(\"name\"),\n                Projections.computed(\n                    \"firstCategory\",\n                    new Document(\"$arrayElemAt\", Arrays.asList(\"$categories\", 0))\n                )\n            )\n        )\n    )\n).forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to use aggregation operations in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/gridfs",
            "title": "GridFS",
            "headings": [
                "Overview",
                "How GridFS Works",
                "Create a GridFS Bucket",
                "Store Files",
                "Upload a File Using an Input Stream",
                "Upload a File Using an Output Stream",
                "Retrieve File Information",
                "Download Files",
                "File Revisions",
                "Download a File to an Output Stream",
                "Download a File to an Input Stream",
                "Rename Files",
                "Delete Files",
                "Delete a GridFS Bucket",
                "Additional Resources"
            ],
            "paragraphs": "In this guide, you can learn how to store and retrieve large files in\nMongoDB using  GridFS . GridFS is a specification implemented by the\ndriver that describes how to split files into chunks when storing them\nand reassemble them when retrieving them. The driver implementation of\nGridFS is an abstraction that manages the operations and organization of\nthe file storage. You should use GridFS if the size of your files exceed the BSON document\nsize limit of 16MB. For more detailed information on whether GridFS is\nsuitable for your use case, see the  GridFS server manual page . See the following sections that describe GridFS operations and how to\nperform them: Create a GridFS bucket Store Files Retrieve File Information Download Files Rename Files Delete Files Delete a GridFS bucket GridFS organizes files in a  bucket , a group of MongoDB collections\nthat contain the chunks of files and information describing them. The\nbucket contains the following collections, named using the convention\ndefined in the GridFS specification: When you create a new GridFS bucket, the driver creates the preceding\ncollections, prefixed with the default bucket name  fs , unless\nyou specify a different name. The driver also creates an index on each\ncollection to ensure efficient retrieval of the files and related\nmetadata. The driver only creates the GridFS bucket on the first write\noperation if it does not already exist. The driver only creates indexes if\nthey do not exist and when the bucket is empty. For more information on\nGridFS indexes, see the server manual page on  GridFS Indexes . When storing files with GridFS, the driver splits the files into smaller\nchunks, each represented by a separate document in the  chunks  collection.\nIt also creates a document in the  files  collection that contains\na file id, file name, and other file metadata. You can upload the file from\nmemory or from a stream. See the following diagram to see how GridFS splits\nthe files when uploaded to a bucket. When retrieving files, GridFS fetches the metadata from the  files \ncollection in the specified bucket and uses the information to reconstruct\nthe file from documents in the  chunks  collection. You can read the file\ninto memory or output it to a stream. The  chunks  collection stores the binary file chunks. The  files  collection stores the file metadata. To store or retrieve files from GridFS, create a bucket or get a reference\nto an existing one on a MongoDB database. Call the  GridFSBuckets.create() \nhelper method with a  MongoDatabase  instance as the parameter to\ninstantiate a  GridFSBucket . You can use the  GridFSBucket  instance to\ncall read and write operations on the files in your bucket. To create or reference a bucket with a custom name other than the default name\n fs , pass your bucket name as the second parameter to the  create() \nmethod as shown below: For more information on the classes and methods mentioned in this section,\nsee the following API Documentation: When you call  create() , MongoDB does not create the bucket if it\ndoes not exist. Instead, MongoDB creates the bucket as necessary such\nas when you upload your first file. GridFSBuckets GridFSBucket To store a file in a GridFS bucket, you can either upload it from an instance\nof  InputStream  or write its data to a  GridFSUploadStream . For either upload process, you can specify configuration information such\nas file chunk size and other field/value pairs to store as metadata. Set\nthis information on an instance of  GridFSUploadOptions  as shown in the\nfollowing code snippet: See the  GridFSUploadOptions \nAPI Documentation for more information. This section shows you how to upload a file to a GridFS bucket using an input\nstream. The following code example shows how you can use a  FileInputStream  to\nread data from a file in your filesystem and upload it to GridFS by performing\nthe following operations: This code example prints the file id of the uploaded file after it is\nsuccessfully saved in GridFS. For more information, see the API Documentation on\n uploadFromStream() . Read from the filesystem using a  FileInputStream . Set the chunk size using  GridFSUploadOptions . Set a custom metadata field called  type  to the value \"zip archive\". Upload a file called  project.zip , specifying the GridFS file name as \"myProject.zip\". This section shows you how to upload a file to a GridFS bucket by writing to\nan output stream. The following code example shows how you can write to a\n GridFSUploadStream  to send data to GridFS by performing the following\noperations: This code example prints the file id of the uploaded file after it is\nsuccessfully saved in GridFS. For more information, see the API Documentation on\n GridFSUploadStream . Read a file named \"project.zip\" from the filesystem into a byte array. Set the chunk size using  GridFSUploadOptions . Set a custom metadata field called  type  to the value \"zip archive\". Write the bytes to a  GridFSUploadStream , assigning the file name\n\"myProject.zip\". The stream reads data into a buffer until it reaches the\nlimit specified in the  chunkSize  setting, and inserts it as a new chunk\nin the  chunks  collection. If your file upload is not successful, the operation throws an exception\nand any uploaded chunks become orphaned chunks. An  orphaned chunk  is a\ndocument in a GridFS  chunks  collection that does not reference any file id\nin the GridFS  files  collection. File chunks can become orphaned chunks\nwhen an upload or delete operation is interrupted. To remove orphaned\nchunks, you must identify them using read operations and remove them using\nwrite operations. In this section, you can learn how to retrieve file metadata stored in the\n files  collection of the GridFS bucket. The metadata contains information\nabout the file it refers to, including: To retrieve files from a GridFS bucket, call the  find()  method on\nthe  GridFSBucket  instance. The method returns a  GridFSFindIterable \nfrom which you can access the results. The following code example shows you how to retrieve and print file metadata\nfrom all your files in a GridFS bucket. Among the different ways that you can\ntraverse the retrieved results from the  GridFSFindIterable , the example\nuses a  Consumer  functional interface to print the following results: The next code example shows you how to retrieve and print the file names\nfor all files that match the fields specified in the query filter. The example\nalso calls  sort()  and  limit()  on the returned  GridFSFindIterable \nto specify the order and maximum number of results: Since  metadata  is an embedded document, the query filter specifies the\n type  field within the document using dot notation. See the server manual\nguide on how to  Query on Embedded/Nested Documents \nfor more information. For more information on the classes and methods mentioned in this section,\nsee the following resources: The id of the file The name of the file The length/size of the file The upload date and time A  metadata  document in which you can store any other information GridFSFindIterable  API Documentation GridFSBucket.find()  API Documentation Sort Results Limit the Number of Returned Results You can download a file from GridFS directly to a stream or you can save it\nto memory from a stream. You can specify the file to retrieve using either\nthe file id or file name. When your bucket contains multiple files that share the same file name,\nGridFS chooses the latest uploaded version of the file by default. To\ndifferentiate between each file that shares the same name, GridFS assigns\nfiles that share the same filename a revision number, ordered by upload time. The original file revision number is \"0\" and the next most recent file\nrevision number is \"1\". You can also specify negative values which\ncorrespond to the recency of the revision. The revision value \"-1\"\nreferences the most recent revision and \"-2\" references the next most\nrecent revision. The following code snippet shows how you can specify the second revision\nof a file in an instance of  GridFSDownloadOptions : For more information on the enumeration of revisions, see the API\ndocumentation for  GridFSDownloadOptions . You can download a file in a GridFS bucket to an output stream. The following\ncode example shows you how you can call the  downloadToStream()  method to\ndownload the first revision of the file named \"myProject.zip\" to an\n OutputStream . For more information on this method, see the\n downloadToStream() \nAPI Documentation. You can download a file in a GridFS bucket to memory by using an input\nstream. You can call the  openDownloadStream()  method on the GridFS\nbucket to open a  GridFSDownloadStream , an input stream from which you\ncan read the file. The following code example shows you how to download a file referenced by\nthe  fileId  variable into memory and print its contents as a string: For more information on this method, see the\n openDownloadStream() .\nAPI Documentation. You can update the name of a GridFS file in your bucket by calling the\n rename()  method. You must specify the file to rename by its file id\nrather than its file name. The following code example shows you how to update the name of the file referenced\nby the  fileId  variable to \"mongodbTutorial.zip\": For more information on this method, see the\n rename() \nAPI Documentation. The  rename()  method only supports updating the name of one file at\na time. To rename multiple files, retrieve a list of files matching the\nfile name from the bucket, extract the file id values from the files you\nwant to rename, and pass each file id in separate calls to the  rename() \nmethod. You can remove a file from your GridFS bucket by calling the  delete() \nmethod. You must specify the file by its file id rather than its file name. The following code example shows you how to delete the file referenced by the\n fileId  variable: For more information on this method, see the\n delete() \nAPI Documentation. The  delete()  method only supports deleting one file at a time. To\ndelete multiple files, retrieve the files from the bucket, extract\nthe file id values from the files you want to delete, and pass each file id\nin separate calls to the  delete()  method. The following code example shows you how to delete the default GridFS bucket\non the database named \"mydb\". If you need to reference a custom named bucket,\nsee the section of this guide on\n how to create a custom bucket . For more information on this method, see the\n drop() \nAPI Documentation. MongoDB GridFS specification Runnable example\n GridFSTour.java \nfrom the MongoDB Java Driver repository.",
            "code": [
                {
                    "lang": "java",
                    "value": "MongoDatabase database = mongoClient.getDatabase(\"mydb\");\nGridFSBucket gridFSBucket = GridFSBuckets.create(database);"
                },
                {
                    "lang": "java",
                    "value": "GridFSBucket gridFSBucket = GridFSBuckets.create(database, \"myCustomBucket\");"
                },
                {
                    "lang": "java",
                    "value": "GridFSUploadOptions options = new GridFSUploadOptions()\n        .chunkSizeBytes(1048576) // 1MB chunk size\n        .metadata(new Document(\"myField\", \"myValue\"));"
                },
                {
                    "lang": "java",
                    "value": "String filePath = \"/path/to/project.zip\";\ntry (InputStream streamToUploadFrom = new FileInputStream(filePath) ) {\n    // Defines options that specify configuration information for files uploaded to the bucket\n    GridFSUploadOptions options = new GridFSUploadOptions()\n            .chunkSizeBytes(1048576)\n            .metadata(new Document(\"type\", \"zip archive\"));\n\n    // Uploads a file from an input stream to the GridFS bucket\n    ObjectId fileId = gridFSBucket.uploadFromStream(\"myProject.zip\", streamToUploadFrom, options);\n\n    // Prints the \"_id\" value of the uploaded file\n    System.out.println(\"The file id of the uploaded file is: \" + fileId.toHexString());\n}"
                },
                {
                    "lang": "java",
                    "value": "Path filePath = Paths.get(\"/path/to/project.zip\");\nbyte[] data = Files.readAllBytes(filePath);\n\n// Defines options that specify configuration information for files uploaded to the bucket\nGridFSUploadOptions options = new GridFSUploadOptions()\n        .chunkSizeBytes(1048576)\n        .metadata(new Document(\"type\", \"zip archive\"));\n\ntry (GridFSUploadStream uploadStream = gridFSBucket.openUploadStream(\"myProject.zip\", options)) {\n    // Writes file data to the GridFS upload stream\n    uploadStream.write(data);\n    uploadStream.flush();\n\n    // Prints the \"_id\" value of the uploaded file\n    System.out.println(\"The file id of the uploaded file is: \" + uploadStream.getObjectId().toHexString());\n\n// Prints a message if any exceptions occur during the upload process\n} catch (Exception e) {\n    System.err.println(\"The file upload failed: \" + e);\n}"
                },
                {
                    "lang": "java",
                    "value": "gridFSBucket.find().forEach(new Consumer<GridFSFile>() {\n    @Override\n    public void accept(final GridFSFile gridFSFile) {\n        System.out.println(gridFSFile);\n    }\n});"
                },
                {
                    "lang": "java",
                    "value": "Bson query = Filters.eq(\"metadata.type\", \"zip archive\");\nBson sort = Sorts.ascending(\"filename\");\n\n// Retrieves 5 documents in the bucket that match the filter and prints metadata\ngridFSBucket.find(query)\n        .sort(sort)\n        .limit(5)\n        .forEach(new Consumer<GridFSFile>() {\n            @Override\n            public void accept(final GridFSFile gridFSFile) {\n                System.out.println(gridFSFile);\n            }\n        });"
                },
                {
                    "lang": "java",
                    "value": "GridFSDownloadOptions downloadOptions = new GridFSDownloadOptions().revision(1);"
                },
                {
                    "lang": "java",
                    "value": "GridFSDownloadOptions downloadOptions = new GridFSDownloadOptions().revision(0);\n\n// Downloads a file to an output stream\ntry (FileOutputStream streamToDownloadTo = new FileOutputStream(\"/tmp/myProject.zip\")) {\n    gridFSBucket.downloadToStream(\"myProject.zip\", streamToDownloadTo, downloadOptions);\n    streamToDownloadTo.flush();\n}"
                },
                {
                    "lang": "java",
                    "value": "ObjectId fileId = new ObjectId(\"60345d38ebfcf47030e81cc9\");\n\n// Opens an input stream to read a file containing a specified \"_id\" value and downloads the file\ntry (GridFSDownloadStream downloadStream = gridFSBucket.openDownloadStream(fileId)) {\n    int fileLength = (int) downloadStream.getGridFSFile().getLength();\n    byte[] bytesToWriteTo = new byte[fileLength];\n    downloadStream.read(bytesToWriteTo);\n\n    // Prints the downloaded file's contents as a string\n    System.out.println(new String(bytesToWriteTo, StandardCharsets.UTF_8));\n}"
                },
                {
                    "lang": "java",
                    "value": "ObjectId fileId = new ObjectId(\"60345d38ebfcf47030e81cc9\");\n\n// Renames the file that has a specified \"_id\" value to \"mongodbTutorial.zip\"\ngridFSBucket.rename(fileId, \"mongodbTutorial.zip\");"
                },
                {
                    "lang": "java",
                    "value": "ObjectId fileId = new ObjectId(\"60345d38ebfcf47030e81cc9\");\n\n// Deletes the file that has a specified \"_id\" value from the GridFS bucket\ngridFSBucket.delete(fileId);"
                },
                {
                    "lang": "java",
                    "value": "MongoDatabase database = mongoClient.getDatabase(\"mydb\");\nGridFSBucket gridFSBucket = GridFSBuckets.create(database);\ngridFSBucket.drop();"
                }
            ],
            "preview": "In this guide, you can learn how to store and retrieve large files in\nMongoDB using GridFS. GridFS is a specification implemented by the\ndriver that describes how to split files into chunks when storing them\nand reassemble them when retrieving them. The driver implementation of\nGridFS is an abstraction that manages the operations and organization of\nthe file storage.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders/indexes",
            "title": "Indexes Builders",
            "headings": [
                "Overview",
                "Ascending Indexes",
                "Descending Indexes",
                "Compound Indexes",
                "Text Indexes",
                "Hashed Indexes",
                "Geospatial Indexes"
            ],
            "paragraphs": "In this guide, you can learn how to specify  indexes  using\n builders  in the MongoDB Java driver.\nThe  Indexes  builder provides helper methods for constructing the\nfollowing types of indexes: Indexes store a subset of the collection\u2019s data set. The index stores\nthe value of a specific field or set of fields, ordered by the value of\nthe field. See our guide on  Indexes  for\nexamples of queries covered by indexes. The  Indexes  class provides static factory methods for all the MongoDB index types.\nEach method returns a  BSON \ninstance, which you can pass to\n createIndex() . Ascending Indexes Descending Indexes Compound Indexes Text Indexes Hashed Indexes Geospatial Indexes For brevity, you may choose to import all methods of the\n Indexes \nclass statically: The following examples assume this static import. An ascending index enables you to sort query results by the value of the\nindexed fields from smallest to largest. In order to create an ascending index, first call the\n ascending() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name or names of the fields you want to index.\nThen, call the  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies an ascending index on the  name  field: If you have an ascending or a descending index on a single field, MongoDB\ncan sort using the index in either direction. A descending index enables you to sort query results by the value of the\nindexed fields from largest to smallest. In order to create a descending index, first call the\n descending() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name or names of the fields you want to index.\nThen, call the  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a descending index on the  capacity  field: In order to create a compound index, first call the\n compoundIndex() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the names of the fields you want to index. Then, call\nthe  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a compound index composed of\ndescending index on the  capacity  and  year  field, followed\nby an ascending index on the  name  field: A text index groups documents by the text in the indexed field. In order to create a text index, first call the\n text() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name of the fields you want to index. Then, call\nthe  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a text index key on the \"theaters\" field: A hashed index groups documents by the hash value in the indexed field. In order to create a hashed index, first call the\n hashed() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name of the fields you want to index. Then, call\nthe  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a hashed index on the  capacity \nfield: A  2dsphere  index groups documents by the coordinates in the indexed field. In order to create a  2dsphere  index, first call the\n geo2dsphere() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name or names of the fields you want to index.\nThen, call the  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a  2dsphere  index on the  location  field:",
            "code": [
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Indexes.*;"
                },
                {
                    "lang": "java",
                    "value": "Bson ascendingIndex = ascending(\"name\");\ncollection.createIndex(ascendingIndex);"
                },
                {
                    "lang": "java",
                    "value": "Bson descendingIndex = descending(\"capacity\");\ncollection.createIndex(descendingIndex);"
                },
                {
                    "lang": "java",
                    "value": "Bson compoundIndexExample = compoundIndex(descending(\"capacity\", \"year\"), ascending(\"name\"));\ncollection.createIndex(compoundIndexExample);"
                },
                {
                    "lang": "java",
                    "value": "Bson textIndex = text(\"theaters\");\ncollection.createIndex(textIndex);"
                },
                {
                    "lang": "java",
                    "value": "Bson hashedIndex = hashed(\"capacity\");\ncollection.createIndex(hashedIndex);"
                },
                {
                    "lang": "java",
                    "value": "Bson geo2dsphereIndex = geo2dsphere(\"location\");\ncollection.createIndex(geo2dsphereIndex);"
                }
            ],
            "preview": "In this guide, you can learn how to specify indexes using\nbuilders in the MongoDB Java driver.\nThe Indexes builder provides helper methods for constructing the\nfollowing types of indexes:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders/projections",
            "title": "Projections Builders",
            "headings": [
                "Overview",
                "Sample Documents and Examples",
                "Projection Operations",
                "Inclusion",
                "Exclusion",
                "Combining Projections",
                "Exclusion of _id",
                "Project an Array Element Match",
                "Project an Array Slice",
                "Project a Text Score"
            ],
            "paragraphs": "In this guide, you can learn how to specify  projections  using\n builders  in the MongoDB Java driver. MongoDB supports  field projection , specifying which fields to include and exclude when returning results from a\nquery. Projection in MongoDB follows some basic rules: Find more information about projection mechanics  here . The  Projections  class provides static factory methods for\nall the MongoDB projection operators. Each method returns an instance of the  BSON  type which you can pass\nto any method that expects a projection. The  _id  field is  always  included unless explicitly excluded Specifying a field for inclusion implicitly excludes all other fields  except  the  _id  field Specifying a field for exclusion removes  only  that field in a query result For brevity, you may choose to import the methods of the\n Projections \nclass statically: The following examples assume this static import. The following sections feature examples that run query and projection operations\non a sample collection called  projection_builders . Each section uses\na variable named  collection  to refer to the  MongoCollection  instance\nof the  projection_builders  collection. The collection contains the following documents, representing the monthly average\ntemperatures in Celsius for the years 2018 and 2019: The following sections contain information on the available projection\noperations and how to construct them using the  Projections  class. Use the  include()  method to specify the inclusion of one or more fields. The following example includes the  year  field and (implicitly) the  _id  field: The following code shows the output from this projection: The following example includes the  year  and  type  fields and (implicitly) the  _id  field: The following code shows the output from this projection: Use the  exclude()  method to specify the exclusion of one or more fields. The following example excludes the  temperatures  field: The following code shows the output from this projection: The following example excludes the  type  and  temperatures  fields: The following code shows the output from this projection: Use the  fields()  method to combine multiple projections. The following example includes the  year  and  type  fields and excludes the\n _id  field: The following code shows the output from this projection: Use the  excludeId()  convenience method to specify the exclusion of the  _id  field: The following code shows the output from this projection: Use the  elemMatch(String, Bson)  method variant to specify an array projection that will include the first\nelement of an array that matches a supplied query filter. This filtering occurs  after  all documents matching the\nquery filter (if supplied) are retrieved. The following example projects the first element of the  temperatures  array where the  avg  field is\ngreater that  10.1 : The following code shows the output from this projection: When you've specified matching criteria in the  query  portion of your operation, use the  elemMatch(String)  method\nvariant to specify a  positional projection  to include\nthe first element of an array. Only documents that match the query filter will be retrieved. The following example projects the first element of the  temperatures  array: The following code shows the output from this projection: Only the first element that matches the specified query filter will be included, regardless of how many matches there\nmay be. In MongoDB versions < 4.4, the specified array field must appear in the query filter. Beginning in MongoDB 4.4,\nyou can use a positional project on an array field that does not appear in the query filter. Use the  slice()  method to project a  slice  of an array. The following example projects the first  6  elements of the  temperatures  array: The following code shows the output from this projection: The following example skips the first  6  elements of the  temperatures  array and projects the next  6 : The following code shows the output from this projection: Use the  metaTextScore()  method to specify a projection of the\n score of a text query The following example projects the text score as the value of the  score  field: The following code shows the output from this projection:",
            "code": [
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Projections.*;"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"year\" : 2018,\n  \"type\" : \"even number but not a leap year\",\n  \"temperatures\" : [\n    { \"month\" : \"January\", \"avg\" : 9.765 },\n    { \"month\" : \"February\", \"avg\" : 9.675 },\n    { \"month\" : \"March\", \"avg\" : 10.004 },\n    { \"month\" : \"April\", \"avg\" : 9.983 },\n    { \"month\" : \"May\", \"avg\" : 9.747 },\n    { \"month\" : \"June\", \"avg\" : 9.65 },\n    { \"month\" : \"July\", \"avg\" : 9.786 },\n    { \"month\" : \"August\", \"avg\" : 9.617 },\n    { \"month\" : \"September\", \"avg\" : 9.51 },\n    { \"month\" : \"October\", \"avg\" : 10.042 },\n    { \"month\" : \"November\", \"avg\" : 9.452 },\n    { \"month\" : \"December\", \"avg\" : 9.86 }\n  ]\n},\n{\n  \"year\" : 2019,\n  \"type\" : \"odd number, can't be a leap year\",\n  \"temperatures\" : [\n    { \"month\" : \"January\", \"avg\" : 10.023 },\n    { \"month\" : \"February\", \"avg\" : 9.808 },\n    { \"month\" : \"March\", \"avg\" : 10.43 },\n    { \"month\" : \"April\", \"avg\" : 10.175 },\n    { \"month\" : \"May\", \"avg\" : 9.648 },\n    { \"month\" : \"June\", \"avg\" : 9.686 },\n    { \"month\" : \"July\", \"avg\" : 9.794 },\n    { \"month\" : \"August\", \"avg\" : 9.741 },\n    { \"month\" : \"September\", \"avg\" : 9.84 },\n    { \"month\" : \"October\", \"avg\" : 10.15 },\n    { \"month\" : \"November\", \"avg\" : 9.84 },\n    { \"month\" : \"December\", \"avg\" : 10.366 }\n  ]\n}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018}\n{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018, \"type\": \"even number but not a leap year\"}\n{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"type\": \"odd number, can't be a leap year\"}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = include(\"year\");\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = include(\"year\", \"type\");\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018, \"type\": \"even number but not a leap year\"}\n{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"type\": \"odd number, can't be a leap year\"}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018}\n{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = exclude(\"temperatures\");\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = exclude(\"temperatures\", \"type\");\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{\"year\": 2018, \"type\": \"even number but not a leap year\"}\n{\"year\": 2019, \"type\": \"odd number, can't be a leap year\"}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = fields(include(\"year\", \"type\"), exclude(\"_id\"));\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{\"year\": 2018, \"type\": \"even number but not a leap year\"}\n{\"year\": 2019, \"type\": \"odd number, can't be a leap year\"}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = fields(include(\"year\", \"type\"), excludeId());\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018}\n{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"temperatures\": [{\"month\": \"March\", \"avg\": 10.43}]}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"temperatures\": [{\"month\": \"March\", \"avg\": 10.43}]}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = fields(include(\"year\"), elemMatch(\"temperatures\", Filters.gt(\"avg\", 10.1)));\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.gt(\"temperatures.avg\", 10.1);\nBson projection = fields(include(\"year\"), elemMatch(\"temperatures\"));\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": {\n    \"$oid\": \"6042f1bc8ee6fa2a84d2be69\"\n  },\n  \"year\": 2018,\n  \"type\": \"even number but not a leap year\",\n  \"temperatures\": [\n      ... <January-June temperature nested documents>\n  ]\n}\n{\n  \"_id\": {\n    \"$oid\": \"6042f1bc8ee6fa2a84d2be6a\"\n  },\n  \"year\": 2019,\n  \"type\": \"odd number, can't be a leap year\",\n  \"temperatures\": [\n      ... <January-June temperature nested documents>\n  ]\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": {\n    \"$oid\": \"6042f1bc8ee6fa2a84d2be69\"\n  },\n  \"year\": 2018,\n  \"type\": \"even number but not a leap year\",\n  \"temperatures\": [\n      ... <July-December temperature nested documents>\n  ]\n}\n{\n  \"_id\": {\n    \"$oid\": \"6042f1bc8ee6fa2a84d2be6a\"\n  },\n  \"year\": 2019,\n  \"type\": \"odd number, can't be a leap year\",\n  \"temperatures\": [\n      ... <July-December temperature nested documents>\n  ]\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\n// first half of the year\nBson projection = slice(\"temperatures\", 6);\ncollection.find(filter).projection(projection)\n        .forEach(doc -> System.out.println(doc.toJson(JsonWriterSettings.builder().indent(true).build())));"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\n// second half of the year\nBson projection = slice(\"temperatures\", 6, 6);\ncollection.find(filter).projection(projection)\n        .forEach(doc -> System.out.println(doc.toJson(JsonWriterSettings.builder().indent(true).build())));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"6042f1bc8ee6fa2a84d2be69\"}, \"year\": 2018, \"score\": 1.25}\n{\"_id\": {\"$oid\": \"6042f1bc8ee6fa2a84d2be6a\"}, \"year\": 2019, \"score\": 0.625}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.text(\"even number\");\nBson projection = fields(include(\"year\"), metaTextScore(\"score\"));\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to specify projections using\nbuilders in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders/sort",
            "title": "Sorts Builders",
            "headings": [
                "Overview",
                "The Sorts Class",
                "Ascending",
                "Descending",
                "Combining Sort Criteria",
                "Text Score"
            ],
            "paragraphs": "In this guide, you can learn how to specify  sort criteria  for your\nqueries using  builders  in the MongoDB Java driver. Sort criteria are the rules MongoDB uses to sort your data. Some\nexamples of sort criteria are: Builders are classes provided by the MongoDB Java driver that help you\nconstruct  BSON  objects. To learn more, see our  guide\non builders . You should read this guide if you would like to use builders to specify sort\ncriteria for your queries. If you want to learn the fundamentals of sorting in the MongoDB Java\ndriver, consider reading our\n guide on sorting . The examples on this page use a sample collection that\ncontains the following documents: Smallest number to largest number Earliest time of day to latest time of day Alphabetical order by first name The  Sorts  class is a builder that provides static factory methods for all sort\ncriteria operators supported by MongoDB. These methods return a  Bson  object\nthat you can pass to the   sort()  method of a  FindIterable  instance or to\n Aggregates.sort() . If you want to learn more about the  Aggregates \nclass, see our\n guide on the Aggregates builder . For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: Sorts BSON FindIterable Aggregates To specify an ascending sort, use the  Sorts.ascending()  static\nfactory method. Pass  Sorts.ascending() \nthe name of the field you need to sort on. The following example sorts the documents in the\n sample collection  by ascending order\non the  _id  field: The output of the preceding example should look something like this: To specify a descending sort, use the  Sorts.descending()  static factory\nmethod. Pass  Sorts.descending()  the name of the field you need to sort on. The following example sorts the documents in the\n sample collection  in descending order\non the  _id  field: The preceding example should output something like this: To combine sort criteria, use the  Sorts.orderBy()  static factory\nmethod. This method constructs an object containing an ordered list of sort\ncriteria. When performing the sort, if the leftmost sort criteria results in a\ntie, the sort uses the next sort criteria in the list to determine the order. The following example sorts the documents in the\n sample collection  in descending order\non the  letter  field, and in the event of a tie, ascending order on the\n _id  field: The output of the preceding example should look something like this: You can sort text search results by their text score, a value that indicates how\nclosely a search result matches your search string. To specify a sort by the\ntext score of a text search, use the  Sorts.metaTextScore()  static factory\nmethod. For a detailed example showing how to specify sort criteria using\nthe  Sorts.metaTextScore()  method, see\n the text search section of our sorting fundamentals guide . For more information, see the  Sorts class \nAPI Documentation.",
            "code": [
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(ascending(\"_id\"));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n..."
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.descending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(descending(\"_id\"));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n..."
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.orderBy;\nimport static com.mongodb.client.model.Sorts.ascending;\nimport static com.mongodb.client.model.Sorts.descending;\n\n// <MongoCollection setup code here>\n\nBson orderBySort = orderBy(descending(\"letter\"), ascending(\"_id\"));\ncollection.find().sort(orderBySort);"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}"
                }
            ],
            "preview": "In this guide, you can learn how to specify sort criteria for your\nqueries using builders in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders/updates",
            "title": "Updates Builders",
            "headings": [
                "Overview",
                "Field Updates",
                "Set",
                "Unset",
                "Set On Insert",
                "Increment",
                "Multiply",
                "Rename",
                "Min",
                "Max",
                "Current Date",
                "Current Timestamp",
                "Bit",
                "Array Updates",
                "Add to Set",
                "Pop",
                "Pull All",
                "Pull",
                "Push",
                "Combining Multiple Update Operators"
            ],
            "paragraphs": "In this guide, you can learn how to specify  updates  using\n builders  in the MongoDB Java driver. The  Updates  builder provides helper methods for the following types of updates: Some methods that expect updates are: The  Updates  class provides static factory methods for all the MongoDB update\noperators. Each method returns an instance of the  BSON \ntype, which you can pass to any method that expects an update argument. The examples in this guide use the following document: Field Updates Array Updates Combining Multiple Update Operators updateOne() updateMany() bulkWrite() For brevity, you may choose to import the methods of the  Updates  class statically: The following examples assume this static import. Use the  set() \nmethod to assign the value of a field in an update operation. The following example sets the value of the  qty  field to \"11\": The preceding example updates the original document to the following state: Use the  unset()  method\nto delete the value of a field in an update operation. The following example deletes the  qty  field: The preceding example updates the original document to the following state: Use the  setOnInsert() \nmethod to assign the value of a field in an update operation on an\ninsert of a document. The following example sets the value of the  qty  field to \"5\"\nif an upsert resulted in the insert of a document: The preceding example updates the original document to the following state: If the document is not inserted, no change will occur. Use the  inc() \nmethod to increment the value of a numeric field in an update operation. The following example increments the value of the  qty  field by\n\"3\": The preceding example updates the original document to the following state: Use the  mul() \nmethod to multiply the value of a numeric field in an update operation. The following example multiplies the value of the  qty  field by\n\"2\": The preceding example updates the original document to the following state: Use the  rename() \nmethod to rename the value of a field in an update operation. The following example renames the  qty  field to \"quantity\": The preceding example updates the original document to the following state: Use the  min() \nmethod to update the value of a field with the smaller number of the two\nspecified in an update operation. The preceding example updates the original document to the following state: Use the  max() \nmethod to update the value of a field with the larger number of the two\nspecified in an update operation. The following example sets the value of the  qty  field to the\nmaximum of its current value and \"8\": The preceding example updates the original document to the following state: Use the  currentDate() \nmethod to assign the value of a field in an update operation to the\ncurrent date as a  BSON date . The following example sets the value of the  lastModified  field to\nthe current date as a BSON date: The preceding example updates the original document to the following state: Use the  currentTimestamp() \nmethod to assign the value of a field in an update operation to the\ncurrent date as a  timestamp . The following example sets the value of the  lastModified  field to\nthe current date as a BSON timestamp: The preceding example updates the original document to the following state: Use the  bitwiseOr() ,\n bitwiseAnd() ,\nand  bitwiseXor() \nmethods to perform a bitwise update of the integer value of a field in\nan update operation. The following example performs a bitwise  AND  between the number\n\"10\" and the integer value of the  qty  field: The bitwise operation results in 15: The preceding example updates the original document to the following state: Use the  addToSet() \nmethod to append a value to an array if the value is not already present\nin an update operation. The following example adds the value \"C\" to the array value of\nthe  vendor  field: The preceding example updates the original document to the following state: Use the  popFirst() \nmethod to remove the first element of an array and the\n popLast() \nmethod to remove the last element of an array in an update operation. The following example pops the first element off of the array value\nof the  vendor  field: The preceding example updates the original document to the following state: Use the  pullAll() \nmethod to remove all instances of values from an existing array in\nan update operation. The following example removes vendor \"A\" and \"M\" from the  vendor  array: The preceding example updates the original document to the following state: Use the  pull() \nmethod to remove all instances of a value from an existing array in\nan update operation. The following example removes the value \"D\" from the  vendor \narray: The preceding example updates the original document to the following state: Use the  push() \nmethod to append a value to an array in an update operation. The following examples pushes \"C\" to the  vendor  array: The preceding example updates the original document to the following state: An application can update multiple fields of a single document by\ncombining two or more of the update operators described in the preceding\nsections. The following example increments the value of the  qty  field by \"6\", sets\nthe value of the  color  field to \"purple\", and pushes \"R\" to\nthe  vendor  field: The preceding example updates the original document to the following state:",
            "code": [
                {
                    "lang": "json",
                    "value": "{\n    \"_id\": 1,\n    \"color\": \"red\",\n    \"qty\": 5,\n    \"vendor\": [ \"A\", \"D\", \"M\" ],\n    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Updates.*;"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 11,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = set(\"qty\", 11);\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = unset(\"qty\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = setOnInsert(\"qty\", 7);\ncollection.updateOne(filter, update, new UpdateOptions().upsert(true));"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 8,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = inc(\"qty\", 3);\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 10,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = mul(\"qty\", 2);\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" },\n   \"quantity\": 5\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = rename(\"qty\", \"quantity\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 2,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = min(\"qty\", 2);\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 8,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = max(\"qty\", 8);\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-22T21:01:20.027Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = currentDate(\"lastModified\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$timestamp\": { \"t\": 1616446880, \"i\": 5 } }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = currentTimestamp(\"lastModified\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "none",
                    "value": "0101\n1010\n----\n1111"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 15,\n   \"vendor\": [ \"A\", \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = bitwiseOr(\"qty\", 10);\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"A\", \"D\", \"M\", \"C\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = addToSet(\"vendor\", \"C\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"D\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = popFirst(\"vendor\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"D\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = pullAll(\"vendor\", Arrays.asList(\"A\", \"M\"));\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"A\", \"M\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = pull(\"vendor\", \"D\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [ \"A\", \"D\", \"M\", \"C\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = push(\"vendor\", \"C\");\ncollection.updateOne(filter, update);"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\": 1,\n   \"color\": \"purple\",\n   \"qty\": 11,\n   \"vendor\": [ \"A\", \"D\", \"M\", \"R\" ],\n   \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = eq(\"_id\", 1);\nBson update = combine(set(\"color\", \"purple\"), inc(\"qty\", 6), push(\"vendor\", \"R\"));\ncollection.updateOne(filter, update);"
                }
            ],
            "preview": "In this guide, you can learn how to specify updates using\nbuilders in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/query-document",
            "title": "Specify a Query",
            "headings": [
                "Overview",
                "Comparison Operators",
                "Logical Operators",
                "Array Operators",
                "Element Operators",
                "Evaluation Operators"
            ],
            "paragraphs": "In this guide, you can learn how to specify a query in the MongoDB Java\ndriver. Most CRUD operations allow you to narrow the set of matched documents by\nspecifying matching criteria in a  query filter . Query filters\ncontain one or more query operators that apply to specific fields which\ndetermine which documents to include in the result set. In this page, we cover the following query operators with\nexamples on how to use them: The examples in this guide use the following documents in the\n paint_purchases  collection: Comparison Operators Logical Operators Array Operators Element Operators Evaluation Operators Comparison operators query data based on comparisons with values in a\ncollection. Common comparison operators include  gt()  for \"greater\nthan\" comparisons,  lte()  for \"less than or equal to\" comparisons,\nand  ne()  for \"not equal to \" comparisons. The following example uses the  Filters.gt()  method to match all\ndocuments where the value of  qty  is greater than  7  in the\n paint_purchases  collection: The following shows the output of the preceding query: Logical operators query data using logic applied to the results of\nfield-level operators. Common logical operators include  and()  where\nall operators must be true, and  or()  where at least one of the\noperators must be true. The following example uses the  Filters.and()  method to match\ndocuments where the value of  qty  is less than or equal to  5  and\nthe value of  color  is not  \"pink\"  in the  paint_purchases \ncollection: The following shows the output of the preceding query: Array operators query data based on the value or quantity of elements in\nan array field. The following example uses the  Filters.size()  method to match\ndocuments where the size of the  vendor  list is  3  in the\n paint_purchases  collection: The following shows the output of the preceding query: Element operators query data based on the presence or type of a field. The following example uses the  Filters.exists()  method to match\ndocuments that have a  rating  in the  paint_purchases  collection: The following shows the output of the preceding query: Evaluation operators query data on higher level logic, like regex\nand text searches. The following example uses the  Filters.regex()  method to match\ndocuments that have a  color  ending with the letter  \"k\"  in the\n paint_purchases  collection: The following shows the output of the preceding query: For more information about the operators mentioned in this guide,\nsee the following Server Manual Entries: Query Operators Comparison Operators Logical Operators Array Operators Element Operators Evaluation Operators",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 9, \"vendor\": [\"A\", \"E\"] }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 5, \"vendor\": [\"A\", \"E\"] }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"], \"rating\": 9 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 4, \"vendor\": [\"A\", \"B\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 3, \"vendor\": [\"C\"] }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 }\n{ \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] }"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 9, \"vendor\": [\"A\", \"E\"] }\n { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }\n { \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.gt(\"qty\", 7);\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 3, \"color\": \"blue\", \"qty\": 5, \"vendor\": [\"A\", \"E\"] }\n { \"_id\": 5, \"color\": \"yellow\", \"qty\": 4, \"vendor\": [\"A\", \"B\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.and(Filters.lte(\"qty\", 5), Filters.ne(\"color\", \"pink\"));\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }\n { \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.size(\"vendor\", 3);\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }\n { \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"], \"rating\": 9 }\n { \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.exists(\"rating\");\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 6, \"color\": \"pink\", \"qty\": 3, \"vendor\": [\"C\"] }\n { \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.regex(\"color\", \"k$\");\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to specify a query in the MongoDB Java\ndriver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations",
            "title": "Read Operations",
            "headings": [],
            "paragraphs": "Retrieve Data Access Data From a Cursor Sort Results Skip Returned Results Limit the Number of Returned Results Specify Which Fields to Return Search Geospatially Search Text",
            "code": [],
            "preview": "Learn about the commands for running read operations on MongoDB by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations",
            "title": "Write Operations",
            "headings": [],
            "paragraphs": "Insert Operations Delete Documents Modify Documents Update Arrays in a Document Insert or Update in a Single Operation Bulk Operations",
            "code": [],
            "preview": "Learn about the commands for running MongoDB write operations by using the MongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders/filters",
            "title": "Filters Builders",
            "headings": [
                "Overview",
                "Comparison",
                "Logical",
                "Arrays",
                "Elements",
                "Evaluation",
                "Bitwise",
                "Geospatial"
            ],
            "paragraphs": "In this guide, you can learn how to use  builders  to specify\n filters  for your queries in the MongoDB Java driver. Builders are classes provided by the MongoDB Java driver that help you\nconstruct  BSON  objects. To learn more, see our  guide\non builders . Filters are the operations MongoDB uses to limit your results to what\nyou want to see. Some places we use filters are: Some examples of results from queries with filters are: This guide shows you how to use builders with examples of the following\ntypes of operators: The  Filters  class provides static factory methods for all the MongoDB query\noperators. Each method returns an instance of the  BSON \ntype, which you can pass to any method that expects a query filter. The Filter examples in this guide use the following sample collections: Collection:  paint_purchases Collection:  binary_numbers Collection:  geo_points find() match stage of aggregation deleteOne() / deleteMany() updateOne() / updateMany() Items that cost $0 to $25 A hotel with amenities that include an indoor swimming pool and free parking A food critic review that mentions \"spicy\" Comparison Logical Arrays Elements Evaluation Bitwise Geospatial For brevity, you may choose to import all methods of the\n Filters \nclass statically: The following examples assume this static import. The comparison filters include all operators that compare the value in a\ndocument to a specified value. The comparison operator methods include: The following example creates a filter that matches all documents where\nthe value of the  qty  field equals \"5\" in the  paint_purchases  collection: The following shows the output of the preceding query: The following example creates a filter that matches all documents where\nthe value of the  qty  field is greater than or equal to \"10\" in the\n paint_purchases  collection: The following shows the output of the preceding query: The following example creates a filter that matches all documents in\nthe  paint_purchases  collection because the predicate is empty: The output of the preceding query consists of\nall the documents in the collection. Comparison Method Matches eq() values equal to a specified value. gt() values greater than a specified value. gte() values greater than or equal to a specified value. lt() values less than a specified value. lte() values less than or equal to a specified value. ne() values not equal to a specified value. in() any of the values specified in an array. nin() none of the values specified in an array. empty() all the documents. The logical operators perform logical operations based on the conditions of the specified method. The logical operator methods include: The following example creates a filter that matches documents where\nthe value of the  qty  field is greater than \"8\" or the value\nof the  color  field equals \"pink\" in the  paint_purchases  collection: The following shows the output of the preceding query: Logical Method Matches and() documents with the conditions of all the filters. This operator joins filters with a logical  AND . or() documents with the conditions of either filter. This operator joins filters with a logical  OR . not() documents that do not match the filter. nor() documents that fail to match both filters. This operator joins filters with a logical  NOR . The array operators evaluate the array field in a document. The array operator methods include: The following example matches documents with a  vendors  array\ncontaining both \"A\" and \"D\" in the  paint_purchases  collection: The following shows the output of the preceding query: Array Method Matches all() documents if the array field contains every element specified in the query. elemMatch() documents if an element in the array field matches all the specified conditions. size() documents if the array field is a specified number of elements. The elements operators evaluate the nature of a specified field. The elements operator methods include: The following example matches documents that have a  qty  field and\nits value does not equal \"5\" or \"8\" in the  paint_purchases  collection: The following shows the output of the preceding query: Elements Method Matches exists() documents that have the specified field. type() documents if a field is of the specified type. The evaluation operators evaluate the value of any field in a document. The evaluation operator methods include: The following example matches documents that have a  color  field\nstarting with the letter \"p\" in the  paint_purchases  collection: The following shows the output of the preceding query: Evaluation Method Matches mod() documents where a modulo operation on the value of a field contain a specified result. regex() documents where values contain a specified regular expression. text() documents which contain a specified full-text search expression. where() documents which contain a specified JavaScript expression. The bitwise operators convert a number into its binary value to\nevaluate its bits. The bitwise operator methods include: The following example matches documents that have a  bitField  field\nwith bits set at positions of the corresponding bitmask \"34\" (i.e.\n\"00100010\") in the  binary_numbers  collection: The following shows the output of the preceding query: Bitwise Method Matches bitsAllSet() documents where the specified bits of a field are set (i.e. \"1\"). bitsAllClear() documents where the specified bits of a field are clear (i.e. \"0\"). bitsAnySet() documents where at least one of the specified bits of a field are set (i.e. \"1\"). bitsAnyClear() documents where at least one of the specified bits of a field are clear (i.e. \"0\"). The geospatial operators evaluate a specified coordinate and its\nrelation to a shape or location. The geospatial operator methods include: The following example creates a filter that matches documents in which\nthe  point  field contains a GeoJSON geometry that falls within\nthe given  Polygon \nin the  geo_points  collection: The following shows the output of the preceding query: Geospatial Method Matches geoWithin() documents containing a GeoJSON geometry value that falls within a bounding GeoJSON geometry. geoWithinBox() documents containing a coordinates value that exist within the specified box. geoWithinPolygon() documents containing a coordinates value that exist within the specified polygon. geoWithinCenter() documents containing a coordinates value that exist within the specified circle. geoWithinCenterSphere() geometries containing a geospatial data value (GeoJSON or legacy coordinate pairs) that exist within the specified circle, using spherical geometry. geoIntersects() geometries that intersect with a GeoJSON geometry. The  2dsphere  index supports  $geoIntersects . near() geospatial objects in proximity to a point. Requires a geospatial index. The  2dsphere  and  2d  indexes support  $near . nearSphere() geospatial objects in proximity to a point on a sphere. Requires a geospatial index. The  2dsphere  and  2d  indexes support  $nearSphere .",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 8, \"vendor\": [\"B\", \"A\"] }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"] }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 8,\"vendor\": [\"B\", \"C\"] }\n{ \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 9, \"a\": 54, \"binaryValue\": \"00110110\" }\n{ \"_id\": 10, \"a\": 20, \"binaryValue\": \"00010100\" }\n{ \"_id\": 11, \"a\": 68, \"binaryValue\": \"1000100\" }\n{ \"_id\": 12, \"a\": 102, \"binaryValue\": \"01100110\" }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 13, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [2.0, 2.0] } }\n{ \"_id\": 14, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [5.0, 6.0] } }\n{ \"_id\": 15, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [1.0, 3.0] } }\n{ \"_id\": 16, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [4.0, 7.0] } }"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Filters.*;"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 8, \"vendor\": [\"B\", \"A\"] }\n..."
                },
                {
                    "lang": "java",
                    "value": "Bson equalComparison = eq(\"qty\", 5);\ncollection.find(equalComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "Bson gteComparison = gte(\"qty\", 10);\ncollection.find(gteComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "Bson emptyComparison = empty();\ncollection.find(emptyComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson orComparison = or(gt(\"qty\", 8), eq(\"color\", \"pink\"));\ncollection.find(orComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] }"
                },
                {
                    "lang": "java",
                    "value": "List<String> search = Arrays.asList(\"A\", \"D\");\nBson allComparison = all(\"vendor\", search);\ncollection.find(allComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"]}\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] }\n{ \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson existsComparison = and(exists(\"qty\"), nin(\"qty\", 5, 8));\ncollection.find(existsComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson regexComparison = regex(\"color\", \"^p\");\ncollection.find(regexComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 9, \"a\": 54, \"binaryValue\": \"00110110\" }\n{ \"_id\": 12, \"a\": 102, \"binaryValue\": \"01100110\" }"
                },
                {
                    "lang": "java",
                    "value": "Bson bitsComparison = bitsAllSet(\"a\", 34);\ncollection.find(bitsComparison).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 13, \"coordinates\": {\"type\": \"Point\", \"coordinates\": [2.0, 2.0]} }\n{ \"_id\": 15, \"coordinates\": {\"type\": \"Point\", \"coordinates\": [1.0, 3.0]} }"
                },
                {
                    "lang": "java",
                    "value": "Polygon square = new Polygon(Arrays.asList(new Position(0, 0), \n                                    new Position(4, 0), \n                                    new Position(4, 4), \n                                    new Position(0, 4),\n                                    new Position(0, 0)));\n\n// Prints documents that contain \"coordinates\" values that are within the bounds of the polygon passed as the filter parameter\nBson geoWithinComparison = geoWithin(\"coordinates\", square);\ncollection.find(geoWithinComparison).forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to use builders to specify\nfilters for your queries in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/builders/aggregates",
            "title": "Aggregates Builders",
            "headings": [
                "Overview",
                "Match",
                "Project",
                "Projecting Computed Fields",
                "Sample",
                "Sort",
                "Skip",
                "Limit",
                "Lookup",
                "Left Outer Join",
                "Full Join and Uncorrelated SubQueries",
                "Group",
                "Unwind",
                "Out",
                "Merge",
                "GraphLookup",
                "SortByCount",
                "ReplaceRoot",
                "AddFields",
                "Count",
                "Bucket",
                "BucketAuto",
                "Facet",
                "SetWindowFields"
            ],
            "paragraphs": "In this guide, you can learn how to use the  Aggregates \nclass which provides static factory methods that build  aggregation pipeline\nstages  in the MongoDB Java driver. For a more thorough introduction to Aggregation, see our  Aggregation guide . Use these methods to construct pipeline stages and specify them in your\naggregation as a list: For brevity, you may choose to import the methods of the following\nclasses statically to make your queries more succinct: The examples on this page assume these static imports, in addition to\nstatically importing the  asList()  method. Aggregates Filters Projections Sorts Accumulators Use the  match()  method to create a  $match \npipeline stage that matches incoming documents against the specified\nquery filter, filtering out documents that do not match. The following example creates a pipeline stage that matches all documents where the\n title  field is equal to \"The Shawshank Redemption\": The filter can be an instance of any class that implements  Bson , but it's\nconvenient to combine with use of the  Filters  class. Use the  project()  method to create a  $project \npipeline stage that project specified document fields. Field projection\nin aggregation follows the same rules as  field projection in queries . The following example creates a pipeline stage that excludes the  _id  field but\nincludes the  title  and  plot  fields: Though the projection can be an instance of any class that implements  Bson ,\nit's convenient to combine with use of  Projections . The  $project  stage can project computed fields as well. The following example creates a pipeline stage that projects the  rated  field\ninto a new field called  rating , effectively renaming the field. Use the  sample()  method to create a  $sample \npipeline stage to randomly select documents from input. The following example creates a pipeline stage that randomly selects 5 documents: Use the  sort()  method to create a   $sort \npipeline stage to sort by the specified criteria. The following example creates a pipeline stage that sorts in descending order according\nto the value of the  year  field and then in ascending order according to the\nvalue of the  title  field: Though the sort criteria can be an instance of any class that\nimplements  Bson , it's convenient to combine with use of  Sorts . Use the  skip()  method to create a  $skip \npipeline stage to skip over the specified number of documents before\npassing documents into the next stage. The following example creates a pipeline stage that skips the first  5  documents: Use the  $limit  pipeline stage\nto limit the number of documents passed to the next stage. The following example creates a pipeline stage that limits the number of documents to  10 : Use the  lookup()  method to create a  $lookup \npipeline stage to perform joins and uncorrelated subqueries between two collections. The following example creates a pipeline stage that performs a left outer\njoin between the  movies  and  comments  collections: It joins the  _id  field from  movies  to the  movie_id  field in  comments It outputs the results in the  joined_comments  field: The following example creates a pipeline stage that joins two collections,  orders \nand  warehouses , by the item and whether the available quantity is enough\nto fulfill the ordered quantity: Use the  group()  method to create a  $group \npipeline stage to group documents by a specified expression and output a document\nfor each distinct grouping. The following example creates a pipeline stage that groups documents by the value\nof the  customerId  field. Each group accumulates the sum and average\nof the values of the  quantity  field into the  totalQuantity  and\n averageQuantity  fields. The driver includes the  Accumulators \nclass with static factory methods for each of the supported accumulators. Use the  unwind()  method to create an  $unwind \npipeline stage to deconstruct an array field from input documents, creating\nan output document for each array element. The following example creates a document for each element in the  sizes  array: To preserve documents that have missing or  null \nvalues for the array field, or where array is empty: To include the array index, in this example in a field called  \"position\" : Use the  out()  method to create an  $out \npipeline stage that writes all documents to the specified collection in\nthe same database. The following example writes the results of the pipeline to the  authors \ncollection: The  $out  stage must be the last stage in any aggregation pipeline. Use the  merge()  method to create a  $merge \npipeline stage that merges all documents into the specified collection. The following example merges the pipeline into the  authors  collection using the default\noptions: The following example merges the pipeline into the  customers  collection in the\n reporting  database using some options that specify to replace\nthe document if both  date  and  customerId  match, otherwise insert the\ndocument: The  $merge  stage must be the last stage in any aggregation pipeline. Use the  graphLookup()  method to create a  $graphLookup \npipeline stage that performs a recursive search on a specified collection to match\na specified field in one document to a specified field of another document. The following example computes the social network graph for users in the\n contacts  collection, recursively matching the value in the  friends  field\nto the  name  field: Using  GraphLookupOptions , you can specify the depth to recurse as well as\nthe name of the depth field, if desired. In this example,  $graphLookup  will\nrecurse up to two times, and create a field called  degrees  with the\nrecursion depth information for every document. Using  GraphLookupOptions , you can specify a filter that documents must match\nin order for MongoDB to include them in your search. In this\nexample, only links with \"golf\" in their  hobbies  field will be included. Use the  sortByCount()  method to create a  $sortByCount \npipeline stage that groups documents by a given expression and then sorts\nthese groups by count in descending order. The following example groups documents by the truncated value of the field  x \nand computes the count for each distinct value: The  $sortByCount  stage is identical to a  $group  stage with a\n $sum  accumulator followed by a  $sort  stage. Use the  replaceRoot()  method to create a  $replaceRoot \npipeline stage that replaces each input document with the specified document. The following example replaces each input document with the nested document\nin the  spanish_translation  field: Use the  addFields()  method to create an  $addFields \npipeline stage that adds new fields to documents. Th following example adds two new fields,  a  and  b  to the input documents: Use  $addFields  when you do not want to project field inclusion\nor exclusion. Use the  count()  method to create a  $count \npipeline stage that counts the number of documents that enter the stage, and assigns\nthat value to a specified field name. If you do not specify a field,\n count()  defaults the field name to \"count\". The following example creates a pipeline stage that outputs the count of incoming\ndocuments in a field called \"total\": The  $count  stage is syntactic sugar for: Use the  bucket()  method to create a  $bucket \npipeline stage that automates the bucketing of data around predefined boundary\nvalues. The following example creates a pipeline stage that groups incoming documents based\non the value of their  screenSize  field, inclusive of the lower boundary\nand exclusive of the upper boundary. Use the  BucketOptions  class to specify a default bucket for values\noutside of the specified boundaries, and to specify additional accumulators. The following example creates a pipeline stage that groups incoming documents based\non the value of their  screenSize  field, counting the number of documents\nthat fall within each bucket, pushing the value of  screenSize  into a\nfield called  matches , and capturing any screen sizes greater than \"70\"\ninto a bucket called \"monster\" for monstrously large screen sizes: The driver includes the  Accumulators \nclass with static factory methods for each of the supported accumulators. Use the  bucketAuto()  method to create a  $bucketAuto \npipeline stage that automatically determines the boundaries of each bucket\nin its attempt to distribute the documents evenly into a specified number of buckets. The following example creates a pipeline stage that will attempt to create and evenly\ndistribute documents into  10  buckets using the value of their  price  field: Use the  BucketAutoOptions  class to specify a  preferred number \nbased scheme to set boundary values, and specify additional accumulators. The following example creates a pipeline stage that will attempt to create and evenly\ndistribute documents into  10  buckets using the value of their  price  field,\nsetting the bucket boundaries at powers of 2 (2, 4, 8, 16, ...). It also counts\nthe number of documents in each bucket, and calculates their average  price \nin a new field called  avgPrice : The driver includes the  Accumulators \nclass with static factory methods for each of the supported accumulators. Use the  facet()  method to create a  $facet \npipeline stage that allows for the definition of parallel pipelines. The following example creates a pipeline stage that executes two parallel aggregations: The first aggregation distributes incoming documents into 5 groups according to\ntheir  attributes.screen_size  field. The second aggregation counts all  manufacturers  and returns their count, limited\nto the top  5 . Use the  setWindowFields()  method to create a  $setWindowFields \npipeline stage that allows using window operators to perform operations\non a specified span of documents in a collection. The following example creates a pipeline stage that computes the\naccumulated rainfall and the average temperature over the past month for\neach locality from more fine-grained measurements presented in the  rainfall \nand  temperature  fields: The driver includes the  WindowedComputations \nclass with static factory methods for each of the supported window operators.",
            "code": [
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Aggregates.*;\nimport static com.mongodb.client.model.Filters.*;\nimport static com.mongodb.client.model.Projections.*;\nimport static com.mongodb.client.model.Sorts.*;\nimport static com.mongodb.client.model.Accumulators.*;\nimport static java.util.Arrays.asList;"
                },
                {
                    "lang": "java",
                    "value": "Bson matchStage = match(eq(\"some_field\", \"some_criteria\"));\nBson sortByCountStage = sortByCount(\"some_field\");\ncollection.aggregate(asList(matchStage, sortByCountStage)).forEach(doc -> System.out.println(doc));"
                },
                {
                    "lang": "java",
                    "value": "match(eq(\"title\", \"The Shawshank Redemption\"));"
                },
                {
                    "lang": "java",
                    "value": "project(fields(include(\"title\", \"plot\"), excludeId()));"
                },
                {
                    "lang": "java",
                    "value": "project(fields(computed(\"rating\", \"$rated\"), excludeId()));"
                },
                {
                    "lang": "java",
                    "value": "sample(5);"
                },
                {
                    "lang": "java",
                    "value": "sort(orderBy(descending(\"year\"), ascending(\"title\")));"
                },
                {
                    "lang": "java",
                    "value": "skip(5);"
                },
                {
                    "lang": "java",
                    "value": "limit(10);"
                },
                {
                    "lang": "java",
                    "value": "lookup(\"comments\", \"_id\", \"movie_id\", \"joined_comments\");"
                },
                {
                    "lang": "java",
                    "value": "List<Variable<String>> variables = asList(new Variable<>(\"order_item\", \"$item\"),\n        new Variable<>(\"order_qty\", \"$ordered\"));\n\nList<Bson> pipeline = asList(\n        match(expr(new Document(\"$and\",\n                asList(new Document(\"$eq\", asList(\"$$order_item\", \"$stock_item\")),\n                        new Document(\"$gte\", asList(\"$instock\", \"$$order_qty\")))))),\n        project(fields(exclude(\"stock_item\"), excludeId())));\n\nList<Bson> innerJoinLookup = lookup(\"warehouses\", variables, pipeline, \"stockdata\");"
                },
                {
                    "lang": "java",
                    "value": "group(\"$customerId\", sum(\"totalQuantity\", \"$quantity\"), avg(\"averageQuantity\", \"$quantity\"));"
                },
                {
                    "lang": "java",
                    "value": "unwind(\"$sizes\");"
                },
                {
                    "lang": "java",
                    "value": "unwind(\"$sizes\", new UnwindOptions().preserveNullAndEmptyArrays(true));"
                },
                {
                    "lang": "java",
                    "value": "unwind(\"$sizes\", new UnwindOptions().includeArrayIndex(\"position\"));"
                },
                {
                    "lang": "java",
                    "value": "out(\"authors\");"
                },
                {
                    "lang": "java",
                    "value": "merge(\"authors\");"
                },
                {
                    "lang": "java",
                    "value": "merge(new MongoNamespace(\"reporting\", \"customers\"),\n        new MergeOptions().uniqueIdentifier(asList(\"date\", \"customerId\"))\n                .whenMatched(MergeOptions.WhenMatched.REPLACE)\n                .whenNotMatched(MergeOptions.WhenNotMatched.INSERT));"
                },
                {
                    "lang": "java",
                    "value": "graphLookup(\"contacts\", \"$friends\", \"friends\", \"name\", \"socialNetwork\");"
                },
                {
                    "lang": "java",
                    "value": "graphLookup(\"contacts\", \"$friends\", \"friends\", \"name\", \"socialNetwork\",\n        new GraphLookupOptions().maxDepth(2).depthField(\"degrees\"));"
                },
                {
                    "lang": "java",
                    "value": "graphLookup(\"contacts\", \"$friends\", \"friends\", \"name\", \"socialNetwork\",\n        new GraphLookupOptions().maxDepth(1).restrictSearchWithMatch(eq(\"hobbies\", \"golf\")));"
                },
                {
                    "lang": "json",
                    "value": "[\n    { \"$group\": { \"_id\": <expression to group on>, \"count\": { \"$sum\": 1 } } },\n    { \"$sort\": { \"count\": -1 } }\n]"
                },
                {
                    "lang": "java",
                    "value": "sortByCount(new Document(\"$floor\", \"$x\"));"
                },
                {
                    "lang": "java",
                    "value": "replaceRoot(\"$spanish_translation\");"
                },
                {
                    "lang": "java",
                    "value": "addFields(new Field(\"a\", 1), new Field(\"b\", 2));"
                },
                {
                    "lang": "json",
                    "value": "{ \"$group\":{ \"_id\": 0, \"count\": { \"$sum\" : 1 } } }"
                },
                {
                    "lang": "java",
                    "value": "count(\"total\");"
                },
                {
                    "lang": "java",
                    "value": "bucket(\"$screenSize\", asList(0, 24, 32, 50, 70, 200));"
                },
                {
                    "lang": "java",
                    "value": "bucket(\"$screenSize\", asList(0, 24, 32, 50, 70),\n        new BucketOptions().defaultBucket(\"monster\").output(sum(\"count\", 1), push(\"matches\", \"$screenSize\")));"
                },
                {
                    "lang": "java",
                    "value": "bucketAuto(\"$price\", 10);"
                },
                {
                    "lang": "java",
                    "value": "bucketAuto(\"$price\", 10, new BucketAutoOptions().granularity(BucketGranularity.POWERSOF2)\n        .output(sum(\"count\", 1), avg(\"avgPrice\", \"$price\")));"
                },
                {
                    "lang": "java",
                    "value": "facet(new Facet(\"Screen Sizes\",\n        bucketAuto(\"$attributes.screen_size\", 5, new BucketAutoOptions().output(sum(\"count\", 1)))),\n        new Facet(\"Manufacturer\", sortByCount(\"$attributes.manufacturer\"), limit(5)));"
                },
                {
                    "lang": "java",
                    "value": "Window pastMonth = Windows.timeRange(-1, MongoTimeUnit.MONTH, Windows.Bound.CURRENT);\nsetWindowFields(\"$localityId\", Sorts.ascending(\"measurementDateTime\"),\n        WindowedComputations.sum(\"monthlyRainfall\", \"$rainfall\", pastMonth),\n        WindowedComputations.avg(\"monthlyAvgTemp\", \"$temperature\", pastMonth));"
                }
            ],
            "preview": "In this guide, you can learn how to use the Aggregates\nclass which provides static factory methods that build aggregation pipeline\nstages in the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/compound-operations",
            "title": "Compound Operations",
            "headings": [
                "Overview",
                "How to Use Compound Operations",
                "Find and Update",
                "Example",
                "Find and Replace",
                "Example",
                "Find and Delete",
                "Example",
                "Avoiding a Race Condition",
                "Example With Race Condition",
                "Example Without Race Condition"
            ],
            "paragraphs": "In this guide, you can learn how to perform  compound operations  with\nthe MongoDB Java driver. Compound operations consist of a read and write operation performed as one\n atomic operation . An atomic operation is an operation which either completes\nentirely, or does not complete at all. Atomic operations cannot partially complete. Atomic operations can help you avoid  race conditions  in your code. A\nrace condition occurs when your code's behavior is dependent on the order of\nuncontrollable events. MongoDB supports the following compound operations: If you need to perform more complex tasks atomically, such as reading and\nwriting to more than one document, use  transactions . Transactions are a\nfeature of MongoDB and other databases that lets you define an arbitrary\nsequence of database commands as an atomic operation. For more information on atomic operations and atomicity, see\n the MongoDB manual entry for atomicity and transactions . For more information on transactions,\n see the MongoDB manual entry for transactions . Find and update one document Find and replace one document Find and delete one document This section shows how to use each compound operation with the MongoDB Java Driver. The following examples use a collection containing these two sample documents. The full code for the following examples is available on Github here. By default, each compound operation returns your found document in the state\nbefore your write operation. You can retrieve your found document in the\nstate after your write operation by using the options class corresponding to\nyour compound operation. You can see an example of this configuration in the\n Find and Replace example below . To find and update one document, use the  findOneAndUpdate()  method of the\n MongoCollection  class. The  findOneAndUpdate()  method returns your found\ndocument or  null  if no documents match your query. The following example uses the  findOneAndUpdate()  method to find a\ndocument with the  color  field set to  \"green\"  and update the\n food  field in that document to  \"pizza\" . The example also uses a  FindOneAndUpdateOptions  instance to specify the\nfollowing options: The output of the preceding code should look like this: For more information on the  Projections  class, see our\n guide on the Projections builder . For more information on the upsert operation, see our\n guide on upserts . For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Exclude the  _id  field from the found document with a projection. Specify an upsert, which inserts the document specified by the query filter if no documents match the query. Set a maximum execution time of 5 seconds for this operation on the MongoDB\ninstance. If the operation takes longer, the  findOneAndUpdate()  method\nwill throw a  MongoExecutionTimeoutException . findOneAndUpdate() FindOneAndUpdateOptions MongoExecutionTimeoutException To find and replace one document, use the  findOneAndReplace()  method of the\n MongoCollection  class. The  findOneAndReplace()  method returns your found\ndocument or  null  if no documents match your query. The following example uses the  findOneAndReplace()  method to find a\ndocument with the  color  field set to  \"green\"  and  replace it\nwith the following document: The example also uses a  FindOneAndReplaceOptions  instance to specify that\nthe returned document should be in the state after our replace operation. The output of the preceding code should look like this: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: findOneAndReplace() FindOneAndReplaceOptions To find and delete one document, use the  findOneAndDelete()  method of the\n MongoCollection  class. The  findOneAndDelete()  method returns your found\ndocument or  null  if no documents match your query. The following example uses the  findOneAndDelete()  method to find and\ndelete the document with the largest value in the  _id  field. The example uses a  FindOneAndDeleteOptions  instance to specify a\ndescending sort on the  _id  field. The output of the preceding code should look like this: For more information on the  Sorts  class, see our\n guide on the Sorts builder . For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: findOneAndDelete() FindOneAndDeleteOptions In this section we explore two examples. The first example contains a\nrace condition, the second example uses a compound operation to\navoid the race condition present in the first example. For both examples, let's imagine that we run a hotel with one room and that we\nhave a small Java program to help us checkout this room to a guest. The following document in MongoDB represents the room: The full code for this example is available on Github here. Let's say our app uses this  bookARoom  method to checkout our room to\na guest: Imagine two separate guests, Jan and Pat, try to book the room with this method\nat the same time. Jan sees this output: And Pat sees this output: When we look at our database, we see the following: Pat will be unhappy. When Pat shows up to our hotel, Jan will be\noccupying her room. What went wrong? Here is the sequence of events that happened from the perspective of our MongoDB\ninstance: Notice that for a brief moment Pat had reserved the room, but as Jan's update\noperation was the last to execute our document has  \"Jan\"  as the guest. Find and return an empty room for Jan Find and return an empty room for Pat Update the room to booked for Pat Update the room to booked for Jan Let's use a compound operation to avoid the race condition and\nalways give our users the correct message. Imagine two separate guests, Jan and Pat, try to book the room with this method\nat the same time. Jan sees this output: And Pat sees this output: When we look at our database, we see the following: Pat got the correct message. While she might be sad she didn't get the\nreservation, at least she knows not to travel to our hotel. Here is the sequence of events that happened from the perspective of our MongoDB\ninstance: For information on the  Updates  class, see our\n guide on the Updates builder . For more information of the  Filters  class, see our\n guide on the Filters builder . For more information on the  findOneAndUpdate()  method, see\nthe API Documentation for the  MongoCollection class . Find an empty room for Jan and reserve it. Try to find an empty room for Pat and reserve it. As there are not any rooms\nleft, return  null . Your MongoDB instance places a write lock on the document you are modifying\nfor the duration of your compound operation.",
            "code": [
                {
                    "lang": "json",
                    "value": " {\"_id\": 1, \"food\": \"donut\", \"color\": \"green\"}\n {\"_id\": 2, \"food\": \"pear\", \"color\": \"yellow\"}"
                },
                {
                    "lang": "json",
                    "value": "{\"food\": \"pizza\", \"color\": \"green\"}"
                },
                {
                    "lang": "java",
                    "value": "// <MongoCollection set up code here>\n\n// Creates a projection to exclude the \"_id\" field from the retrieved documents\nBson projection = Projections.excludeId();\n\n// Creates a filter to match documents with a \"color\" value of \"green\"\nBson filter = Filters.eq(\"color\", \"green\");\n\n// Creates an update document to set the value of \"food\" to \"pizza\"\nBson update = Updates.set(\"food\", \"pizza\");\n\n// Defines options that specify projected fields, permit an upsert and limit execution time\nFindOneAndUpdateOptions options = new FindOneAndUpdateOptions().\n        projection(projection).\n        upsert(true).\n        maxTime(5, TimeUnit.SECONDS);\n\n// Updates the first matching document with the content of the update document, applying the specified options\nDocument result = collection.findOneAndUpdate(filter, update, options);\n\n// Prints the matched document in its state before the operation\nSystem.out.println(result.toJson());"
                },
                {
                    "lang": "json",
                    "value": "{\"music\": \"classical\", \"color\": \"green\"}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"music\": \"classical\", \"color\": \"green\"}"
                },
                {
                    "lang": "java",
                    "value": "// <MongoCollection set up code here>\n\n// Creates instructions to replace the matching document with a new document\nBson filter = Filters.eq(\"color\", \"green\");\nDocument replace = new Document(\"music\", \"classical\").append(\"color\", \"green\");\n\n// Defines options specifying that the operation should return a document in its post-operation state\nFindOneAndReplaceOptions options = new FindOneAndReplaceOptions().\n        returnDocument(ReturnDocument.AFTER);\n\n// Atomically finds and replaces the matching document and prints the replacement document\nDocument result = collection.findOneAndReplace(filter, replace, options);\nSystem.out.println(result.toJson());"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 2, \"food\": \"pear\", \"color\": \"yellow\"}"
                },
                {
                    "lang": "java",
                    "value": "// <MongoCollection set up code here>\nBson sort = Sorts.descending(\"_id\");\n\n// Creates an empty filter to match all documents in the collection\nBson filter = Filters.empty();\n\n// Defines options that specify a descending sort on the \"_id\" field\nFindOneAndDeleteOptions options = new FindOneAndDeleteOptions().\n        sort(sort);\n\n// Deletes the document containing the highest \"_id\" value and prints the deleted document\nDocument result = collection.findOneAndDelete(filter, options);\nSystem.out.println(result.toJson());"
                },
                {
                    "lang": "json",
                    "value": " {\"_id\": 1, \"guest\": null, \"room\": \"Blue Room\", \"reserved\": false}"
                },
                {
                    "lang": "none",
                    "value": "You got the Blue Room Jan"
                },
                {
                    "lang": "none",
                    "value": "You got the Blue Room Pat"
                },
                {
                    "lang": "json",
                    "value": " {\"_id\": 1, \"guest\": \"Jan\", \"room\": \"Blue Room\", \"reserved\": true}"
                },
                {
                    "lang": "java",
                    "value": "public void bookARoom() {\n    // Creates a filter to match documents representing available rooms\n    Bson filter = Filters.eq(\"reserved\", false);\n\n    // Retrieves a document that represents the first available room\n    Document myRoom = this.collection.find(filter).first();\n\n    // Prints a message if no documents representing available rooms are found\n    if (myRoom == null){\n        System.out.println(\"Sorry, we are booked \" + this.guest);\n        return;\n    }\n\n    String myRoomName = myRoom.getString(\"room\");\n\n    // Prints a message that guest that successfully booked the room\n    System.out.println(\"You got the \" + myRoomName + \" \" + this.guest);\n\n    // Creates an update document to mark a room as reserved\n    Bson update = Updates.combine(Updates.set(\"reserved\", true), Updates.set(\"guest\", guest));\n    \n    // Creates a filter that matches the \"_id\" field of the first available room\n    Bson roomFilter = Filters.eq(\"_id\", myRoom.get(\"_id\", Integer.class));\n\n    // Updates the first matching document to mark it as reserved\n    this.collection.updateOne(roomFilter, update);\n}"
                },
                {
                    "lang": "none",
                    "value": "You got the Blue Room Jan"
                },
                {
                    "lang": "none",
                    "value": "Sorry, we are booked Pat"
                },
                {
                    "lang": "json",
                    "value": " {\"_id\":1, \"guest\":\"Jan\", \"room\":\"Blue Room\", \"reserved\":true}"
                },
                {
                    "lang": "java",
                    "value": "public void bookARoom(){\n    // Creates an update document to mark a room as reserved\n    Bson update = Updates.combine(Updates.set(\"reserved\", true), Updates.set(\"guest\", guest));\n    \n    // Creates a filter to match a document representing an available room\n    Bson filter = Filters.eq(\"reserved\", false);\n\n    // Updates the first document that matches the filter to mark it as reserved\n    Document myRoom = this.collection.findOneAndUpdate(filter, update);\n   \n    // Prints a message when there are no available rooms\n    if (myRoom == null){\n        System.out.println(\"Sorry, we are booked \" + this.guest);\n        return;\n    }\n\n    // Prints the name of the guest that successfully booked the room\n    String myRoomName = myRoom.getString(\"room\");\n    System.out.println(\"You got the \" + myRoomName + \" \" + this.guest);\n}"
                }
            ],
            "preview": "In this guide, you can learn how to perform compound operations with\nthe MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/project",
            "title": "Specify Which Fields to Return",
            "headings": [
                "Overview",
                "Behavior",
                "Explanation"
            ],
            "paragraphs": "In this guide, you can learn how to control which fields appear in\ndocuments returned from read operations with the MongoDB Java driver. Many read requests require only a subset of fields in a document.\nFor example, when logging a user in you may only need their username, and\nnot all of their profile information. By default, queries in MongoDB return\nall fields in matching documents. You can use a  projection  to return\nonly the data you need. A projection is a document that instructs MongoDB which fields of a\ndocument to return. Use the  Projections  class\nto construct a projection document. Projections work in two ways: These two methods of projection are mutually exclusive: if you\nexplicitly include fields, you cannot explicitly exclude fields, and\nvice versa. Explicitly including fields. This has the side-effect of implicitly\nexcluding all unspecified fields. Implicitly excluding fields. This has the side-effect of implicitly\nincluding all unspecified fields. The  _id  field is  not  subject to these mechanics. You must\nexplicitly exclude the  _id  field if you do not want it returned.\nYou can exclude the  _id  field even if you have specified certain\nfields to include. Consider the following collection containing documents that describe\nvarieties of fruit: In the following query, pass the projection to return the  name \nfield of each document: The projection document specifies that the read operation result should\n include  the  name  field of each returned document. As a result, this\nprojection implicitly excludes the  qty  and  rating  fields. Chaining\nthis projection to  find()  with an empty query filter yields the\nfollowing results: Despite the fact that this projection only explicitly included the\n name  field, the query returned the  _id  field as well. The  _id  field is a special case: it is always included in every query\nresult unless explicitly excluded. That's because the  _id  field is a\nunique identifier for each document, a property that can be useful when\nconstructing queries. A  movies  collection is a good example of why this property is useful:\nbecause remakes and even separate works sometimes reuse movie titles,\nyou need a unique  _id  value to refer to any specific movie. The  _id  is the only exception to the mutually exclusive include-exclude\nbehavior in projections: you  can  explicitly exclude the  _id  field\neven when explicitly including other fields if you do not want  _id \nto be present in returned documents. The projection document specifies that the read operation result should\n include  the  name  field of each returned document, and specifies to\n exclude  the  _id  field. As a result, this projection implicitly\nexcludes the  qty  and  rating  fields. Chaining this projection to\n find()  with an empty query filter yields the following results: You can also specify multiple fields to include in your projection. This example that identifies two fields to include in the projection yields\nthe following results: For additional projection examples, see the\n MongoDB Manual page on Project Fields to Return from Query . The order in which you specify the fields in the projection does not\nalter the order in which they are returned.",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 },\n{ \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 },\n{ \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 },\n{ \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 },"
                },
                {
                    "lang": "java",
                    "value": "// return all documents with *only* the name field\nBson filter = Filters.empty();\nBson projection = Projections.fields(Projections.include(\"name\"));\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"name\": \"apples\" }\n{ \"_id\": 2, \"name\": \"bananas\" }\n{ \"_id\": 3, \"name\": \"oranges\" }\n{ \"_id\": 4, \"name\": \"avocados\" }"
                },
                {
                    "lang": "java",
                    "value": "// return all documents with only the name field\nBson filter = Filters.empty();\nBson projection = Projections.fields(Projections.include(\"name\"), Projections.excludeId());\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc));"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"name\": \"apples\" }\n{ \"name\": \"bananas\" }\n{ \"name\": \"oranges\" }\n{ \"name\": \"avocados\" }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson projection = Projections.fields(Projections.include(\"name\", \"rating\"), Projections.excludeId());\ncollection.find(filter).projection(projection).forEach(doc -> System.out.println(doc));"
                },
                {
                    "lang": "json",
                    "value": "  { \"name\": \"apples\", \"rating\": 3 }\n  { \"name\": \"bananas\", \"rating\": 1 }\n  { \"name\": \"oranges\", \"rating\": 2 }\n  { \"name\": \"avocados\", \"rating\": 5 }"
                }
            ],
            "preview": "In this guide, you can learn how to control which fields appear in\ndocuments returned from read operations with the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/geo",
            "title": "Search Geospatially",
            "headings": [
                "Overview",
                "Coordinates on Earth",
                "GeoJSON Positions",
                "GeoJSON Types",
                "Index",
                "Coordinates on a 2D Plane",
                "Index",
                "Geospatial Queries",
                "Query Operators",
                "Query Parameters",
                "Examples",
                "Query by Proximity",
                "Query Within a Range"
            ],
            "paragraphs": "In this guide, you can learn how to search  geospatial data  with the\nMongoDB Java Driver, and the different geospatial data formats supported by MongoDB. Geospatial data is data that represents a geographic location on\nthe surface of the Earth. Examples of geospatial data include: Locations of movie theaters Borders of countries Routes of bicycle rides Dog exercise areas in New York City To store and query your geospatial data in MongoDB, use  GeoJSON . GeoJSON is\na data format created by the Internet Engineering Task Force (IETF). Here is the location of MongoDB headquarters in GeoJSON: For definitive information on GeoJSON, see the\n official IETF specification . A position represents a single place on Earth, and exists in code as an array\ncontaining two or three number values: Longitude in the first position (required) Latitude in the second position (required) Elevation in the third position (optional) GeoJSON orders coordinates as longitude first and latitude second. This may\nbe surprising as geographic coordinate system conventions generally list\nlatitude first and longitude second. Make sure to check what format any other\ntools you are working with use. Popular tools such as OpenStreetMap and Google\nMaps list coordinates as latitude first and longitude second. Your GeoJSON object's type determines its geometric shape. Geometric shapes are\nmade up of positions. Here are some common GeoJSON types and how you can specify them with positions: To learn more about the shapes you can use in MongoDB, see the\n GeoJSON manual entry . Point : a single position. This could represent the location of a\n sculpture . LineString : an array of two or more positions, thus forming a series of line\nsegments. This could represent\n the route of the Great Wall of China . Polygon : an array of positions in which the first and last\nposition are the same, thus enclosing some space. This could represent\n the land within Vatican City . To query data stored in the GeoJSON format, add the field containing\nGeoJSON data to a  2dsphere  index. The following snippet creates a\n 2dsphere  index on the  location.geo  field using the  Indexes  builder: For more information on the  Indexes  builder, see our\n guide on the Indexes builder . You can store geospatial data using  x  and  y  coordinates on\na two-dimensional Euclidean plane. We refer to coordinates on a two-dimensional\nplane as \"legacy coordinate pairs\". Legacy coordinate pairs have the following structure: Your field should contain an array of two values in which the first represents\nthe  x  axis value and the second represents the  y  axis value. To query data stored as legacy coordinate pairs, you must add the field containing\nlegacy coordinate pairs to  a  2d  index. The following snippet creates a\n 2d  index on the  coordinates  field using the  Indexes  builder: For more information on the  Indexes  builder, see our\n guide on the Indexes builder . For more information on legacy coordinate pairs, see the\n MongoDB Server manual page on legacy coordinate pairs . Spherical ( 2dsphere ) and flat ( 2d ) indexes support some, but\nnot all, of the same query operators. For a full list of operators\nand their index compatibility, see the\n manual entry for geospatial queries . Geospatial queries consist of a query operator and GeoJSON shapes as query\nparameters. To query your geospatial data, use one of the following query operators: You can specify these query operators in the MongoDB Java driver with the\n near() ,  geoWithin() ,  nearSphere() , and  geoIntersects()  utility\nmethods of the  Filters  builder class. For more information on geospatial query operators, see the\n manual entry for geospatial queries . For more information on  Filters , see our\n guide on the Filters builder . $near $geoWithin $nearSphere $geoIntersects   requires a 2dsphere index To specify a shape to use in a geospatial query, use the\n Position ,  Point ,  LineString , and  Polygon  classes of the MongoDB\nJava driver. For a full list of the GeoJSON shapes available in the MongoDB Java driver, see the\n GeoJSON package \nAPI Documentation. The following examples use the MongoDB Atlas sample dataset. You can learn how\nto  set up your own free-tier Atlas cluster and how to load the sample dataset\nin our  quick start guide . The examples use the  theaters  collection in the  sample_mflix  database\nfrom the sample dataset. The  theaters  collection contains a  2dsphere  index\non the  location.geo  field. The examples require the following imports: You can find the\n source code for the examples on Github here . To search for and return documents from nearest to farthest from a point, use\nthe  near()  static utility method of the  Filters  builder class. The\n near()  method constructs a query with the  $near  query operator. The following example queries for theaters between  10,000  and  5,000 \nmeters from the\n Great Lawn of Central Park . The output of the code snippet should look something like this: For more information on the  $near  operator, see\n the reference documentation for $near . For more information on  Filters ,\n see our guide on the Filters builder . MongoDB uses the\n same reference system \nas GPS satellites to calculate geometries over the Earth. To search for geospatial data within a specified shape use the  geoWithin() \nstatic utility method of the  Filters  builder class. The  geoWithin() \nmethod constructs a query with the  $geoWithin  query operator. The following example searches for movie theaters in a section of Long Island. The output of the code snippet should look something like this: The following figure shows the polygon defined by the\n longIslandTriangle  variable and dots representing the locations of\nthe movie theaters returned by our query. For more information on the  $geoWithin  operator, see the\n reference documentation for $geoWithin For more information on the operators you can use in your query, see the\n MongoDB Server manual page on geospatial query operators",
            "code": [
                {
                    "lang": "json",
                    "value": "\"MongoDB Headquarters\" : {\n   \"type\": \"point\",\n   \"coordinates\": [-73.986805, 40.7620853]\n}"
                },
                {
                    "lang": "java",
                    "value": "// <MongoCollection setup code here>\ncollection.createIndex(Indexes.geo2dsphere(\"location.geo\"));"
                },
                {
                    "lang": "json",
                    "value": "\"<field name>\" : [ x, y ]"
                },
                {
                    "lang": "java",
                    "value": "// <MongoCollection setup code here>\ncollection.createIndex(Indexes.geo2d(\"coordinates\"));"
                },
                {
                    "lang": "java",
                    "value": "import java.util.Arrays;\nimport org.bson.conversions.Bson;\nimport com.mongodb.client.model.geojson.Point;\nimport com.mongodb.client.model.geojson.Polygon;\nimport com.mongodb.client.model.geojson.Position;\nimport static com.mongodb.client.model.Filters.near;\nimport static com.mongodb.client.model.Filters.geoWithin;\nimport static com.mongodb.client.model.Projections.fields;\nimport static com.mongodb.client.model.Projections.include;\nimport static com.mongodb.client.model.Projections.excludeId;"
                },
                {
                    "lang": "json",
                    "value": "{\"location\": {\"address\": {\"city\": \"Bronx\"}}}\n{\"location\": {\"address\": {\"city\": \"New York\"}}}\n{\"location\": {\"address\": {\"city\": \"New York\"}}}\n{\"location\": {\"address\": {\"city\": \"Long Island City\"}}}\n{\"location\": {\"address\": {\"city\": \"New York\"}}}\n{\"location\": {\"address\": {\"city\": \"Secaucus\"}}}\n{\"location\": {\"address\": {\"city\": \"Jersey City\"}}}\n{\"location\": {\"address\": {\"city\": \"Elmhurst\"}}}\n{\"location\": {\"address\": {\"city\": \"Flushing\"}}}\n{\"location\": {\"address\": {\"city\": \"Flushing\"}}}\n{\"location\": {\"address\": {\"city\": \"Flushing\"}}}\n{\"location\": {\"address\": {\"city\": \"Elmhurst\"}}}"
                },
                {
                    "lang": "java",
                    "value": "\n// Add your MongoClient setup code here\nMongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\nMongoCollection<Document> collection = database.getCollection(\"theaters\");\n\nPoint centralPark = new Point(new Position(-73.9667, 40.78));\n\n// Creates a query that matches all locations between 5,000 and 10,000 meters from the specified Point\nBson query = near(\"location.geo\", centralPark, 10000.0, 5000.0);\n\n// Creates a projection to include only the \"location.address.city\" field in the results\nBson projection = fields(include(\"location.address.city\"), excludeId());\n\n// Prints the projected field of the results from the geospatial query as JSON\ncollection.find(query)\n        .projection(projection)\n        .forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{\"location\": {\"address\": {\"city\": \"Baldwin\"}}}\n{\"location\": {\"address\": {\"city\": \"Levittown\"}}}\n{\"location\": {\"address\": {\"city\": \"Westbury\"}}}\n{\"location\": {\"address\": {\"city\": \"Mount Vernon\"}}}\n{\"location\": {\"address\": {\"city\": \"Massapequa\"}}}"
                },
                {
                    "lang": "java",
                    "value": "// Add your MongoCollection setup code here\n\n// Creates a set of points that defines the bounds of a geospatial shape\nPolygon longIslandTriangle = new Polygon(Arrays.asList(new Position(-72, 40),\n        new Position(-74, 41),\n        new Position(-72, 39),\n        new Position(-72, 40)));\n\n// Creates a projection to include only the \"location.address.city\" field in the results\nBson projection = fields(include(\"location.address.city\"), excludeId());\n\n// Creates a query that matches documents containing \"location.geo\" values within the specified bounds\nBson geoWithinComparison = geoWithin(\"location.geo\", longIslandTriangle);\n\n// Prints the projected field of the results from the geolocation query as JSON\ncollection.find(geoWithinComparison)\n        .projection(projection)\n        .forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to search geospatial data with the\nMongoDB Java Driver, and the different geospatial data formats supported by MongoDB.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/skip",
            "title": "Skip Returned Results",
            "headings": [
                "Overview",
                "Examples",
                "Using a FindIterable",
                "Using Aggregation"
            ],
            "paragraphs": "In this guide, you can learn how to skip a specified number of returned\nresults from read operations with the MongoDB Java driver. You can skip results on the returned results of a query by using the\n skip()  method. You can also skip documents at a specific stage in an\naggregation pipeline by specifying a  $skip  aggregation stage. The  skip()  method takes an integer that specifies the number of documents\nto omit from the beginning of the list of documents returned by the\n FindIterable . You can use the  skip()  method to skip the first two documents as follows: Aggregates.skip() \nis an optional stage in the aggregation pipeline that specifies how many\ndocuments to omit from the beginning of the results of the prior stage. You can use the  Aggregates.skip()  method to skip the first two documents as follows: The following example is about a paint store that sells eight different\ncolors of paint.  The best colors sell quicker than the other colors.\nOne day, a customer asks what the three best-selling (lowest inventory)\ncolors are. The paint store keeps track of inventory in the  qty \nfield in their  paint_inventory  collection: To address the scenario, the paint store needs to query the\n paint_inventory  collection with an empty filter, sort the documents\nby  qty  field and omit the first five results. The  find()  method returns all documents. The  sort()  method specifies documents to display from highest to lowest based on the  qty  field. The  skip()  method specifies to omit the first five documents. The following shows the output of both preceding queries: After the paint store runs the query, they find the three best-selling colors are pink,\nred, and white. The  match()  stage returns all documents. The  sort()  stage specifies documents to display from highest to lowest based on the  qty  field. The  skip()  stage specifies to omit the first five documents. If the value of skip is greater than or equal to the number of matched\ndocuments for a query, that query returns no documents. If the  skip()  method from the preceding example skips the first nine\ndocuments, no results would return since the specified quantity\nexceeds the number of matched documents.",
            "code": [
                {
                    "lang": "java",
                    "value": "collection.find().skip(2);"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Aggregates;\n\ncollection.aggregate(Arrays.asList(Aggregates.match(), Aggregates.skip(2)));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10 }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 9 }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11 }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 3 }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 8 }\n{ \"_id\": 8, \"color\": \"orange\", \"qty\": 7 }"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.Sorts;\n\n// <MongoCollection setup code here>\n\nBson filter = Filters.empty();\ncollection.find(filter)             \n    .sort(Sorts.descending(\"qty\"))        \n    .skip(5)                       \n    .forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 4, \"color\": \"white\", \"qty\": 6 }\n{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 3 }"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.Sorts;\nimport com.mongodb.client.model.Aggregates;\n\n// <MongoCollection setup code here>\n\nBson filter = Filters.empty();\ncollection.aggregate(Arrays.asList(\n    Aggregates.match(filter), \n    Aggregates.sort(Sorts.descending(\"qty\")), \n    Aggregates.skip(5)))\n    .forEach(doc -> System.out.println(doc.toJson())); "
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\ncollection.find(filter)             \n    .sort(Sorts.descending(\"qty\"))        \n    .skip(9)                       \n    .forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to skip a specified number of returned\nresults from read operations with the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/retrieve",
            "title": "Retrieve Data",
            "headings": [
                "Overview",
                "Sample Data for Examples",
                "Find Operation",
                "Example",
                "Aggregate Operation",
                "Example",
                "Change Streams",
                "Example"
            ],
            "paragraphs": "In this guide, you can learn how to retrieve data from your MongoDB\ndatabase. To retrieve data, use read operations. Read operations allow you to do the following: Retrieve a subset of documents from your collection using a  find operation Perform transformations on retrieved documents from your collection using an  aggregate operation Monitor real-time changes to your database using a  change stream The following sections feature examples of how the owner of a paint\nstore manages their customers' orders. For each order, the owner keeps\ntrack of the color and quantity, which corresponds to the  color  and\n qty  fields in their  paint_order  collection: Use the find operation to retrieve a subset of your existing data in\nMongoDB. You can specify what data to return including which documents\nto retrieve, in what order to retrieve them, and how many to retrieve. To perform a find operation, call the  find()  method on an instance\nof a  MongoCollection . This method searches a collection for documents that\nmatch the query filter you provide. For more information on how to\nspecify a query, see our  Specify a Query  guide. The owner would like to know which orders contain greater than three, but\nless than nine cans of paint from their  paint_order collection . To address this scenario, the owner finds orders to match the criteria: For more information on how to build filters, see our  Filters Builders  guide. The following shows the output of the preceding query: After the owner runs this query, they find two orders that matched the\ncriteria. For a runnable  find()  example, see our  Find Multiple\nDocuments  page. Use the aggregate operation to perform the stages in an aggregation\npipeline.  An aggregation pipeline is a multi-staged transformation that\nproduces an aggregated result. To perform an aggregate operation, call the  aggregate()  method on an\ninstance of a  MongoCollection . This method accepts aggregation\nexpressions to run in sequence. To perform aggregations, you can\ndefine aggregation stages that specify how to match documents, rename\nfields, and group values. For more information, see our\n Aggregation  guide. The owner would like to know which paint color is the most purchased\n(highest quantity sold) from their  paint_order collection . To address the scenario, the owner creates an aggregation pipeline that: The following shows the output of the preceding aggregation: After the owner runs the aggregation, they find that \"green\" is the most\npurchased color. For more information on how to construct an aggregation pipeline, see\nthe MongoDB Server manual page on  Aggregation . Matches all the documents in the  paint_order  collection Groups orders by colors Sums up the quantity field by color Orders the results by highest-to-lowest quantity Open a change stream to monitor real-time changes to a collection.\nChange streams can subscribe to specific types of data changes and\nimmediately produce change events. For more information on change\nstreams, see the MongoDB server manual page on  Change Streams . To open a change stream, call the  watch()  method on an instance of a\n MongoCollection ,  MongoDatabase , or  MongoClient .\nYou can pass an aggregation pipeline to this method to notify you as\nsoon as a change occurs. The instance you call the  watch()  method on determines the scope of\nevents which the change stream listens for. If you call  watch()  on a\n MongoCollection , the method monitors a collection. If you call\n watch()  on a  MongoDatabase , the method monitors all the\ncollections in the database. If you call  watch()  on a\n MongoClient , the method monitors a standalone MongoDB instance, a\nreplica set, or a sharded cluster. Change streams don't support standalone MongoDB instances because\nstandalone MongoDB instances don't have an oplog. The owner would like to receive notifications for when customers submit new\norders or update their orders in the  paint_order collection . To address this scenario, the owner: After creating the change stream, the owner gets notifications for\nfuture inserts or updates to their collection. An insert notification looks similar to the following: For a runnable  watch()  example, see our  Watch For\nChanges  page. For additional information on the methods mentioned on this page, see\nthe following API Documentation: Creates an aggregation pipeline that filters for \"insert\" and \"update\" operation types Creates a change stream on the aggregation pipeline Prints changes picked up by the change stream MongoCollection.find() MongoCollection.aggregate() MongoCollection.watch() MongoDatabase.watch() MongoClient.watch()",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"purple\", \"qty\": 10 }\n{ \"_id\": 2, \"color\": \"green\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"purple\", \"qty\": 4 }\n{ \"_id\": 4, \"color\": \"green\", \"qty\": 11 }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2, \"color\": \"green\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"purple\", \"qty\": 4 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.and(Filters.gt(\"qty\", 3), Filters.lt(\"qty\", 9));\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": \"green\", \"qty\": 19 }\n{ \"_id\": \"purple\", \"qty\": 14 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\ncollection.aggregate(Arrays.asList(\n    Aggregates.match(filter), \n    Aggregates.group(\"$color\", Accumulators.sum(\"qty\", \"$qty\")),\n    Aggregates.sort(Sorts.descending(\"qty\"))))\n    .forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": null,
                    "value": "Received a change to the collection: ChangeStreamDocument{\n   operationType=OperationType{value='insert'},\n   resumeToken={\"_data\": \"825EC...\"},\n   namespace=database.collection,\n   ...\n}"
                },
                {
                    "lang": "java",
                    "value": "List<Bson> pipeline = Arrays.asList(\n    Aggregates.match(Filters.in(\"operationType\", Arrays.asList(\"insert\", \"update\"))));\n\nChangeStreamIterable<Document> changeStream = database.watch(pipeline)\n    .fullDocument(FullDocument.UPDATE_LOOKUP);\n\nchangeStream.forEach(event -> \n    System.out.println(\"Received a change to the collection: \" + event));"
                }
            ],
            "preview": "In this guide, you can learn how to retrieve data from your MongoDB\ndatabase. To retrieve data, use read operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/cursor",
            "title": "Access Data From a Cursor",
            "headings": [
                "Overview",
                "Terminal Methods",
                "First",
                "Number of Results",
                "Into",
                "Cursor",
                "Explain",
                "Usage Patterns",
                "Functional Iteration",
                "Conditional Iteration",
                "Cursor Cleanup",
                "Close",
                "Try with Resources Statement"
            ],
            "paragraphs": "In this guide, you can learn how to access data using a  cursor  with the\nMongoDB Java driver. A cursor is a mechanism that allows an application to iterate over database\nresults while only holding a subset of them in memory at a given time. The\ndriver uses cursors in read operations that match multiple documents to return\nmatched documents in batches as opposed to returning them all at once. This page uses an initiating method,  find()  to show how to access\ndata from a  FindIterable . The  find()  method creates and returns an instance of a\n FindIterable . A  FindIterable  allows you to browse the documents\nmatched by your search criteria and to further specify which documents\nto see by setting parameters through methods. The following ways to access and store data apply to\nother iterables such as an  AggregateIterable . Terminal methods execute an operation on the MongoDB deployment after\nconfiguring all parameters of an  Iterable  instance controlling the\noperation. Use the  first()  method to retrieve the first document in your query\nresults: This method is often used when your query filter will match one\ndocument, such as when filtering by a unique index. Use the  available()  method to retrieve the number of results\nlocally present without blocking: The method returns  0  if the application has already iterated though\nall the documents in the cursor or if the cursor is closed. Use the  into()  method to store your query results in a  List : This method is often used when your query filter returns a small number\nof documents that can fit into available memory. Use the  cursor()  method to iterate through fetched documents and\nensure that the cursor closes if there is an early termination: For more information on how to ensure a cursor closes, see the  cursor cleanup section . Use the  explain()  method to view information about how MongoDB\nexecutes your operation. The  explain()  method returns  execution plans  and performance\nstatistics. An execution plan is a potential way MongoDB\ncan complete an operation. The  explain()  method provides both the\nwinning plan (the plan MongoDB executed) and rejected plans. The following example prints the JSON representation of the\nwinning plan for aggregation stages that produce execution plans: The preceding code snippet should produce the following output: For more information on the explain operation, see the following\nServer Manual Entries: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: You can specify the level of detail of your explanation by passing a\nverbosity level to the  explain()  method. The following table shows all verbosity levels for explanations and\ntheir intended use cases: Verbosity Level Use Case ALL_PLANS_EXECUTIONS You want to know which plan MongoDB will choose to run your query. EXECUTION_STATS You want to know if your query is performing well. QUERY_PLANNER You have a problem with your query and you want as much information\nas possible to diagnose the issue. Explain Output Query Plans first() available() into() cursor() explain() ExplainVerbosity A  MongoCursor  and  FindIterable  allow you to access query results\none document at a time, abstracting away network and caching logic. Pass a function to the  forEach()  method of a  FindIterable  to\niterate through results in a functional style: Initiating methods return objects that implement the  Iterable  interface which allows you\nto iterate through them using iterator methods. Sometimes, we use an enhanced\nfor-each loop to iterate through results: Iterating this way is not preferable because if an exception is\nthrown before the loop completes, the cursor will not close. Using a\n MongoCursor  allows us to ensure the cursor closes as shown in the\n cursor cleanup section . Use the  hasNext()  method to check if there are any documents\navailable in the cursor, and then use the  next()  method to retrieve\nthe next available document from the cursor: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: forEach() hasNext() next() Use the  close()  method in a  finally  block to free up a cursor's\nconsumption of resources in both the client application and the MongoDB\ndeployment: Use a try-with-resources statement\nto automatically free up a cursor's consumption of resources in both the\nclient application and the MongoDB deployment: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: close() try-with-resources statement",
            "code": [
                {
                    "lang": "java",
                    "value": "FindIterable<Document> iterable = collection.find();\nSystem.out.println(iterable.first());"
                },
                {
                    "lang": "java",
                    "value": "MongoCursor<Document> cursor = collection.find().cursor();\nSystem.out.println(cursor.available());"
                },
                {
                    "lang": "java",
                    "value": "List<Document> results = new ArrayList<>();\nFindIterable<Document> iterable = collection.find();\niterable.into(results);\nSystem.out.println(results);"
                },
                {
                    "lang": "java",
                    "value": "MongoCursor<Document> cursor = collection.find().cursor();"
                },
                {
                    "lang": "none",
                    "value": "{ \"stage\": \"COLLSCAN\", \"direction\": \"forward\" }"
                },
                {
                    "lang": "java",
                    "value": "Document explanation = collection.find().explain(ExplainVerbosity.EXECUTION_STATS);\nList<String> keys = Arrays.asList(\"queryPlanner\", \"winningPlan\");\nSystem.out.println(explanation.getEmbedded(keys, Document.class).toJson());"
                },
                {
                    "lang": "java",
                    "value": "FindIterable<Document> iterable = collection.find();\niterable.forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "java",
                    "value": "for (Document cur : collection.find()) {\n   ...\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoCursor<Document> cursor = collection.find().cursor();\nwhile (cursor.hasNext()){\n    System.out.println(cursor.next().toJson());\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoCursor<Document> cursor = collection.find().cursor();\n\ntry {\n    while (cursor.hasNext()){\n        System.out.println(cursor.next().toJson());\n    }\n} finally {\n    cursor.close();\n}"
                },
                {
                    "lang": "java",
                    "value": "try(MongoCursor<Document> cursor = collection.find().cursor()) {\n    while (cursor.hasNext()){\n        System.out.println(cursor.next().toJson());\n    }\n}"
                }
            ],
            "preview": "In this guide, you can learn how to access data using a cursor with the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/limit",
            "title": "Limit the Number of Returned Results",
            "headings": [
                "Overview",
                "Sample Documents",
                "Specify a Limit",
                "Combining Skip and Limit"
            ],
            "paragraphs": "In this guide, you can learn how to limit the number of results returned\nfrom read operations with the MongoDB Java driver. Use  limit()  to cap the number of documents that a read operation returns.\nThis instance method designates the maximum number of\ndocuments that a read operation can return. If there are not enough documents\nto reach the specified limit, it can return a smaller number.\nIf you use  limit()  with the  skip()  instance method, the skip applies\nfirst and the limit only applies to the documents left over after\nthe skip. For more information on the  skip()  method, see our\n guide on Skipping Returned Documents . The following examples demonstrate, respectively, how to insert data into\na collection, how to use  limit()  to restrict the number of returned documents,\nand how to combine  limit()  with  skip()  to further narrow the results returned from a query. The following operation inserts documents representing books into a collection: The next example queries the collection to return the top three\nlongest books. It first matches all the documents with the query, then sorts on the\n length  field to return books with longer lengths before\nbooks with shorter lengths. Lastly, it limits the return value to  3  documents: The preceding code example prints out the following three documents, sorted by\nlength: The order in which you call  limit()  and  sort()  does not matter\nbecause the driver reorders the calls to apply the sort first and the\nlimit after it. The following two calls are equivalent: To see the next three longest books, append the  skip()  method to your\n find()  call as shown in the following code example: This operation returns the documents that describe the fourth through sixth\nlongest books: You can combine  skip()  and  limit()  in this way to implement paging for your\ncollection, returning only small subsets of the collection at one time. For more information about the methods and classes mentioned in this guide,\nsee the following API Documentation: In order to ensure stable sorts across multiple queries, you must sort\nusing a unique key (such as  _id ). Otherwise, a call to  skip() \nand  limit()  may produce unpredictable results when combined with\n sort() . For example, consider the following data: If you sorted by  type  alone,  sort()  does not guarantee the same order\nupon return. Appending  skip()  and  limit()  to the  sort() \ncould return different documents for different queries. In this case, sorting\nby  data  or  serial_no  would guarantee a stable sort, as both are unique keys. FindIterable MongoIterable MongoCursor find()",
            "code": [
                {
                    "lang": "java",
                    "value": "collection.insertMany(Arrays.asList(\n    new Document().append(\"_id\", 1)\n        .append(\"title\", \"The Brothers Karamazov\").append(\"length\", 824)\n        .append(\"author\", \"Dostoyevsky\"),\n    new Document().append(\"_id\", 2)\n        .append(\"title\", \"Les Mis\u00e9rables\").append(\"length\", 1462).append(\"author\", \"Hugo\"),\n    new Document().append(\"_id\", 3)\n        .append(\"title\", \"Atlas Shrugged\").append(\"length\", 1088).append(\"author\", \"Rand\"),\n    new Document().append(\"_id\", 4)\n        .append(\"title\", \"Infinite Jest\").append(\"length\", 1104).append(\"author\", \"Wallace\"),\n    new Document().append(\"_id\", 5)\n        .append(\"title\", \"Cryptonomicon\").append(\"length\", 918).append(\"author\", \"Stephenson\"),\n    new Document().append(\"_id\", 6)\n        .append(\"title\", \"A Dance with Dragons\").append(\"length\", 1104)\n        .append(\"author\", \"Martin\")\n));"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.*;\nimport org.bson.Document;\nimport static com.mongodb.client.model.Sorts.descending;\n\n// ...\n\n// define a cursor that will return the first 3 sorted items\nMongoCursor<Document> cursor = collection.find()\n    .sort(descending(\"length\"))\n    .limit(3)\n    .iterator();\n// print out items\ntry {\n    while (cursor.hasNext()) {\n        System.out.println(cursor.next());\n    }\n}\n// close the cursor\nfinally {\n    cursor.close();\n}"
                },
                {
                    "lang": "java",
                    "value": " Document{{_id=2, title=Les Mis\u00e9rables, author=Hugo, length=1462}}\n Document{{_id=6, title=A Dance with Dragons, author=Martin, length=1104}}\n Document{{_id=4, title=Infinite Jest, author=Wallace, length=1104}}"
                },
                {
                    "lang": "java",
                    "value": "collection.find().sort(descending(\"length\")).limit(3);\ncollection.find().limit(3).sort(descending(\"length\"));"
                },
                {
                    "lang": "java",
                    "value": "MongoCursor<Document> cursor = collection.find()\n    .sort(descending(\"length\"))\n    .limit(3)\n    .skip(3)\n    .iterator();"
                },
                {
                    "lang": "java",
                    "value": "Document{{_id=3, title=Atlas Shrugged, author=Rand, length=1088}}\nDocument{{_id=5, title=Cryptonomicon, author=Stephenson, length=918}}\nDocument{{_id=1, title=The Brothers Karamazov, author=Dostoyevsky, length=824}}"
                },
                {
                    "lang": "java",
                    "value": "{ type: \"computer\", data: \"1\", serial_no: 235235 }\n{ type: \"computer\", data: \"2\", serial_no: 235237 }\n{ type: \"computer\", data: \"3\", serial_no: 235239 }\n{ type: \"computer\", data: \"4\", serial_no: 235241 }"
                }
            ],
            "preview": "In this guide, you can learn how to limit the number of results returned\nfrom read operations with the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/sort",
            "title": "Sort Results",
            "headings": [
                "Overview",
                "Methods For Sorting",
                "Sorting Direction",
                "Ascending",
                "Descending",
                "Handling Ties",
                "Combining Sort Criteria",
                "Text Search"
            ],
            "paragraphs": "In this guide, you can learn how to use the  sort  operation to order your\nresults from read operations with the MongoDB Java driver. The sort operation orders the documents returned from your query by your specified\n sort criteria . Sort criteria are the rules you pass to MongoDB that describe\nhow you would like your data to be ordered. Some examples of sort criteria are: You should read this guide if you would like to: The examples in this guide use a sample collection that contains the following\ndocuments: Smallest number to largest number Earliest time of day to latest time of day Alphabetical order by first name Perform ascending sorts and descending sorts. Combine sort criteria. Sort on the text score of a\n text search . You can sort results retrieved by a query and you can sort results\nwithin an aggregation pipeline. To sort your query results, use the\n sort()  method of a  FindIterable  instance. To sort your results within an\naggregation pipeline, use the  Aggregates.sort()  static factory method. Both\nof these methods receive objects that implement the  Bson  interface as\narguments. For more information, see our API Documentation for the\n BSON interface . You can use the  sort()  method of a  FindIterable  instance as follows: You can use the  Aggregates.sort()  method within an aggregation pipeline\nas follows: The preceding code snippets sort the documents in the\n sample collection  from smallest to\nlargest value of the  _id  field: In the preceding code snippets, we specify our sort criteria using the  Sorts \nbuilder class. While it is possible to specify sort criteria using any class\nthat implements the  Bson  interface, we recommend that you specify sort\ncriteria through the  Sorts  builder. For more information on the  Sorts \nbuilder class, see our\n guide on the Sorts builder . For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: FindIterable Aggregates Sorts BSON Document The direction of your sort can either be  ascending  or  descending .\nAn ascending sort orders your results from smallest to largest. A\ndescending sort orders your results from largest to smallest. Here are some examples of data sorted in ascending order: Here are some examples of data sorted in descending order: The following subsections show how to specify these sort criteria. Numbers: 1, 2, 3, 43, 43, 55, 120 Dates: 1990-03-10, 1995-01-01, 2005-10-30, 2005-12-21 Words (ASCII): Banana, Dill, carrot, cucumber, hummus Numbers: 100, 30, 12, 12, 9, 3, 1 Dates: 2020-01-01, 1998-12-11, 1998-12-10, 1975-07-22 Words (reverse ASCII): pear, grapes, apple, Cheese To specify an ascending sort, use the  Sorts.ascending()  static\nfactory method. Pass the  Sorts.ascending()  method\nthe name of the field you need to sort in ascending order. You can pass the  sort()  method the output of the  Sorts.ascending() \nmethod to specify an ascending sort on a field as follows: The preceding  sort()  method returns a  FindIterable  object that can iterate\nover the documents in your collection, sorted from smallest to largest on the\nspecified field name. In the following code example, we use the  ascending()  method to sort the\n sample collection \nby the  _id  field: The output of the preceding code example should look something like this: To specify a descending sort, use the  Sorts.descending()  static factory\nmethod. Pass the  Sorts.descending()  method the name of the field you need to sort in descending order. The following code snippet shows how to specify a descending sort on the\n _id  field: The preceding code snippet returns the documents in the\n sample collection \nin descending order: A tie occurs when two or more documents have identical values in the field\nyou are using to order your results. MongoDB does not guarantee sort order in\nthe event of ties. For example, suppose we encounter a tie when applying a sort\nto the  sample collection  using the following\ncode: Since multiple documents that matched our query contain the value \"a\" for the\nfield on which we perform the sort, the following documents could be returned\nin any order: If you need to guarantee a specific sort order for documents that have fields\nwith identical values, you can specify additional fields to sort on in the event\nof a tie. We can specify an ascending sort on the  letter  field followed by the\n _id  field as follows: The preceding code snippet returns the documents in the\n sample collection \nin the following order: To combine sort criteria, use the  Sorts.orderBy()  static factory\nmethod. This method constructs an object containing an ordered list of sort\ncriteria. When performing the sort, if the leftmost sort criteria results in a\ntie, the sort uses the next sort criteria in the list to determine the order. In the following code snippet, we use the  orderBy()  method to order our data\nby performing a descending sort on the  letter  field, and in the event of a\ntie, by performing an ascending sort on the  _id  field. The preceding code snippet returns the documents in the\n sample collection \nin the following order: You can specify the order of the results of a\n text search  by how closely the string values of\neach result's fields specified by the collection's text index match your search\nstring. The text search assigns a numerical\n text score  to\nindicate how closely each result matches the search string. Use the\n Sorts.metaTextScore()  static factory method to build your sort criteria to\nsort by the text score. In the following code example, we show how you can use the\n Sorts.metaTextScore()  method to sort the results of a text\nsearch on the  sample collection .\nThe code example uses the  Filters ,\n Indexes , and\n Projections  builders.\nThe code example performs the following actions: The output of the preceding code example should look something like this: For more information about the classes in this section, see the\nfollowing API Documentation: For more information, see the\n Sorts class  API Documentation.\nSee the server manual documentation for more information on the  $text \nquery operator and the\n $meta \naggregation pipeline operator. You need a  text index  on your collection to\nperform a text search. See the server manual documentation for more\ninformation on how to\n create a text index . Creates a text index for your\n sample collection \non the  food  field. If you call  createIndex()  specifying an index that\nalready exists on the collection, the operation does not create a new index. Runs your text search for the phrase \"maple donut\". Projects text scores into your query results as the\n score  field. Sorts your results by text score (best match first). The structure of text search has changed for MongoDB 4.4 or later. You no\nlonger need to project  Projections.metaTextScore()  into your\n FindIterable  instance in order to sort on the text score. In addition,\nthe field name you specify in a  $meta  text score aggregation operation\nused in a sort is ignored. This means that the field name argument you pass\nto  Sorts.metaTextScore()  is disregarded. Filters Indexes Projections MongoCollection",
            "code": [
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(ascending(\"_id\"));"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Aggregates;\nimport static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\ncollection.aggregate(Arrays.asList(Aggregates.sort(ascending(\"_id\"))));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n..."
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(ascending(\"<field name>\"));"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\nList<Document> results = new ArrayList<>();\ncollection.find().sort(ascending(\"_id\")).into(results);\nfor (Document result : results) {\n      System.out.println(result.toJson());\n}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n..."
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.descending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(descending(\"_id\"));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n..."
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(ascending(\"letter\"));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.ascending;\n\n// <MongoCollection setup code here>\n\ncollection.find().sort(ascending(\"letter\", \"_id\"));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}"
                },
                {
                    "lang": "java",
                    "value": "import static com.mongodb.client.model.Sorts.orderBy;\nimport static com.mongodb.client.model.Sorts.ascending;\nimport static com.mongodb.client.model.Sorts.descending;\n\n// <MongoCollection setup code here>\n\nBson orderBySort = orderBy(descending(\"letter\"), ascending(\"_id\"));\ncollection.find().sort(orderBySort);"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}\n{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}\n{\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}\n{\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Sorts;\nimport com.mongodb.client.model.Projections;\nimport com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.Indexes;\n\n// <MongoCollection setup code here>\n\ncollection.createIndex(Indexes.text(\"food\"));\nBson metaTextScoreSort = Sorts.metaTextScore(\"score\");\nBson metaTextScoreProj = Projections.metaTextScore(\"score\");\nString searchTerm = \"maple donut\";\nBson searchQuery = Filters.text(searchTerm);\ncollection.find(searchQuery)\n         .projection(metaTextScoreProj)\n         .sort(metaTextScoreSort)\n         .into(results);\nfor (Document result : results) {\n      System.out.println(result.toJson());\n}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\", \"score\": 1.5}\n{\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\", \"score\": 0.75}\n{\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\", \"score\": 0.75}"
                }
            ],
            "preview": "In this guide, you can learn how to use the sort operation to order your\nresults from read operations with the MongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/embedded-arrays",
            "title": "Update Arrays in a Document",
            "headings": [
                "Overview",
                "Sample Document",
                "Specifying an Update",
                "Specifying Array Elements",
                "The First Matching Array Element",
                "Example",
                "Matching All Array Elements",
                "Example",
                "Matching Multiple Array Elements",
                "Example"
            ],
            "paragraphs": "In this guide, you can learn how to update arrays in a document with the\nMongoDB Java driver. To update an array, you must do the following: Specify the update you want to perform Specify what array elements to apply your update to Perform an update operation using these specifications The following sections feature examples that update this sample\ndocument: The examples on this page use the  findOneAndUpdate()  method of the\n MongoCollection  class to retrieve and update the document. Each\nexample uses an instance of the  FindOneAndUpdateOptions  class to\nhave MongoDB retrieve the document after the update occurs. For\nmore information on the  findOneAndUpdate()  method, see our\n Compound Operations guide . To specify an update, use the  Updates  builder. The  Updates \nbuilder provides static utility methods to construct update\nspecifications. For more information on using the  Updates  builder with\narrays, see our  guide on the Updates builder . The following example performs these actions: The preceding example updates the original document to the following state: Query for the sample document Append \"17\" to the  qty  array in the document that matches the query filter You can specify which array elements to update using a positional\noperator. Positional operators can specify the first, all, or certain\narray elements to update. To specify elements in an array with positional operators, use  dot\nnotation . Dot notation is a property access syntax for navigating BSON\nobjects. For additional information, see the Server Manual Entry on\n dot notation . To update the first array element that matches your query filter, use the\npositional  $  operator. The array field must appear as part of your\nquery filter to use the positional  $  operator. The following example performs these actions: The preceding example updates the original document to the following state: For more information about the methods and operators mentioned in this section,\nsee the following resources: Query for a document with a  qty  field containing the value \"18\" Decrement the first array value in the document that matches the query filter by \"3\" Positional $ Operator  Server Manual Entry inc()  API Documentation To update all elements in an array, use the all positional  $[]  operator. The following example performs these actions: The preceding example updates the original document to the following state: For more information about the methods and operators mentioned in this section,\nsee the following resources: Query for the sample document Multiply array elements matching the query filter by \"2\" All Positional $[] Operator  Server Manual Entry mul()  API Documentation To update array elements that match a filter, use the\nfiltered positional  $[<identifier>]  operator. You must include an\narray filter in your update operation to specify which array elements to\nupdate. The  <identifier>  is the name you give your array filter. This value\nmust begin with a lowercase letter and contain only alphanumeric\ncharacters. The following example performs these actions: The preceding example updates the original document to the following state: For more information about the methods and operators mentioned in this section,\nsee the following resources: Query for the sample document Set an array filter to search for values less than \"15\" Increment array elements matching the query filter by \"5\" Filtered Positional $[<identifier>] Operator  Server Manual Entry inc()  API Documentation",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"green\", \"qty\": [8, 12, 18] }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"green\", \"qty\": [8, 12, 18, 17] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"_id\", 1);\nBson update = Updates.push(\"qty\", 17);\nFindOneAndUpdateOptions options = new FindOneAndUpdateOptions()\n                                    .returnDocument(ReturnDocument.AFTER);\nDocument result = collection.findOneAndUpdate(filter, update, options);\nSystem.out.println(result.toJson());"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"green\", \"qty\": [8, 12, 15] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"qty\", 18);\nBson update = Updates.inc(\"qty.$\", -3);\nFindOneAndUpdateOptions options = new FindOneAndUpdateOptions()\n                                    .returnDocument(ReturnDocument.AFTER);\nDocument result = collection.findOneAndUpdate(filter, update, options);\nSystem.out.println(result.toJson());"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"green\", \"qty\": [16, 24, 36] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"_id\", 1);\nBson update = Updates.mul(\"qty.$[]\", 2);\nFindOneAndUpdateOptions options = new FindOneAndUpdateOptions()\n                                    .returnDocument(ReturnDocument.AFTER);\nDocument result = collection.findOneAndUpdate(filter, update, options);\nSystem.out.println(result.toJson());"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"green\", \"qty\": [13, 17, 18] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"_id\", 1);\nBson smallerFilter = Filters.lt(\"smaller\", 15);\nFindOneAndUpdateOptions options = new FindOneAndUpdateOptions()\n                                    .returnDocument(ReturnDocument.AFTER)\n                                    .arrayFilters(Arrays.asList(smallerFilter));\nBson update = Updates.inc(\"qty.$[smaller]\", 5);\n\nDocument result = collection.findOneAndUpdate(filter, update, options);\nSystem.out.println(result.toJson());"
                }
            ],
            "preview": "In this guide, you can learn how to update arrays in a document with the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/text",
            "title": "Search Text",
            "headings": [
                "Overview",
                "Sample Documents",
                "Text Index",
                "Text Search",
                "Specify Options",
                "Search Text by a Term",
                "Example",
                "Example",
                "Search Text by a Phrase",
                "Example",
                "Search Text with Terms Excluded",
                "Example"
            ],
            "paragraphs": "In this guide, you can learn how to run a  text search  in the MongoDB\nJava driver. You can use a text search to retrieve documents that contain a  term \nor a  phrase  in a specified field. A term is a sequence of characters\nthat excludes whitespace characters. A phrase is a sequence of terms\nwith any number of whitespace characters. The following sections show you how to perform the following types of\ntext searches: If you want to sort your text search results, see the  Text Search  section of our Sort Results guide. Search Text by a Term Search Text by a Phrase Search Text with Terms Excluded The following sections feature examples of text searches on the\n fast_and_furious_movies  collection. Each section uses a variable\nnamed  collection  to refer to the  MongoCollection  instance of the\n fast_and_furious_movies  collection. The  fast_and_furious_movies  collection contains documents that\ndescribe one of the several movies that are part of the Fast and Furious\nmovie franchise. Each document contains a title field and a tags field. You must create a  text index  before running a text search. A text\nindex specifies the string or string array field on which to run a text\nsearch. In the following examples, you run text searches on the  title \nfield in the  fast_and_furious_movies  collection. To enable text\nsearches on the  title  field, create a text index using the\n Indexes  builder with the following\nsnippet: For more information, see the following resources: Text Indexes  section of our Indexes guide Text Indexes  Server Manual Entry Use the  Filters.text()  method to specify a text search. The  Filters.text()  method uses the  Filters builder  to define a query filter specifying\nwhat to search for during the text search. The query filter is\nrepresented by a  BSON  instance. Pass the query filter to the\n find()  method to run a text search. When you execute the  find()  method, MongoDB runs a text search on\nall the fields indexed with the text index on the collection. MongoDB\nreturns documents that contain one or more of the search terms and a\nrelevance score for each result. For more information on relevance\nscores, see the  Text Search  section in\nour Sort Results guide. You can include  TextSearchOptions  as the second parameter of the\n Filters.text()  method to specify text search options such as case\nsensitivity. By default, text searches run without case sensitivity\nwhich means the search matches lowercase and uppercase values. To specify a case sensitive search, use the following snippet: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Filters.text() TextSearchOptions Pass a term as a string to the  Filters.text()  method to specify the\nterm in your text search. The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nterm \"fast\": The following shows the output of the preceding code: To match multiple terms in your text search, separate each term\nwith spaces in the  Filters.text()  builder method. The builder method\nreturns the text search query as a  Bson  instance. When you pass\nthis to the  find()  method, it returns documents that match any of\nthe terms. The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nterms \"fate\" or \"7\": The following shows the output of the preceding code: Pass a phrase with  escaped quotes  to the  Filters.text()  method to\nspecify the phrase in your text search. Escaped quotes are double quote\ncharacters preceded by a backslash character. If you don't add escaped\nquotes around the phrase, the  find()  method runs a  term search . The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nphrase \"fate of the furious\": The following shows the output of the preceding code: For each term you want to exclude from your text search, prefix the term\nwith a minus sign in the string that you pass to the  Filters.text() \nbuilder method. None of the documents returned from the search contain the excluded term\nin your text index field. You must have at least one text search term if you want to\nexclude terms from your search. The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nterm \"furious\", but do not contain the term \"fast\": The following shows the output of the preceding code:",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"title\": \"2 Fast 2 Furious \", \"tags\": [\"undercover\", \"drug dealer\"] }\n{ \"_id\": 2, \"title\": \"Fast 5\", \"tags\": [\"bank robbery\", \"full team\"] }\n{ \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] }\n{ \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] }"
                },
                {
                    "lang": "java",
                    "value": "collection.createIndex(Indexes.text(\"title\"));"
                },
                {
                    "lang": "java",
                    "value": "TextSearchOptions options = new TextSearchOptions().caseSensitive(true);\nBson filter = Filters.text(\"SomeText\", options);"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"title\": \"2 Fast 2 Furious \", \"tags\": [\"undercover\", \"drug dealer\"] }\n{ \"_id\": 2, \"title\": \"Fast 5\", \"tags\": [\"bank robbery\", \"full team\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.text(\"fast\");\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] }\n{ \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.text(\"fate 7\");\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.text(\"\\\"fate of the furious\\\"\");\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] }\n{ \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.text(\"furious -fast\");\ncollection.find(filter).forEach(doc -> System.out.println(doc.toJson()));"
                }
            ],
            "preview": "In this guide, you can learn how to run a text search in the MongoDB\nJava driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/delete",
            "title": "Delete Documents",
            "headings": [
                "Overview",
                "Sample Documents",
                "Delete Many Documents",
                "Delete a Document",
                "Find and Delete a Document"
            ],
            "paragraphs": "In this guide, you can learn how to remove documents with the MongoDB Java\ndriver. You can remove documents by passing a query filter to the\n deleteOne() ,  deleteMany()  or  findOneAndDelete()  methods. The  deleteOne()  method deletes a single document. If the query\nfilter matches more than one document, the method will remove the first\noccurrence of a match in the collection. The  deleteMany()  method deletes all documents that match the query\nfilter. The  findOneAndDelete()  method atomically finds and deletes the first\noccurrence of a match in the collection. To specify a collation or hint an index, use  DeleteOptions \nas a second parameter to the  deleteOne()  and  deleteMany()  methods. To specify a collation, hint an index, specify sort order, or specify a\nprojection on the returned document, use  FindOneAndDeleteOptions \nas the second parameter to the  findOneAndDelete()  method. The following examples are about a paint store that sells eight different\ncolors of paint. The store had their annual online sale resulting in the\nfollowing documents in their  paint_inventory  collection: The paint store website displays all documents in the\n paint_inventory  collection. To reduce customer confusion, the store\nwants to remove the colors that are out of stock. To remove the out of stock colors, query the  paint_inventory \ncollection where the  qty  is  0  and pass the query to the\n deleteMany()  method: The following shows the documents remaining in the  paint_inventory \ncollection: The store is donating the remaining quantity of their yellow paint. This\nmeans that the  qty  for yellow is now  0  and we need to remove yellow\nfrom the collection. To remove yellow, query the  paint_inventory  collection where the\n color  is  \"yellow\"  and pass the query to the  deleteOne() \nmethod: The following shows the documents remaining in the  paint_inventory \ncollection: The store would like to raffle the remaining quantity of purple paint\nand remove purple from the  paint_inventory  collection. To pick a color, query the  paint_inventory  collection where the\n color  is  \"purple\"  and pass the query to the  findOneAndDelete() \nmethod: Unlike the other delete methods,  findOneAndDelete()  returns the\ndeleted document: The following shows the documents remaining in the  paint_inventory \ncollection: For more information about the methods and classes mentioned in this guide,\nsee the following resources: If there are no matches to your query filter, no document gets\ndeleted and the method returns  null . deleteOne()  API Documentation deleteMany()  API Documentation findOneAndDelete()  API Documentation DeleteOptions  API Documentation FindOneAndDeleteOptions  API Documentation db.collection.deleteOne()  Server Manual Entry db.collection.deleteMany()  Server Manual Entry db.collection.findOneAndDelete()  Server Manual Entry",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 0 }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 0 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 6 }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 0 }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 0 }\n{ \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n { \"_id\": 5, \"color\": \"yellow\", \"qty\": 6 }\n { \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"qty\", 0);\ncollection.deleteMany(filter);"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n { \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"color\", \"yellow\");\ncollection.deleteOne(filter);"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n { \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"color\", \"purple\");\nSystem.out.println(collection.findOneAndDelete(filter).toJson());"
                }
            ],
            "preview": "In this guide, you can learn how to remove documents with the MongoDB Java\ndriver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/modify",
            "title": "Modify Documents",
            "headings": [
                "Overview",
                "Update",
                "Update Operation Parameters",
                "Example",
                "Replace",
                "Replace Operation Parameters",
                "Example"
            ],
            "paragraphs": "In this guide, you can learn how to modify documents in a MongoDB\ncollection using two distinct operation types: Update operations specify the fields and values to change in one or more\ndocuments. A replace operation specifies the fields and values to replace\na single document from your collection. In the following examples, a paint store sells five different\ncolors of paint. The  paint_inventory  collection represents their\ncurrent inventory: Update Replace Update operations can modify fields and values. They apply changes\nspecified in an update document to one or more documents that match your\nquery filter. The  updateOne() \nmethod changes the first document your query filter matches and the\n updateMany() \nmethod changes all the documents your query filter matches. You can call the  updateOne()  and  updateMany()  methods on a\n MongoCollection  instance as follows: The  updateOne()  and  updateMany()  methods both have the following\nparameters: You can create the  updateDocument  using an  Updates  builder as\nfollows: See the MongoDB API documentation for a  complete list of\nUpdates builders and their usage . query  specifies a query filter with the criteria to match documents to update in your collection updateDocument  specifies the fields and values to modify in the matching document or documents. For this example, we use the  Updates builder  to create the update document. The paint store receives a fresh shipment and needs to update their inventory.\nThe shipment contains 20 cans of each paint color. To update the inventory, call the  updateMany()  method specifying the\nfollowing: Your output should look something like this: The following shows the updated documents in the  paint_inventory  collection: If zero documents match the query filter in the update operation,\n updateMany()  makes no changes to documents in the collection. See\nour  upsert guide  to\nlearn how to insert a new document instead of updating one if no\ndocuments match. A query filter that matches all the colors An update document that contains instructions to increment the  qty  field by \"20\" The  updateOne()  and  updateMany()  methods cannot make changes\nto a document that violate unique index constraints on the\ncollection. For more information about constraints on unique indexes,\nsee  Unique Indexes  in the\nMongoDB Server manual. A replace operation substitutes one document from your collection. The\nsubstitution occurs between a document your query filter matches and a\nreplacement document. The  replaceOne() \nmethod removes all the existing fields and values in the\nmatching document (except the  _id  field) and substitutes it with the\nreplacement document. You can call the  replaceOne()  method on a  MongoCollection \ninstance as follows: The  replaceOne()  method has the following parameters: query  specifies a query filter with the criteria to match a document to replace in your collection replacementDocument  specifies fields and values of a new  Document  object to replace in the matched document The paint store realizes they need to update their inventory again.  What they\nthought was 20 cans of pink paint is actually 25 cans of orange paint. To update the inventory, call the  replaceOne()  method specifying the\nfollowing: Your output should look something like this: The following shows the updated document: If zero documents match the query filter in the replace operation,\n replaceOne()  makes no changes to documents in the collection. See\nour  upsert guide  to\nlearn how to insert a new document instead of replacing one if no\ndocuments match. If multiple documents match the query filter specified in\nthe  replaceOne()  method, it replaces the first result. A query filter that matches documents where the  color  is \"pink\" A replacement document where the  color  is \"orange\" and the  qty  is \"25\" The  replaceOne()  method cannot make changes to a document that\nviolate unique index constraints on the collection.\nFor more information about constraints on unique indexes,\nsee  Unique Indexes  in the\nMongoDB Server manual.",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"yellow\", \"qty\": 0 }\n{ \"_id\": 4, \"color\": \"green\", \"qty\": 6 }\n{ \"_id\": 5, \"color\": \"pink\", \"qty\": 0 }"
                },
                {
                    "lang": "java",
                    "value": "collection.updateOne(query, updateDocument);\n\ncollection.updateMany(query, updateDocument);"
                },
                {
                    "lang": "java",
                    "value": "Bson updateDocument = Updates.operator(field, value);"
                },
                {
                    "lang": "none",
                    "value": " Matched document count: 5\n Modified document count: 5"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 25 }\n { \"_id\": 2, \"color\": \"purple\", \"qty\": 28 }\n { \"_id\": 3, \"color\": \"yellow\", \"qty\": 20 }\n { \"_id\": 4, \"color\": \"green\", \"qty\": 26 }\n { \"_id\": 5, \"color\": \"pink\", \"qty\": 20 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.empty();\nBson update = Updates.inc(\"qty\", 20);\nUpdateResult result = collection.updateMany(filter, update);\nSystem.out.println(\"Matched document count: \" + result.getMatchedCount());\nSystem.out.println(\"Modified document count: \" + result.getModifiedCount());"
                },
                {
                    "lang": "java",
                    "value": "collection.replaceOne(query, replacementDocument);"
                },
                {
                    "lang": "none",
                    "value": " Matched document count: 1\n Modified document count: 1"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": 5, \"color\": \"orange\", \"qty\": 25 }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"color\", \"pink\");\nDocument document = new Document(\"color\", \"orange\").append(\"qty\", 25);\nUpdateResult result = collection.replaceOne(filter, document);\nSystem.out.println(\"Matched document count: \" + result.getMatchedCount());\nSystem.out.println(\"Modified document count: \" + result.getModifiedCount());"
                }
            ],
            "preview": "In this guide, you can learn how to modify documents in a MongoDB\ncollection using two distinct operation types:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/upsert",
            "title": "Insert or Update in a Single Operation",
            "headings": [
                "Overview",
                "Specify an Upsert"
            ],
            "paragraphs": "In this guide, you can learn how to perform an  upsert  with the\nMongoDB Java driver. Applications use insert and update operations to store and modify data.\nSometimes, you need to choose between an insert and update depending on\nwhether the document exists. MongoDB simplifies this decision for us\nwith an  upsert  option. An  upsert : Updates documents that match your query filter Inserts a document if there are no matches to your query filter To specify an upsert with the  updateOne()  or  updateMany() \nmethods, pass  true  to  UpdateOptions.upsert() . To specify an upsert with the  replaceOne()  method, pass  true  to\n ReplaceOptions.upsert() . In the following example, a paint store sells eight different\ncolors of paint. The store had their annual online sale. Their\n paint_inventory  collection now shows the following documents: The store received a fresh shipment and needs to update their inventory.\nThe first item in the shipment is ten cans of orange paint. To update the inventory, query the  paint_inventory  collection\nwhere the  color  is  \"orange\" , specify an update to  increment  the\n qty  field by  10 , and specify  true  to\n UpdateOptions.upsert() : The method returns: This  AcknowledgedUpdateResult  tells us: The following shows the documents in the  paint_inventory  collection: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Zero documents matched our query filter Zero documents in our collection got modified A document with an  _id  of   606b4cfc1601f9443b5d6978  got upserted Not including  UpdateOptions  results in no change to the collection. The method returns: UpdateOptions.upsert() ReplaceOptions.upsert()",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958da\" }, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958db\" }, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dc\" }, \"color\": \"blue\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dd\" }, \"color\": \"white\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958de\" }, \"color\": \"yellow\", \"qty\": 6 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958df\" }, \"color\": \"pink\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e0\" }, \"color\": \"green\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e1\" }, \"color\": \"black\", \"qty\": 8 }"
                },
                {
                    "lang": "json",
                    "value": " AcknowledgedUpdateResult{ matchedCount=0, modifiedCount=0, upsertedId=BsonObjectId{ value=606b4cfc1601f9443b5d6978 }}"
                },
                {
                    "lang": "json",
                    "value": " { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958da\" }, \"color\": \"red\", \"qty\": 5 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958db\" }, \"color\": \"purple\", \"qty\": 8 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dc\" }, \"color\": \"blue\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dd\" }, \"color\": \"white\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958de\" }, \"color\": \"yellow\", \"qty\": 6 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958df\" }, \"color\": \"pink\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e0\" }, \"color\": \"green\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e1\" }, \"color\": \"black\", \"qty\": 8 }\n { \"_id\": { \"$oid\": \"606b4cfc1601f9443b5d6978\" }, \"color\": \"orange\", \"qty\": 10 }]"
                },
                {
                    "lang": "java",
                    "value": "// Creates a filter and update document to increment the matching document's \"qty\" value\nBson filter = Filters.eq(\"color\", \"orange\");\nBson update = Updates.inc(\"qty\", 10);\n\n// Updates the matching document or inserts a document if none match the query filter\nUpdateOptions options = new UpdateOptions().upsert(true);\nSystem.out.println(collection.updateOne(filter, update, options));"
                },
                {
                    "lang": "json",
                    "value": " AcknowledgedUpdateResult{ matchedCount=0, modifiedCount=0, upsertedId=null }"
                },
                {
                    "lang": "java",
                    "value": "Bson filter = Filters.eq(\"color\", \"orange\");\nBson update = Updates.inc(\"qty\", 10);\nSystem.out.println(collection.updateOne(filter, update));"
                }
            ],
            "preview": "In this guide, you can learn how to perform an upsert with the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/bulk",
            "title": "Bulk Operations",
            "headings": [
                "Overview",
                "Performing Bulk Operations",
                "Insert Operation",
                "Example",
                "Replace Operation",
                "Example",
                "Update Operation",
                "Example",
                "Delete Operation",
                "Example",
                "Order of Execution",
                "Ordered Execution",
                "Example",
                "Unordered Execution",
                "Summary"
            ],
            "paragraphs": "In this guide, you can learn how to use bulk operations in the\nMongoDB Java Driver. To perform a create, replace, update, or delete operation,\nuse its corresponding method. For example, to insert one document,\nupdate multiple documents, and delete one document in your collection,\nuse the  insertOne() ,  updateMany()  and  deleteOne()  methods. The  MongoClient  performs these operations by making a call for each\noperation to the database. You can reduce the number of calls to the\ndatabase to one by using bulk operations. Bulk operations consist of a large number of write operations. To perform\na bulk operation, pass a  List  of  WriteModel  documents  to the\n bulkWrite()  method. A  WriteModel  is a model that represents any\nof the write operations. The following sections show how to create and use each  WriteModel \ndocument. The examples in each section contain the following documents\nin a collection: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: bulkWrite() WriteModel BulkWriteOptions To perform an insert operation, create an  InsertOneModel  specifying\nthe document you want to insert. To insert multiple documents, you must\ncreate an  InsertOneModel  for each document you want to insert. The following example creates an  InsertOneModel  for two documents\nwhere the  _id  values are \"3\" and \"4\": For more information about the methods and classes mentioned in this section,\nsee the  InsertOneModel \nAPI Documentation. When performing a  bulkWrite() , the  InsertOneModel  cannot\ninsert a document with an  _id  that already exists in the\ncollection. Instead, the method throws a  MongoBulkWriteException . The following example tries to insert two documents where the  _id  is\n\"1\" and \"3\": The following shows the output of the preceding code: To see why the document with the  _id  of \"3\" didn't insert, see\nthe  Order of Execution  section. To perform a replace operation, create a  ReplaceOneModel  specifying\na query filter for the document you want to replace with the replacement\ndocument. When performing a  bulkWrite() , the  ReplaceOneModel  cannot\nmake changes to a document that violate unique index constraints on\nthe collection, and the model does not replace a document if there\nare no matches to your query filter. The following example creates a  ReplaceOneModel  to\nreplace a document where the  _id  is \"1\" with a document that\ncontains an additional field: For more information about the methods and classes mentioned in this section,\nsee the following resources: ReplaceOneModel  API Documentation Unique indexes  Server Manual Explanation To perform an update operation, create an  UpdateOneModel  or an\n UpdateManyModel  specifying a query filter for documents you want to\nupdate with what the updates are. The  UpdateOneModel  updates the first document that matches your query\nfilter and the  UpdateManyModel  updates all the documents that\nmatch your query filter. When performing a  bulkWrite() , the  UpdateOneModel  and\n UpdateManyModel  cannot make changes to a document that violate\nunique index constraints on the collection, and the models do not\nupdate any documents if there are no matches to your query filter. The following example creates an  UpdateOneModel  to update\na document where the  _id  is \"2\" to a document that\ncontains an additional field: For more information about the methods and classes mentioned in this section,\nsee the following resources: UpdateOneModel  API Documentation UpdateManyModel  API Documentation unique indexes  Server Manual Explanation To perform a delete operation, create a  DeleteOneModel  or a\n DeleteManyModel  specifying a query filter for documents you want to\ndelete. The  DeleteOneModel  deletes the first document that matches your query\nfilter and the  DeleteManyModel  deletes all the documents that\nmatch your query filter. When performing a  bulkWrite() , the  DeleteOneModel  and\n DeleteManyModel  do not delete any documents if there are no matches\nto your query filter. The following example creates a  DeleteOneModel  to delete\na document where the  _id  is \"1\": For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: DeleteOneModel DeleteManyModel The  bulkWrite()  method accepts an optional  BulkWriteOptions  as\na second parameter to specify if you want to execute the bulk operations\nas ordered or unordered. By default, the  bulkWrite()  method executes bulk operations in\norder. This means that the bulk operations execute in the order you\nadded them to the list until an error occurs, if any. The following example performs these bulk operations: After running this example, your collection contains the following\ndocument: An insert operation for a document where the  _id  is \"3\" A replace operation for a document where the  _id  is \"1\" with a document that contains an additional field An update operation for a document where the  _id  is \"3\" to a document that contains an additional field A delete operation for all documents that contain the field  x  with the value \"2\" You can also execute bulk operations in any order by specifying \"false\"\nto the  order()  method on  BulkWriteOptions . This means that\nall the write operations execute regardless of errors and if any errors occur\nthe bulk operation reports them at the end. Adding to the preceding example, including the following specifies the bulk\noperations to execute in any order: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Unordered bulk operations do not guarantee order of execution. The\norder may differ from the way you list them to optimize the runtime. In the preceding example, if the  bulkWrite()  method decided to\nperform the insert operation after the update operation, nothing\nchanges with the update operation because the document does not exist\nat that point in time. Your collection then contains the following\ndocuments: BulkWriteOptions ordered() To perform a bulk operation, you create and pass a list of\n WriteModel  documents to the  bulkWrite()  method. There are 6 different  WriteModel  documents:  InsertOneModel ,\n ReplaceOneModel ,  UpdateOneModel ,  UpdateManyModel ,\n DeleteOneModel  and  DeleteManyModel . There are two ways to execute the  bulkWrite()  method: Ordered, which performs the bulk operations in order until an error occurs, if any Unordered, which performs all the bulk operations in any order and reports errors at the end, if any",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1 }\n{ \"_id\": 2 }"
                },
                {
                    "lang": "java",
                    "value": "InsertOneModel<Document> juneDoc = new InsertOneModel<>(new Document(\"name\", \"June Carrie\")\n                                                            .append(\"age\", 17));\n                                                  \nInsertOneModel<Document> kevinDoc = new InsertOneModel<>(new Document(\"name\", \"Kevin Moss\")\n                                                            .append(\"age\", 22));"
                },
                {
                    "lang": "shell",
                    "value": "A MongoBulkWriteException occurred with the following message:\nBulk write operation error on server sample-shard-00-02.pw0q4.mongodb.net:27017.\nWrite errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key\nerror collection: crudOps.bulkWrite index: _id_ dup key: { _id: 1 }', details={}}]."
                },
                {
                    "lang": "java",
                    "value": "try {\n    List<WriteModel<Document>> bulkOperations = new ArrayList<>();\n\n    // Creates instructions to insert documents\n    InsertOneModel<Document> doc1 = new InsertOneModel<>(new Document(\"_id\", 1));\n    InsertOneModel<Document> doc3 = new InsertOneModel<>(new Document(\"_id\", 3));\n    \n    bulkOperations.add(doc1);\n    bulkOperations.add(doc3);\n    \n    // Runs a bulk write operation for the specified insert WriteModels\n    collection.bulkWrite(bulkOperations); \n\n// Prints a message if any exceptions occur during the bulk write operation\n} catch (MongoBulkWriteException e){\n    System.out.println(\"A MongoBulkWriteException occurred with the following message: \" + e.getMessage());\n}"
                },
                {
                    "lang": "java",
                    "value": "ReplaceOneModel<Document> doc3 = new ReplaceOneModel<>(\n                                    Filters.eq(\"_id\", 1), \n                                    new Document(\"name\", \"Celine Stork\")\n                                        .append(\"location\", \"San Diego, CA\"));"
                },
                {
                    "lang": "java",
                    "value": "UpdateOneModel<Document> doc3 = new UpdateOneModel<>(\n                                    Filters.eq(\"_id\", 2), \n                                    Updates.set(\"x\", 8));"
                },
                {
                    "lang": "java",
                    "value": "DeleteOneModel<Document> doc3 = new DeleteOneModel<>(Filters.eq(\"_id\", 1));"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2 }"
                },
                {
                    "lang": "java",
                    "value": "List<WriteModel<Document>> bulkOperations = new ArrayList<>();\n\n// Creates instructions to insert a document\nInsertOneModel<Document> insertDoc = new InsertOneModel<>(new Document(\"_id\", 6)\n                                                        .append(\"name\", \"Zaynab Omar\")\n                                                        .append(\"age\", 37));\n\n// Creates instructions to replace the first document matched by the query                                       \nReplaceOneModel<Document> replaceDoc = new ReplaceOneModel<>(Filters.eq(\"_id\", 1), \n                                        new Document(\"name\", \"Sandy Kane\")\n                                            .append(\"location\", \"Helena, MT\")); \n\n// Creates instructions to update the first document matched by the query                                                                 \nUpdateOneModel<Document> updateDoc = new UpdateOneModel<>(Filters.eq(\"name\", \"Zaynab Omar\"), \n                                        Updates.set(\"name\", \"Zaynab Hassan\"));\n\n// Creates instructions to delete all documents matched by the query                                \nDeleteManyModel<Document> deleteDoc = new DeleteManyModel<>(Filters.gt(\"age\", 50));\n\nbulkOperations.add(doc1);\nbulkOperations.add(doc2);\nbulkOperations.add(doc3);\nbulkOperations.add(doc4);\n\n// Runs a bulk write operation for the specified the insert, replace, update, and delete WriteModels in order\ncollection.bulkWrite(bulkOperations);               "
                },
                {
                    "lang": "java",
                    "value": "BulkWriteOptions options = new BulkWriteOptions().ordered(false);\n\n// Runs a bulk write operation for the specified insert, replace, update, and delete WriteModels in any order\ncollection.bulkWrite(bulkOperations, options); "
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 2 }\n{ \"_id\": 3 }"
                }
            ],
            "preview": "In this guide, you can learn how to use bulk operations in the\nMongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/jndi",
            "title": "Connect to MongoDB Using a JNDI Datasource",
            "headings": [
                "Overview"
            ],
            "paragraphs": "In this guide, you can learn how to connect the MongoDB Java driver\nto your MongoDB instance using a Java Naming and Directory Interface\n(JNDI) Datasource. MongoClientFactory includes a  JNDI \n ObjectFactory  implementation that returns  MongoClient  instances\nbased on a  connection URI . Consult the following\nguides to learn how to configure your application to connect using a\nJNDI Datasource. This makes a MongoClient instance accessible via the JNDI name\n MyMongoClient  in the  java:global  context. In a  Wildfly  installation, create a new module\nfor MongoDB at  modules/system/layers/base/org/mongodb/main . Copy\nthe following jar files into the module: Add the following  module.xml  file into the module: mongodb-driver-sync-4.6.1.jar mongodb-driver-core-4.6.1.jar bson-4.6.1.jar bson-record-codec-4.6.1.jar Add a binding to the naming subsystem configuration that references the\npreceding module, the  MongoClientFactory  class, and the\n connection string  for the MongoDB cluster. Replace the placeholder connection value in the  property  tag\nwith a value that points to your MongoDB installation. This makes a  MongoClient  instance accessible via the JNDI name\n mongodb/MyMongoClient  in the  java:comp/env  context. Copy the following jar files into the  lib  directory\nof your  Tomcat  installation: mongodb-driver-sync-4.6.1.jar mongodb-driver-core-4.6.1.jar bson-4.6.1.jar bson-record-codec-4.6.1.jar In the  context.xml  file of your application, add a resource that references\nthe  MongoClientFactory  class and the  connection string  for the MongoDB cluster: Replace the placeholder URI in the  connectionString \nattribute with a value that points to your MongoDB installation. In  web.xml  of your application, add a reference to the\n MongoClientFactory  resource defined in the previous step: For JNDI implementations other than those listed here, you can create\nyour own  Factory  wrapper based on the driver's built-in\n MongoClientFactory \nimplementation.",
            "code": [
                {
                    "lang": "xml",
                    "value": "<module xmlns=\"urn:jboss:module:1.3\" name=\"org.mongodb\">\n   <resources>\n      <resource-root path=\"mongodb-driver-sync-4.1.0.jar\"/>\n   </resources>\n   <dependencies>\n      <module name=\"javax.api\"/>\n      <module name=\"javax.transaction.api\"/>\n      <module name=\"javax.servlet.api\" optional=\"true\"/>\n   </dependencies>\n</module>"
                },
                {
                    "lang": "xml",
                    "value": "<subsystem xmlns=\"urn:jboss:domain:naming:2.0\">\n   <bindings>\n      <object-factory name=\"java:global/MyMongoClient\" module=\"org.mongodb\" class=\"com.mongodb.client.MongoClientFactory\">\n         <environment>\n            <property name=\"connectionString\" value=\"<connection string uri>\"/>\n         </environment>\n      </object-factory>\n   </bindings>\n   <remote-naming/>\n</subsystem>"
                },
                {
                    "lang": "xml",
                    "value": "<Resource name=\"mongodb/MyMongoClient\"\n   auth=\"Container\"\n   type=\"com.mongodb.client.MongoClient\"\n   closeMethod=\"close\"\n   factory=\"com.mongodb.client.MongoClientFactory\"\n   singleton=\"true\"\n   connectionString=\"<connection string uri>\"/>"
                },
                {
                    "lang": "xml",
                    "value": "<resource-ref>\n  <res-ref-name>\n    mongodb/MyMongoClient\n  </res-ref-name>\n  <res-type>\n    com.mongodb.MongoClient\n  </res-type>\n  <res-auth>\n    Container\n  </res-auth>\n</resource-ref>"
                }
            ],
            "preview": "In this guide, you can learn how to connect the MongoDB Java driver\nto your MongoDB instance using a Java Naming and Directory Interface\n(JNDI) Datasource.",
            "tags": "code example, wildfly, tomcat",
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/insert",
            "title": "Insert Operations",
            "headings": [
                "Overview",
                "A Note About _id",
                "Insert a Single Document",
                "Example",
                "Insert Multiple Documents",
                "Example",
                "Summary"
            ],
            "paragraphs": "In this guide, you can learn how to insert documents with the MongoDB Java\ndriver. You can use MongoDB to retrieve, update, and delete information. To\nperform any of those operations, that information, such as user profiles\nand orders, needs to exist in MongoDB. For that information to exist,\nyou need to first perform an insert operation. An insert operation inserts a single or multiple documents into MongoDB\nusing the   insertOne() ,  insertMany() , and  bulkWrite() \nmethods. The following sections focus on  insertOne()  and\n insertMany() . For information on how to use the  bulkWrite() \nmethod, see our\n guide on Bulk Operations . When inserting a document, MongoDB enforces one constraint on your\ndocuments by default: each document  must  contain a unique  _id \nfield. There are two ways to manage this field: Unless you have provided strong guarantees for uniqueness, we recommend\nyou let the driver automatically generate  _id  values. For additional information on unique indexes, see the manual entry on\n Unique Indexes . You can manage this field yourself, ensuring each value you use is unique. You can let the driver automatically generate unique ObjectId values. Duplicate  _id  values violate unique index constraints, resulting\nin a  WriteError . Use the  insertOne()  method when you want to insert a single\ndocument. On successful insertion, the method returns an  InsertOneResult \ninstance representing the  _id  of the new document. The following example creates and inserts a document using the\n insertOne()  method: Your output should look something like this: For more information about the methods and classes mentioned in this section,\nsee the following resources: insertOne()  API Documentation InsertOneResult  API Documentation Manual Explanation on  insertOne() Runnable  Insert a Document Example Use the  insertMany()  method when you want to insert multiple\ndocuments. This method inserts documents in the order specified until an\nexception occurs, if any. For example, assume you want to insert the following documents: If you attempt to insert these documents, a  WriteError  occurs at the\nthird document and the documents prior to the error get inserted into\nyour collection. On successful insertion, the method returns an  InsertManyResult \ninstance representing the  _id  of each new document. Use a try-catch block to get an acknowledgment for successfully\nprocessed documents before the error occurs: The output consists of documents MongoDB can process and should look\nsomething like this: If you look inside your collection, you should see the following documents: The following example creates and adds two documents to a  List , and\ninserts the  List  using the  insertMany()  method: Your output should look something like this: For more information about the methods and classes mentioned in this section,\nsee the following resources: insertMany()  API Documentation InsertManyResult  API Documentation Manual Explanation on  insertMany() Runnable  Insert Multiple Documents Example There are three ways to perform an insert operation, but we focused on two: Both methods automatically generate an  _id  if you omit the field in\nyour document. If the insertion is successful, both methods return an instance\nrepresenting the  _id  of each new document. The  insertOne()  method inserts a single document. The  insertMany()  method inserts multiple documents.",
            "code": [
                {
                    "lang": "none",
                    "value": "Inserted a document with the following id: 60930c39a982931c20ef6cd6"
                },
                {
                    "lang": "java",
                    "value": "Document doc1 = new Document(\"color\", \"red\").append(\"qty\", 5);\n\nInsertOneResult result = collection.insertOne(doc1);\nSystem.out.println(\"Inserted a document with the following id: \" \n    + result.getInsertedId().asObjectId().getValue());"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 3, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 4, \"color\": \"purple\", \"qty\": 10 }\n{ \"_id\": 3, \"color\": \"yellow\", \"qty\": 3 }\n{ \"_id\": 6, \"color\": \"blue\", \"qty\": 8 }"
                },
                {
                    "lang": null,
                    "value": "A MongoBulkWriteException occurred, but there are successfully processed\ndocuments with the following ids: [3, 4, 6]"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 3, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 4, \"color\": \"purple\", \"qty\": 10 }"
                },
                {
                    "lang": "java",
                    "value": "List<Integer> insertedIds = new ArrayList<>();\n\n// Inserts sample documents and prints their \"_id\" values\ntry {\n    InsertManyResult result = collection.insertMany(documents);  \n    result.getInsertedIds().values()\n        .forEach(doc -> insertedIds.add(doc.asInt32().getValue()));\n    System.out.println(\"Inserted documents with the following ids: \" + insertedIds);\n\n// Prints a message if any exceptions occur during the operation and the \"_id\" values of inserted documents\n} catch(MongoBulkWriteException exception) {\n    exception.getWriteResult().getInserts()\n        .forEach(doc -> insertedIds.add(doc.getId().asInt32().getValue()));\n    System.out.println(\"A MongoBulkWriteException occurred, but there are \" + \n        \"successfully processed documents with the following ids: \" + insertedIds);\n}"
                },
                {
                    "lang": null,
                    "value": "Inserted documents with the following ids: [60930c3aa982931c20ef6cd7, 60930c3aa982931c20ef6cd8]"
                },
                {
                    "lang": "java",
                    "value": "List<Document> documents = new ArrayList<>();\n\nDocument doc1 = new Document(\"color\", \"red\").append(\"qty\", 5);\nDocument doc2 = new Document(\"color\", \"purple\").append(\"qty\", 10);\n\ndocuments.add(doc1);\ndocuments.add(doc2);\n\nInsertManyResult result = collection.insertMany(documents);\n\n// Retrieves and prints the ID values of each inserted document\nList<ObjectId> insertedIds = new ArrayList<>();\nresult.getInsertedIds().values()\n    .forEach(doc -> insertedIds.add(doc.asObjectId().getValue()));\n\nSystem.out.println(\"Inserted documents with the following ids: \" + insertedIds);\n"
                }
            ],
            "preview": "In this guide, you can learn how to insert documents with the MongoDB Java\ndriver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/connect",
            "title": "Connect to MongoDB",
            "headings": [
                "MongoClient",
                "Connection URI",
                "Atlas Connection Example",
                "Other Ways to Connect to MongoDB",
                "Connect to a MongoDB Deployment on Your Local Machine",
                "Connect to a Replica Set"
            ],
            "paragraphs": "In this guide, you can learn how to connect to a\n MongoDB Atlas deployment ,\na MongoDB instance, or a replica set using the Java Driver. You can view sample code to  connect to an Atlas cluster \nor continue reading to learn more about the  MongoClient  class and\nconnection URIs. You can connect to and communicate with MongoDB using the  MongoClient \nclass. Use the  MongoClients.create()  method to construct a  MongoClient . All resource usage limits, such as max connections, apply to individual\n MongoClient  instances. To learn about the different settings you can use to control the\nbehavior of your  MongoClient , see the guide on\n MongoClient Settings . As each  MongoClient  represents a thread-safe pool of connections to the\ndatabase, most applications only require a single instance of a\n MongoClient , even across multiple threads. To learn more about\nhow connection pools work in the driver, see the  FAQ page . Always call  MongoClient.close()  to clean up resources when an\ninstance is no longer needed. The  connection URI  provides a set of instructions that the driver uses to\nconnect to a MongoDB deployment. It instructs the driver on how it should\nconnect to MongoDB and how it should behave while connected. The following\nfigure explains each part of a sample connection URI: In this example, you connect to an Atlas MongoDB deployment that has a\nDNS SRV record. For more details, see the  DNS Seed List\nConnection Format \ndocumentation. This format offers flexibility in deployment and the\nability to change the servers in rotation without reconfiguring clients. If you are connecting to an instance or replica set that does not have a\nDNS SRV address, you must use  mongodb  for the protocol, which specifies\nthe  Standard Connection String Format . After the protocol, the connection string contains your\ncredentials if you are using a password-based authentication mechanism.\nReplace the value of  user  with your username and  pass  with your\npassword. If your authentication mechanism does not require credentials,\nomit this part of the connection URI. The next part of the connection URI specifies the hostname or IP\naddress, followed by the port of your MongoDB instance. In the example,\n sample.host  represents the hostname and  27017  is the port number.\nReplace these values to refer to your MongoDB instance. The last part of the connection URI contains connection options as parameters.\nIn the example, you set two connection options:  maxPoolSize=20  and\n w=majority . For more information on connection options, skip to the\n Connection Options  section of this guide. If your deployment is on MongoDB Atlas, see the\n Atlas driver connection guide \nand select Java from the language dropdown to retrieve your connection\nstring. To connect to a MongoDB deployment on Atlas, create a client. You can\ncreate a client that uses your connection string and other\nclient options by passing a  MongoClientSettings  object to the\n MongoClients.create()  method. To instantiate a  MongoClientSettings  object, use the builder method to specify\nyour connection string and any other client options, and then call the  build() \nmethod. Chain the  applyConnectionString()  method to the builder to specify your\nconnection URI. You can set the Stable API version client option to avoid\nbreaking changes when you upgrade to a new version of MongoDB Server. To\nlearn more about the Stable API feature, see the  Stable API page . The following code shows how you can specify the connection string and\nthe Stable API client option when connecting to a MongoDB\ndeployment on Atlas and verify that the connection is successful: If you are connecting to a single MongoDB deployment or replica set\nthat is not hosted on Atlas, see the following sections to find out how to\nconnect. To test whether you can connect to your deployment, replace the connection\nstring in the  Connect to MongoDB Atlas  code\nexample and run it. If you need to run a MongoDB deployment on your local machine for development\npurposes instead of using an Atlas cluster, you need to complete the following: After you successfully start your MongoDB deployment, specify your connection\nstring in your driver connection code. If your MongoDB deployment is running locally, you can use the connection string\n \"mongodb://localhost:<port>\"  where  <port>  is the port number you\nconfigured your server to listen for incoming connections. If you need to specify a different hostname or IP address, see our Server\nManual entry on  Connection Strings . Download the  Community \nor  Enterprise  version\nof MongoDB Server. Install and configure \nMongoDB Server. Start the deployment. Always secure your MongoDB deployment from malicious attacks. See our\n Security Checklist  for a\nlist of security recommendations. A MongoDB replica set deployment is a group of connected instances that\nstore the same set of data. This configuration of instances provides data\nredundancy and high data availability. To connect to a replica set deployment, specify the hostnames (or IP\naddresses) and port numbers of the members of the replica set. If you are not able to provide a full list of hosts in the replica set,\nyou can specify a single or subset of the hosts in the replica and\ninstruct the driver to perform automatic discovery in one of the following\nways: The following examples show how to specify multiple hosts to a  MongoClient \ninstance using either the  ConnectionString  or  MongoClientSettings \nclass. Select the tab that corresponds to your preferred class. Specify the name of the replica set as the value of the  replicaSet \nparameter Specify  false  as the value of the  directConnection  parameter Specify more than one host in the replica set Although you can specify a subset of the hosts in a replica set,\ninclude all the hosts in the replica set to ensure the driver is able to\nestablish the connection if one of the hosts are unreachable.",
            "code": [
                {
                    "lang": "java",
                    "value": "package fundamentals;\n\nimport com.mongodb.*;\nimport org.bson.BsonDocument;\nimport org.bson.BsonInt64;\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoDatabase;\n\npublic class MongoClientConnectionExample {\n    public static void main(String[] args) {\n        // Replace the placeholder with your Atlas connection string\n        String uri = \"<connection string>\";\n\n        // Construct a ServerApi instance using the ServerApi.builder() method\n        ServerApi serverApi = ServerApi.builder()\n                .version(ServerApiVersion.V1)\n                .build();\n\n        MongoClientSettings settings = MongoClientSettings.builder()\n                .applyConnectionString(new ConnectionString(uri))\n                .serverApi(serverApi)\n                .build();\n\n        // Create a new client and connect to the server\n        try (MongoClient mongoClient = MongoClients.create(settings)) {\n            MongoDatabase database = mongoClient.getDatabase(\"admin\");\n            try {\n                // Send a ping to confirm a successful connection\n                Bson command = new BsonDocument(\"ping\", new BsonInt64(1));\n                Document commandResult = database.runCommand(command);\n                System.out.println(\"Pinged your deployment. You successfully connected to MongoDB!\");\n            } catch (MongoException me) {\n                System.err.println(me);\n            }\n        }\n    }\n}\n"
                },
                {
                    "lang": "java",
                    "value": "ConnectionString connectionString = new ConnectionString(\"mongodb://host1:27017,host2:27017,host3:27017/\");\nMongoClient mongoClient = MongoClients.create(connectionString);"
                },
                {
                    "lang": "java",
                    "value": "ServerAddress seed1 = new ServerAddress(\"host1\", 27017);\nServerAddress seed2 = new ServerAddress(\"host2\", 27017);\nServerAddress seed3 = new ServerAddress(\"host3\", 27017);\nMongoClientSettings settings = MongoClientSettings.builder()\n        .applyToClusterSettings(builder ->\n               builder.hosts(Arrays.asList(seed1, seed2, seed3)))\n        .build();\nMongoClient mongoClient = MongoClients.create(settings);"
                }
            ],
            "preview": "In this guide, you can learn how to connect to a\nMongoDB Atlas deployment,\na MongoDB instance, or a replica set using the Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/tls",
            "title": "Enable TLS/SSL on a Connection",
            "headings": [
                "Overview",
                "Enable TLS/SSL",
                "Configure Certificates",
                "Configure the JVM Trust Store",
                "Configure the JVM Key Store",
                "Configure a Client-Specific Trust Store and Key Store",
                "Disable Hostname Verification",
                "Restrict Connections to TLS 1.2 Only",
                "Customize TLS/SSL Configuration through the Java SE SSLContext",
                "Customize TLS/SSL Configuration through the Netty SslContext",
                "Online Certificate Status Protocol (OCSP)",
                "Client-Driven OCSP",
                "OCSP Stapling"
            ],
            "paragraphs": "In this guide, you can learn how to connect to MongoDB instances with the\n TLS/SSL \nsecurity protocol using the underlying TLS/SSL support in the JDK. To\nconfigure your connection to use TLS/SSL, enable the TLS/SSL settings in\neither the  ConnectionString \nor  MongoClientSettings . If you experience trouble setting up your TLS/SSL connection, you can\nuse the  -Djavax.net.debug=all  system property to view additional\nlog statements. See  the Oracle guide to debugging TLS/SSL connections \nfor more information. You can enable TLS/SSL for the connection to your MongoDB instance\nin two different ways: through a parameter in your connection string, or\nusing a method in the  MongoClientSettings.Builder  class. If you connect by using the DNS seedlist protocol, indicated by the\n mongodb+srv  prefix in your connection string, the driver enables\nTLS/SSL. To disable it, set the  tls  or  ssl  parameter value to\n false  in your connection string or  MongoClientSettings  instance. To learn more about connection behavior when you use a DNS seedlist,\nsee the  SRV Connection Format \nsection in the Server manual. To enable TLS/SSL on a connection with a  ConnectionString , assign the connection string\nparameter  tls  a value of  true  in the connection string passed to\n MongoClients.create() : To configure your  MongoClient 's TLS/SSL connection options using the\n MongoClientSettings.Builder  class, call the\n applyToSslSettings() \nmethod. Set the  enabled  property to  true  in the  SslSettings.Builder \nblock to enable TLS/SSL: Java applications that initiate TLS/SSL requests require access to\ncryptographic certificates that prove identity for the application\nitself as well as other applications with which the application\ninteracts. You can configure access to these certificates in your application with\nthe following mechanisms: The JVM Trust Store and JVM Key Store A Client-Specific Trust Store and Key Store The following sections are based on the documentation for Oracle JDK,\nso some parts may be inapplicable to your JDK or to the custom TLS/SSL\nimplementation you use. The JVM trust store saves certificates that securely identify other\napplications with which your Java application interacts. Using these\ncertificates, your application can prove that the connection to another\napplication is genuine and secure from tampering by third parties. If your MongoDB instance uses a certificate that is signed by an\nauthority that is not present in the JRE's default certificate store,\nyour application must configure two system properties to initiate\nSSL/TLS requests. These properties ensure that your application is able to\nvalidate the TLS/SSL certificate presented by a connected MongoDB instance. You can create a trust store with the  keytool \ncommand line tool provided as part of the JDK: By default, the JRE includes many commonly used public certificates\nfrom signing authorities like  Let's Encrypt . As a result, you can connect to\ninstances of  MongoDB Atlas  (or any other\nserver whose certificate is signed by an authority in the JRE's default\ncertificate store) with TLS/SSL without configuring the trust store. javax.net.ssl.trustStore : the path to a trust store containing the\ncertificate of the signing authority javax.net.ssl.trustStorePassword : the password to access the trust\nstore defined in  javax.net.ssl.trustStore The JVM key store saves certificates that securely identify your Java\napplication to other applications. Using these certificates, other\napplications can prove that the connection to your application is\ngenuine and secure from tampering by third parties. An application that initiates TLS/SSL requests needs to set two JVM system\nproperties to ensure that the client presents a TLS/SSL certificate to\nthe MongoDB deployment: You can create a key store with the  keytool \nor  openssl  command\nline tools. For more information on configuring a Java application to use TLS/SSL,\nplease refer to the  JSSE Reference Guide . By default, MongoDB instances do not perform client certificate\nvalidation. You only need to configure the key store if you explicitly\nconfigured your MongoDB instance to validate client certificates. javax.net.ssl.keyStore : the path to a key store containing the client's\nTLS/SSL certificates javax.net.ssl.keyStorePassword : the password to access the key store\ndefined in  javax.net.ssl.keyStore You can configure a client-specific trust store and key store using the\n init()  method of the  SSLContext  class. You can find an example showing how to configure a client with an  SSLContext \ninstance in the\n Customize TLS/SSL Configuration with an SSLContext section of this guide . For more information on the  SSLContext  class, see the API\ndocumentation for  SSL Context . By default, the driver ensures that the hostname included in the server's\nTLS/SSL certificates matches the hostnames provided when constructing\na  MongoClient . If you need to disable hostname verification for your\napplication, you can explicitly disable this by setting the\n invalidHostNameAllowed  property of the builder to  true  in the\n applytoSslSettings()  builder lambda: Disabling hostname verification can make your configuration\n insecure .\nYou should only disable hostname verification for testing purposes or\nwhen there is no other alternative. To restrict your application to use only the TLS 1.2 protocol, set the\n jdk.tls.client.protocols  system property to \"TLSv1.2\". Java Runtime Environments (JREs) prior to Java 8 only enabled\nthe TLS 1.2 protocol in update releases. If your JRE has not enabled\nthe TLS 1.2 protocol, you may need to upgrade to a later release to\nconnect using TLS 1.2. If your TLS/SSL configuration requires additional customization, you can\nset the  sslContext  property of your  MongoClient  by\npassing an  SSLContext \nobject to the builder in the  applyToSslSettings()  lambda: If you use the driver with  Netty  for network IO,\nyou have an option to plug an alternative TLS/SSL protocol implementation\nprovided by Netty. To instruct the driver to use  io.netty.handler.ssl.SslContext ,\nuse the  NettyStreamFactoryFactory.Builder.sslContext \nmethod. See the method documentation for details about the different  io.netty.handler.ssl.SslProvider \nvariants the driver supports and the implications of using them. OCSP is a standard used to check whether X.509 certificates have been\nrevoked. A certificate authority can add an X.509 certificate to the\nCertificate Revocation List (CRL) prior to the expiry time to invalidate\nthe certificate. When a client sends an X.509 certificate during the TLS\nhandshake, the CA's revocation server checks the CRL and returns a status\nof \"good\", \"revoked\", or \"unknown\". The driver supports the following variations of OCSP: The following sections describe the differences between them and how to enable\nthem for your application. Client-Driven OCSP OCSP Stapling The Java driver uses the JVM arguments configured for the application\nand cannot be overridden for a specific  MongoClient  instance. In client-driven OCSP, the client sends the certificate in an OCSP request to\nan OCSP responder after receiving the certificate from the server. The OCSP\nresponder checks the status of the certificate with a certificate\nauthority (CA) and reports whether it's valid in a response sent to the\nclient. To enable client-driven OCSP for your application, set the following JVM\nsystem properties: Property Value com.sun.net.ssl.checkRevocation Set this property to  true  to enable revocation checking. ocsp.enable Set this property to  true  to enable client-driven OCSP. If the OCSP responder is unavailable, the TLS support provided by the\nJDK reports a \"hard fail\". This differs from the \"soft fail\" behavior of\nthe MongoDB Shell and some other drivers. OCSP stapling is a mechanism in which the server must obtain the signed\ncertificate from the certificate authority (CA) and include it in a\ntime-stamped OCSP response to the client. To enable OCSP stapling for your application, set the following JVM system\nproperties: For additional information about OCSP, check out the following resources: Property Description com.sun.net.ssl.checkRevocation Set this property to  true  to enable revocation checking. jdk.tls.client.enableStatusRequestExtension Oracle JDK 8 Documentation on  how to enable OCSP for an application Official IETF specification for OCSP (RFC 6960)",
            "code": [
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\"mongodb+srv://<user>:<password>@<cluster-url>?tls=true\");"
                },
                {
                    "lang": "java",
                    "value": "MongoClientSettings settings = MongoClientSettings.builder()\n       .applyToSslSettings(builder ->\n           builder.enabled(true))\n       .build();\nMongoClient client = MongoClients.create(settings);"
                },
                {
                    "lang": "console",
                    "value": "keytool -importcert -trustcacerts -file <path to certificate authority file>\n         -keystore <path to trust store> -storepass <password>"
                },
                {
                    "lang": "java",
                    "value": "MongoClientSettings settings = MongoClientSettings.builder()\n     .applyToSslSettings(builder -> {\n                 builder.enabled(true);\n                 builder.invalidHostNameAllowed(true);\n             })\n     .build();"
                },
                {
                    "lang": "java",
                    "value": "SSLContext sslContext = ...\nMongoClientSettings settings = MongoClientSettings.builder()\n     .applyToSslSettings(builder -> {\n                 builder.enabled(true);\n                 builder.context(sslContext);\n             })\n     .build();\nMongoClient client = MongoClients.create(settings);"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.MongoClientSettings;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.connection.netty.NettyStreamFactoryFactory;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslProvider;"
                },
                {
                    "lang": "java",
                    "value": "SslContext sslContext = SslContextBuilder.forClient()\n        .sslProvider(SslProvider.OPENSSL)\n        .build();\nMongoClientSettings settings = MongoClientSettings.builder()\n        .applyToSslSettings(builder -> builder.enabled(true))\n        .streamFactoryFactory(NettyStreamFactoryFactory.builder()\n                .sslContext(sslContext)\n                .build())\n        .build();\nMongoClient client = MongoClients.create(settings);"
                }
            ],
            "preview": "In this guide, you can learn how to connect to MongoDB instances with the\nTLS/SSL\nsecurity protocol using the underlying TLS/SSL support in the JDK. To\nconfigure your connection to use TLS/SSL, enable the TLS/SSL settings in\neither the ConnectionString\nor MongoClientSettings.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/connection-options",
            "title": "Connection Options",
            "headings": [],
            "paragraphs": "This section explains MongoDB connection and authentication options\nsupported by the driver. You can pass the connection options as\nparameters of the connection URI to specify the behavior of the client. For a complete list of options, see the\n ConnectionString \nAPI reference page. Option Name Type Description minPoolSize integer Specifies the minimum number of connections that must exist at\nany moment in a single connection pool. maxPoolSize integer Specifies the maximum number of connections that a connection\npool may have at a given time. waitQueueTimeoutMS integer Specifies the maximum amount of time, in milliseconds that a\nthread may wait for a connection to become available. serverSelectionTimeoutMS integer Specifies the maximum amount of time, in milliseconds, the driver\nwill wait for server selection to succeed before throwing an\nexception. localThresholdMS integer When communicating with multiple instances of MongoDB in a replica\nset, the driver will only send requests to a server whose\nresponse time is less than or equal to the server with the fastest\nresponse time plus the local threshold, in milliseconds. heartbeatFrequencyMS integer Specifies the frequency, in milliseconds that the driver will\nwait between attempts to determine the current state of each\nserver in the cluster. replicaSet string Specifies that the  connection string \nprovided includes multiple hosts. When specified, the driver\nattempts to find all members of that set. ssl boolean Specifies that all communication with MongoDB instances should\nuse TLS/SSL. Superseded by the  tls  option. tls boolean Specifies that all communication with MongoDB instances should\nuse TLS. Supersedes the  ssl  option. tlsInsecure boolean Specifies that the driver should allow invalid hostnames for TLS\nconnections. Has the same effect as setting\n tlsAllowInvalidHostnames  to  true . To configure TLS security\nconstraints in other ways, use a\n custom SSLContext . tlsAllowInvalidHostnames boolean Specifies that the driver should allow invalid hostnames in the\ncertificate for TLS connections. Supersedes\n sslInvalidHostNameAllowed . connectTimeoutMS integer Specifies the maximum amount of time, in milliseconds, the Java\ndriver waits for a connection to open before timing out. A value of\n 0  instructs the driver to never time out while waiting for a connection\nto open. socketTimeoutMS integer Specifies the maximum amount of time, in milliseconds, the Java\ndriver will wait to send or receive a request before timing out.\nA value of  0  instructs the driver to never time out while waiting\nto send or receive a request. maxIdleTimeMS integer Specifies the maximum amount of time, in milliseconds, the Java\ndriver will allow a pooled connection to idle before closing the\nconnection. A value of  0  indicates that there is no upper bound\non how long the driver can allow a pooled collection to be idle. maxLifeTimeMS integer Specifies the maximum amount of time, in milliseconds, the Java\ndriver will continue to use a pooled connection before closing the\nconnection. A value of  0  indicates that there is no upper bound\non how long the driver can keep a pooled connection open. journal boolean Specifies that the driver must wait for the connected MongoDB\ninstance to group commit to the journal file on disk for all writes. w string or integer Specifies the write concern. For more information on values, see\nthe server documentation for the  w option . wtimeoutMS integer Specifies a time limit, in milliseconds, for the write concern. For\nmore information, see the server documentation for the\n wtimeoutMS option .\nA value of  0  instructs the driver to never time out write operations. readPreference string Specifies the read preference. For more information on values, see\nthe server documentation for the\n readPreference option . readPreferenceTags string Specifies the read preference tags. For more information on values, see\nthe server documentation for the\n readPreferenceTags option . maxStalenessSeconds integer Specifies, in seconds, how stale a secondary can be before the\ndriver stops communicating with that secondary. The minimum value is\neither 90 seconds or the heartbeat frequency plus 10 seconds, whichever\nis greater. For more information, see the server documentation for the\n maxStalenessSeconds option .\nNot providing a parameter or explicitly specifying  -1  indicates\nthat there should be no staleness check for secondaries. authMechanism string Specifies the  authentication mechanism  that the driver should use if a credential\nwas supplied. authSource string Specifies the database that the supplied credentials should be\nvalidated against. authMechanismProperties string Specifies authentication properties for the specified authentication\nmechanism as a list of colon-separated properties and values.\nFor more information, see the server documentation for\nthe  authMechanismProperties option . appName string Specifies the name of the application provided to MongoDB instances\nduring the connection handshake. Can be used for server logs and\nprofiling. compressors string Specifies one or more compression algorithms that the driver\nwill attempt to use to compress requests sent to the connected\nMongoDB instance. Possible values include:  zlib ,  snappy ,\nand  zstd . zlibCompressionLevel integer Specifies the degree of compression that  Zlib \nshould use to decrease the size of requests to the connected MongoDB\ninstance. The level can range from  -1  to  9 , with lower values\ncompressing faster (but resulting in larger requests) and larger values\ncompressing slower (but resulting in smaller requests). retryWrites boolean Specifies that the driver must retry supported write operations\nif they fail due to a network error. retryReads boolean Specifies that the driver must retry supported read operations\nif they fail due to a network error. uuidRepresentation string Specifies the UUID representation to use for read and write\noperations. For more information, see the driver documentation\nfor the\n MongoClientSettings.getUuidRepresentation() method . directConnection boolean Specifies that the driver must connect to the host directly. maxConnecting integer Specifies the maximum number of connections a pool may be establishing\nconcurrently. srvServiceName string Specifies the service name of the\n SRV resource records \nthe driver retrieves to construct your\n seed list .\nYou must use the\n DNS Seed List Connection Format \nin your\n connection URI \nto use this option.",
            "code": [],
            "preview": "This section explains MongoDB connection and authentication options\nsupported by the driver. You can pass the connection options as\nparameters of the connection URI to specify the behavior of the client.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/network-compression",
            "title": "Network Compression",
            "headings": [
                "Specify Compression Algorithms",
                "Compression Algorithm Dependencies"
            ],
            "paragraphs": "You can enable a driver option to compress messages which reduces the amount\nof data passed over the network between MongoDB and your application. The driver supports the following algorithms: The driver tests against the following versions of these libraries: If you specify multiple compression algorithms, the driver selects the\nfirst one in the list supported by the MongoDB instance to which it is\nconnected. Snappy : available in MongoDB 3.4 and later. Zlib : available in MongoDB 3.6 and later. Zstandard : available in MongoDB 4.2 and later. org.xerial.snappy:snappy-java:1.1.8.4 com.github.luben:zstd-jni:1.5.0-4 Applications that require Snappy or Zstandard compression must\n add explicit dependencies  for those\nalgorithms. You can enable compression for the connection to your MongoDB instance\nby specifying the algorithms in one of two ways: adding the parameter to your\nconnection string using  ConnectionString  or by calling the method in the\n MongoClientSettings.Builder  class. To enable compression using the  ConnectionString ,\nadd the parameter  compressors  in the connection string passed to\n MongoClients.create() . You can specify one or more compression\nalgorithms, separating them with commas: Specify compression algorithms using the following strings: \"snappy\" for  Snappy  compression \"zlib\" for  Zlib  compression \"zstd\" for  Zstandard  compression To enable compression using the  MongoClientSettings ,\npass the  compressorList() \nbuilder method a list of  MongoCompressor \ninstances. You can specify one or more compression algorithms in the list: The JDK supports  Zlib  compression natively, but\n Snappy  and\n Zstandard  depend on open source\nimplementations. See\n snappy-java  and\n zstd-java  for details.",
            "code": [
                {
                    "lang": "java",
                    "value": "ConnectionString connectionString = new ConnectionString(\"mongodb+srv://<user>:<password>@<cluster-url>/?compressors=snappy,zlib,zstd\");\nMongoClient mongoClient = MongoClients.create(connectionString);"
                },
                {
                    "lang": "java",
                    "value": "MongoClientSettings settings = MongoClientSettings.builder()\n     .compressorList(Arrays.asList(MongoCompressor.createSnappyCompressor(),\n                                   MongoCompressor.createZlibCompressor(),\n                                   MongoCompressor.createZstdCompressor()))\n     .build();\nMongoClient client = MongoClients.create(settings);"
                }
            ],
            "preview": "You can enable a driver option to compress messages which reduces the amount\nof data passed over the network between MongoDB and your application.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/document-data-format-bson",
            "title": "Document Data Format: BSON",
            "headings": [
                "Overview",
                "BSON Data Format",
                "MongoDB and BSON",
                "Install the BSON Library"
            ],
            "paragraphs": "In this guide, you can learn about the BSON data format, how MongoDB\nuses it, and how to install the BSON library independently of the\nMongoDB Java driver. BSON , or Binary JSON, is the data format that MongoDB uses to organize\nand store data. This data format includes all JSON data structure types and\nadds support for types including dates, different size integers, ObjectIds, and\nbinary data. For a complete list of supported types, see the\n BSON Types  server manual page. The binary format is not human-readable, but you can use the\n Java BSON library  to convert it to a JSON\nrepresentation. You can read more about the relationship between these\nformats in our article on  JSON and BSON . The MongoDB Java Driver, which uses the BSON library, allows you to work\nwith BSON data by using one of the object types that implements the\n BSON interface ,\nincluding: For more information on using these object types, see our\n Documents guide . Document  (BSON library package) BsonDocument  (BSON library package) RawBsonDocument  (BSON library package) JsonObject  (BSON library package) BasicDBObject  (Java Driver package) These instructions show you how to add the BSON library as a dependency to\nyour project. If you added the MongoDB Java driver as a dependency to your\nproject, you can skip this step since the BSON library is already included\nas a required dependency of the driver. For instructions on how to add the\nMongoDB Java driver as a dependency to your project, see the\n driver installation  section of our Quick Start\nguide. We recommend that you use the  Maven  or\n Gradle  build automation tool to manage your project's\ndependencies. Select from the following tabs to see the dependency declaration\nfor that tool: If you are not using one of the preceding tools, you can include it in\nyour project by downloading the JAR file directly from the\n sonatype repository . The following snippet shows the dependency declaration in the\n dependencies  section of your  pom.xml  file. The following snippet shows the dependency declaration in the\n dependencies  object in your  build.gradle  file.",
            "code": [
                {
                    "lang": "xml",
                    "value": "<dependencies>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>bson</artifactId>\n        <version>4.6.1</version>\n    </dependency>\n</dependencies>"
                },
                {
                    "lang": "groovy",
                    "value": "dependencies {\n   compile 'org.mongodb:bson:4.6.1'\n}"
                }
            ],
            "preview": "In this guide, you can learn about the BSON data format, how MongoDB\nuses it, and how to install the BSON library independently of the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/document-data-format-pojo",
            "title": "Document Data Format: POJOs",
            "headings": [
                "Overview",
                "Example POJO",
                "Configure the Driver for POJOs",
                "Summary"
            ],
            "paragraphs": "In this guide, you can learn how to store and retrieve data in the\nMongoDB Java driver using plain old Java objects ( POJOs ).\nPOJOs are often used for data encapsulation, separating business logic from\ndata representation. The example in this guide shows how to perform the following: Configure the driver to serialize and deserialize POJOs How to read and write to documents using POJOs To follow the steps in this guide, use the following sample POJO class\nwhich describes characteristics of a flower: If you are creating your own POJO for storing and retrieving data in MongoDB,\nmake sure to follow these guidelines: The POJO class should not implement interfaces or extend classes from a\nframework. Include all the fields for which you want to store and retrieve data;\nmake sure they are not  static  or  transient . If you include public getter or setter methods using the\n JavaBean naming conventions \nin your POJO, the driver calls them when serializing or deserializing data.\nIf you omit the getter or setter methods for a public property field, the\ndriver accesses or assigns them directly. To set up the driver to store and retrieve POJOs, we need to specify: Consult the following steps to see how to perform each of the configuration\nrequirements: Once you have configured the preceding  MongoCollection  instance, you\ncan perform the following  CRUD operations \nwith the POJOs: The following code snippet shows how you can insert an instance of  Flower  into\nthe collection and then retrieve it as a  List  of your POJO class objects: When you run this code, your output should look something like this: For more information about the methods and classes mentioned in this section,\nsee the following API documentation: The  PojoCodecProvider , a codec provider that includes\n Codecs  that define how to\nencode/decode the data between the POJO and MongoDB document, and which\nPOJO classes or packages that the codecs should apply to. A  CodecRegistry  instance that contains the codecs and other related information. A  MongoDatabase  or  MongoCollection  instance configured to use the\n CodecRegistry . A  MongoCollection  instance created with the POJO document class\nbound to the  TDocument  generic type. Configure the  PojoCodecProvider . In this example, we use the  automatic(true) \nsetting of the  PojoCodecProvider.Builder  to apply the Codecs to\nany class and its properties. Codec providers also contain other objects such as  ClassModel  and\n Convention  instances that further define serialization behavior.\nFor more information on codec providers and customization, see the guide\non  POJO Customization . Add the  PojoCodecProvider  instance to a  CodecRegistry . The\n CodecRegistry  allows you to specify one or more codec providers to\nencode the POJO data. In this example, we call the following methods: See the following code to see how to instantiate the  CodecRegistry : fromRegistries()  to combine multiple  CodecRegistry  instances into a single one getDefaultCodecRegistry()  to retrieve a  CodecRegistry  instance from a list of codec providers fromProviders()  to create a  CodecRegistry  instance from the  PojoCodecProvider Configure the  MongoDatabase  or  MongoCollection  instance to use the\nCodecs in the  CodecRegistry . You only need to configure one of these.\nIn this example, we set the  CodecRegistry  on a  MongoDatabase  called\n sample_pojos  using the  withCodecRegistry()  method. Pass your POJO class to your call to  getCollection()  as the\ndocument class parameter and specify it as the type argument of your\n MongoCollection  instance as follows: Create a document from a POJO Retrieve data in a POJO instance By default, the  PojoCodecProvider  omits fields in your POJO that are\nset to  null . For more information on how to specify this behavior, see\nthe guide on  POJO Customization . CodecRegistry TDocument PojoCodecProvider automatic(true) PojoCodecProvider.Builder fromRegistries() getDefaultCodecRegistry() fromProviders() In this guide, we explained how to convert data between BSON and POJO fields\nby performing the following: Instantiate a  PojoCodecProvider  which contains codecs which define how to\nencode/decode data between BSON and the POJO fields. Specify the  automatic  conversion behavior for the  PojoCodecProvider \nto apply the  Codecs  to any class and its properties. Add the  PojoCodecProvider  to a  CodecRegistry , and specify the\nregistry on an instance of a  MongoDatabase  or  MongoCollection .",
            "code": [
                {
                    "lang": "java",
                    "value": "public class Flower {\n\n    private ObjectId id;\n    private String name;\n    private List<String> colors;\n    private Boolean isBlooming;\n    private Float height;\n\n    // public empty constructor needed for retrieving the POJO\n    public Flower() {}\n\n    public Flower(String name, Boolean isBlooming, Float height, List<String> colors) {\n        this.name = name;\n        this.isBlooming = isBlooming;\n        this.height = height;\n        this.colors = colors;\n    }\n\n    public ObjectId getId() {\n        return id;\n    }\n\n    public void setId(ObjectId id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Boolean getIsBlooming() {\n        return isBlooming;\n    }\n\n    public void setIsBlooming(Boolean isBlooming) {\n        this.isBlooming = isBlooming;\n    }\n\n    public Float getHeight() {\n        return height;\n    }\n\n    public void setHeight(Float height) {\n        this.height = height;\n    }\n\n    public List<String> getColors() {\n        return colors;\n    }\n\n    public void setColors(List<String> colors) {\n        this.colors = colors;\n    }\n\n    @Override\n    public String toString() {\n        return \"Flower [id=\" + id + \", name=\" + name + \", colors=\" + colors + \", isBlooming=\" + isBlooming + \", height=\" + height + \"]\";\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "Flower flower = new Flower(\"rose\", false, 25.4f, Arrays.asList(new String[] {\"red\", \"green\"}));\n\n// insert the instance\ncollection.insertOne(flower);\n\n// return all documents in the collection\nList<Flower> flowers = new ArrayList<>();\ncollection.find().into(flowers);\nSystem.out.println(flowers);"
                },
                {
                    "lang": "none",
                    "value": "[Flower [id=5f7f87659ed5b07cf3480a06, name=rose, colors=[green, red], isBlooming=false, height=25.4]]"
                },
                {
                    "lang": "java",
                    "value": "CodecProvider pojoCodecProvider = PojoCodecProvider.builder().automatic(true).build();"
                },
                {
                    "lang": "java",
                    "value": "// ensure you use the following static imports before your class definition\nimport static com.mongodb.MongoClientSettings.getDefaultCodecRegistry;\nimport static org.bson.codecs.configuration.CodecRegistries.fromProviders;\nimport static org.bson.codecs.configuration.CodecRegistries.fromRegistries;\n\n// ...\n\nCodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider));"
                },
                {
                    "lang": "java",
                    "value": "try (MongoClient mongoClient = MongoClients.create(uri)) {\n    MongoDatabase database = mongoClient.getDatabase(\"sample_pojos\").withCodecRegistry(pojoCodecRegistry);\n    // ...\n}"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<Flower> collection = database.getCollection(\"flowers\", Flower.class);"
                }
            ],
            "preview": "In this guide, you can learn how to store and retrieve data in the\nMongoDB Java driver using plain old Java objects (POJOs).\nPOJOs are often used for data encapsulation, separating business logic from\ndata representation.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/mongoclientsettings",
            "title": "Specify MongoClient Settings",
            "headings": [
                "Overview",
                "MongoClient Settings",
                "Example",
                "Cluster Settings",
                "Example",
                "Connection Pool Settings",
                "Example",
                "Server Settings",
                "Example",
                "Socket Settings",
                "Example",
                "TLS/SSL Settings",
                "Example"
            ],
            "paragraphs": "In this guide, you can learn about the different settings to control\nthe behavior of your  MongoClient . The following sections describe commonly used settings: MongoClient Settings Cluster Settings Socket Settings Connection Pool Settings Server Settings TLS/SSL Settings You can control the behavior of your  MongoClient  by creating and passing\nin a  MongoClientSettings \nobject to the  MongoClients.create() \nmethod. To create a  MongoClientSettings  object, use the\n MongoClientSettings.builder()  method and chain methods to specify your\nsettings. After chaining them, use the  build()  method to create the\n MongoClientSettings  object. The following table describes all the methods you can chain to modify your\nconnection behavior: Method Description addCommandListener() Adds a listener for  command events . applicationName() Sets the logical name of the application using the  MongoClient . applyConnectionString() Applies the settings from the given  ConnectionString  to the\nbuilder. If you omit this method, the driver attempts to connect to\n localhost . applyToClusterSettings() Applies the  ClusterSettings.Builder  block and then sets the\n cluster settings . applyToConnectionPoolSettings() Applies the  ConnectionPoolSettings.Builder  block and then sets the\n connection pool settings . applyToServerSettings() Applies the  ServerSettings.Builder  block and then sets the\n server settings . applyToSocketSettings() Applies the  SocketSettings.Builder  block and then sets the\n socket settings . applyToSslSettings() Applies the  SslSettings.Builder  block and then sets the\n TLS/SSL settings . autoEncryptionSettings() codecRegistry() Sets the  codec registry . commandListenerList() Sets the  command listeners . compressorList() Sets the  compressors  to use for compressing\nmessages to the server. credential() Sets the  credential . readConcern() Sets the  read concern . readPreference() retryReads() retryWrites() serverApi() Sets the  server API  to use when sending\ncommands to the server. streamFactoryFactory() Sets the factory to use to create a  StreamFactory . uuidRepresentation() Sets the UUID representation to use when encoding instances of UUID\nand decoding BSON binary values with subtype of 3. writeConcern() This example demonstrates specifying a  ConnectionString : Some options in the settings map to a connection string option.\nIf you specify the same options in your settings and connection\nstring, the order you chain them determines which option the driver\nuses. The driver uses the  last  setting it reads. For example, this snippet contains settings with the following times\nfor the driver to connect to an available socket: Since the driver reads the socket settings options last, the driver\nexpects to connect to an available socket within  5 SECONDS  before\ntiming out. The connection string specifies within  2 SECONDS The  socket settings  specifies within\n 5 SECONDS To log the  MongoClient  instance settings,\nset the  org.mongodb.driver.client  named\nlogger to the  INFO  level. To learn more about logging with the MongoDB Java Driver, see the\n Logging  guide. Chain the  applyToClusterSettings() \nmethod to modify the driver's behavior when interacting with your\nMongoDB cluster. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description addClusterListener() Adds a listener for cluster-related events. applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the cluster settings specified in a  ClusterSettings  object. hosts() Sets all the specified locations of a Mongo deployment. localThreshold() mode() Sets how to connect to a MongoDB deployment. requiredClusterType() Sets the type of cluster required for the cluster. requiredReplicaSetName() Sets the replica set name required for the cluster. serverSelectionTimeout() serverSelector() Adds a server selector to apply before server selection. srvHost() Sets the host name to use to look up an SRV DNS record to find the\nMongoDB hosts. When setting  srvHost , the driver does not process any\nassociated TXT records associated with the host. If you want to enable the processing of TXT records, you must\nspecify the SRV host in the connection string using the\n applyConnectionString()  method. srvMaxHosts() This example specifies for the driver to connect directly to a server,\nregardless of the type of MongoDB cluster it's a part of: This is analogous to the  directConnection  parameter you can specify\nin your connection URI. See  Connection Options  for more\ninformation. Chain the  applyToConnectionPoolSettings() \nmethod to modify the way the driver manages its connection pool. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description addConnectionPoolListener() Adds a listener for connection pool-related events. applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the connection pool settings specified in a\n ConnectionPoolSettings  object. maintenanceFrequency() Sets the frequency for running a maintenance job. maintenanceInitialDelay() Sets the time to wait before running the first maintenance job. maxConnectionIdleTime() Sets the maximum time a connection can be idle before it's closed. maxConnectionLifeTime() Sets the maximum time a pooled connection can be alive before it's\nclosed. maxSize() maxWaitTime() minSize() This  maxSize  and  minSize  settings apply to each server\nin the cluster you connect the driver to. For example, assume you connect the driver to a cluster with three\n mongos  servers. This means that there can be at most  maxSize \nconnections and at least  minSize  connections to each  mongos  server. This example specifies the following driver behavior in a pool of\n Connection  types: The thread to wait at most  10 SECONDS  for an available connection To have at most  200  connections associated with the pool Chain the  applyToServerSettings() \nmethod to modify the driver's behavior when monitoring each MongoDB\ndeployment. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description addServerListener() Adds a listener for server-related events. addServerMonitorListener() Adds a listener for server monitor-related events. applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the server settings specified in a  ServerSettings  object. heartbeatFrequency() minHeartbeatFrequency() This example specifies the following driver behavior in a MongoDB deployment: The minimum interval for server monitoring checks to be at least\n 700 MILLISECONDS The cluster monitor to attempt reaching a server every  15 SECONDS Chain the  applyToSocketSettings() \nmethod to modify the driver's behavior when connecting and communicating\nwith your MongoDB deployment. The following table describes the methods you can chain to your settings\nto modify the driver's behavior: Method Description applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the socket settings specified in a  SocketSettings  object. connectTimeout() readTimeout() receiveBufferSize() sendBufferSize() This example specifies the following driver behavior in a MongoDB socket: To connect to an available socket within  10 SECONDS To read from an available socket within  15 SECONDS Chain the  applyToSslSettings() \nmethod to modify the driver's behavior when using TLS/SSL to secure a\nconnection between your application and MongoDB. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the TLS/SSL settings specified in a  SslSettings  object. context() Sets the  SSLContext  for use when you enable TLS/SSL. enabled() Whether to enable TLS/SSL. (You must enable this for Atlas clusters.) invalidHostNameAllowed() Whether to allow a mismatch between the server\u2019s hostname and the\nhostname specified by the TLS certificate. This example specifies for the driver to enable TLS/SSL when connecting\nto MongoDB:",
            "code": [
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n    .applyConnectionString(new ConnectionString(\"<your connection string>\"))\n    .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n   MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"mongodb+srv://<username>:<password>@<hostname>:<port>/<auth db>?connectTimeoutMS=2000\"))\n      .applyToSocketSettings(builder ->\n      builder.connectTimeout(5, SECONDS))\n      .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n   MongoClientSettings.builder()\n      .applyConnectionString(new ConnectionString(\"mongodb+srv://host1.acme.com\")))"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder()\n    .applyToClusterSettings(builder ->\n        builder.mode(ClusterConnectionMode.SINGLE)\n    .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))\n    .applyToConnectionPoolSettings(builder ->\n        builder.maxWaitTime(10, SECONDS)\n        .maxSize(200)\n    .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))\n    .applyToServerSettings(builder ->\n        builder.minHeartbeatFrequency(700, MILLISECONDS)\n        .heartbeatFrequency(15, SECONDS))\n    .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))\n    .applyToSocketSettings(builder ->\n        builder.connectTimeout(10, SECONDS)\n        .readTimeout(15, SECONDS))\n    .build());"
                },
                {
                    "lang": "java",
                    "value": "MongoClient mongoClient = MongoClients.create(\n    MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))\n    .applyToSslSettings(builder ->\n        builder.enabled(true))\n    .build());"
                }
            ],
            "preview": "In this guide, you can learn about the different settings to control\nthe behavior of your MongoClient.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/documents",
            "title": "Documents",
            "headings": [
                "Overview",
                "Document",
                "BsonDocument",
                "JsonObject",
                "BasicDBObject",
                "Summary"
            ],
            "paragraphs": "In this guide, you can learn how to use  documents  in the\nMongoDB Java Driver. A MongoDB document is a data structure that contains key/value fields in\nbinary JSON (BSON) format. You can use documents and the data they contain\nin their fields to store data as well as issue commands or queries in\nMongoDB. For more information on the terminology, structure, and limitations of documents,\nread our page on  Documents  in the MongoDB manual. The MongoDB Java driver and BSON library include the following classes that help you\naccess and manipulate the BSON data in documents: While you can use any of these classes in your application, we recommend\nthat you use the  Document  class since it can concisely represent\ndynamically structured documents of any complexity. It implements the\n Map<String, Object>  interface which enables it to use loosely-typed\nvalues. Name Package Implements Map Recommended Usage Document org.bson Yes, implements  Map<String, Object> When you want a flexible and concise data representation. BsonDocument org.bson Yes, implements  Map<String, BsonValue> When you need a type-safe API. JsonObject org.bson.json No When you only want to work with JSON strings. BasicDBObject com.mongodb No When you are migrating your application from a legacy driver version. The  Document  class offers a flexible representation of a BSON document.\nYou can access and manipulate fields using Java types from the standard\nlibrary with this class. See the following table for mappings between\nfrequently-used BSON and Java types: The preceding mapping table shows the default mapping when working with the\n Document  class. You can customize the type mapping by specifying a\ncustom codec. For more information on customizing mapped types, see our guide\non using  Codecs . In the following code snippet, we show how to instantiate and build a sample\n Document  instance representing a document containing several\ndifferent field types: To insert this document into a collection, instantiate a collection\nusing the  getCollection()  method and call the  insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample document\ndata from the collection using the following code: The output should look something like this: For more information on retrieving and manipulating MongoDB data, see our\n CRUD guide . For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: BSON type Java type Array java.util.List Binary org.bson.types.Binary Boolean java.lang.Boolean Date java.util.Date Document org.bson.Document Double java.lang.Double Int32 java.lang.Integer Int64 java.lang.Long Null null ObjectId org.bson.types.ObjectId String java.lang.String The preceding code sample uses helper methods that check the returned type\nand throw an exception if it is unable to cast the field value.\nYou can call the  get()  method specified by the  Map  interface\nto retrieve field values as type  Object  and to skip type checking. Document getCollection() get() The  BsonDocument  class provides a type-safe API to access and manipulate\na BSON document. You need to specify the BSON type from the Java BSON\nlibrary for each field. See the following table for mappings between\nfrequently-used BSON and Java BSON library types: In the following code snippet, we show how to instantiate and build a sample\n BsonDocument  instance representing a document containing several\ndifferent field types: To insert this document into a collection, instantiate a collection\nusing the  getCollection()  method specifying the  BsonDocument \nclass as the  documentClass  parameter. Then, call the\n insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample document\ndata from the collection using the following code: The output should look something like this: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: BSON type Java BSON library type Array org.bson.BsonArray Binary org.bson.BsonBinary Boolean org.bson.Boolean Date (long value) org.bson.BsonDateTime Document org.bson.BsonDocument Double org.bson.BsonDouble Int32 org.bson.BsonInt32 Int64 org.bson.BsonInt64 Null org.bson.BsonNull ObjectId org.bson.BsonObjectId String org.bson.BsonString The preceding code sample uses helper methods that check the returned type\nand throw a  BsonInvalidOperationException  if it is unable to cast\nthe field value. You can call the  get()  method specified by the\n Map  interface to retrieve field values as type  BsonValue  and\nto skip type checking. BsonDocument getCollection() BsonInvalidOperationException get() BsonValue The  JsonObject  class acts as a wrapper for JSON strings.\nIf you only want to work with JSON data, you can use  JsonObject \nto avoid unnecessary data conversion to a  Map  object. By default,  JsonObject  stores  Extended JSON .\nYou can customize the format of JSON in  JsonObject  by specifying a\n JsonObjectCodec  and passing it a  JsonWriterSettings \nobject. For more information on JSON formats, see\nour  Extended JSON guide .\nFor more information on specifying codecs, see our\n Codecs guide . In the following code snippet, we show how to instantiate a sample  JsonObject \ninstance wrapping an Extended JSON string containing different types of key value pairs: To insert this document into a collection, instantiate a collection\nusing the  getCollection()  method specifying the  JsonObject  class\nas the  documentClass  parameter. Then, call the\n insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample JSON data from the\ncollection. While you can use any class that extends  Bson  to specify your query,\nhere is how to query your data using a  JsonObject : The output should look something like this: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: If you would like to work with other formats of JSON strings\nin your application, you can use the  JsonObjectCodec  class\nalong with  JsonWriterSettings  to specify your desired JSON\nformat. The following code example reads and writes\nto our MongoDB instance using\n Relaxed mode JSON \nstrings and outputs  ObjectId  instances as hex strings: The output of this code should look something like this: JsonObject JsonObjectCodec JsonWriterSettings getCollection() The  BasicDBObject  class allows you to access and manipulate document data\nusing Java types. We recommend that you avoid using this class unless you\nare migrating an application from an older driver version\nbecause of the following limitations: In the following code snippet, we show how to instantiate and build a sample\n BasicDBObject  instance representing a document containing several\ndifferent field types: To insert this document into a collection, instantiate a collection using\nthe  getCollection()  method specifying the  BasicDBObject  class as\nthe  documentClass  parameter. Then, call the\n insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample document\ndata from the collection using the following code: The output should look something like this: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: BasicDBObject  does not implement  Map<K, V>  and therefore\nlacks the data access and manipulation convenience methods of a  Map . It implements the  DBObject  interface rather than a class, so you\ncannot extend the API without breaking  binary compatibility .\nThis means that if the interface was ever changed in a way that broke\nthe binary compatibility, all applications and classes that use the\ninterface need to be recompiled to run the new version without errors. The preceding code sample uses helper methods that check the returned type\nand throw an exception if it is unable to cast the field value.\nYou can call the  get()  method to retrieve values as type\n Object  and to skip type checking. BasicDBObject getCollection() get() In this guide, we covered the following topics on classes you can use to\nwork with BSON data: Described four Java classes you can use to work with MongoDB documents and\nwhy you might prefer one over the other. Provided usage examples for each class on building documents containing\nmultiple types, inserting them into a collection, and\nretrieving/accessing their typed fields.",
            "code": [
                {
                    "lang": "java",
                    "value": "Document author = new Document(\"_id\", new ObjectId())\n    .append(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")\n    .append(\"dateOfDeath\", Date.from(LocalDate.of(2014, 4, 17).atStartOfDay(ZoneId.systemDefault()).toInstant()))\n    .append(\"novels\", Arrays.asList(\n        new Document(\"title\", \"One Hundred Years of Solitude\").append(\"yearPublished\", 1967),\n        new Document(\"title\", \"Chronicle of a Death Foretold\").append(\"yearPublished\", 1981),\n        new Document(\"title\", \"Love in the Time of Cholera\").append(\"yearPublished\", 1985)));"
                },
                {
                    "lang": "java",
                    "value": "// MongoClient mongoClient = <code to instantiate your client>;\n\nMongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\");\nMongoCollection<Document> collection = database.getCollection(\"authors\");\n\nInsertOneResult result = collection.insertOne(author);"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Filters;\n// <MongoCollection setup code here>\n\nDocument doc = collection.find(Filters.eq(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")).first();\nif (doc != null) {\n    System.out.println(\"_id: \" + doc.getObjectId(\"_id\")\n        + \", name: \" + doc.getString(\"name\")\n        + \", dateOfDeath: \" + doc.getDate(\"dateOfDeath\"));\n\n    doc.getList(\"novels\", Document.class).forEach((novel) -> {\n        System.out.println(\"title: \" + novel.getString(\"title\")\n            + \", yearPublished: \" + novel.getInteger(\"yearPublished\"));\n        });\n}"
                },
                {
                    "lang": "none",
                    "value": "_id: 5fb5fad05f734e3794741a35, name: Gabriel Garc\u00eda M\u00e1rquez, dateOfDeath: Thu Apr 17 00:00:00 EDT 2014\ntitle: One Hundred Years of Solitude, yearPublished: 1967\ntitle: Chronicle of a Death Foretold, yearPublished: 1981\ntitle: Love in the Time of Cholera, yearPublished: 1985"
                },
                {
                    "lang": "java",
                    "value": "BsonDocument author = new BsonDocument()\n    .append(\"_id\", new BsonObjectId())\n    .append(\"name\", new BsonString(\"Gabriel Garc\u00eda M\u00e1rquez\"))\n    .append(\"dateOfDeath\", new BsonDateTime(LocalDate.of(2014, 4, 17).atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()))\n    .append(\"novels\", new BsonArray(Arrays.asList(\n        new BsonDocument().append(\"title\", new BsonString(\"One Hundred Years of Solitude\")).append(\"yearPublished\", new BsonInt32(1967)),\n        new BsonDocument().append(\"title\", new BsonString(\"Chronicle of a Death Foretold\")).append(\"yearPublished\", new BsonInt32(1981)),\n        new BsonDocument().append(\"title\", new BsonString(\"Love in the Time of Cholera\")).append(\"yearPublished\", new BsonInt32(1985))\n   )));"
                },
                {
                    "lang": "java",
                    "value": "// MongoClient mongoClient = <code to instantiate your client>;\n\nMongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\");\nMongoCollection<BsonDocument> collection = database.getCollection(\"authors\", BsonDocument.class);\n\nInsertOneResult result = collection.insertOne(author);"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Filters;\n\n// <MongoCollection setup code here>\n\nBsonDocument doc = collection.find(Filters.eq(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")).first();\nif (doc != null) {\n    System.out.println(\"_id: \" + doc.getObjectId(\"_id\").getValue()\n            + \", name: \" + doc.getString(\"name\").getValue()\n            + \", dateOfDeath: \" + new Date(doc.getDateTime(\"dateOfDeath\").getValue()));\n\n    doc.getArray(\"novels\").forEach((novel) -> {\n        System.out.println(\"title: \" + novel.asDocument().getString(\"title\").getValue()\n                + \", yearPublished: \" + novel.asDocument().getInt32(\"yearPublished\").getValue());\n    });\n}"
                },
                {
                    "lang": "none",
                    "value": "_id: 5fb5fad05f734e3794741a35, name: Gabriel Garc\u00eda M\u00e1rquez, dateOfDeath: Thu Apr 17 00:00:00 EDT 2014\ntitle: One Hundred Years of Solitude, yearPublished: 1967\ntitle: Chronicle of a Death Foretold, yearPublished: 1981\ntitle: Love in the Time of Cholera, yearPublished: 1985"
                },
                {
                    "lang": "java",
                    "value": "String ejsonStr = \"{\\\"_id\\\": {\\\"$oid\\\": \\\"6035210f35bd203721c3eab8\\\"},\"\n        + \"\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\",\"\n        + \"\\\"dateOfDeath\\\": {\\\"$date\\\": \\\"2014-04-17T04:00:00Z\\\"},\"\n        + \"\\\"novels\\\": [\"\n        + \"{\\\"title\\\": \\\"One Hundred Years of Solitude\\\",\\\"yearPublished\\\": 1967},\"\n        + \"{\\\"title\\\": \\\"Chronicle of a Death Foretold\\\",\\\"yearPublished\\\": 1981},\"\n        + \"{\\\"title\\\": \\\"Love in the Time of Cholera\\\",\\\"yearPublished\\\": 1985}]}\";\nJsonObject author = new JsonObject(ejsonStr);"
                },
                {
                    "lang": "java",
                    "value": "// MongoClient mongoClient = <code to instantiate your client>;\n\nMongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\");\nMongoCollection<JsonObject> collection = database.getCollection(\"authors\", JsonObject.class);\n\nInsertOneResult result = collection.insertOne(author);"
                },
                {
                    "lang": "java",
                    "value": "// MongoClient mongoClient = <code to instantiate your client>;\n\nJsonObject query = new JsonObject(\"{\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\"}\");\nJsonObject jsonResult = collection.find(query).first();\nif (jsonResult != null) {\n    System.out.println(\"query result in extended json format: \" + jsonResult.getJson());\n}"
                },
                {
                    "lang": "none",
                    "value": "query result in extended json format: {\"_id\": {\"$oid\": \"6035210f35bd203721c3eab8\"}, \"name\": \"Gabriel Garc\u00eda M\u00e1rquez\", \"dateOfDeath\": {\"$date\": \"2014-04-17T04:00:00Z\"}, \"novels\": [{\"title\": \"One Hundred Years of Solitude\", \"yearPublished\": 1967}, {\"title\": \"Chronicle of a Death Foretold\", \"yearPublished\": 1981}, {\"title\": \"Love in the Time of Cholera\", \"yearPublished\": 1985}]}"
                },
                {
                    "lang": "java",
                    "value": "import static org.bson.codecs.configuration.CodecRegistries.fromCodecs;\n\n// MongoClient mongoClient = <code to instantiate your client>;\n\nMongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\");\nMongoCollection<JsonObject> collection = database.getCollection(\"authors\", JsonObject.class)\n        .withCodecRegistry(\n                fromCodecs(\n                        // define a JsonObjectCodec with a JsonWriterSettings in Relaxed mode\n                        new JsonObjectCodec(JsonWriterSettings\n                                .builder()\n                                .outputMode(JsonMode.RELAXED)\n                                .objectIdConverter((objectId, strictJsonWriter) -> {\n                                    strictJsonWriter.writeString(objectId.toHexString());\n                                })\n                                .build())));\nJsonObject author = new JsonObject(\"{\\\"_id\\\": \\\"6035210f35bd203721c3eab8\\\", \"\n        + \"\\\"name\\\": \\\"Gabriel Garc\u00eda M\u00e1rquez\\\", \"\n        + \"\\\"dateOfDeath\\\": {\\\"$date\\\": \\\"2014-04-17T04:00:00Z\\\"}, \"\n        + \"\\\"novels\\\": [{\\\"title\\\": \\\"One Hundred Years of Solitude\\\", \\\"yearPublished\\\": 1967}, {\\\"title\\\": \\\"Chronicle of a Death Foretold\\\", \\\"yearPublished\\\": 1981}, \"\n        + \"{\\\"title\\\": \\\"Love in the Time of Cholera\\\", \\\"yearPublished\\\": 1985}]}\\n\");\ncollection.insertOne(author);\nJsonObject query = new JsonObject(\"{\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\"}\");\nJsonObject jsonResult = collection.find(query).first();\nif (jsonResult != null) {\n    System.out.println(\"query result in relaxed json format: \" + jsonResult.getJson());\n}"
                },
                {
                    "lang": "none",
                    "value": "query result in relaxed json format: {\"_id\": \"6035210f35bd203721c3eab8\", \"name\": \"Gabriel Garc\u00eda M\u00e1rquez\", \"dateOfDeath\": {\"$date\": \"2014-04-17T04:00:00Z\"}, \"novels\": [{\"title\": \"One Hundred Years of Solitude\", \"yearPublished\": 1967}, {\"title\": \"Chronicle of a Death Foretold\", \"yearPublished\": 1981}, {\"title\": \"Love in the Time of Cholera\", \"yearPublished\": 1985}]}"
                },
                {
                    "lang": "java",
                    "value": "BasicDBObject author = new BasicDBObject(\"_id\", new ObjectId())\n    .append(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")\n    .append(\"dateOfDeath\", Date.from(LocalDate.of(2014, 4, 17).atStartOfDay(ZoneId.systemDefault()).toInstant()))\n    .append(\"novels\", Arrays.asList(\n        new BasicDBObject(\"title\", \"One Hundred Years of Solitude\").append(\"yearPublished\", 1967),\n        new BasicDBObject(\"title\", \"Chronicle of a Death Foretold\").append(\"yearPublished\", 1981),\n        new BasicDBObject(\"title\", \"Love in the Time of Cholera\").append(\"yearPublished\", 1985)));"
                },
                {
                    "lang": "java",
                    "value": "// MongoClient mongoClient = <code to instantiate your client>;\n\nMongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\");\nMongoCollection<BasicDBObject> collection = database.getCollection(\"authors\", BasicDBObject.class);\n\nInsertOneResult result = collection.insertOne(author);"
                },
                {
                    "lang": "java",
                    "value": "import com.mongodb.client.model.Filters;\n// <MongoCollection setup code here>\n\nBasicDBObject doc = collection.find(Filters.eq(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")).first();\nif (doc != null) {\n    System.out.println(\"_id: \" + doc.getObjectId(\"_id\")\n        + \", name: \" + doc.getString(\"name\")\n        + \", dateOfDeath: \" + doc.getDate(\"dateOfDeath\"));\n\n    BasicDBList novels = (BasicDBList) doc.get(\"novels\");\n    if (novels != null) {\n        BasicDBObject[] novelArr = novels.toArray(new BasicDBObject[0]);\n        for (BasicDBObject novel : novelArr) {\n            System.out.println(\"title: \" + novel.getString(\"title\")\n            + \", yearPublished: \" + novel.getInt(\"yearPublished\"));\n        }\n    }\n}"
                },
                {
                    "lang": "none",
                    "value": "_id: 5fb5fad05f734e3794741a35, name: Gabriel Garc\u00eda M\u00e1rquez, dateOfDeath: Thu Apr 17 00:00:00 EDT 2014\ntitle: One Hundred Years of Solitude, yearPublished: 1967\ntitle: Chronicle of a Death Foretold, yearPublished: 1981\ntitle: Love in the Time of Cholera, yearPublished: 1985"
                }
            ],
            "preview": "In this guide, you can learn how to use documents in the\nMongoDB Java Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/pojo-customization",
            "title": "POJO Customization",
            "headings": [
                "Overview",
                "Customize a PojoCodecProvider",
                "ClassModel",
                "PropertyModel",
                "Conventions",
                "Annotations",
                "Discriminators",
                "Advanced Configuration",
                "Abstract or Interface Types in Properties",
                "POJOs without No-Argument Constructors",
                "Serialization Customization",
                "Generics Support",
                "Enum Type Support"
            ],
            "paragraphs": "In this guide, you can learn how to define custom data conversions between\nBSON and POJOs in the MongoDB Java driver. In our guide on  POJOs ,\nwe show how to specify a  PojoCodecProvider  which contains classes that\nprovide instructions on how to convert data for one or more POJO classes\nand their properties. We show how to specify your data conversion using the  ClassModel \nand  PropertyModel  classes. You can also learn\nabout more specific customization from the section on  Advanced Configuration . We also show how to use helpers such as  Conventions \nand  Annotations  to specify common serialization actions. See the section on  Discriminators  if you want to\nserialize multiple POJO classes to documents in the same collection. If you need to implement conditional serialization, or if you need to use\nenums, generics, interface types, or abstract types, see the section on\n Advanced Configuration . If you only need to use the predefined behavior to convert data between\nBSON and POJOs, you can use the  automatic  setting for the\n PojoCodecProvider  shown in the  Document Data Formats: POJOs guide . This section shows you how to specify your data conversion logic and POJO\nclasses with a  PojoCodecProvider . The  PojoCodecProvider  is an\nimplementation of the  CodecProvider  interface that specifies the\nCodecs to use in data conversion. Use this implementation when performing\ndata conversion between BSON and POJOs. You can create a  PojoCodecProvider  instance using the\n PojoCodecProvider.builder()  method. You can also chain methods to the\nbuilder to register any of the following: The following example shows how you can specify the POJOs in a package named\n\"org.example.pojos\" and add the  PojoCodecProvider  to a  CodecRegistry : For more information on this class, see the  PojoCodecProvider.Builder \nAPI Documentation. Individual POJO classes Package names that contain POJO classes Instances of  ClassModel  that describe conversion logic for a specific\nPOJO class A  ClassModel  instance stores data conversion information about a specific\nPOJO class. It contains a list of  PropertyModel  instances which describe\nthe property fields of the POJO, whether to convert fields, and optionally,\n Codecs  to convert the fields. A  ClassModel  contains the following fields: For more information on this class, see the  ClassModel \nAPI Documentation. To instantiate a  ClassModel , use the  ClassModel.builder()  method and\nspecify your POJO class. The builder uses reflection to create the required\nmetadata. Field Name Description Name The POJO class name to associate with the  ClassModel . InstanceCreatorFactory Contains a new instance factory that creates new instances of the POJO.\nBy default, it requires the POJO to have an empty constructor. PropertyModels Contains a list of  PropertyModel  instances that specify how to\nconvert data to and from BSON for a field in the POJO. IdPropertyModelHolder Specifies the POJO field that corresponds to the document  _id  field. Optional. Discriminator Key Discriminator Value Discriminator Flag Specifies whether to serialize the discriminator, off by default. Optional. A  PropertyModel  stores information on how to serialize/deserialize a\nspecific field in a document. The  PropertyModel  contains the following information: To create a  PropertyModel  use a  PropertyModelBuilder  which you\ncan instantiate by calling the  PropertyModel.builder()  method. For more information on this class, see the\n PropertyModel.Builder  API Documentation. Field Name Description Name Specifies the property name in the model. Read Name Name of the property to use as the key when serializing to BSON. Write Name Name of the property to use as the key when deserializing from BSON. Type data Contains an instance of  org.bson.codecs.pojo.TypeData  that\ndescribes the data type for the field. Codec Specifies a codec to use to encode or decode the field. Optional. Serialization checker Determines whether to serialize a value by using the criteria\nspecified in the checker. Property accessor Method used to access the value of the property from the POJO. useDiscriminator The  Convention  interface contains configuration options that modify the\nbehavior of a  ClassModel  or  PropertyModel . You can specify a\n Convention  in a call to  PojoCodecProvider.Builder.conventions()  or to\n ClassModelBuilder.conventions() . You can access the  Convention  instances defined in the BSON library\nfrom the following static fields in the  Conventions  class: You can specify Conventions using one of the following methods: To create a custom Convention, create a class that implements the\n Convention  interface and override the  apply()  method from which you can\naccess your  ClassModelBuilder  instance. The builders apply  Convention  instances in order which may override\nbehavior defined in one applied earlier. Field Name Description ANNOTATION_CONVENTION Enables the annotations defined in the  org.bson.codecs.pojo.annotations \npackage for your POJO. See the section on  Annotations \nfor more information. CLASS_AND_PROPERTY_CONVENTION DEFAULT_CONVENTIONS NO_CONVENTIONS Provides an empty list. OBJECT_ID_GENERATORS Adds a default  IdGenerator  that adds a new  ObjectId  for each\n ClassModel  that use  ObjectId  values in the  id  property. SET_PRIVATE_FIELDS_CONVENTION Enables the  ClassModel  to set private fields using reflection\nwithout requiring a setter method. USE_GETTERS_FOR_SETTERS Enables use of getter methods as setters for  Collection  and  Map \nfields if no setter method exists. PojoCodecProvider.Builder.conventions() ClassModelBuilder.conventions() You can apply annotations to the getter and setter methods of a POJO\nclass. These annotations configure the  ClassModel  and  PropertyModel \nbehavior for a specific field, method, or class. The following annotations are available from the\n org.bson.codecs.pojo.annotations \npackage: The following code snippet shows a sample POJO called  Product  that uses\nthe preceding annotations. The annotations in the example POJO specify the following behavior: Annotation Name Description BsonCreator Marks a public constructor or a public static method as the creator for\nnew instances of the class. You must annotate all parameters in the\nconstructor with either the  BsonProperty  or  BsonId  annotations. BsonDiscriminator Specifies that a class uses a discriminator. You can set a custom\ndiscriminator key and value. BsonRepresentation Specifies the BSON type used to store the value when different from the\nPOJO property. BsonId Marks a property to serialize as the _id property. BsonIgnore Marks a property to ignore. You can configure whether to serialize\nand/or deserialize a property. BsonProperty Specifies a custom document field name when converting the POJO\nfield to BSON. You can include a discriminator to serialize POJOs\nnested within the field. When using annotations, remember to specify the\n Conventions.ANNOTATION_CONVENTION  in your  ClassModelBuilder \nor  PojoCodecProvider.Builder . For example: Reference the POJO with the specified discriminator key and value, adding\nthe  cls  field with the value of \"AnnotatedProduct\" to the BSON document\non write operations Convert between the POJO  name  field and value and the BSON  modelName \nfield and value in the document Convert between the POJO  serialNumber  field and value the BSON document\n _id  field and value in the document Omit the  relatedItems  field and value when converting data Use the  Product(String name)  constructor when instantiating the POJO A discriminator is a property that identifies a specific document schema. The\ndiscriminator key identifies a document field to use to identify the schema.\nThe discriminator value identifies the default value of the document field. Use discriminators to instruct the  CodecProvider  which object class to use\nwhen deserializing to different object classes from the same collection. When\nserializing the POJO to a MongoDB collection, the associated codec sets the\ndiscriminator key-value field, unless otherwise specified in the POJO property\ndata. You can set and enable a discriminator in a POJO by performing one of the\nfollowing: See the following example POJO classes that contain  @BsonDiscriminator \nannotations and example documents that contain the discriminator fields: The following shows sample documents created from the preceding POJOs in a\nsingle MongoDB collection: Use the  @BsonDiscriminator  annotation to specify the discriminator for\nthe POJO class Call  enableDiscriminator(true)  on the  ClassModelBuilder \nassociated with the POJO class To serialize a POJO that includes abstract class or interface type properties,\nyou must specify discriminators on the type and all its subtypes or\nimplementations. Suppose you defined a POJO that referenced an abstract class  User  in one\nof its fields as follows: If the  User  abstract class has subclasses  FreeUser  and\n SubscriberUser , you can add your POJO and abstract classes to your\n CodecRegistry  as follows: For more information on specifying discriminators, see the section of this\nguide on  Discriminators . The POJO  Codecs  default to calling the empty, no-argument constructor.\nTo specify a different constructor, you must perform the following in your\nPOJO: For an example of setting the  ANNOTATION_CONVENTION , see the\n ANNOTATION_CONVENTION example .\nFor an example of the  BsonCreator  annotation, see the\n POJO with annotation code example . pass the  ANNOTATION_CONVENTION  setting to your  ClassModelBuilder identify the constructor using the  BsonCreator  annotation By default,  ClassModelBuilder  attempts to serialize all the non-null\nproperties in your POJO. If a property value is  null , the default\n PropertySerialization  implementation skips that field. You can customize your POJO serialization behavior by performing one of the\nfollowing: For more information on how to use the  @BsonIgnore  annotation in a POJO,\nsee the section of this guide on  Annotations . The following sample code shows a custom class that implements the\n PropertySerialization  interface to override the default conditions\nby which to determine whether to serialize a field: The preceding class specifies that any integer greater than 29 is not serialized, and,\ntherefore, not included in the MongoDB document. Suppose you applied this\ncustom serialization behavior to the following sample POJO: You can specify the custom serialization by adding the\n CourteousAgeSerialization  instance to the  PropertyModelBuilder  from\nthe  ClassModel  property associated with the  age  field using the\nfollowing code: If you insert a POJO that contains a value greater than 29 in the  age \nfield, the serialized document omits it. The POJO declaration and\nresulting document could look something like this: Since the  age  field value is greater than 29, the serialized document\nshould look something like this: Use the  @BsonIgnore  annotation for a property to always skip\nserialization. Make sure to enable annotations using the appropriate\n Conventions . Create a custom class that overrides the  shouldSerialize()  method of the\n PropertySerialization  interface. Specify your custom implementation to\nthe  PropertyModelBuilder  which is accessible from the\n ClassModelBuilder . You can use the POJO  Codec  to serialize classes that contain generic\nproperties if they meet the following criteria: The  ClassModelBuilder  inspects and saves concrete type parameters to work\naround type erasure. It cannot serialize classes that contain generic\nproperties without concrete type parameters since the JVM removes the type\nparameter information. To save type parameters, you can implement the  PropertyCodecProvider \ninterface to specify them for generic types defined in a POJO. The following\ncode snippets show an example implementation of the  PropertyCodecProvider \nthat adds serialization compatibility to the Guava  Optional  class. Suppose you wanted to serialize the following POJO with  Optional  fields: You can use the following implementation of  PropertyCodecProvider  to\nretrieve your custom Codec. This implementation uses the\n TypeWithTypeParameters  interface to access the type information. Register your  OptionalPropertyCodecProvider  in your  PojoCodecProvider \nand the package that contains your POJO as follows: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: For more information on generics and type parameters, see the\n Java language guide on Invoking and Instantiating a Generic Type . Contain only bounded concrete type parameters If it or any of its fields are part of a class hierarchy, the top-level\nPOJO does not contain any type parameters PropertyCodecProvider TypeWithTypeParameters In driver versions 4.5 and later, the  PojoCodecProvider  no longer\nincludes a codec to convert  enum  types. Ensure that you register\na codec for  enum  types if you need one, such as the one in the default\ncodec registry. See the documentation on the  default codec registry \nfor more information on how to register the codecs it includes.",
            "code": [
                {
                    "lang": "java",
                    "value": "import org.bson.codecs.configuration.CodecProvider;\nimport org.bson.codecs.configuration.CodecRegistry;\nimport org.bson.codecs.pojo.PojoCodecProvider;\n\nimport static org.bson.codecs.configuration.CodecRegistries.fromRegistries;\nimport static org.bson.codecs.configuration.CodecRegistries.fromProviders;\nimport static com.mongodb.MongoClientSettings.getDefaultCodecRegistry;\n\nCodecProvider pojoCodecProvider = PojoCodecProvider.builder().register(\"org.example.pojos\").build();\nCodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider));\n\n// Call withCodecRegistry(pojoCodecRegistry) on an instance of MongoClient, MongoDatabase, or MongoCollection"
                },
                {
                    "lang": "java",
                    "value": "ClassModel<Flower> classModel = ClassModel.builder(Flower.class).build();"
                },
                {
                    "lang": "java",
                    "value": "import org.bson.BsonType;\nimport org.bson.codecs.pojo.annotations.BsonCreator;\nimport org.bson.codecs.pojo.annotations.BsonDiscriminator;\nimport org.bson.codecs.pojo.annotations.BsonId;\nimport org.bson.codecs.pojo.annotations.BsonIgnore;\nimport org.bson.codecs.pojo.annotations.BsonProperty;\nimport org.bson.codecs.pojo.annotations.BsonRepresentation;\n\n@BsonDiscriminator(value=\"AnnotatedProduct\", key=\"_cls\")\npublic class Product {\n    @BsonProperty(\"modelName\")\n    private String name;\n\n    @BsonId()\n    @BsonRepresentation(BsonType.OBJECT_ID)\n    private String serialNumber;\n\n    @BsonIgnore\n    private List<Product> relatedItems;\n\n    @BsonCreator\n    public Product(@BsonProperty(\"modelName\") String name) {\n        this.name = name;\n    }\n\n    // ...\n\n}"
                },
                {
                    "lang": "java",
                    "value": "ClassModel<Product> classModel = ClassModel.builder(Product.class).\n       conventions(Arrays.asList(Conventions.ANNOTATION_CONVENTION)).build();"
                },
                {
                    "lang": "java",
                    "value": "@BsonDiscriminator(value=\"AnonymousUser\", key=\"_cls\")\npublic class AnonymousUser {\n    // class code\n}\n\n@BsonDiscriminator(value=\"RegisteredUser\", key=\"_cls\")\npublic class RegisteredUser {\n    // class code\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_cls\": \"AnonymousUser\", \"_id\": ObjectId(\"<Object ID>\"),  ... }\n{ \"_cls\": \"RegisteredUser\", \"_id\": ObjectId(\"<Object ID>\"), ... }"
                },
                {
                    "lang": "java",
                    "value": "public class UserRecordPojo {\n     private User user;\n     // ...\n}"
                },
                {
                    "lang": "java",
                    "value": "ClassModel<UserRecordPojo> userRecordPojo = ClassModel.builder(UserRecordPojo.class).enableDiscriminator(true).build();\nClassModel<User> userModel = ClassModel.builder(User.class).enableDiscriminator(true).build();\nClassModel<FreeUser> freeUserModel = ClassModel.builder(FreeUser.class).enableDiscriminator(true).build();\nClassModel<SubscriberUser> subscriberUserModel = ClassModel.builder(SubscriberUser.class).enableDiscriminator(true).build();\n\nPojoCodecProvider pojoCodecProvider = PojoCodecProvider.builder().register(userRecordPojo, userModel, freeUserModel, subscriberUserModel).build();\n\nCodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider));"
                },
                {
                    "lang": "java",
                    "value": "public class CourteousAgeSerialization implements PropertySerialization<Integer> {\n    @Override\n    public boolean shouldSerialize(Integer value) {\n        return (value < 30);\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "public class BirthdayInvitation {\n    private String name;\n    private Integer age;\n    private LocalDateTime eventDateTime;\n\n    // ...\n}"
                },
                {
                    "lang": "java",
                    "value": "ClassModelBuilder<BirthdayInvitation> classModel = ClassModel.builder(BirthdayInvitation.class);\n((PropertyModelBuilder<Integer>) classModel.getProperty(\"age\"))\n        .propertySerialization(new CourteousAgeSerialization());\n\nPojoCodecProvider pojoCodecProvider = PojoCodecProvider.builder().register(classModel.build()).build();\nCodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider));"
                },
                {
                    "lang": "java",
                    "value": "// constructor with parameters for name, age, and eventDateTime, respectively\nBirthdayInvitation invitation = new BirthdayInvitation(\n        \"Galadriel\",\n        7582,\n        LocalDateTime.of(2021, Month.JANUARY, 18, 30, 0)\n    );"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : ObjectId(\"...\"), \"eventDateTime\" : ..., \"name\" : \"Galadriel\" }"
                },
                {
                    "lang": "java",
                    "value": "public class ApplicationUser {\n    private Optional<Address> optionalAddress;\n    private Optional<Subscription> optionalSubscription;\n\n    // ...\n}"
                },
                {
                    "lang": "java",
                    "value": "CodecProvider pojoCodecProvider = PojoCodecProvider.builder()\n        .register(\"org.example.pojos\")\n        .register(new OptionalPropertyCodecProvider())\n        .build();"
                },
                {
                    "lang": "java",
                    "value": "public class OptionalPropertyCodecProvider implements PropertyCodecProvider {\n\n    @Override\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public <T> Codec<T> get(final TypeWithTypeParameters<T> type, final PropertyCodecRegistry registry) {\n        // Check the main type and number of generic parameters\n        if (Optional.class.isAssignableFrom(type.getType()) && type.getTypeParameters().size() == 1) {\n            // Get the codec for the concrete type of the Optional, as its declared in the POJO.\n            Codec<?> valueCodec = registry.get(type.getTypeParameters().get(0));\n            return new OptionalCodec(type.getType(), valueCodec);\n        } else {\n            return null;\n        }\n    }\n\n    private static final class OptionalCodec<T> implements Codec<Optional<T>> {\n        private final Class<Optional<T>> encoderClass;\n        private final Codec<T> codec;\n\n        private OptionalCodec(final Class<Optional<T>> encoderClass, final Codec<T> codec) {\n            this.encoderClass = encoderClass;\n            this.codec = codec;\n        }\n\n        @Override\n        public void encode(final BsonWriter writer, final Optional<T> optionalValue, final EncoderContext encoderContext) {\n            if (optionalValue != null && optionalValue.isPresent()) {\n                codec.encode(writer, optionalValue.get(), encoderContext);\n            } else {\n                writer.writeNull();\n            }\n        }\n\n        @Override\n        public Optional<T> decode(final BsonReader reader, final DecoderContext context) {\n            return Optional.of(codec.decode(reader, context));\n        }\n\n        @Override\n        public Class<Optional<T>> getEncoderClass() {\n            return encoderClass;\n        }\n    }\n}"
                }
            ],
            "preview": "In this guide, you can learn how to define custom data conversions between\nBSON and POJOs in the MongoDB Java driver. In our guide on POJOs,\nwe show how to specify a PojoCodecProvider which contains classes that\nprovide instructions on how to convert data for one or more POJO classes\nand their properties.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/document-data-format-record",
            "title": "Document Data Format: Records",
            "headings": [
                "Overview",
                "Serialize and Deserialize a Record",
                "Example Record",
                "Insert a Record",
                "Retrieve a Record"
            ],
            "paragraphs": "In this guide, you can learn how to store and retrieve data in the MongoDB Java Driver\nusing  Java records . Java records are a type of Java class often used to\nmodel data and separate business logic from data representation. You can declare Java records in Java 16 or later. Learn more about the\nfunctionality and restrictions of records from  Java 17 Language Updates: Record Classes . If you are using an earlier version of Java, you can use plain old Java\nobjects instead. See the  Document Data Format: POJOs  guide for\nimplementation details. The driver natively supports encoding and decoding Java records for\nMongoDB read and write operations using the  default codec registry . The\ndefault codec registry is a collection of classes called  codecs  that\ndefine how to convert encode and decode Java types.  Learn more about\ncodecs and the default codec registry in the guide on  Codecs . The code examples in this guide reference the following sample record, which\ndescribes a data storage device: You can insert a  DataStorageRecord  instance as shown in the following code: You can retrieve documents as  DataStorageRecord  instances and print them\nas shown in the following code:",
            "code": [
                {
                    "lang": "java",
                    "value": "public record DataStorageRecord(\n        String productName,\n        double capacity\n) {}"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<DataStorageRecord> collection = database.getCollection(\"data_storage_devices\", DataStorageRecord.class);\n\n// insert the record\ncollection.insertOne(new DataStorageRecord(\"2TB SSD\", 1.71));"
                },
                {
                    "lang": "java",
                    "value": "MongoCollection<DataStorageRecord> collection = database.getCollection(\"data_storage_devices\", DataStorageRecord.class);\n\n// retrieve and print the records\nList<DataStorageRecord> records = new ArrayList<DataStorageRecord>();\ncollection.find().into(records);\nrecords.forEach(System.out::println);"
                },
                {
                    "lang": "none",
                    "value": "DataStorageRecord[productName=1TB SSD, capacity=1.71]"
                }
            ],
            "preview": "In this guide, you can learn how to store and retrieve data in the MongoDB Java Driver\nusing Java records. Java records are a type of Java class often used to\nmodel data and separate business logic from data representation.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/document-data-format-extended-json",
            "title": "Document Data Format: Extended JSON",
            "headings": [
                "Overview",
                "Extended JSON Formats",
                "Extended JSON Examples",
                "Read Extended JSON",
                "Using the Document Classes",
                "Using the BSON Library",
                "Write Extended JSON",
                "Using the Document Classes",
                "Using the BSON Library",
                "Custom BSON Type Conversion"
            ],
            "paragraphs": "In this guide, you can learn how to use the Extended JSON format in the\nMongoDB Java driver. JSON is a data format that represents the values of objects, arrays, numbers,\nstrings, booleans, and nulls. The  Extended JSON  format defines a reserved\nset of keys prefixed with \" $ \" to represent field type information that\ndirectly corresponds to each type in BSON, the format that MongoDB uses to\nstore data. This guide explains the following topics: For more information on the difference between these formats, see our\n article on JSON and BSON . The different MongoDB Extended JSON formats How to use the BSON library to convert between Extended JSON and Java objects How to create a custom conversion of BSON types MongoDB Extended JSON features different string formats to represent BSON data.\nEach of the different formats conform to the JSON RFC\nand meet specific use cases. The  extended  format, also known as the\n canonical  format, features specific representations for every BSON type\nfor bidirectional conversion without loss of information. The  Relaxed mode \nformat is more concise and closer to ordinary JSON, but does not represent\nall the type information such as the specific byte size of number fields. See the following table to see a description of each format: For more detailed information on these formats, see the following\nresources: Name Description Extended Relaxed Mode Shell Strict The driver parses the  $uuid  Extended JSON type from a string to a\n BsonBinary  object of binary subtype 4. For more information about  $uuid  field\nparsing, see the\n special rules for parsing $uuid fields \nsection in the extended JSON specification. JSON RFC  Official Documentation MongoDB Extended JSON  Server Manual Entry BsonBinary  API Documentation Extended JSON specification  GitHub Documentation The following examples show a document containing an ObjectId, date, and long\nnumber field represented in each Extended JSON format. Click the tab that\ncorresponds to the format of the example you want to see: You can read an Extended JSON string into a Java document object by calling\nthe  parse()  static method from either the  Document  or  BsonDocument \nclass, depending on which object type you need. This method parses the Extended\nJSON string in any of the formats and returns an instance of that class\ncontaining the data. The following example shows how you can use the  Document  class to read\nan example Extended JSON string into a  Document  object using the\n parse()  method: For more information, see our Fundamentals page\non  Documents . You can also read an Extended JSON string into Java objects without using\nthe MongoDB Java driver's document classes by using the  JsonReader  class.\nThis class contains methods to sequentially parse the fields and values\nin any format of the Extended JSON string, and returns them as Java objects.\nThe driver's document classes also use this class to parse Extended JSON. The following code example shows how you can use the  JsonReader  class to convert\nan Extended JSON string into Java objects: For more information, see the  JsonReader  API Documentation. You can write an Extended JSON string from an instance of  Document  or\n BsonDocument  by calling the  toJson()  method, optionally passing it an\ninstance of  JsonWriterSettings  to specify the Extended JSON format. In this example, we output the Extended JSON in the Relaxed mode format. You can also output an Extended JSON string from data in Java objects using\nthe BSON library with the  JsonWriter  class. To construct an instance\nof  JsonWriter , pass a subclass of a Java  Writer  to specify how\nyou want to output the Extended JSON. You can optionally pass a  JsonWriterSettings \ninstance to specify options such as the Extended JSON format. By default, the\n JsonWriter  uses the Relaxed mode format. The MongoDB Java driver's\ndocument classes also use this class to convert BSON to Extended JSON. The following code example shows how you can use  JsonWriter  to create an\nExtended JSON string and output it to  System.out . We specify the format\nby passing the  outputMode()  builder method the  JsonMode.EXTENDED  constant: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: JsonWriter JsonWriterSettings outputMode() In addition to specifying the  outputMode()  to format the JSON output, you\ncan further customize the output by adding converters to your\n JsonWriterSettings.Builder . These converter methods detect the Java types\nand execute the logic defined by the  Converter  passed to them. The following sample code shows how to append converters, defined as lambda\nexpressions, to simplify the Relaxed mode JSON output. The output of this code resembles the following text: Without specifying the converters, the Relaxed mode JSON output resembles the following text: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Converter JsonWriterSettings.Builder",
            "code": [
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": { \"$oid\": \"573a1391f29313caabcd9637\" },\n  \"createdAt\": { \"$date\": { \"$numberLong\": \"1601499609\" }},\n  \"numViews\": { \"$numberLong\": \"36520312\" }\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": { \"$oid\": \"573a1391f29313caabcd9637\" },\n  \"createdAt\": { \"$date\": \"2020-09-30T18:22:51.648Z\" },\n  \"numViews\": 36520312\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": ObjectId(\"573a1391f29313caabcd9637\"),\n  \"createdAt\": ISODate(\"2020-09-30T18:22:51.648Z\"),\n  \"numViews\": NumberLong(\"36520312\")\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": { \"$oid\": \"573a1391f29313caabcd9637\" },\n  \"createdAt\": { \"$date\": 1601499609 },\n  \"numViews\": { \"$numberLong\": \"36520312\" }\n}"
                },
                {
                    "lang": "java",
                    "value": "String ejsonStr = \"{ \\\"_id\\\": { \\\"$oid\\\": \\\"507f1f77bcf86cd799439011\\\"},\" +\n                  \"\\\"myNumber\\\": {\\\"$numberLong\\\": \\\"4794261\\\" }}}\";\n\nDocument doc = Document.parse(ejsonStr);\nSystem.out.println(doc);"
                },
                {
                    "lang": "none",
                    "value": "Document{{_id=507f1f77bcf86cd799439011, myNumber=4794261}}"
                },
                {
                    "lang": "java",
                    "value": "String ejsonStr = \"{ \\\"_id\\\": { \\\"$oid\\\": \\\"507f1f77bcf86cd799439011\\\"},\" +\n                  \"\\\"myNumber\\\": {\\\"$numberLong\\\": \\\"4794261\\\" }}}\";\n\nJsonReader jsonReader = new JsonReader(ejsonStr);\n\njsonReader.readStartDocument();\n\njsonReader.readName(\"_id\");\nObjectId id = jsonReader.readObjectId();\njsonReader.readName(\"myNumber\");\nLong myNumber = jsonReader.readInt64();\n\njsonReader.readEndDocument();\n\nSystem.out.println(id + \" is type: \" + id.getClass().getName());\nSystem.out.println(myNumber + \" is type: \" + myNumber.getClass().getName());\n\njsonReader.close();"
                },
                {
                    "lang": "none",
                    "value": "507f1f77bcf86cd799439011 is type: org.bson.types.ObjectId\n4794261 is type: java.lang.Long"
                },
                {
                    "lang": "java",
                    "value": "Document myDoc = new Document();\nmyDoc.append(\"_id\", new ObjectId(\"507f1f77bcf86cd799439012\")).append(\"myNumber\", 11223344);\n\nJsonWriterSettings settings = JsonWriterSettings.builder().outputMode(JsonMode.RELAXED).build();\nSystem.out.println(doc.toJson(settings));"
                },
                {
                    "lang": "none",
                    "value": "{\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"myNumber\": 11223344}"
                },
                {
                    "lang": "java",
                    "value": "JsonWriterSettings settings = JsonWriterSettings.builder().outputMode(JsonMode.EXTENDED).build();\n\ntry (JsonWriter jsonWriter = new JsonWriter(new BufferedWriter(new OutputStreamWriter(System.out)), settings)) {\n    jsonWriter.writeStartDocument();\n    jsonWriter.writeObjectId(\"_id\", new ObjectId(\"507f1f77bcf86cd799439012\"));\n    jsonWriter.writeInt64(\"myNumber\", 11223344);\n    jsonWriter.writeEndDocument();\n    jsonWriter.flush();\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"myNumber\": {\"$numberLong\": \"11223344\"}}"
                },
                {
                    "lang": "java",
                    "value": "JsonWriterSettings settings = JsonWriterSettings.builder().outputMode(JsonMode.RELAXED)\n        .objectIdConverter((value, writer) -> writer.writeString(value.toHexString()))\n        .dateTimeConverter(\n                (value, writer) -> {\n                    ZonedDateTime zonedDateTime = Instant.ofEpochMilli(value).atZone(ZoneOffset.UTC);\n                    writer.writeString(DateTimeFormatter.ISO_DATE_TIME.format(zonedDateTime));\n                })\n        .build();\n\nDocument doc = new Document()\n     .append(\"_id\", new ObjectId(\"507f1f77bcf86cd799439012\"))\n     .append(\"createdAt\", Date.from(Instant.ofEpochMilli(1601499609000L)))\n     .append(\"myNumber\", 4794261);\n\nSystem.out.println(doc.toJson(settings)));"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": \"507f1f77bcf86cd799439012\", \"createdAt\": \"2020-09-30T21:00:09Z\", \"myNumber\": 4794261}"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"createdAt\": {\"$date\": \"2020-09-30T21:00:09Z\"}, \"myNumber\": 4794261}"
                }
            ],
            "preview": "In this guide, you can learn how to use the Extended JSON format in the\nMongoDB Java driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "fundamentals/data-formats/codecs",
            "title": "Codecs",
            "headings": [
                "Overview",
                "Codec",
                "CodecRegistry",
                "CodecProvider",
                "Default Codec Registry",
                "BsonTypeClassMap",
                "Custom Codec Example"
            ],
            "paragraphs": "In this guide, you can learn about  Codecs  and the supporting classes that\nhandle the encoding and decoding of Java objects to and from BSON data\nin the MongoDB Java driver. The  Codec  abstraction allows you to map any Java type to\na corresponding BSON type. You can use this to map your domain objects\ndirectly to and from BSON instead of using an intermediate map-based object such\nas  Document  or  BsonDocument . You can learn how to specify custom encoding and decoding logic using\nthe  Codec  abstraction and view example implementations in the following\nsections: If you are customizing encoding and decoding logic for plain old Java objects\n(POJOs), read our guide on  POJO Customization . Codec CodecRegistry CodecProvider Custom Codec Example The  Codec  interface contains abstract methods for serializing and\ndeserializing Java objects to BSON data. You can define your conversion logic\nbetween BSON and your Java object in your implementation of this interface. To implement the  Codec  interface, override the  encode() ,  decode() ,\nand  getEncoderClass()  abstract methods. The  encode()  method requires the following parameters: This method uses the  BsonWriter  instance to send the encoded value to\nMongoDB and does not return a value. The  decode()  method returns your Java object instance populated with the\nvalue from the BSON data. This method requires the following parameters: The  getEncoderClass()  method returns a class instance of the Java class\nsince Java cannot infer the type due to type erasure. See the following code examples that show how you can implement a custom\n Codec . The  PowerStatus  enum contains the values \"ON\" and \"OFF\" to represent\nthe states of an electrical switch. The  PowerStatusCodec  class implements  Codec  in order to convert\nthe Java  enum  values to corresponding BSON boolean values. The\n encode()  method converts a  PowerStatus  to a BSON boolean and the\n decode()  method performs the conversion in the opposite direction. You can add an instance of the  PowerStatusCodec  to your  CodecRegistry \nwhich contains a mapping between your  Codec  and the Java object type to\nwhich it applies. Continue to the  CodecRegistry \nsection of this page to see how you can include your  Codec . For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: Parameter Type Description writer An instance of a class that implements  BsonWriter , an interface type\nthat exposes methods for writing a BSON document. For example, the\n BsonBinaryWriter  implementation writes to a binary stream of data.\nUse this instance to write your BSON value using the appropriate\nwrite method. value The data that your implementation encodes. The type must match the type\nvariable assigned to your implementation. encoderContext Contains meta information about the Java object data that it encodes\nto BSON including whether to store the current value in a\nMongoDB collection. Parameter Type Description bsonReader An instance of a class that implements  BsonReader , an interface type\nthat exposes methods for reading a BSON document. For example, the\n BsonBinaryReader  implementation reads from a binary stream of data. decoderContext Contains information about the BSON data that it decodes to a Java\nobject. Codec BsonWriter BsonBinaryWriter EncoderContext BsonReader DecoderContext BsonBinaryReader A  CodecRegistry  is an immutable collection of  Codec  instances that\nencode and decode the Java classes they specify. You can use any of the\nfollowing  CodecRegistries  class static factory methods to construct a\n CodecRegistry  from the  Codec  instances contained in the associated\ntypes: The following code snippet shows how to construct a  CodecRegistry  using\nthe  fromCodecs()  method: In the preceding example, we assign the  CodecRegistry  the following  Codec \nimplementations: You can retrieve the  Codec  instances from the  CodecRegistry  instance\nfrom the prior example using the following code: If you attempt to retrieve a  Codec  instance for a class that is not\nregistered, the  get()  method throws a  CodecConfigurationException \nexception. For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: fromCodecs() fromProviders() fromRegistries() IntegerCodec , a  Codec  that converts  Integers  and is part of the BSON package. PowerStatusCodec , our sample  Codec \nthat converts certain Java strings to BSON booleans. CodecRegistries IntegerCodec A  CodecProvider  is an interface that contains abstract methods that create\n Codec  instances and assign them to a  CodecRegistry  instance. Similar\nto the  CodecRegistry , the BSON library uses the  Codec  instances\nretrieved by the  get()  method to convert between Java and BSON data types. However, in cases in which you add a class that contains fields that require\ncorresponding  Codec  objects, you need to ensure that you instantiate the\n Codec  objects for the class fields before you instantiate the\n Codec  for the class. You can use the  CodecRegistry  parameter in\nthe  get()  method to pass any of the  Codec  instances that the\n Codec  relies on. The following code example shows how you can implement  CodecProvider  to\npass the  MonolightCodec  any  Codec  instances it needs in a\n CodecRegistry  instance such as the  PowerStatusCodec  from our prior\nexample: To see a runnable example that demonstrates read and write operations using\nthese  Codec  classes, see the  Custom Codec Example \nsection of this guide. When working with POJOs, consider using the   PojoCodecProvider  to\nminimize duplicate code to convert commonly-used data types and customize\ntheir behavior. See our\n POJO Customization guide \nfor more information. The default codec registry is a set of  CodecProvider  classes that\nspecify conversion between commonly-used Java and MongoDB types. The\ndriver automatically uses the default codec registry unless you specify\na different one. If you need to override the behavior of one or more  Codec  classes, but\nkeep the behavior from the default codec registry for the other classes,\nyou can specify all of the registries in order of precedence. For example,\nsuppose you wanted to override the default provider behavior of a  Codec  for\nenum types with your custom  MyEnumCodec , you must add it to the registry\nlist prior to the default codec registry as shown in the example below: For more information about the classes and interfaces in this section, see\nthe following API documentation sections: CodecProvider Default codec registry The  BsonTypeClassMap  class contains a recommended mapping between BSON\nand Java types. You can use this class in your custom  Codec  or\n CodecProvider  to help you manage which Java types to decode your BSON\ntypes to container classes that implement  Iterable  or  Map  such as\nthe  Document  class. You can add or modify the  BsonTypeClassMap  default mapping by passing a\n Map  containing new or replacement entries. The following code snippet shows how you can retrieve the Java class type\nthat corresponds to the BSON type in the default  BsonTypeClassMap \ninstance: This code outputs the following: You can modify these mappings in your instance by specifying replacements in the\n BsonTypeClassMap  constructor. The following code snippet shows how\nyou can replace the mapping for  ARRAY  in your  BsonTypeClassMap \ninstance with the  Set  class: This code outputs the following: For a complete list of the default mappings, refer to the\n BsonTypeClassMap  API Documentation. For an example of how the  Document  class uses  BsonTypeClassMap , see\nthe driver source code for the following classes: DocumentCodecProvider DocumentCodec In this section, we show how you can implement  Codec  and  CodecProvider \nto define the encoding and decoding logic for a custom Java class. We also show\nhow you can specify and use your custom implementations to perform insert\nand retrieve operations. The following code snippet shows our example custom class called  Monolight \nand its fields that we want to store and retrieve from a MongoDB collection: This class contains the following fields, each of which we need to assign a\n Codec : The following code example shows how we can implement a  Codec  for the\n Monolight  class. Note that the constructor expects an instance of\n CodecRegistry  from which it retrieves the  Codec  instances it needs\nto encode and decode its fields: To ensure we make the  Codec  instances for the fields available for\n Monolight , we implement a custom  CodecProvider  shown in the following\ncode example: After defining the conversion logic, we can perform the following: The following example class contains code that assigns the\n MonolightCodecProvider  to the  MongoCollection  instance by passing it\nto the  withCodecRegistry()  method. The example class also inserts and\nretrieves data using the  Monolight  class and associated codecs: If you run the preceding example, you should see the following output: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: powerStatus  describes whether the light is switched \"on\" or \"off\" for\nwhich we use the  PowerStatusCodec  that\nconverts specific enum values to BSON booleans. colorTemperature  describes the color of the light and contains an\n Integer  value for which we use the  IntegerCodec  included in the\nBSON library. Store data from instances of  Monolight  into MongoDB Retrieve data from MongoDB into instances of  Monolight withCodecRegistry() MongoClientSettings.getDefaultCodecRegistry() Codec CodecProvider",
            "code": [
                {
                    "lang": "java",
                    "value": "public enum PowerStatus {\n    ON,\n    OFF\n}"
                },
                {
                    "lang": "java",
                    "value": "public class PowerStatusCodec implements Codec<PowerStatus> {\n\n    @Override\n    public void encode(BsonWriter writer, PowerStatus value, EncoderContext encoderContext) {\n        if (value != null) {\n            writer.writeBoolean(value.equals(PowerStatus.ON) ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    @Override\n    public PowerStatus decode(BsonReader reader, DecoderContext decoderContext) {\n        return reader.readBoolean() ? PowerStatus.ON : PowerStatus.OFF;\n    }\n\n    @Override\n    public Class<PowerStatus> getEncoderClass() {\n        return PowerStatus.class;\n    }\n}"
                },
                {
                    "lang": "java",
                    "value": "CodecRegistry codecRegistry = CodecRegistries.fromCodecs(new IntegerCodec(), new PowerStatusCodec());"
                },
                {
                    "lang": "java",
                    "value": "Codec<String> powerStatusCodec = codecRegistry.get(String.class);\nCodec<Integer> integerCodec = codecRegistry.get(Integer.class);"
                },
                {
                    "lang": "java",
                    "value": "public class MonolightCodecProvider implements CodecProvider {\n\n    public MonolightCodecProvider() {}\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> Codec<T> get(Class<T> clazz, CodecRegistry registry) {\n        if (clazz == Monolight.class) {\n            return (Codec<T>) new MonolightCodec(registry);\n        }\n\n        // return null when not a provider for the requested class\n        return null;\n    }\n\n}"
                },
                {
                    "lang": "java",
                    "value": "CodecRegistry newRegistry = CodecRegistries.fromRegistries(\n    CodecRegistries.fromCodecs(new MyEnumCodec()),\n    MongoClientSettings.getDefaultCodecRegistry());"
                },
                {
                    "lang": "java",
                    "value": "BsonTypeClassMap bsonTypeClassMap = new BsonTypeClassMap();\nClass<?> clazz = bsonTypeClassMap.get(BsonType.ARRAY);\nSystem.out.println(\"Java type: \" + clazz.getName());"
                },
                {
                    "lang": "none",
                    "value": "Java type: java.util.List"
                },
                {
                    "lang": "java",
                    "value": "Map<BsonType, Class<?>> replacements = new HashMap<BsonType, Class<?>>();\nreplacements.put(BsonType.ARRAY, Set.class);\nBsonTypeClassMap bsonTypeClassMap = new BsonTypeClassMap(replacements);\n\nClass<?> clazz = bsonTypeClassMap.get(BsonType.ARRAY);\nSystem.out.println(\"Java type: \" + clazz.getName());"
                },
                {
                    "lang": "none",
                    "value": "Java type: java.util.Set"
                },
                {
                    "lang": "none",
                    "value": "[Monolight [powerStatus=ON, colorTemperature=5200]]"
                },
                {
                    "lang": "java",
                    "value": "public class Monolight {\n    private PowerStatus powerStatus = PowerStatus.OFF;\n    private Integer colorTemperature;\n\n    public Monolight() {}\n\n    // ..."
                },
                {
                    "lang": "java",
                    "value": "public class MonolightCodec implements Codec<Monolight>{\n\n    private Codec<PowerStatus> powerStatusCodec;\n    private Codec<Integer> integerCodec;\n\n    public MonolightCodec(CodecRegistry registry) {\n        this.powerStatusCodec = registry.get(PowerStatus.class);\n        this.integerCodec = registry.get(Integer.class);\n    }\n\n    @Override\n    public void encode(BsonWriter writer, Monolight value, EncoderContext encoderContext) {\n        writer.writeStartDocument();\n        writer.writeName(\"powerStatus\");\n        powerStatusCodec.encode(writer, value.getPowerStatus(), encoderContext);\n        writer.writeName(\"colorTemperature\");\n        integerCodec.encode(writer, value.getColorTemperature(), encoderContext);\n        writer.writeEndDocument();\n    }\n\n    @Override\n    public Monolight decode(BsonReader reader, DecoderContext decoderContext) {\n        Monolight monolight = new Monolight();\n\n        reader.readStartDocument();\n        while (reader.readBsonType() != BsonType.END_OF_DOCUMENT) {\n            String fieldName = reader.readName();\n            if (fieldName.equals(\"powerStatus\")) {\n                monolight.setPowerStatus(powerStatusCodec.decode(reader, decoderContext));\n            } else if (fieldName.equals(\"colorTemperature\")) {\n                monolight.setColorTemperature(integerCodec.decode(reader, decoderContext));\n            } else if (fieldName.equals(\"_id\")){\n                reader.readObjectId();\n            }\n        }\n        reader.readEndDocument();\n\n        return monolight;\n    }\n\n    @Override\n    public Class<Monolight> getEncoderClass() {\n        return Monolight.class;\n    }\n\n}"
                },
                {
                    "lang": "java",
                    "value": "public class MonolightCodecProvider implements CodecProvider {\n\n    public MonolightCodecProvider() {}\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> Codec<T> get(Class<T> clazz, CodecRegistry registry) {\n        if (clazz == Monolight.class) {\n            return (Codec<T>) new MonolightCodec(registry);\n        }\n\n        // return null when not a provider for the requested class\n        return null;\n    }\n\n}"
                },
                {
                    "lang": "java",
                    "value": "public class MonolightCodecExample {\n\n    public static void main(String[] args) {\n\n        String uri = \"<MongoDB connection URI>\";\n\n        try (MongoClient mongoClient = MongoClients.create(uri)) {\n            CodecRegistry codecRegistry = CodecRegistries.fromRegistries(\n                    CodecRegistries.fromCodecs(new IntegerCodec(), new PowerStatusCodec()),\n                    CodecRegistries.fromProviders(new MonolightCodecProvider()),\n                    MongoClientSettings.getDefaultCodecRegistry());\n\n            MongoDatabase database = mongoClient.getDatabase(\"codecs_example_products\");\n            MongoCollection<Monolight> collection = database.getCollection(\"monolights\", Monolight.class).withCodecRegistry(codecRegistry);\n\n            // construct and insert an instance of Monolight\n            Monolight myMonolight = new Monolight();\n            myMonolight.setPowerStatus(PowerStatus.ON);\n            myMonolight.setColorTemperature(5200);\n            collection.insertOne(myMonolight);\n\n            // retrieve one or more instances of Monolight\n            List<Monolight> lights = new ArrayList<>();\n            collection.find().into(lights);\n            System.out.println(lights);\n        }\n    }\n\n}"
                }
            ],
            "preview": "In this guide, you can learn about Codecs and the supporting classes that\nhandle the encoding and decoding of Java objects to and from BSON data\nin the MongoDB Java driver. The Codec abstraction allows you to map any Java type to\na corresponding BSON type. You can use this to map your domain objects\ndirectly to and from BSON instead of using an intermediate map-based object such\nas Document or BsonDocument.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ]
            }
        },
        {
            "slug": "compatibility",
            "title": "Compatibility",
            "headings": [
                "MongoDB Compatibility",
                "Compatibility Table Legend",
                "Language Compatibility"
            ],
            "paragraphs": "You can use the Java Driver to connect to deployments hosted in the\nfollowing environments: MongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud MongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB MongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB The following compatibility table specifies the recommended version or versions\nof the MongoDB Java Driver for use with a specific version of MongoDB. The first column lists the driver version. MongoDB ensures compatibility between the MongoDB Server and the drivers\nfor three years after the server version's end of life (EOL) date. To learn\nmore about the MongoDB release and EOL dates, see\n MongoDB Software Lifecycle Schedules . Icon Explanation \u2713 All features are supported. \u229b The Driver version will work with the MongoDB version, but not all\nnew MongoDB features are supported. No mark The Driver version is not tested with the MongoDB version. Java Driver Version MongoDB 7.0 MongoDB 6.1 MongoDB 6.0 MongoDB 5.0 MongoDB 4.4 MongoDB 4.2 MongoDB 4.0 MongoDB 3.6 MongoDB 3.4 MongoDB 3.2 MongoDB 3.0 MongoDB 2.6 4.11 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.10 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.9 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.8 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.7 \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.6 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.5 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.4 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.3 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.2 \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.1 \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.0 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 3.12 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 3.11 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 3.10 \u229b \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 3.9 \u229b \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 3.8 \u229b \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 3.7 \u2713 \u2713 \u2713 \u2713 \u2713 3.6 \u2713 \u2713 \u2713 \u2713 \u2713 3.5 \u2713 \u2713 \u2713 \u2713 3.4 \u2713 \u2713 \u2713 \u2713 3.3 \u2713 \u2713 \u2713 3.2 \u2713 \u2713 \u2713 3.1 \u2713 \u2713 3.0 \u2713 \u2713 The following compatibility table specifies the recommended version or versions\nof the MongoDB Java Driver for use with a specific version of Java. Starting\nwith Java 11, the table explicitly lists only Long-Term-Support (LTS)\nJava versions. The first column lists the driver version. For more information on how to read the compatibility tables, see our guide on\n MongoDB Compatibility Tables. Java Driver Version Java 21 Java 17 Java 11 Java 8 Java 7 Java 6 Java 5 5.0 \u2713 \u2713 \u2713 \u2713 4.11 \u2713 \u2713 \u2713 \u2713 4.10 \u2713  \u2713 \u2713 \u2713 4.9 \u2713  \u2713 \u2713 \u2713 4.8 \u2713  \u2713 \u2713 \u2713 4.7 \u2713  \u2713 \u2713 \u2713 4.6 \u2713  \u2713 \u2713 \u2713 4.5 \u2713  \u2713 \u2713 \u2713 4.4 \u2713 \u2713 \u2713 4.3 \u2713 \u2713 4.2 \u2713 \u2713 4.1 \u2713 \u2713 4.0 \u2713 \u2713 3.12 \u2713 \u2713 \u2713 \u2713 3.11 \u2713 \u2713 \u2713 \u2713 3.10 \u2713 \u2713 \u2713 \u2713 3.9 \u2713 \u2713 \u2713 \u2713 3.8 \u2713 \u2713 \u2713 \u2713 3.4 \u2713 \u2713 \u2713 \u2713 3.3 \u2713 \u2713 \u2713 \u2713 3.2 \u2713 \u2713 \u2713 \u2713 3.1 \u2713 \u2713 \u2713 \u2713 3.0 \u2713 \u2713 \u2713 \u2713 This driver version is not compatible with virtual threads.",
            "code": [],
            "preview": "You can use the Java Driver to connect to deployments hosted in the\nfollowing environments:",
            "tags": "java sync",
            "facets": {
                "programming_language": [
                    "java"
                ],
                "genre": [
                    "reference"
                ]
            }
        }
    ]
}