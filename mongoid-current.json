{
    "url": "http://mongodb.com/docs/mongoid/current",
    "includeInGlobalSearch": true,
    "documents": [
        {
            "slug": "nesting-levels",
            "title": "Page Title",
            "headings": [
                "First Level Heading",
                "Second Level Heading",
                "Third Level Heading",
                "Fourth Level Heading"
            ],
            "paragraphs": "This file is not part of Mongoid documentation proper, it is an internal\nreference for the nesting levels that other files should be using. Mongoid documentation nesting levels:",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "schema-configuration",
            "title": "Schema Configuration",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "contributing",
            "title": "Contributing",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "release-notes",
            "title": "Release Notes",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "additional-resources",
            "title": "Additional Resources",
            "headings": [
                "Screencasts",
                "Articles",
                "Sample Applications"
            ],
            "paragraphs": "This page lists some of the third-party guides and blog posts about Mongoid,\nas well as sample Mongoid applications. Additional resources for the driver\nare listed on the  respective driver page . RailsCasts: Mongoid (revised) An overview of Mongoid, by Ryan Bates including the basics\nof setting up an app, querying for documents, adding embedded\nassociations, overriding the id, and more. Ruby on Rails Web Services and Integration with MongoDB, Week 3: Mongoid A detailed introduction to Mongoid and Ruby on Rails web services. Create a search bar in Rails with Mongoid A Tutorial explaining how to implement text search with Mongoid. A Simple Content Management System in Sinatra Building a content management application with Sinatra and Mongoid. How To Create A Ruby API With Sinatra Creating a Sinatra API with Mongoid. Converting an existing Ruby on Rails application to MongoDB How to Convert an existing Ruby on Rails application to use MongoDB and Mongoid. Mongoid Demo A repository containing sample applications using Mongoid.",
            "code": [],
            "preview": "This page lists some of the third-party guides and blog posts about Mongoid,\nas well as sample Mongoid applications. Additional resources for the driver\nare listed on the respective driver page.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "",
            "title": "Mongoid",
            "headings": [],
            "paragraphs": "Mongoid is the officially supported object-document mapper (ODM)\nfor MongoDB in Ruby. For documentation on Mongoid 3 and 4, see  http://mongoid.github.io .",
            "code": [],
            "preview": "Mongoid is the officially supported object-document mapper (ODM)\nfor MongoDB in Ruby.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "tutorials",
            "title": "Tutorials",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "installation",
            "title": "Installation",
            "headings": [
                "Install the Gem",
                "Using Mongoid with a New Rails Application",
                "Using Mongoid with an Existing Rails Application"
            ],
            "paragraphs": "Mongoid is bundled as a gem, and is  hosted on Rubygems .\nIt can be installed manually or with bundler. To install the gem manually: To install the gem with bundler, include the following in your  Gemfile : When creating a new Rails application and wish to use Mongoid for\ndata access, give the  --skip-active-record  flag to the  rails new \ncommand to avoid depending on and configuring ActiveRecord.. When converting an existing Rails application to use Mongoid for data access,\nthe  config/application.rb  file needs to be updated to remove the\n require 'rails/all'  line and explicitly include the required frameworks\n(which could be all of the frameworks provided by Rails with the exception of\nActiveRecord). Any references to ActiveRecord in files in the  config \ndirectory and in the models also need to be removed.",
            "code": [
                {
                    "lang": "sh",
                    "value": "gem install mongoid"
                },
                {
                    "lang": "ruby",
                    "value": "gem 'mongoid', '~> 8.1.0'"
                }
            ],
            "preview": "Mongoid is bundled as a gem, and is hosted on Rubygems.\nIt can be installed manually or with bundler.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "working-with-data",
            "title": "Working With Data",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "installation-configuration",
            "title": "Installation & Configuration",
            "headings": [],
            "paragraphs": "",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": null
        },
        {
            "slug": "ecosystem",
            "title": "Ecosystem",
            "headings": [
                "Projects",
                "Extension Libraries",
                "Integration Libraries"
            ],
            "paragraphs": "Mongoid has an extensive ecosystem of libraries integrating with or built\non top of Mongoid, are listed below. Workarea Commerce Workarea is an enterprise-grade Ruby on Rails commerce platform that uses Mongoid. Mongoid Tree A tree structure for Mongoid documents using the materialized path pattern. Mongoid Token A little random, unique token generator for Mongoid documents. Mongoid Collection Snapshot Easy maintenance of collections of processed data in MongoDB with the Mongoid ODM. Mongoid Locker Document-level locking for MongoDB via Mongoid. Mongo Beautiful Logger A simple and beautiful logger library for MongoDB in your Ruby/Rails app. Mongoid Search Simple full text search for Mongoid. Mongoid Fulltext Search Full-text search using n-gram matching for the Mongoid ODM. CarrierWave Mongoid Mongoid Support for the Carrierwave file uploads library. Mongoid RSpec RSpec matchers and macros for Mongoid applications. RailsAdmin  supports Mongoid out\nof the box. ActiveAdmin Mongoid ActiveAdmin hacks to support Mongoid. Mongoid History Multi-user non-linear history tracking, auditing, undo, redo for mongoid. Delayed Job Mongoid Mongoid backend for delayed_job. Mongo Session Store A Rails-compatible session store for Mongoid.",
            "code": [],
            "preview": "Mongoid has an extensive ecosystem of libraries integrating with or built\non top of Mongoid, are listed below.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "tutorials/common-errors",
            "title": "Common Errors",
            "headings": [
                "Mongoid/Moped Authentication Error: failed with error 13"
            ],
            "paragraphs": "If you are encountering the following error: This error is caused by Moped, a Ruby driver that is no longer in use by\nMongoid. Upgrading to Mongoid 5+ should fix this issue. You can find more information about this issue here:\n MONGOID-4067 .",
            "code": [
                {
                    "lang": "ruby",
                    "value": "Moped::Errors::OperationFailure: The operation: #<Moped::Protocol::Command\n  @length=83\n  @request_id=5\n  @response_to=0\n  @op_code=2004\n  @flags=[]\n  @full_collection_name=\"mongose_development.$cmd\"\n  @skip=0\n  @limit=-1\n  @selector={:getlasterror=>1, :w=>1}\n  @fields=nil>\nfailed with error 13: \"not authorized for insert on mongose_development.people\"\n\nSee https://github.com/mongodb/mongo/blob/master/docs/errors.md\nfor details about this error.\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/bundler/gems/moped-10abbf3eac37/lib/moped/operation/read.rb:50:in `block in execute'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/bundler/gems/moped-10abbf3eac37/lib/moped/node.rb:594:in `[]'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/bundler/gems/moped-10abbf3eac37/lib/moped/node.rb:594:in `block (2 levels) in flush'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/bundler/gems/moped-10abbf3eac37/lib/moped/node.rb:593:in `map'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/bundler/gems/moped-10abbf3eac37/lib/moped/node.rb:593:in `block in flush'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/bundler/gems/moped-10abbf3eac37/lib/moped/node.rb:617:in `block in logging'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/gems/activesupport-4.2.0/lib/active_support/notifications.rb:164:in `block in instrument'\n  from /.rbenv/versions/2.1.4/lib/ruby/gems/2.1.0/gems/activesupport-4.2.0/lib/active_support/notifications/instrumenter.rb:20:in `instrumen"
                }
            ],
            "preview": "If you are encountering the following error:",
            "tags": null,
            "facets": null
        },
        {
            "slug": "tutorials/documents",
            "title": "Documents",
            "headings": [],
            "paragraphs": "Documents are the core objects in Mongoid and any object that is to be persisted to the\ndatabase must include  Mongoid::Document . The representation of a Document in MongoDB\nis a BSON object that is very similar to a Ruby hash or JSON object. Documents can be stored\nin their own collections in the database, or can be embedded in other Documents n levels deep.",
            "code": [],
            "preview": "Documents are the core objects in Mongoid and any object that is to be persisted to the\ndatabase must include Mongoid::Document. The representation of a Document in MongoDB\nis a BSON object that is very similar to a Ruby hash or JSON object. Documents can be stored\nin their own collections in the database, or can be embedded in other Documents n levels deep.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "tutorials/getting-started-sinatra",
            "title": "Getting Started (Sinatra)",
            "headings": [
                "New Application",
                "Create Git Repo",
                "Create Gemfile",
                "Install Dependencies",
                "Run MongoDB Locally",
                "Use MongoDB Atlas",
                "Basic Application",
                "Run Application",
                "Existing Application"
            ],
            "paragraphs": "This section shows how to create a new Sinatra application using Mongoid\nfor data access. The process is similar for other Ruby applications not\nusing Ruby on Rails. The complete source code for this application is available  in the\nmongoid-demo GitHub repository . While not required, we recommend creating a Git repository for your application: Commit your changes as you are following this tutorial. Create a file named  Gemfile  with the following contents: Run the following commands to install the dependencies: This command will generate a file named  Gemfile.lock  which we recommend\ncommitting to your Git repository. To develop locally with MongoDB,  download and install MongoDB . Once MongoDB is installed and running, create a file named  config/mongoid.yml \npointing to your deployment. For example, if you launched a standalone\n mongod  on the default port, the following contents would be appropriate: Instead of downloading, installing and running MongoDB locally, you can create\na free MongoDB Atlas account and create a  free MongoDB cluster in Atlas .\nOnce the cluster is created, follow the instructions in  connect to the cluster\npage \nto obtain the URI. Use the  Ruby driver 2.5 or later  format. Create a file named  config/mongoid.yml  with the following\ncontents, replacing the URI with the actual URI for your cluster: Create a file named  app.rb  with the following contents. First, some\nrequires: Load the Mongoid configuration file and configure Mongoid. This is done\nautomatically when Mongoid is used with Rails, but since we are using Mongoid\nwith Sinatra, we need to do this ourselves: Now we can define some models: ... and add some routes: Launch the application: Try some requests via curl: To start using Mongoid in an existing Sinatra applications, the steps are\nessentially the same as the one given above for a new application: Add the  mongoid  dependency to the  Gemfile . Create a  mongoid.yml  configuration file. Load the configuration file and configure Mongoid in the application. Define Mongoid models.",
            "code": [
                {
                    "lang": "sh",
                    "value": "git init blog\ncd blog"
                },
                {
                    "lang": "ruby",
                    "value": "source 'https://rubygems.org'\n\ngem 'sinatra'\ngem 'mongoid'\ngem 'puma'"
                },
                {
                    "lang": "sh",
                    "value": "gem install bundler\nbundle install"
                },
                {
                    "lang": "none",
                    "value": "development:\n  clients:\n    default:\n      database: blog_development\n      hosts:\n        - localhost:27017\n      options:\n        server_selection_timeout: 1"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      uri: mongodb+srv://user:pass@yourcluster.mongodb.net/blog_development?retryWrites=true&w=majority\n      options:\n        server_selection_timeout: 5"
                },
                {
                    "lang": "ruby",
                    "value": "require 'sinatra'\nrequire 'mongoid'"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.load!(File.join(File.dirname(__FILE__), 'config', 'mongoid.yml'))"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n\n  field :title, type: String\n  field :body, type: String\n\n  has_many :comments\nend\n\nclass Comment\n  include Mongoid::Document\n\n  field :name, type: String\n  field :message, type: String\n\n  belongs_to :post\nend"
                },
                {
                    "lang": "ruby",
                    "value": "get '/posts' do\n  Post.all.to_json\nend\n\npost '/posts' do\n  post = Post.create!(params[:post])\n  post.to_json\nend\n\nget '/posts/:post_id' do |post_id|\n  post = Post.find(post_id)\n  post.attributes.merge(\n    comments: post.comments,\n  ).to_json\nend\n\npost '/posts/:post_id/comments' do |post_id|\n  post = Post.find(post_id)\n  comment = post.comments.create!(params[:comment])\n  {}.to_json\nend"
                },
                {
                    "lang": "sh",
                    "value": "bundle exec ruby app.rb"
                },
                {
                    "lang": "sh",
                    "value": "curl http://localhost:4567/posts\n# => []\n\ncurl -d 'post[title]=hello&post[body]=hello+world' http://localhost:4567/posts\n# => {\"_id\":{\"$oid\":\"5d8151ec96fb4f0ed5a7a03f\"},\"body\":\"hello world\",\"title\":\"hello\"}\n\ncurl http://localhost:4567/posts\n# => [{\"_id\":{\"_id\":{\"$oid\":\"5d8151ec96fb4f0ed5a7a03f\"},\"body\":\"hello world\",\"title\":\"hello\"}]\n\ncurl -d 'comment[name]=David&comment[message]=I+like' http://localhost:4567/posts/5d8151ec96fb4f0ed5a7a03f/comments\n# => {}\n\ncurl http://localhost:4567/posts/5d8151ec96fb4f0ed5a7a03f\n# => {\"_id\":{\"$oid\":\"5d8151ec96fb4f0ed5a7a03f\"},\"title\":\"hello\",\"body\":\"hello world\",\"comments\":[{\"_id\":{\"$oid\":\"5d8157ac96fb4f20c5e45c4d\"},\"message\":\"I like\",\"name\":\"David\",\"post_id\":{\"$oid\":\"5d8151ec96fb4f0ed5a7a03f\"}}]}"
                }
            ],
            "preview": "This section shows how to create a new Sinatra application using Mongoid\nfor data access. The process is similar for other Ruby applications not\nusing Ruby on Rails.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "contributing/code-documentation",
            "title": "Code Documentation",
            "headings": [
                "Code Documentation",
                "Structure",
                "Formatting",
                "Type Declaration"
            ],
            "paragraphs": "Mongoid uses its own flavor of  YARD \nfor code documentation. Please note the conventions outlined in this document. Modules:  All class and module definitions should be preceded by\na documentation comment. Methods:  All method definitions should be preceded by a documentation comment.\nUse  @param  and  @return  to specify input(s) and output respectively.\nFor further details, refer to\n Type Declaration  below. Private Methods:  Private methods should be documented unless they are\nso brief and straightforward that it is obvious what they do. Note that,\nfor example, a method may be brief and straightforward but the type of\nits parameter may not be obvious, in which case the parameter needs to\nbe appropriately documented. Notes:  Use the  @note  macro to explain caveats, edge cases,\nand behavior which may surprise users. API Private:  Classes and public methods which are not intended for\nexternal usage should be marked  @api private . This macro does not\nrequire a comment. Note that, because Mongoid's modules are mixed into application classes,\n private  visibility of a method does not necessarily indicate its\nstatus as an API private method. Deprecation:  Use the  @deprecated  macro to indicate deprecated\nfunctionality. This macro does not require a comment. Line Wrapping:  Use double-space indent when wrapping lines of macros.\nDo not indent line wraps in the description. Whitespace:  Do not use leading/trailing empty comment lines,\nor more than one consecutive empty comment line. Type Unions:  Use pipe  |  to denote a union of allowed types. Nested Types:  Use angle brackets  < >  to denote type nesting. Hash:  Use comma  ,  to denote the key and value types. Array:  Use pipe  |  to denote a union of allowed types. Array:  Use comma  ,  to denote the types of each position in a tuple. Array:  Use pipe  |  on the top level if the inner types cannot be\nmixed within the Array. Nested Types:  For clarity, use square brackets  [ ]  to denote nested unions\nwhen commas are also used. Ruby Values:  Specific values may be denoted in the type using Ruby syntax. True, False, and Nil:  Use  true ,  false , and  nil  rather than\n TrueClass ,  FalseClass , and  NilClass . Do not use  Boolean  as a type\nsince it does not exist in Ruby. Return Self:  Specify return value  self  where a method returns  self . Splat Args:  Use three-dot ellipses  ...  in the type declaration and\nstar  *  in the parameter name to denote a splat. Splat Args:  Do not use  Array  as the type unless each arg is actually an Array. Splat Args:  Use comma  ,  to denote positionality in a splat. Splat Args:  Specify type unions with square brackets  [ ] . Keyword Arguments:  Following YARD conventions, use  @param  for keyword\narguments, and specify keyword argument names as symbols. Hash Options:  Define hash key-value options with  @option  macro\nimmediately following the Hash  @param . Note  @option  parameter names\nare symbols. Double Splats:  Use double-star  **  in the parameter name to denote a\nkeyword arg splat (double splat).  Note that type does not need declared on\nthe double-splat element,   as it is implicitly <Symbol, Object>. Instead,\ndefine value types with  @option    macro below. Note  @option  parameter\nnames are symbols.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "# This is the documentation for the class. It's amazing\n# what they do with corrugated cardboard these days.\nclass CardboardBox"
                },
                {
                    "lang": "ruby",
                    "value": "# Turn a person into whatever they'd like to be.\n#\n# @param [ Person ] person The human to transmogrify.\n#\n# @return [ Tiger ] The transmogrified result.\ndef transmogrify(person)"
                },
                {
                    "lang": "ruby",
                    "value": "private\n\n# Documentation is optional here.\ndef my_internal_method"
                },
                {
                    "lang": "ruby",
                    "value": "# Clear all stored data.\n#\n# @note This operation deletes data in the database.\ndef erase_data!"
                },
                {
                    "lang": "ruby",
                    "value": "# This is an internal-only method.\n#\n# @api private\ndef dont_call_me_from_outside"
                },
                {
                    "lang": "ruby",
                    "value": "# This is how we did things back in the day.\n#\n# @deprecated\ndef the_old_way"
                },
                {
                    "lang": "ruby",
                    "value": "# This is the description of the method. Line wraps in the description\n# should not be indented.\n#\n# @return [ Symbol ] For macros, wraps must be double-space indented\n#   on the second, third, etc. lines."
                },
                {
                    "lang": "ruby",
                    "value": "# GOOD:\n# @return [ Symbol ] The return value\ndef my_method\n\n# BAD:\n# @return [ Symbol ] The return value\n#\ndef my_method\n\n# BAD:\n# @param [ Symbol ] foo The input value\n#\n#\n# @return [ Symbol ] The return value\ndef my_method(foo)"
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Symbol | String ] name Either a Symbol or a String."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Array<Symbol> ] array An Array of symbols."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Hash<Symbol, Integer> ] hash A Hash whose keys are Symbols,\n#   and whose values are Integers."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Array<Symbol | String> ] array An Array whose members must\n#   be either Symbols or Strings."
                },
                {
                    "lang": "ruby",
                    "value": "# @return [ Array<Symbol, Integer, Integer> ] A 3-member Array whose first\n#   element is a Symbol, and whose second and third elements are Integers."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Array<Symbol> | Array<Hash> ] array An Array containing only\n#   Symbols, or an Array containing only Hashes. The Array may not contain\n#   a mix of Symbols and Hashes."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Hash<Symbol, [ true | false ]> ] hash A Hash whose keys are Symbols,\n#   and whose values are boolean values."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ :before | :after ] timing One of the Symbol values :before or :after."
                },
                {
                    "lang": "ruby",
                    "value": "# GOOD:\n# @param [ true | false | nil ] bool A boolean or nil value.\n\n# BAD:\n# @param [ TrueClass | FalseClass | NilClass ] bool A boolean or nil value.\n# @param [ Boolean ] bool A boolean value."
                },
                {
                    "lang": "ruby",
                    "value": "# @return [ self ] Returns the object itself."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ String... ] *items The list of items name(s) as Strings.\ndef buy_groceries(*items)"
                },
                {
                    "lang": "ruby",
                    "value": "# BAD:\n# @param [ Array<String> ] *items The list of items name(s) as Strings.\ndef buy_groceries(*items)\n\nbuy_groceries(\"Cheese\", \"Crackers\", \"Wine\")\n\n# OK:\n# @param [ Array<String>... ] *arrays One or more arrays containing name parts.\ndef set_people_names(*arrays)\n\nset_people_names([\"Harlan\", \"Sanders\"], [\"Jane\", \"K\", \"\"Doe\"], [\"Jim\", \"Beam\"])"
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ Symbol..., Hash ] *args A list of names, followed by a hash\n#   as the optional last arg.\ndef say_hello(*args)"
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ [ String | Symbol ]... ] *fields A splat of mixed Symbols and Strings."
                },
                {
                    "lang": "ruby",
                    "value": "# @param [ String ] query The search string\n# @param [ Boolean ] :exact_match Whether to do an exact match\n# @param [ Integer ] :results_per_page Number of results\ndef search(query, exact_match: false, results_per_page: 10)"
                },
                {
                    "lang": "ruby",
                    "value": "# @param opts [ Hash<Symbol, Object> ] The optional hash argument(s).\n# @option opts [ String | Array<String> ] :items The items(s) as Strings to include.\n# @option opts [ Integer ] :limit An Integer denoting the limit.\ndef buy_groceries(opts = {})"
                },
                {
                    "lang": "ruby",
                    "value": "# @param **kwargs The optional keyword argument(s).\n# @option **kwargs [ String | Array<String> ] :items The items(s) as Strings to include.\n# @option **kwargs [ Integer ] :limit An Integer denoting the limit.\ndef buy_groceries(**kwargs)"
                }
            ],
            "preview": "Mongoid uses its own flavor of YARD\nfor code documentation. Please note the conventions outlined in this document.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "tutorials/getting-started-rails7",
            "title": "Getting Started (Rails 7)",
            "headings": [
                "New Application",
                "Install rails",
                "Create New Application",
                "Optionally Skip Tests",
                "Setup Mongoid",
                "Configure for Self Managed MongoDB",
                "Configure for MongoDB Atlas",
                "Run Application",
                "Add Posts",
                "Add Comments",
                "Existing Application",
                "Dependencies",
                "Mongoid Configuration",
                "Loaded Frameworks",
                "ActiveRecord Configuration",
                "Adjust Models",
                "Data Migration",
                "Rails API"
            ],
            "paragraphs": "This tutorial is for Ruby on Rails 7. If this is not the version you're using choose\nthe appropriate tutorial for your Rails version from the navigation menu. This section demonstrates how to create a new Ruby on Rails application using the Mongoid ODM.\nBy replacing Rails' default  ActiveRecord \nadapter with MongoDB's ORM-like library for data access we will create an application similar to the\nblog application described in the  Ruby on Rails Getting Started  guide. The complete source code for this application can be found in the\n mongoid-demo GitHub repository . This guide assumes basic familiarity with Ruby on Rails.\nTo learn more about Ruby on Rails, please refer to its  Getting Started\nguide  or\nother Rails guides. We will use a Rails generator to create the application skeleton.\nIn order to do so, the first step is to install the  rails  gem: Use the  rails  command to create the application skeleton, as follows: We pass  --skip-active-record  to request that ActiveRecord is not added\nas a dependency, because we will be using Mongoid instead. If you intend to test your application with  RSpec , you can instruct the\ngenerator to omit the default Rails test setup by passing  --skip-test \nand  --skip-system-test  options: 1. Modify the  Gemfile  to add a reference to the\n mongoid  gem: This generator will create the  config/mongoid.yml  configuration file,\nwhich is used to configure the connection to the MongoDB deployment.\nNote that as we are not using ActiveRecord we will not have a  database.yml \nfile. Install gem dependencies: Generate the default  Mongoid configuration : The configuration created in the previous step is suitable when\na MongoDB server is running locally. If you do not already have a\nlocal MongoDB server,  download and install MongoDB . While the generated  mongoid.yml  will work without modifications,\nwe recommend reducing the server selection timeout for development.\nWith this change, the uncommented lines of  mongoid.yml  should look\nlike this: Instead of downloading, installing and running MongoDB locally, you can create\na free MongoDB Atlas account and create a  free MongoDB cluster in Atlas .\nOnce the cluster is created, follow the instructions in  connect to the cluster\npage \nto obtain the URI. Use the  Ruby driver 2.5 or later  format. Paste the URI into the  config/mongoid.yml  file, and comment out the\nhosts that are defined. We recommend setting the server selection timeout to 5\nseconds for development environment when using Atlas. The uncommented contents of  config/mongoid.yml  should look like this: You can now start the application server by running: Access the application by navigating to  localhost:3000 . Using the standard Rails scaffolding, Mongoid can generate the necessary\nmodel, controller and view files for our blog so that we can quickly begin\ncreating blog posts: Navigate to  localhost:3000/posts \nto create posts and see the posts that have already been created. To make our application more interactive, let's add the ability for users to\nadd comments to our posts. Create the  Comment  model: Open the  Post  model file,  app/models/post.rb , and add a  has_many \nassociation for the comments: Open  app/views/posts/show.html.erb  and add\na section rendering existing comments and prompting to leave a new comment: Open  app/views/comments/_form.html.erb  and change the type of field for  :message \nfrom  text_field  to  text_area , as well as the type of field for\n :post_id  from  text_field  to  hidden_field . The result\nshould look like this: Next replace  app/view/comments/_comment.html.erb  with the following contents: You should now be able to leave comments for the posts: Mongoid can be easily added to an existing Rails application and run alongside other ActiveRecord\nadapters. If this is your use case, updating dependencies and populating the configuration file will\nallow you to start using MongoDB within your application. To switch an existing Ruby on Rails application to use Mongoid instead of ActiveRecord additional\nconfiguration changes will be required, as described below. First, the  mongoid  gem will need to be added your  Gemfile . If Mongoid will be the  only  database adapter, remove or comment out any RDBMS libraries\nlike  sqlite  or  pg  mentioned in the  Gemfile . Install gem dependencies: Generate the default Mongoid configuration: This generator will create the  config/mongoid.yml  configuration file,\nwhich is used to configure the connection to the MongoDB deployment. Review the sections  Configure for Self Managed MongoDB \nand  Configure for MongoDB Atlas  to decide how you\nwould like to deploy MongoDB, and adjust the Mongoid configuration\n( config/mongoid.yml ) to match. Examine  config/application.rb . If it is requiring all components of Rails\nvia  require 'rails/all' , change it to require individual frameworks. To verify the contents of\n rails/all  for your version see the  Github Repository : Due to their reliance on ActiveRecord,  ActionText ,\n ActiveStorage  and\n ActionMailbox  cannot be used\nwith Mongoid. Review all configuration files ( config/application.rb ,\n config/environments/{development,production.test}.rb ) and remove or\ncomment out any references to  config.active_record  and\n config.active_storage . If your application already has models, these will need to be changed when\nmigrating from ActiveRecord to Mongoid. ActiveRecord models derive from  ApplicationRecord  and do not have\ncolumn definitions. Mongoid models generally have no superclass but must\ninclude  Mongoid::Document , and usually define the fields explicitly\n(but  dynamic fields  may also be used instead of\nexplicit field definitions). For example, a bare-bones Post model may look like this in ActiveRecord: The same model may look like this in Mongoid: Or like this with dynamic fields: Mongoid does not utilize ActiveRecord migrations, since MongoDB does not\nrequire a schema to be defined prior to storing data. If you already have data in a relational database that you would like to\ntransfer to MongoDB, you will need to perform a data migration. As noted\nabove, no schema migration is necessary because MongoDB does not require\na predefined schema to store the data. The migration tools are often specific to the data being migrated because,\neven though Mongoid supports a superset of ActiveRecord associations,\nthe way that model references are stored in collections differs between\nMongoid and ActiveRecord. With that said, MongoDB has\nsome resources on migrating from an RDBMS to MongoDB such as the\n RDBMS to MongoDB Migration Guide  and\n Modernization Guide . The process for creating a Rails API application with Mongoid is the same\nas when creating a regular application, with the only change being the\n --api  parameter to  rails new . Migrating a Rails API application to\nMongoid follows the same process described above for regular Rails applications. A complete Rails API application similar to the one described in this tutorial\ncan be found in  the mongoid-demo GitHub repository .",
            "code": [
                {
                    "lang": "sh",
                    "value": "gem install rails -v '~> 7'"
                },
                {
                    "lang": "sh",
                    "value": "rails new blog --skip-active-record\ncd blog"
                },
                {
                    "lang": "sh",
                    "value": "rails new blog --skip-active-record --skip-test --skip-system-test\ncd blog"
                },
                {
                    "lang": "ruby",
                    "value": "  gem 'mongoid'"
                },
                {
                    "lang": "sh",
                    "value": "bundle install"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g mongoid:config"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      database: blog_development\n      hosts:\n        - localhost:27017\n      options:\n        server_selection_timeout: 1"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      uri: mongodb+srv://user:pass@yourcluster.mongodb.net/blog_development?retryWrites=true&w=majority\n      options:\n        server_selection_timeout: 5"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails s"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g scaffold Post title:string body:text"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g scaffold Comment name:string message:string post:belongs_to"
                },
                {
                    "lang": "ruby",
                    "value": "  class Post\n    include Mongoid::Document\n    include Mongoid::Timestamps\n    field :title, type: String\n    field :body, type: String\n\n    has_many :comments, dependent: :destroy\n  end"
                },
                {
                    "lang": "erb",
                    "value": "<section class=\"section comments\">\n  <div class=\"container\">\n    <h2 class=\"subtitle is-5\">\n      <strong><%= @post.comments.count %></strong> Comments\n    </h2>\n    <%= render @post.comments %>\n    <div class=\"comment-form\">\n      <hr />\n      <h3 class=\"subtitle is-3\">Leave a reply</h3>\n      <%= render partial: 'comments/form', locals: { comment: @post.comments.build } %>\n    </div>\n  </div>\n</section>"
                },
                {
                    "lang": "erb",
                    "value": "<%= form_with(model: comment, local: true) do |form| %>\n  <% if comment.errors.any? %>\n    <div id=\"error_explanation\">\n      <h2><%= pluralize(comment.errors.count, \"error\") %> prohibited this comment from being saved:</h2>\n\n      <ul>\n        <% comment.errors.full_messages.each do |message| %>\n          <li><%= message %></li>\n        <% end %>\n      </ul>\n    </div>\n  <% end %>\n\n  <div class=\"field\">\n    <%= form.label :name %>\n    <%= form.text_field :name %>\n  </div>\n\n  <div class=\"field\">\n    <%= form.label :message %>\n    <%= form.text_area :message %>\n  </div>\n\n  <div class=\"field\">\n    <%= form.hidden_field :post_id %>\n  </div>\n\n  <div class=\"actions\">\n    <%= form.submit %>\n  </div>\n<% end %>"
                },
                {
                    "lang": "erb",
                    "value": "<p>\n  <strong><%= comment.name %>:</strong>\n  <%= comment.message %>\n  <%= link_to 'Delete', [comment],\n    data: {\n      \"turbo-method\": :delete,\n      \"turbo-confirm\": 'Are you sure?'\n    } %>\n</p>"
                },
                {
                    "lang": "ruby",
                    "value": "  gem 'mongoid'"
                },
                {
                    "lang": "sh",
                    "value": "bundle install"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g mongoid:config"
                },
                {
                    "lang": "ruby",
                    "value": "# Remove or comment out\n#require \"rails/all\"\n\n# Add the following instead of \"rails/all\":\nrequire \"rails\"\n\n# require \"active_record/railtie\" rescue LoadError\n# require \"active_storage/engine\" rescue LoadError\nrequire \"action_controller/railtie\" rescue LoadError\nrequire \"action_view/railtie\" rescue LoadError\nrequire \"action_mailer/railtie\" rescue LoadError\nrequire \"active_job/railtie\" rescue LoadError\nrequire \"action_cable/engine\" rescue LoadError\n# require \"action_mailbox/engine\" rescue LoadError\n# require \"action_text/engine\" rescue LoadError\nrequire \"rails/test_unit/railtie\" rescue LoadError"
                },
                {
                    "lang": "ruby",
                    "value": "class Post < ApplicationRecord\n  has_many :comments, dependent: :destroy\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n\n  field :title, type: String\n  field :body, type: String\n\n  has_many :comments, dependent: :destroy\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n  include Mongoid::Attributes::Dynamic\n\n  has_many :comments, dependent: :destroy\nend"
                }
            ],
            "preview": "This section demonstrates how to create a new Ruby on Rails application using the Mongoid ODM.\nBy replacing Rails' default ActiveRecord\nadapter with MongoDB's ORM-like library for data access we will create an application similar to the\nblog application described in the Ruby on Rails Getting Started guide.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "meta/404",
            "title": "File not found",
            "headings": [],
            "paragraphs": "The URL you requested does not exist or has been removed.",
            "code": [],
            "preview": "The URL you requested does not exist or has been removed.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "tutorials/getting-started-rails6",
            "title": "Getting Started (Rails 6)",
            "headings": [
                "New Application",
                "Install rails",
                "Create New Application",
                "Create Git Repo",
                "Add Mongoid",
                "Run MongoDB Locally",
                "Use MongoDB Atlas",
                "Other Rails Dependencies",
                "Run Application",
                "Add Posts",
                "Add Comments",
                "Existing Application",
                "Dependencies",
                "Loaded Frameworks",
                "ActiveRecord Configuration",
                "Stop Spring",
                "Mongoid Configuration",
                "Adjust Models",
                "Data Migration",
                "Rails API"
            ],
            "paragraphs": "This tutorial is for Ruby on Rails 6. If this is not the version you're using choose\nthe appropriate tutorial for your Rails version from the navigation menu. This section shows how to create a new Ruby on Rails application using Mongoid\nfor data access. The application will be similar to the blog application\ndescribed in the  Ruby on Rails Getting Started \nguide, however using Mongoid instead of ActiveRecord as the database adapter. The complete source code for this application can be found in the\n mongoid-demo GitHub repository . This guide assumes basic familiarity with Ruby on Rails.\nTo learn more about Ruby on Rails, please refer to its  Getting Started\nguide  or\nother Rails guides. We will use a Rails generator to create the application skeleton.\nIn order to do so, the first step is to install the  rails  gem: Use the  rails  command to create the application skeleton, as follows: We pass  --skip-active-record  to request that ActiveRecord is not added\nas a dependency, because we will be using Mongoid instead. Additionally\nwe pass  --skip-bundle  because we'll be modifying the  Gemfile  to\nadd the  mongoid  dependency. If you intend to test your application with RSpec, you can instruct the\ngenerator to omit default Rails test setup by passing  --skip-test \nand  --skip-system-test  options: You may receive a warning like this: Disregard it as we will be taking care of gem installation\nin a moment. While not required, we recommend creating a Git repository for your application: Commit your changes as you are following this tutorial. 1. Modify the  Gemfile  to add a reference to the\n mongoid  gem: This generator will create the  config/mongoid.yml  configuration file,\nwhich is used to configure the connection to the MongoDB deployment.\nNote that as we are not using ActiveRecord we will not have a  database.yml \nfile. Mongoid 7.0.5 or higher is required to use Rails 6.0. Install gem dependencies: Generate the default Mongoid configuration: The configuration created in the previous step is suitable when\na MongoDB server is running locally. If you do not already have a\nlocal MongoDB server,  download and install MongoDB . While the generated  mongoid.yml  will work without modifications,\nwe recommend reducing the server selection timeout for development.\nWith this change, the uncommented lines of  mongoid.yml  should look\nlike this: Instead of downloading, installing and running MongoDB locally, you can create\na free MongoDB Atlas account and create a  free MongoDB cluster in Atlas .\nOnce the cluster is created, follow the instructions in  connect to the cluster\npage \nto obtain the URI. Use the  Ruby driver 2.5 or later  format. Paste the URI into the  config/mongoid.yml  file, and comment out the\nhosts that are defined. We recommend setting the server selection timeout to 5\nseconds for development environment when using Atlas. The uncommented contents of  config/mongoid.yml  should look like this: If this is the first Rails application you are creating, you may need to\ninstall Node.js on your computer. This can be done via your operating system\npackages or by  downloading a binary . Next, if you do not have Yarn installed,  follow its installation instructions . Finally, install webpacker: You can now start the application server by running: Access the application by navigating to  localhost:3000 . Using the standard Rails scaffolding, Mongoid can generate the necessary\nmodel, controller and view files for our blog so that we can quickly begin\ncreating blog posts: Navigate to  localhost:3000/posts \nto create posts and see the posts that have already been created. To make our application more interactive, let's add the ability for users to\nadd comments to our posts. Create the  Comment  model: Open the  Post  model file,  app/models/post.rb , and add a  has_many \nassociation for the comments: Open the post show view file,  app/views/posts/show.html.erb , and add\na section rendering existing comments and prompting to leave a new comment: Open the comment form file and change the type of field for  :message \nfrom  text_field  to  text_area , as well as the type of field for\n :post_id  from  text_field  to  hidden_field . The result\nshould look like this: Create a partial for the comment view,  app/views/comments/_comment.html.erb \nwith the following contents: You should now be able to leave comments for the posts: The following is only required if using a version of Mongoid < 7.0.8 or 7.1.2 (see \n MONGOID-4885   for details) Open the  Comment  model file,  app/models/comment.rb , and change the\ngenerated  embedded_in  association to  belongs_to : Follow these steps to switch an existing Ruby on Rails application to use\nMongoid instead of ActiveRecord. Remove or comment out any RDBMS libraries like  sqlite ,  pg  etc.\nmentioned in  Gemfile , and add  mongoid : Install gem dependencies: Mongoid 7.0.5 or higher is required to use Rails 6.0. Examine  config/application.rb . If it is requiring all components of Rails\nvia  require 'rails/all' , change it to require individual frameworks: At this time ActiveStorage requires ActiveRecord and is not usable with\nMongoid. Review all configuration files ( config/application.rb ,\n config/environments/{development,production.test}.rb ) and remove or\ncomment out any references to  config.active_record  and\n config.active_storage . If your application is using Spring, which is the default on Rails 6,\nSpring must be stopped after changing dependencies or configuration. Sometimes running  ./bin/spring stop  claims to stop Spring, but does\nnot. Verify that all Spring processes are terminated before proceeding. Sometimes Spring tries to load ActiveRecord even when the application\ncontains no ActiveRecord references. If this happens, add an ActiveRecord\nadapter dependency such as  sqlite3  to your  Gemfile  so that\nActiveRecord may be completely loaded or remove Spring from your\napplication. Generate the default Mongoid configuration: This generator will create the  config/mongoid.yml  configuration file,\nwhich is used to configure the connection to the MongoDB deployment. Review the sections  Run MongoDB Locally  and\n Use MongoDB Atlas  to decide how you would like to deploy\nMongoDB, and adjust Mongoid configuration ( config/mongoid.yml ) to match. If your application already has models, these will need to be changed when\nmigrating from ActiveRecord to Mongoid. ActiveRecord models derive from  ApplicationRecord  and do not have\ncolumn definitions. Mongoid models generally have no superclass but must\ninclude  Mongoid::Document , and usually define the fields explicitly\n(but  dynamic fields  may also be used instead of\nexplicit field definitions). For example, a bare-bones Post model may look like this in ActiveRecord: The same model may look like this in Mongoid: Or like this with dynamic fields: Mongoid does not utilize ActiveRecord migrations, since MongoDB does not\nrequire a schema to be defined prior to storing data. If you already have data in a relational database that you would like to\ntransfer to MongoDB, you will need to perform a data migration. As noted\nabove, no schema migration is necessary because MongoDB does not require\na predefined schema to store the data. The migration tools are often specific to the data being migrated because,\neven though Mongoid supports a superset of ActiveRecord associations,\nthe way that model references are stored in collections differs between\nMongoid and ActiveRecord. With that said, MongoDB has\nsome resources on migrating from an RDBMS to MongoDB such as the\n RDBMS to MongoDB Migration Guide  and\n Modernization Guide . The process for creating a Rails API application with Mongoid is the same\nas when creating a regular application, with the only change being the\n --api  parameter to  rails new . Migrating a Rails API application to\nMongoid follows the same process described above for regular Rails applications. A complete Rails API application similar to the one described in this tutorial\ncan be found in  the mongoid-demo GitHub repository .",
            "code": [
                {
                    "lang": "sh",
                    "value": "gem install rails -v '~> 6.0.0'"
                },
                {
                    "lang": "sh",
                    "value": "rails new blog --skip-active-record --skip-bundle\ncd blog"
                },
                {
                    "lang": "sh",
                    "value": "rails new blog --skip-bundle --skip-active-record --skip-test --skip-system-test\ncd blog"
                },
                {
                    "lang": "sh",
                    "value": "Could not find gem 'puma (~> 3.11)' in any of the gem sources listed in your Gemfile.\nRun `bundle install` to install missing gems."
                },
                {
                    "lang": "sh",
                    "value": "git init .\ngit add .\ngit commit"
                },
                {
                    "lang": "ruby",
                    "value": "  gem 'mongoid', '~> 7.0.5'"
                },
                {
                    "lang": "sh",
                    "value": "bundle install"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g mongoid:config"
                },
                {
                    "lang": "none",
                    "value": "development:\n  clients:\n    default:\n      database: blog_development\n      hosts:\n        - localhost:27017\n      options:\n        server_selection_timeout: 1"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      uri: mongodb+srv://user:pass@yourcluster.mongodb.net/blog_development?retryWrites=true&w=majority\n      options:\n        server_selection_timeout: 5"
                },
                {
                    "lang": "sh",
                    "value": "rails webpacker:install"
                },
                {
                    "lang": "sh",
                    "value": "rails s"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g scaffold Post title:string body:text"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g scaffold Comment name:string message:string post:belongs_to"
                },
                {
                    "lang": "ruby",
                    "value": "  class Post\n    include Mongoid::Document\n\n    field :title, type: String\n    field :body, type: String\n\n    has_many :comments, dependent: :destroy\n  end"
                },
                {
                    "lang": "html",
                    "value": "<section class=\"section comments\">\n  <div class=\"container\">\n    <h2 class=\"subtitle is-5\">\n      <strong><%= @post.comments.count %></strong> Comments\n    </h2>\n    <%= render @post.comments %>\n    <div class=\"comment-form\">\n      <hr />\n      <h3 class=\"subtitle is-3\">Leave a reply</h3>\n      <%= render partial: 'comments/form', locals: { comment: @post.comments.build } %>\n    </div>\n  </div>\n</section>"
                },
                {
                    "lang": "html",
                    "value": "<%= form_with(model: comment, local: true) do |form| %>\n  <% if comment.errors.any? %>\n    <div id=\"error_explanation\">\n      <h2><%= pluralize(comment.errors.count, \"error\") %> prohibited this comment from being saved:</h2>\n\n      <ul>\n        <% comment.errors.full_messages.each do |message| %>\n          <li><%= message %></li>\n        <% end %>\n      </ul>\n    </div>\n  <% end %>\n\n  <div class=\"field\">\n    <%= form.label :name %>\n    <%= form.text_field :name %>\n  </div>\n\n  <div class=\"field\">\n    <%= form.label :message %>\n    <%= form.text_area :message %>\n  </div>\n\n  <div class=\"field\">\n    <%= form.hidden_field :post_id %>\n  </div>\n\n  <div class=\"actions\">\n    <%= form.submit %>\n  </div>\n<% end %>"
                },
                {
                    "lang": "html",
                    "value": "<p>\n  <strong><%= comment.name %>:</strong>\n  <%= comment.message %>\n<br>\n<%= link_to 'Delete', [comment],\n  method: :delete,\n  class: \"button is-danger\",\n  data: { confirm: 'Are you sure?' } %>\n</p>"
                },
                {
                    "lang": "ruby",
                    "value": "  class Comment\n    include Mongoid::Document\n\n    field :name, type: String\n    field :message, type: String\n\n    belongs_to :post\n  end"
                },
                {
                    "lang": "ruby",
                    "value": "  gem 'mongoid', '~> 7.0.5'"
                },
                {
                    "lang": "sh",
                    "value": "bundle install"
                },
                {
                    "lang": "ruby",
                    "value": "# Remove or comment out\n#require \"rails/all\"\n\n# Add this require instead of \"rails/all\":\nrequire \"rails\"\n\n# Pick the frameworks you want:\nrequire \"active_model/railtie\"\nrequire \"active_job/railtie\"\nrequire \"action_controller/railtie\"\nrequire \"action_mailer/railtie\"\n# require \"action_mailbox/engine\"\n# require \"action_text/engine\"\nrequire \"action_view/railtie\"\nrequire \"action_cable/engine\"\nrequire \"sprockets/railtie\"\nrequire \"rails/test_unit/railtie\"\n\n# Remove or comment out ActiveRecord and ActiveStorage:\n# require \"active_record/railtie\"\n# require \"active_storage/engine\""
                },
                {
                    "lang": "sh",
                    "value": "./bin/spring stop"
                },
                {
                    "lang": "sh",
                    "value": "bin/rails g mongoid:config"
                },
                {
                    "lang": "ruby",
                    "value": "class Post < ApplicationRecord\n  has_many :comments, dependent: :destroy\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n\n  field :title, type: String\n  field :body, type: String\n\n  has_many :comments, dependent: :destroy\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n  include Mongoid::Attributes::Dynamic\n\n  has_many :comments, dependent: :destroy\nend"
                }
            ],
            "preview": "This section shows how to create a new Ruby on Rails application using Mongoid\nfor data access. The application will be similar to the blog application\ndescribed in the Ruby on Rails Getting Started\nguide, however using Mongoid instead of ActiveRecord as the database adapter.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "contributing/contributing-guidelines",
            "title": "Contributing Guidelines",
            "headings": [
                "Contributing Guidelines"
            ],
            "paragraphs": "If you wish to propose an enhancement to Mongoid, please create a Jira ticket\ndescribing the enhancement and what it would enable you to achieve in your\napplication that is not already possible. If you believe Mongoid is not\nbehaving correctly, please create a Jira ticket describing how you use Mongoid,\nwhat the existing behavior is that you consider incorrect or problematic, and\nwhat your desired behavior is. If you wish to make changes yourself, the\nfollowing guildelines should be followed: Create a fork of Mongoid. Create a new branch in that fork. Make your changes. Ensure that the proposed changes have adequate test coverage. Raise a PR against Mongoid master. If these changes correspond to a specific\nJira ticket, title the PR: \"MONGOID-<ticket #> Description of Changes\". The Mongoid team will review the PR and make comments/suggest changes. Once all of the changes and fixes are made, and the Mongoid team determine\nthe PR fit for merging, we will merge the PR into master and determine\nwhether it needs to be backported. Backports to previous stable versions are done if the change is a bug fix,\nis not backwards breaking, and if the commit is applicable to the\ncorresponding stable branch. Presently backport candidates would include\nversions 7.3-8.0. Changes to 6.0-7.2 are generally not made unless it fixes a security\nvulnerability. 5.x and earlier is generally not supported.",
            "code": [],
            "preview": "If you wish to propose an enhancement to Mongoid, please create a Jira ticket\ndescribing the enhancement and what it would enable you to achieve in your\napplication that is not already possible. If you believe Mongoid is not\nbehaving correctly, please create a Jira ticket describing how you use Mongoid,\nwhat the existing behavior is that you consider incorrect or problematic, and\nwhat your desired behavior is. If you wish to make changes yourself, the\nfollowing guildelines should be followed:",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/nested-attributes",
            "title": "Nested Attributes",
            "headings": [
                "Behavior"
            ],
            "paragraphs": "Nested attributes provide a mechanism for updating documents and their\nassociations in a single operation by nesting attributes in a single\nparameters hash. This is useful when wanting to edit multiple documents\nwithin a single web form. Nested attributes can be enabled for any association, embedded or referenced.\nTo enable this for an association, simply provide the association name to the\n accepts_nested_attributes_for  macro. Note that when you add nested attributes functionality to a referenced\nassociation, Mongoid will automatically enable autosave for that association. When an association gains nested attributes behavior, an additional method is\nadded to the base model, which should be used to update the attributes with\nthe new functionality. This method is the association name plus  _attributes= .\nYou can use this method directly, or more commonly the name of the method can\nbe an attribute in the updates for the base class, in which case\nMongoid will call the appropriate setter under the covers. Note that this will work with any attribute based setter method in Mongoid. This includes:\n update_attributes ,  update_attributes!  and  attributes= .",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_many :albums\n  belongs_to :producer\n  accepts_nested_attributes_for :albums, :producer\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.first\nband.producer_attributes = { name: \"Flood\" }\nband.attributes = { producer_attributes: { name: \"Flood\" }}"
                }
            ],
            "preview": "Nested attributes provide a mechanism for updating documents and their\nassociations in a single operation by nesting attributes in a single\nparameters hash. This is useful when wanting to edit multiple documents\nwithin a single web form.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/validation",
            "title": "Validation",
            "headings": [
                "validates_uniqueness_of and :conditions  Option"
            ],
            "paragraphs": "Mongoid includes  ActiveModel::Validations  to supply the basic\nvalidation plus an additional associated and uniqueness validator. See the  Active Record Validations \nRails guide and  ActiveModel::Validations \ndocumentation for more information. Mongoid behaves slightly differently to Active Record when using  #valid? \non already persisted data. Active Record's  #valid?  will run all\nvalidations whereas Mongoid's  #valid?  will only run validations on\ndocuments that are in memory as an optimization. The  :conditions  option to  validates_uniqueness_of  can be used to\nprovide additional conditions to add to the database query looking for\nidentical documents. This option does not influence when the validation\nis executed because it is not considered when Mongoid retrieves the present\nvalue of the respective field from the model. Consider the following example:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  field :year, type: Integer\n\n  validates_uniqueness_of :name, conditions: -> { where(:year.gte => 2000) }\nend\n\n# OK\nBand.create!(name: \"Sun Project\", year: 2000)\n\n# Fails validation because there is a band with the \"Sun Project\" name\n# and year 2000 in the database, even though the model being created now\n# does not have a year.\nBand.create!(name: \"Sun Project\")"
                }
            ],
            "preview": "Mongoid includes ActiveModel::Validations to supply the basic\nvalidation plus an additional associated and uniqueness validator.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/compatibility",
            "title": "Compatibility",
            "headings": [
                "Ruby MongoDB Driver Compatibility",
                "Ruby Compatibility",
                "MongoDB Server Compatibility",
                "Rails Compatibility"
            ],
            "paragraphs": "The following compatibility table specifies the versions of  Ruby driver for\nMongoDB \n(the  mongo  gem) supported by the most recent patch releases of the\nspecified Mongoid versions. Older versions of Mongoid within the same minor release may support older\ndriver versions. For example, Mongoid 7.0.5 supports driver versions 2.5 and\nnewer, whereas Mongoid 7.0.6 requires driver version 2.7 or newer. Mongoid Driver 2.19-2.18 Driver 2.17-2.10 Driver 2.9-2.7 8.1 8.0 7.5 7.4 7.3 7.2 7.1 7.0 6.4 The following compatibility table specifies the versions of Ruby interpreters\nsupported by Mongoid. \"D\" in a column means support for that Ruby version\nis deprecated. Mongoid Ruby 3.2 Ruby 3.1 Ruby 3.0 Ruby 2.7 Ruby 2.6 Ruby 2.5 Ruby 2.4 Ruby 2.3 Ruby 2.2 JRuby 9.2 JRuby 9.3 8.1 8.0 7.5 D D 7.4 7.3 \u2713   \u2713   D D 7.2 \u2713   \u2713   D D 7.1 \u2713   \u2713   \u2713   7.0 \u2713   \u2713   6.4 \u2713   \u2713   Mongoid version 7.3.2 or higher is required. Mongoid version 7.2.5 or higher is required. Mongoid version 7.1.10 or higher is required. Ruby version 2.4.1 or higher is required. Ruby version 2.2.2 or higher is required. The following compatibility table specifies the recommended\nversion(s) of Mongoid for use with a specific version of MongoDB server. Note that in order to use features of a particular MongoDB server version,\nboth the driver and Mongoid must support that server version.\nPlease refer to  the driver compatibility page \nfor driver compatibility matrices. \"D\" in a column means support for that MongoDB server version is deprecated\nand will be removed in a next version. Mongoid MongoDB 7.0 MongoDB 6.0 MongoDB 5.0 MongoDB 4.4 MongoDB 4.2 MongoDB 4.0 MongoDB 3.6 MongoDB 3.4 MongoDB 3.2 MongoDB 3.0 MongoDB 2.6 8.1 8.0 7.5 D D D D 7.4 D D D D 7.3 D D D D 7.2 D D D D 7.1 D D D D 7.0 D D D D 6.4 D D D D The following compatibility table specifies which versions of Ruby on Rails\nare supported by Mongoid. Mongoid Rails 7.1 Rails 7.0 Rails 6.1 Rails 6.0 Rails 5.2 Rails 5.1 8.1 \u2713   \u2713   8.0 \u2713   \u2713   7.5 \u2713   D 7.4 \u2713   \u2713   7.3 \u2713   \u2713   \u2713   7.2 \u2713   \u2713   \u2713   7.1 \u2713   7.0 \u2713   \u2713   6.4 Using Rails 5.x with Ruby 3 is not supported. Rails 6.0 requires Mongoid 7.0.5 or later. Rails 6.1 requires Mongoid 7.0.12, 7.1.7 or 7.2.1 in the\nrespective 7.0, 7.1 and 7.2 stable branches. Rails 7.x requires Mongoid 7.3.4 or later. Rails 7.1 requires Mongoid 8.0.7 or 8.1.3 in the respective\n8.0 and 8.1 stable branches.",
            "code": [],
            "preview": "The following compatibility table specifies the versions of Ruby driver for\nMongoDB\n(the mongo gem) supported by the most recent patch releases of the\nspecified Mongoid versions.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/crud",
            "title": "CRUD Operations",
            "headings": [
                "Saving Documents",
                "Standard",
                "Atomic",
                "Atomic Operation Grouping",
                "Reloading",
                "Reloading Unsaved Documents",
                "Accessing Field Values",
                "Getters & Setters",
                "Custom Getters & Setters",
                "read_attribute & write_attribute",
                "Hash Access",
                "Bulk Attribute Writes",
                "Dirty Tracking",
                "Viewing Changes",
                "Resetting Changes",
                "Persistence",
                "Viewing Previous Changes",
                "Updating Container Fields",
                "Readonly Documents",
                "Overriding readonly?"
            ],
            "paragraphs": "Mongoid supports all expected CRUD operations for those familiar with other\nRuby mappers like Active Record or Data Mapper. What distinguishes Mongoid\nfrom other mappers for MongoDB is that the general persistence operations\nperform atomic updates on only the fields that have changed instead of\nwriting the entire document to the database each time. The persistence sections will provide examples on what database operation is\nperformed when executing the documented command. Mongoid's standard persistence methods come in the form of common methods you\nwould find in other mapping frameworks. The following table shows all standard\noperations with examples. Mongoid provides the following persistence-related attributes: Operation Example Model#attributes Returns a hash of the document's attributes with its values in\nmongoized form (i.e. the way they are stored in the db). In Mongoid 8.0 by default, and Mongoid 7.5 with the \n legacy_attributes   flag set to false, the object returned from this\nmethod will have class   Hash ,  and have string keys. In Mongoid 7.5\nby default, and in Mongoid 8.0 with the   legacy_attributes   flag set\nto true, the object returned from this method will be a \n BSON::Document   (and thus, indifferently accessible) if the document\nhas been retrieved from the database, and a   Hash   with string keys\nif it is a new document. The attributes hash also contains the attributes of all embedded\ndocuments, as well as their embedded documents, etc. If an embedded\nassociation is empty, its key will not show up in the returned hash. Model.create! Insert a document or multiple documents into the database, raising an\nerror if a validation or server error occurs. Pass a hash of attributes to create one document with the specified\nattributes, or an array of hashes to create multiple documents.\nIf a single hash is passed, the corresponding document is returned.\nIf an array of hashes is passed, an array of documents corresponding\nto the hashes is returned. If a block is given to   create!   , it will be invoked with each\ndocument as the argument in turn prior to attempting to save that\ndocument. If there is a problem saving any of the documents, such as\na validation error or a server error, an exception is raised\nand, consequently, none of the documents are returned.\nHowever, if an array of hashes was passed and previous documents were\nsuccessfully saved, those documents will remain in the database. Model.create Instantiate a document or multiple documents and, if validations pass,\ninsert them into the database. create   is similar to   create!   but does not raise\nexceptions on validation errors. It still raises errors on server\nerrors, such as trying to insert a document with an   _id   that\nalready exists in the collection. If any validation errors are encountered, the respective document\nis not inserted but is returned along with documents that were inserted.\nUse   persisted?   ,   new_record?   or   errors   methods\nto check which of the returned documents were inserted into the\ndatabase. Model#save! Save the changed attributes to the database atomically, or insert the document if\nnew. Raises an exception if validations fail or there is a server error. Returns true if the changed attributes were saved, raises an exception otherwise. Model#save Save the changed attributes to the database atomically, or insert the document\nif new. Returns true if the changed attributes were saved. Returns false\nif there were any validation errors. Raises an exception if\nthe document passed validation but there was a server error during\nthe save. Pass   validate: false   option to bypass validations. Pass   touch: false   option to ignore the updates to the updated_at\nfield. If the document being save has not been previously persisted,\nthis option is ignored and the created_at and updated_at fields will be\nupdated with the current time. Model#update_attributes Update the document attributes in the database. Will return true if validation passed,\nfalse if not. Model#update_attributes! Update the document attributes in the database and raise an error if validation failed. Model#update_attribute Update a single attribute, bypassing validations. Model#upsert Performs a MongoDB replace with upsert on the document. If the document\nexists in the database and the   :replace   option is set to true\n(default), it will get overwritten with the current document in the\napplication (any attributes present in the database but not in the\napplication's document instance will be lost). If the   :replace \n option is false, the document will be updated, and any attributes not\nin the application's document will be maintained.\nIf the document does not exist in the database, it will be inserted.\nNote that this only runs the   {before|after|around}_upsert   callbacks. Model#touch Update the document's updated_at timestamp, optionally with one extra\nprovided time field. This will cascade the touch to all \n belongs_to   associations of the document with the option set.\nThis operation skips validations and callbacks. Attempting to touch a destroyed document will raise   FrozenError ,\n same as if attempting to update an attribute on a destroyed\ndocument. Model#delete Deletes the document from the database without running callbacks. If the document is not persisted, Mongoid will attempt to delete from\nthe database any document with the same   _id . Model#destroy Deletes the document from the database while running destroy callbacks. If the document is not persisted, Mongoid will attempt to delete from\nthe database any document with the same   _id . Model.delete_all Deletes all documents from the database without running any callbacks. Model.destroy_all Deletes all documents from the database while running callbacks. This is a\npotentially expensive operation since all documents will be loaded into memory. Attribute Example Model#new_record? Returns   true   if the model instance has not yet been saved\nto the database. Opposite of   persisted? Model#persisted? Returns   true   if the model instance has been saved\nto the database. Opposite of   new_record? Although Mongoid performs atomic operations under the covers by default,\nthere may be cases where you want to do this explicitly without persisting\nother fields. Mongoid provides support for all of these operations as well.\nWhen executing atomic operations via these methods, callbacks and validations\nare not invoked. Operation Example Model#add_to_set Performs an atomic $addToSet on the field. Model#bit Performs an atomic $bit on the field. Model#inc Performs an atomic $inc on the field. Model#pop Performs an atomic $pop on the field. Model#pull Performs an atomic $pull on the field. Model#pull_all Performs an atomic $pullAll on the field. Model#push Performs an atomic $push on the field. Model#rename Performs an atomic $rename on the field. Model#set Updates an attribute on the model instance and, if the instance\nis already persisted, performs an atomic $set on the field, bypassing\nvalidations. set   can also deeply set values on Hash fields. set   can also deeply set values on   embeds_one   associations.\nIf such an association's document is nil, one will be created prior\nto the update. set   should not be used with   has_one   associations, as it\ndoes not correctly work in such cases. Model#unset Performs an atomic $unset on the field. Atomic operations may be grouped together using the  #atomically  method\non a document. All operations inside the block given to  #atomically \nare sent to the cluster in a single atomic command. For example: #atomically  blocks may be nested. The default behavior is to write\nchanges performed by each block as soon as the block ends: This behavior can be changed by specifying the  join_context: true  option\nto  #atomically , or globally by setting the  join_contexts \n configuration option  to  true . When\ncontext joining is enabled, nested  #atomically  blocks are joined with\nthe outer blocks, and only the outermost block (or the first block where\n join_contexts  is false) actually writes changes to the cluster.\nFor example: The context joining behavior can be enabled globally by default by setting\n join_context  option in Mongoid configuration. In this case specifying\n join_context: false  on an  #atomically  block can be used to\nobtain the independent persistence context behavior. If an exception is raised in an  #atomically  block which has not yet\npersisted its changes to the cluster, any pending attribute changes on\nMongoid models are reverted. For example: Atomic operations described in this section apply to one document at a time,\ntherefore nesting  #atomically  blocks invoked on multiple documents does\nnot make changes to the different documents be persisted atomically together.\nHowever, MongoDB offers  multi-document transactions \nas of server version 4.0 which provide atomic persistence across multiple\ndocuments. Use the  reload  method to fetch the most recent version of a document from\nthe database. Any unsaved modifications to the document's attributes are lost: When a document is reloaded, all of its embedded associations are also reloaded\nin the same query (since embedded documents are stored in the parent document\non the server). If a document has referenced associations, the loaded\nassociations' are not reloaded but their values are cleared, such that these\nassociations would be loaded from the database at the next access. If the model has a  shard key  defined, the shard key value\nis included in the reloading query. If the database does not contain a matching document, Mongoid normally raises\n Mongoid::Errors::DocumentNotFound . However, if the configuration option\n raise_not_found_error  is set to  false , and the database does not\ncontain a matching document, Mongoid replaces the current document with a newly\ncreated document whose attributes are set to default values. Importantly, this\ngenerally causes the  _id  of the document to change, as the following\nexample demonstrates: For this reason, it is not recommended to use  reload  when\n raise_not_found_error  is set to  false . Some operations on associations, for example assignment, persists the new\ndocument. In these cases there may not be any unsaved modifications to\nrevert by reloading. In the following example, the assignment of the\nempty array to the association is immediately persisted and reloading\ndoes not make any changes to the document: reload  can be called when the document has not yet been persisted.\nIn this case  reload  performs a  find  query using the  id  value\nspecified in the document (and the shard key value, if a shard key is defined): Mongoid provides several ways of accessing field values. All of the access methods described below raise\n ActiveModel::MissingAttributeError  when the field being accessed is\n projected out , either by virtue of not being included in\n only  or by virtue of being included in\n without . This applies to both reads and writes. The recommended way is to use the getter and setter methods generated for\neach declared field: To use this mechanism, each field must be explicitly declared, or the\nmodel class must enable  dynamic fields . It is possible to explicitly define the getter and setter methods to provide\ncustom behavior when reading or writing fields, for example value\ntransformations or storing values under different field names. In this case\n read_attribute  and  write_attribute  methods can be used to read and\nwrite the values directly into the attributes hash: The custom setters are called during the assignment of\n nested attributes , however they are called before\nthe associations are set up. Because of this, associations may not always\nbe available during these methods, and it is encouraged to include checks\nfor their presence whenever referring to them.  Callbacks \ncan also be used to perform operations on certain events, and associations\nwill have already been setup and are available during their execution. The  read_attribute  and  write_attribute  methods can be used explicitly\nas well. Note that if a field specifies its  storage field name , both  read_attribute  and  write_attribute \naccept either the declared field name or the storage field name for operations: read_attribute  and  write_attribute  do not require that a field with\nthe used name is defined, but writing field values with  write_attribute \ndoes not cause the respective field to be defined either: When  read_attribute  is used to access a missing field, it returns  nil . Mongoid model instances define the  []  and  []=  methods to provide\n Hash  style access to the attributes.  []  is an alias for\n read_attribute  and  []=  is an alias for  write_attribute ; see\nthe section on  read_attribute and write_attribute \nfor the detailed description of their behavior. In cases where you want to set multiple field values at once, there are a few\ndifferent ways of accomplishing this as well. Mongoid supports tracking of changed or \"dirty\" fields with an API that mirrors that of\nActive Model. If a defined field has been modified in a model the model will be marked as\ndirty and some additional behavior comes into play. There are various ways to view what has been altered on a model. Changes are recorded\nfrom the time a document is instantiated, either as a new document or via loading from\nthe database up to the time it is saved. Any persistence operation clears the changes. Setting the associations on a document does not cause the  changes  or\n changed_attributes  hashes to be modified. This is true for all associations\nwhether referenced or embedded. Note that changing the _id(s) field on\nreferenced associations does cause the changes to show up in the  changes \nand the  changed_attributes  hashes. You can reset changes of a field to its previous value by calling the reset method. Mongoid uses dirty tracking as the core of its persistence operations. It looks at the\nchanges on a document and atomically updates only what has changed, unlike other frameworks\nthat write the entire document on each save. If no changes have been made, Mongoid will\nnot hit the database on a call to  Model#save . After a document has been persisted, you can see what the changes were previously by\ncalling  Model#previous_changes . Be aware that, until\n MONGOID-2951 \nis resolved, all fields including container ones must be assigned to for\ntheir values to be persisted to the database. For example, adding to a set like this does not work: Instead, the field value must be modified outside of the model and assigned\nback to the model as follows: Documents can be marked read-only in two ways, depending on the value of the\n Mongoid.legacy_readonly  feature flag: If this flag is turned off, a document is marked read-only when the  #readonly! \nmethod is called on that documnet. A read-only document, with this flag turned off,\nwill raise a ReadonlyDocument error on attempting to perform any persistence\noperation, including (but not limited to) saving, updating, deleting and\ndestroying. Note that reloading does not reset the read-only state. If this flag is turned on, a document is marked read-only when that document\nhas been projected (i.e. using  #only  or  #without ). A read-only document,\nwith this flag turned on, will not be deletable or destroyable (a\n ReadonlyDocument  error will be raised), but will be saveable and updatable.\nThe read-only status is reset on reloading the document. Another way to make a document read-only is by overriding the readonly? method:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "person = Person.new(first_name: \"Heinrich\", last_name: \"Heine\")\n\nperson.attributes\n# => { \"_id\" => BSON::ObjectId('633467d03282a43784c2d56e'), \"first_name\" => \"Heinrich\", \"last_name\" => \"Heine\" }"
                },
                {
                    "lang": "ruby",
                    "value": "Person.create!(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n) # => Person instance\n\nPerson.create!([\n  { first_name: \"Heinrich\", last_name: \"Heine\" },\n  { first_name: \"Willy\", last_name: \"Brandt\" }\n]) # => Array of two Person instances\n\nPerson.create!(first_name: \"Heinrich\") do |doc|\n  doc.last_name = \"Heine\"\nend # => Person instance"
                },
                {
                    "lang": "ruby",
                    "value": "Person.create(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n) # => Person instance\n\nPerson.create([\n  { first_name: \"Heinrich\", last_name: \"Heine\" },\n  { first_name: \"Willy\", last_name: \"Brandt\" }\n]) # => Array of two Person instances\n\nPerson.create(first_name: \"Heinrich\") do |doc|\n  doc.last_name = \"Heine\"\nend # => Person instance\n\nclass Post\n  include Mongoid::Document\n\n  validates_uniqueness_of :title\nend\n\nposts = Post.create([{title: \"test\"}, {title: \"test\"}])\n# => array of two Post instances\nposts.map { |post| post.persisted? } # => [true, false]"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.new(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n)\nperson.save!\n\nperson.first_name = \"Christian Johan\"\nperson.save!"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.new(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n)\nperson.save\nperson.save(validate: false)\nperson.save(touch: false)\n\nperson.first_name = \"Christian Johan\"\nperson.save"
                },
                {
                    "lang": "ruby",
                    "value": "person.update_attributes(\n  first_name: \"Jean\",\n  last_name: \"Zorg\"\n)"
                },
                {
                    "lang": "ruby",
                    "value": "person.update_attributes!(\n  first_name: \"Leo\",\n  last_name: \"Tolstoy\"\n)"
                },
                {
                    "lang": "ruby",
                    "value": "person.update_attribute(:first_name, \"Jean\")"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.new(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n)\nperson.upsert\nperson.upsert(replace: false)"
                },
                {
                    "lang": "ruby",
                    "value": "person.touch\nperson.touch(:audited_at)"
                },
                {
                    "lang": "ruby",
                    "value": "person.delete\n\nperson = Person.create!(...)\nunsaved_person = Person.new(id: person.id)\nunsaved_person.delete\nperson.reload\n# raises Mongoid::Errors::DocumentNotFound because the person was deleted"
                },
                {
                    "lang": "ruby",
                    "value": "person.destroy\n\nperson = Person.create!(...)\nunsaved_person = Person.new(id: person.id)\nunsaved_person.destroy\nperson.reload\n# raises Mongoid::Errors::DocumentNotFound because the person was deleted"
                },
                {
                    "lang": "ruby",
                    "value": "Person.delete_all"
                },
                {
                    "lang": "ruby",
                    "value": "Person.destroy_all"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.new(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n)\nperson.new_record? # => true\nperson.save!\nperson.new_record? # => false"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.new(\n  first_name: \"Heinrich\",\n  last_name: \"Heine\"\n)\nperson.persisted? # => false\nperson.save!\nperson.persisted? # => true"
                },
                {
                    "lang": "ruby",
                    "value": "person.add_to_set(aliases: \"Bond\")"
                },
                {
                    "lang": "ruby",
                    "value": "person.bit(age: { and: 10, or: 12 })"
                },
                {
                    "lang": "ruby",
                    "value": "person.inc(age: 1)"
                },
                {
                    "lang": "ruby",
                    "value": "person.pop(aliases: 1)"
                },
                {
                    "lang": "ruby",
                    "value": "person.pull(aliases: \"Bond\")"
                },
                {
                    "lang": "ruby",
                    "value": "person.pull_all(aliases: [ \"Bond\", \"James\" ])"
                },
                {
                    "lang": "ruby",
                    "value": "person.push(aliases: [\"007\",\"008\"])"
                },
                {
                    "lang": "ruby",
                    "value": "person.rename(bday: :dob)"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.create!(name: \"Ricky Bobby\")\nperson.set(name: \"Tyler Durden\") # updates name in the database\n\n\nperson = Person.new\nperson.set(name: \"Tyler Durden\") # does not write to database\nperson.name # => \"Tyler Durden\"\nperson.persisted? # => true\n\n\nclass Post\n  include Mongoid::Document\n\n  field :metadata, type: Hash\nend\n\npost = Post.create!\npost.set('metadata.published_at' => Time.now)\npost.metadata['published_at'] # => Time instance\n\npost.set('metadata.approved.today' => true)\npost.metadata['approved'] # => {'today' => true}\n\n\nclass Flight\n  include Mongoid::Document\n\n  embeds_one :plan\nend\n\nclass Plan\n  include Mongoid::Document\n\n  embedded_in :flight\n\n  field :route, type: String\nend\n\nflight = Flight.create!\nflight.plan # => nil\nflight.set('plan.route', 'test route')\nflight.plan # => Plan instance\nflight.plan.route # => \"test route\""
                },
                {
                    "lang": "ruby",
                    "value": "person.unset(:name)"
                },
                {
                    "lang": "ruby",
                    "value": "person.atomically do\n  person.inc(age: 1)\n  person.set(name: 'Jake')\nend"
                },
                {
                    "lang": "ruby",
                    "value": "person.atomically do\n  person.atomically do\n    person.inc(age: 1)\n    person.set(name: 'Jake')\n  end\n  raise 'An exception'\n  # name and age changes are still persisted\nend"
                },
                {
                    "lang": "ruby",
                    "value": "person.atomically do\n  person.atomically(join_context: true) do\n    person.inc(age: 1)\n    person.set(name: 'Jake')\n  end\n  raise 'An exception'\n  # name and age changes are not persisted\nend"
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.new(name: 'Tom')\nbegin\n  person.atomically do\n    person.inc(age: 1)\n    person.set(name: 'Jake')\n    person.name # => 'Jake'\n    raise 'An exception'\n  end\nrescue Exception\n  person.name # => 'Tom'\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!(name: 'foo')\n# => #<Band _id: 6206d06de1b8324561f179c9, name: \"foo\", description: nil, likes: nil>\n\nband.name = 'bar'\nband\n# => #<Band _id: 6206d06de1b8324561f179c9, name: \"bar\", description: nil, likes: nil>\n\nband.reload\n# => #<Band _id: 6206d06de1b8324561f179c9, name: \"foo\", description: nil, likes: nil>"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!\n# => #<Band _id: 6206d00de1b8324561f179c7, name: \"foo\", description: nil, likes: nil>\n\nMongoid.raise_not_found_error = false\nband.destroy\n\nband.reload\n# => #<Band _id: 6206d031e1b8324561f179c8, name: nil, description: nil, likes: nil>"
                },
                {
                    "lang": "ruby",
                    "value": "# Assuming band has many tours, which could be referenced:\nband = Band.create!(tours: [Tour.create!])\n# ... or embedded:\nband = Band.create!(tours: [Tour.new])\n\n# This writes the empty tour list into the database.\nband.tours = []\n\n# There are no unsaved modifications in band at this point to be reverted.\nband.reload\n\n# Returns the empty array since this is what is in the database.\nband.tours\n# => []"
                },
                {
                    "lang": "ruby",
                    "value": "existing = Band.create!(name: 'Photek')\n\n# Unsaved document\nband = Band.new(id: existing.id)\nband.reload\nband.name\n# => \"Photek\""
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :first_name\nend\n\nperson = Person.new\n\nperson.first_name = \"Artem\"\nperson.first_name\n# => \"Artem\""
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  def first_name\n    read_attribute(:fn)\n  end\n\n  def first_name=(value)\n    write_attribute(:fn, value)\n  end\nend\n\nperson = Person.new\n\nperson.first_name = \"Artem\"\nperson.first_name\n# => \"Artem\"\n\nperson.attributes\n# => {\"_id\"=>BSON::ObjectId('606477dc2c97a628cf47075b'), \"fn\"=>\"Artem\"}"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :first_name, as: :fn\n  field :last_name, as: :ln\nend\n\nperson = Person.new(first_name: \"Artem\")\n# => #<Person _id: 60647a522c97a6292c195b4b, first_name(fn): \"Artem\", last_name(ln): nil>\n\nperson.read_attribute(:first_name)\n# => \"Artem\"\n\nperson.read_attribute(:fn)\n# => \"Artem\"\n\nperson.write_attribute(:last_name, \"Pushkin\")\nperson\n# => #<Person _id: 60647a522c97a6292c195b4b, first_name(fn): \"Artem\", last_name(ln): \"Pushkin\">\n\nperson.write_attribute(:ln, \"Medvedev\")\nperson\n# => #<Person _id: 60647a522c97a6292c195b4b, first_name(fn): \"Artem\", last_name(ln): \"Medvedev\">"
                },
                {
                    "lang": "ruby",
                    "value": "person.write_attribute(:undefined, \"Hello\")\nperson\n# => #<Person _id: 60647b212c97a6292c195b4c, first_name(fn): \"Artem\", last_name(ln): \"Medvedev\">\nperson.attributes\n# => {\"_id\"=>BSON::ObjectId('60647b212c97a6292c195b4c'), \"first_name\"=>\"Artem\", \"last_name\"=>\"Medvedev\", \"undefined\"=>\"Hello\"}\n\nperson.read_attribute(:undefined)\n# => \"Hello\"\nperson.undefined\n# raises NoMethodError"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :first_name, as: :fn\n  field :last_name, as: :ln\nend\n\nperson = Person.new(first_name: \"Artem\")\n\nperson[\"fn\"]\n# => \"Artem\"\n\nperson[:first_name]\n# => \"Artem\"\n\nperson[:ln] = \"Medvedev\"\nperson\n# => #<Person _id: 606483742c97a629bdde5cfc, first_name(fn): \"Artem\", last_name(ln): \"Medvedev\">\n\nperson[\"last_name\"] = \"Pushkin\"\nperson\n# => #<Person _id: 606483742c97a629bdde5cfc, first_name(fn): \"Artem\", last_name(ln): \"Pushkin\">"
                },
                {
                    "lang": "ruby",
                    "value": "# Get the field values as a hash.\nperson.attributes\n\n# Set the field values in the document.\nPerson.new(first_name: \"Jean-Baptiste\", middle_name: \"Emmanuel\")\nperson.attributes = { first_name: \"Jean-Baptiste\", middle_name: \"Emmanuel\" }\nperson.write_attributes(\n  first_name: \"Jean-Baptiste\",\n  middle_name: \"Emmanuel\",\n)"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :name, type: String\nend\n\nperson = Person.first\nperson.name = \"Alan Garner\"\n\n# Check to see if the document has changed.\nperson.changed? # true\n\n# Get an array of the names of the changed fields.\nperson.changed # [ :name ]\n\n# Get a hash of the old and changed values for each field.\nperson.changes # { \"name\" => [ \"Alan Parsons\", \"Alan Garner\" ] }\n\n# Check if a specific field has changed.\nperson.name_changed? # true\n\n# Get the changes for a specific field.\nperson.name_change # [ \"Alan Parsons\", \"Alan Garner\" ]\n\n# Get the previous value for a field.\nperson.name_was # \"Alan Parsons\""
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.first\nperson.name = \"Alan Garner\"\n\n# Reset the changed name back to the original\nperson.reset_name!\nperson.name # \"Alan Parsons\""
                },
                {
                    "lang": "ruby",
                    "value": "person = Person.first\nperson.name = \"Alan Garner\"\nperson.save # Clears out current changes.\n\n# View the previous changes.\nperson.previous_changes # { \"name\" => [ \"Alan Parsons\", \"Alan Garner\" ] }"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :tours, type: Set\nend\n\nband = Band.new\nband.tours\n# => #<Set: {}>\n\nband.tours << 'London'\n# => #<Set: {\"London\"}>\nband.tours\n# => #<Set: {}>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :tours, type: Set\nend\n\nband = Band.new\n\ntours = band.tours\n# => #<Set: {}>\n\ntours << 'London'\n# => #<Set: {\"London\"}>\n\nband.tours = tours\n# => #<Set: {\"London\"}>\n\nband.tours\n# => #<Set: {\"London\"}>"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.first\nband.readonly? # => false\nband.readonly!\nband.readonly? # => true\nband.name = \"The Rolling Stones\"\nband.save # => raises ReadonlyDocument error\nband.reload.readonly? # => true"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :genre, type: String\nend\n\nband = Band.only(:name).first\nband.readonly? # => true\nband.destroy # => raises ReadonlyDocument error\nband.reload.readonly? # => false"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :genre, type: String\n\n  def readonly?\n    true\n  end\nend\n\nband = Band.first\nband.readonly? # => true\nband.destroy # => raises ReadonlyDocument error"
                }
            ],
            "preview": "Mongoid supports all expected CRUD operations for those familiar with other\nRuby mappers like Active Record or Data Mapper. What distinguishes Mongoid\nfrom other mappers for MongoDB is that the general persistence operations\nperform atomic updates on only the fields that have changed instead of\nwriting the entire document to the database each time.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/callbacks",
            "title": "Callbacks",
            "headings": [
                "Document Callbacks",
                "Association Callbacks"
            ],
            "paragraphs": "Mongoid implements many of the  ActiveRecord callbacks . Mongoid supports the following callbacks for  documents : Callbacks are available on any document, whether it is embedded within\nanother document or not. Note that to be efficient, Mongoid only invokes\nthe callback on the document that the persistence action was executed on.\nThis enables Mongoid to support large hierarchies and to handle optimized\natomic updates efficiently (without invoking callbacks throughout the document\nhierarchy). Note that using callbacks for domain logic is a bad design practice, and can\nlead to unexpected errors that are hard to debug when callbacks in\nthe chain halt execution. It is our recommendation to only use them\nfor cross-cutting concerns, like queueing up background jobs. Callbacks are coming from Active Support, so you can use the new\nsyntax as well: after_initialize after_build before_validation after_validation before_create around_create after_create after_find before_update around_update after_update before_upsert around_upsert after_upsert before_save around_save after_save before_destroy around_destroy after_destroy Mongoid has a set of callbacks that are specific to associations - these are: Each time a document is added or removed from any of the following\nassociations, the respective callbacks are invoked:  embeds_many ,\n has_many  and  has_and_belongs_to_many . Association callbacks are specified as options on the respective association.\nThe document added/removed will be passed as the parameter to the specified\ncallback. Example: after_add after_remove before_add before_remove",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Article\n  include Mongoid::Document\n  field :name, type: String\n  field :body, type: String\n  field :slug, type: String\n\n  before_create :send_message\n\n  after_save do |document|\n    # Handle callback here.\n  end\n\n  protected\n  def send_message\n    # Message sending code here.\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Article\n  include Mongoid::Document\n  field :name, type: String\n\n  set_callback(:create, :before) do |document|\n    # Message sending code here.\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  has_many :posts, after_add: :send_email_to_subscribers\nend\n\ndef send_email_to_subscribers(post)\n  Notifications.new_post(post).deliver\nend"
                }
            ],
            "preview": "Mongoid implements many of the ActiveRecord callbacks.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/text-search",
            "title": "Text Search",
            "headings": [
                "Defining Text Search Index",
                "Creating Text Index",
                "Querying Using Text Index"
            ],
            "paragraphs": "MongoDB provides  text indexes \nto support text search queries on string content. Text indexes\ncan include any field whose value is a string or an array of\nstring elements. To perform text search with Mongoid, follow these steps: MongoDB Atlas also provides\n Atlas Search \nwhich is a more powerful and flexible text search solution.\nThe rest of this section discusses text indexes and not Atlas Search. Define a text index on a model. Create the text index on the server. Build a text search query. Index definition through Mongoid is described in detail on the  indexes  page. Text search indexes are described in detail\nunder  text indexes \nin the MongoDB manual. Below is an example definition of a Band model with\na text index utilizing the description field: Note that the index type ( text ) must be given as a string, not as a symbol. To create the index, invoke the  db:mongoid:create_indexes  Rake task: To find bands whose description contains \"ounces\" or its variations, use the\n $text operator : Note that the description contains the word \"ounce\" even though the search\nquery was \"ounces\". Note also that when performing text search, the name of the field is not\nexplicitly specified -  $text  operator searches all fields indexed with\nthe text index.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  field :description, type: String\n\n  index description: 'text'\nend"
                },
                {
                    "lang": "ruby",
                    "value": "bundle exec rake db:mongoid:create_indexes"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where('$text' => {'$search' => 'ounces'}).to_a\n# => [#<Band _id: 5d5341b3ce4ef35d5016746d, name: \"foo\", description: \"ounce\">]"
                }
            ],
            "preview": "MongoDB provides text indexes\nto support text search queries on string content. Text indexes\ncan include any field whose value is a string or an array of\nstring elements.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/sessions",
            "title": "Sessions",
            "headings": [
                "Using a Session via Model#with_session",
                "Using a Session via model#with_session"
            ],
            "paragraphs": "Versions 3.6 and higher of the MongoDB server support sessions. You can use sessions with Mongoid in a similar way\nthat you would execute a transaction in ActiveRecord. Namely, you can call a method,  #with_session  on a model class\nor on an instance of a model and execute some operations in a block. All operations in the block will be\nexecuted in the context of single session. Please see the MongoDB Ruby driver documentation for what session options\nare available. Please note the following limitations of sessions: Sessions cannot be shared across threads; sessions are not thread-safe. This is consistent with the Ruby driver's support for sessions. Sessions cannot be nested. You cannot called  #with_session  on a model class or a model instance within the block passed to the  #with_session  method on another model class or model instance. All model classes and instances used within the session block must use the same driver client. For example, if you have specified different  storage_options  for another model used in the block than that of the model class or instance on which  #with_session  is called, you will get an error. All connected MongoDB servers must be version 3.6 or higher. Call  #with_session  on a model class and pass it session options to execute a block in the context\nof a session. Call  #with_session  on a model instance and pass it session options to execute a block in the context\nof a session.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "Person.with_session(causal_consistency: true) do\n  Person.create!\n  person = Person.first\n  person.name = \"Emily\"\n  person.save\nend"
                },
                {
                    "lang": "ruby",
                    "value": "person.with_session(causal_consistency: true) do\n  person.username = 'Emily'\n  person.save\n  person.posts << Post.create!\nend"
                }
            ],
            "preview": "Versions 3.6 and higher of the MongoDB server support sessions. You can use sessions with Mongoid in a similar way\nthat you would execute a transaction in ActiveRecord. Namely, you can call a method, #with_session on a model class\nor on an instance of a model and execute some operations in a block. All operations in the block will be\nexecuted in the context of single session. Please see the MongoDB Ruby driver documentation for what session options\nare available.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/fields",
            "title": "Field Definition",
            "headings": [
                "Field Types",
                "Omitting Field Type Definition",
                "Field Type: StringifiedSymbol",
                "Field Type: Symbol",
                "Field Type: Hash",
                "Field Type: Time",
                "Field Type: Date",
                "Field Type: DateTime",
                "Field Type: Regexp",
                "BigDecimal Fields",
                "Migration to decimal128-backed BigDecimal Field",
                "Using Symbols Or Strings Instead Of Classes",
                "Specifying Field Default Values",
                "Specifying Storage Field Names",
                "Field Aliases",
                "Unaliasing id",
                "Reserved Names",
                "Field Redefinition",
                "Custom IDs",
                "Uncastable Values",
                "Assigning Uncastable Values",
                "Reading Uncastable Values",
                "Customizing Field Behavior",
                "Custom Getters And Setters",
                "Custom Field Types",
                "Phantom Custom Field Types",
                "Custom Field Options",
                "Dynamic Fields",
                "Special Characters in Field Names",
                "Localized Fields",
                "Localize :present Field Option",
                "Fallbacks",
                "Querying",
                "Indexing",
                "Read-Only Attributes",
                "Timestamp Fields",
                "Field Names with Dots/Periods (.) and Dollar Signs ($)"
            ],
            "paragraphs": "MongoDB stores underlying document data using\n BSON types , and\nMongoid converts BSON types to Ruby types at runtime in your application.\nFor example, a field defined with  type: :float  will use the Ruby  Float \nclass in-memory and will persist in the database as the the BSON  double  type. Field type definitions determine how Mongoid behaves when constructing queries\nand retrieving/writing fields from/to the database. Specifically: 1. When assigning values to fields at runtime, the values are converted to the\nspecified type. 2. When persisting data to MongoDB, the data is sent in an appropriate\ntype, permitting richer data manipulation within MongoDB or by other\ntools. 3. When querying documents, query parameters are converted to the specified\ntype before being sent to MongoDB. 4. When retrieving documents from the database, field values are converted\nto the specified type. Changing the field definitions in a model class does not alter data already stored in\nMongoDB. To update type or contents of fields of existing documents,\nthe field must be re-saved to the database. Note that, due to Mongoid\ntracking which attributes on a model change and only saving the changed ones,\nit may be necessary to explicitly write a field value when changing the\ntype of an existing field without changing the stored values. Consider a simple class for modeling a person in an application. A person may\nhave a name, date_of_birth, and weight. We can define these attributes\non a person by using the  field  macro. The valid types for fields are as follows: Mongoid also recognizes the string  \"Boolean\"  as an alias for the\n Mongoid::Boolean  class. To define custom field types, refer to  Custom Field Types  below. Array BigDecimal Mongoid::Boolean , which may be specified simply as  Boolean  in the\nscope of a class which included  Mongoid::Document . Date DateTime Float Hash Integer BSON::ObjectId BSON::Binary Range Regexp Set String Mongoid::StringifiedSymbol , which may be specified simply as\n StringifiedSymbol  in the scope of a class which included\n Mongoid::Document . Symbol Time ActiveSupport::TimeWithZone Using the  BSON::Int64  and  BSON::Int32  types as field types is unsupported.\nSaving these types to the database will work as expected, however, querying them\nwill return the native Ruby  Integer  type. Querying fields of type\n BSON::Decimal128  will return values of type  BSON::Decimal128  in\nBSON <=4 and values of type  BigDecimal  in BSON 5+. If you decide not to specify the type of field with the definition, Mongoid will treat\nit as an object and not try to typecast it when sending the values to the database.\nThis can be advantageous as the lack of attempted conversion will yield a slight\nperformance gain. However some types are not supported if not defined as fields.\nYou can safely omit type specifications when: Types that are not supported as dynamic attributes since they cannot be cast are: You're not using a web front end and values are already properly cast. All of your fields are strings. Date DateTime Range The  StringifiedSymbol  field type is the recommended field type for storing\nvalues that should be exposed as symbols to Ruby applications. When using the  Symbol  field type,\nMongoid defaults to storing values as BSON symbols. For more information on the\nBSON symbol type, see  here .\nHowever, the BSON symbol type is deprecated and is difficult to work with in programming languages\nwithout native symbol types, so the  StringifiedSymbol  type allows the use of symbols\nwhile ensuring interoperability with other drivers. The  StringifiedSymbol  type stores all data\non the database as strings, while exposing values to the application as symbols. An example usage is shown below: All non-string values will be stringified upon being sent to the database (via  to_s ), and\nall values will be converted to symbols when returned to the application. Values that cannot be\nconverted directly to symbols, such as integers and arrays, will first be converted to strings and\nthen symbols before being returned to the application. For example, setting an integer as  status : If the  StringifiedSymbol  type is applied to a field that contains BSON symbols, the values\nwill be stored as strings instead of BSON symbols on the next save. This permits transparent lazy\nmigration from fields that currently store either strings or BSON symbols in the database to the\n StringifiedSymbol  field type. New applications should use the  StringifiedSymbol field type \nto store Ruby symbols in the database. The  StringifiedSymbol  field type\nprovides maximum compatibility with other applications and programming languages\nand has the same behavior in all circumstances. Mongoid also provides the deprecated  Symbol  field type for serializing\nRuby symbols to BSON symbols. Because the BSON specification deprecated the\nBSON symbol type, the  bson  gem will serialize Ruby symbols into BSON strings\nwhen used on its own. However, in order to maintain backwards compatibility\nwith older datasets, the  mongo  gem overrides this behavior to serialize Ruby\nsymbols as BSON symbols. This is necessary to be able to specify queries for\ndocuments which contain BSON symbols as fields. To override the default behavior and configure the  mongo  gem (and thereby\nMongoid as well) to encode symbol values as strings, include the following code\nsnippet in your project: When using a field of type Hash, be wary of adhering to the\n legal key names for mongoDB ,\nor else the values will not store properly. Time  fields store values as  Time  instances in the  configured\ntime zone . Date  and  DateTime  instances are converted to  Time  instances upon\nassignment to a  Time  field: In the above example, the value was interpreted as the beginning of today in\nlocal time, because the application was not configured to use UTC times. When the database contains a string value for a  Time  field, Mongoid\nparses the string value using  Time.parse  which considers values without\ntime zones to be in local time. Mongoid allows assignment of values of several types to  Date  fields: In other words, if a date is specified in the value, that date is used without\nfirst converting the value to the configured time zone. As a date & time to date conversion is lossy (it discards the time component),\nespecially if an application operates with times in different time zones it is\nrecommended to explicitly convert  String ,  Time  and  DateTime \nobjects to  Date  objects before assigning the values to fields of type\n Date . Date  - the provided date is stored as is. Time ,  DateTime ,  ActiveSupport::TimeWithZone  - the date component\nof the value is taken in the value's time zone. String  - the date specified in the string is used. Integer ,  Float  - the value is taken to be a UTC timestamp which is\nconverted to the  configured time zone  (note that\n Mongoid.use_utc  has no effect on this conversion), then the date is\ntaken from the resulting time. When the database contains a string value for a  Date  field, Mongoid\nparses the string value using  Time.parse , discards the time portion of\nthe resulting  Time  object and uses the date portion.  Time.parse \nconsiders values without time zones to be in local time. MongoDB stores all times as UTC timestamps. When assigning a value to a\n DateTime  field, or when querying a  DateTime  field, Mongoid\nconverts the passed in value to a UTC  Time  before sending it to the\nMongoDB server. Time ,  ActiveSupport::TimeWithZone  and  DateTime  objects embed\ntime zone information, and the value persisted is the specified moment in\ntime, in UTC. When the value is retrieved, the time zone in which it is\nreturned is defined by the  configured time zone settings . Mongoid also supports casting integers and floats to  DateTime . When\ndoing so, the integers/floats are assumed to be Unix timestamps (in UTC): If a string is used as a  DateTime  field value, the behavior depends on\nwhether the string includes a time zone. If no time zone is specified,\nthe  default Mongoid time zone  is used: If a time zone is specified, it is respected: When the database contains a string value for a  DateTime  field, Mongoid\nparses the string value using  Time.parse  which considers values without\ntime zones to be in local time. MongoDB supports storing regular expressions in documents, and querying using\nregular expressions. Note that MongoDB uses\n Perl-compatible regular expressions (PCRE) \nand Ruby uses  Onigmo , which is a\nfork of  Oniguruma regular expression engine .\nThe two regular expression implementations generally provide equivalent\nfunctionality but have several important syntax differences. When a field is declared to be of type Regexp, Mongoid converts Ruby regular\nexpressions to BSON regular expressions and stores the result in MongoDB.\nRetrieving the field from the database produces a  BSON::Regexp::Raw \ninstance: Use  #compile  method on  BSON::Regexp::Raw  to get back the Ruby regular\nexpression: Note that, if the regular expression was not originally a Ruby one, calling\n #compile  on it may produce a different regular expression. For example,\nthe following is a PCRE matching a string that ends in \"hello\": Compiling this regular expression produces a Ruby regular expression that\nmatches strings containing \"hello\" before a newline, besides strings ending in\n\"hello\": This is because the meaning of  $  is different between PCRE and Ruby\nregular expressions. The  BigDecimal  field type is used to store numbers with increased precision. The  BigDecimal  field type stores its values in two different ways in the\ndatabase, depending on the value of the  Mongoid.map_big_decimal_to_decimal128 \nglobal config option. If this flag is set to false (which is the default),\nthe  BigDecimal  field will be stored as a string, otherwise it will be stored\nas a  BSON::Decimal128 . The  BigDecimal  field type has some limitations when converting to and from\na  BSON::Decimal128 : There is an additional caveat when storing a  BigDecimal  in a field with no\ntype (i.e. a dynamically typed field) and  Mongoid.map_big_decimal_to_decimal128 \nis  false . In this case, the  BigDecimal  is stored as a string, and since a\ndynamic field is being used, querying for that field with a  BigDecimal  will\nnot find the string for that  BigDecimal , since the query is looking for a\n BigDecimal . In order to query for that string, the  BigDecimal  must\nfirst be converted to a string with  to_s . Note that this is not a problem\nwhen the field has type  BigDecimal . If you wish to avoid using  BigDecimal  altogether, you can set the field\ntype to  BSON::Decimal128 . This will allow you to keep track of trailing\nzeroes and signed  NaN  values. BSON::Decimal128  has a limited range and precision, while  BigDecimal \nhas no restrictions in terms of range and precision.  BSON::Decimal128  has\na max value of approximately  10^6145  and a min value of approximately\n -10^6145 , and has a maximum of 34 bits of precision. When attempting to\nstore values that don't fit into a  BSON::Decimal128 , it is recommended to\nhave them stored as a string instead of a  BSON::Decimal128 . You can do\nthat by setting  Mongoid.map_big_decimal_to_decimal128  to  false . If a\nvalue that does not fit in a  BSON::Decimal128  is attempted to be stored\nas one, an error will be raised. BSON::Decimal128  is able to accept signed  NaN  values, while\n BigDecimal  is not. When retrieving signed  NaN  values from\nthe database using the  BigDecimal  field type, the  NaN  will be\nunsigned. BSON::Decimal128  maintains trailing zeroes when stored in the database.\n BigDecimal , however, does not maintain trailing zeroes, and therefore\nretrieving  BSON::Decimal128  values using the  BigDecimal  field type\nmay result in a loss of precision. In a future major version of Mongoid, the  Mongoid.map_big_decimal_to_decimal128 \nglobal config option will be defaulted to  true . When this flag is turned on,\n BigDecimal  values in queries will not match to the strings that are already\nstored in the database; they will only match to  decimal128  values that are\nin the database. If you have a  BigDecimal  field that is backed by strings,\nyou have three options: The  Mongoid.map_big_decimal_to_decimal128  global config option can be\nset to  false , and you can continue storing your  BigDecimal  values as\nstrings. Note that you are surrendering the advantages of storing  BigDecimal \nvalues as a  decimal128 , like being able to do queries and aggregations\nbased on the numerical value of the field. The  Mongoid.map_big_decimal_to_decimal128  global config option can be\nset to  true , and you can convert all values for that field from strings to\n decimal128  values in the database. You should do this conversion before\nsetting the global config option to true. An example query to accomplish this\nis as follows: This query updates all documents that have the given field, setting that\nfield to its corresponding  decimal128  value. Note that this query only\nworks in MongoDB 4.2+. The  Mongoid.map_big_decimal_to_decimal128  global config option can be\nset to  true , and you can have both strings and  decimal128  values for\nthat field. This way, only  decimal128  values will be inserted into and\nupdated to the database going forward. Note that you still don't get the\nfull advantages of using only  decimal128  values, but your dataset is\nslowly migrating to all  decimal128  values, as old string values are\nupdated to  decimal128  and new  decimal128  values are added. With this\nsetup, you can still query for  BigDecimal  values as follows: This query will find all values that are either a  decimal128  value or\na string that match that value. Mongoid permits using symbols or strings instead of classes to specify the\ntype of fields, for example: Only standard field types as listed below can be specified using symbols or\nstrings in this manner. Mongoid recognizes the following expansions: :array  =>  Array :big_decimal  =>  BigDecimal :binary  =>  BSON::Binary :boolean  =>  Mongoid::Boolean :date  =>  Date :date_time  =>  DateTime :float  =>  Float :hash  =>  Hash :integer  =>  Integer :object_id  =>  BSON::ObjectId :range  =>  Range :regexp  =>  Regexp :set  =>  Set :string  =>  String :stringified_symbol  =>  StringifiedSymbol :symbol  =>  Symbol :time  =>  Time A field can be configured to have a default value. The default value can be\nfixed, as in the following example: The default value can also be specified as a  Proc : To set a default which depends on the document's state, use  self \ninside the  Proc  instance which would evaluate to the document instance\nbeing operated on: When defining a default value as a  Proc , Mongoid will apply the default\nafter all other attributes are set and associations are initialized.\nTo have the default be applied before the other attributes are set,\nuse the  pre_processed: true  field option: The  pre_processed: true  option is also necessary when specifying a custom\ndefault value via a  Proc  for the  _id  field, to ensure the  _id \nis set correctly via associations: Default values that are not  Proc  instances are evaluated at class load\ntime, meaning the following two definitions are not equivalent: The second definition is most likely the desired one, which causes the\ntime of submission to be set to the current time at the moment of\ndocument instantiation. One of the drawbacks of having a schemaless database is that MongoDB must\nstore all field information along with every document, meaning that it\ntakes up a lot of storage space in RAM and on disk. A common pattern to limit\nthis is to alias fields to a small number of characters, while keeping the\ndomain in the application expressive. Mongoid allows you to do this and\nreference the fields in the domain via their long names in getters, setters,\nand criteria while performing the conversion for you. It is possible to define field aliases. The value will be stored in the\ndestination field but can be accessed from either the destination field or\nfrom the aliased field: Aliases can be removed from model classes using the  unalias_attribute \nmethod. unalias_attribute  can be used to remove the predefined  id  alias.\nThis is useful for storing different values in  id  and  _id  fields: Attempting to define a field on a document that conflicts with a reserved\nmethod name in Mongoid will raise an error. The list of reserved names can\nbe obtained by invoking the  Mongoid.destructive_fields  method. By default Mongoid allows redefining fields on a model. To raise an error\nwhen a field is redefined, set the  duplicate_fields_exception \n configuration option  to  true . With the option set to true, the following example will raise an error: To define the field anyway, use the  overwrite: true  option: By default, Mongoid defines the  _id  field on documents to contain a\n BSON::ObjectId  value which is automatically generated by Mongoid. It is possible to replace the  _id  field definition to change the type\nof the  _id  values or have different default values: It is possible to omit the default entirely: If the default on  _id  is omitted, and no  _id  value is provided by\nyour application, Mongoid will persist the document without the  _id \nvalue. In this case, if the document is a top-level document, an  _id \nvalue will be assigned by the server; if the document is an embedded document,\nno  _id  value will be assigned. Mongoid will not automatically retrieve\nthis value, if assigned, when the document is persisted - you\nmust obtain the persisted value (and the complete persisted document) using\nother means: Omitting  _id  fields is more common in  embedded documents . Mongoid also defines the  id  field aliased to  _id . The  id \nalias can  be removed  if desired (such as to integrate\nwith systems that use the  id  field to store value different from  _id . In Mongoid 8, Mongoid has standardized the treatment of the assignment and\nreading of \"uncastable\" values. A value is considered \"uncastable\" when it\ncannot be coerced to the type of its field. For example, an array would be an\n\"uncastable\" value to an Integer field. The assignment of uncastable values has been standardized to assign  nil  by\ndefault. Consider the following example: Assigning an array to a field of type Integer doesn't work since an array can't\nbe coerced to an Integer. The assignment of uncastable values to a field will\ncause a  nil  to be written: Note that the original uncastable values will be stored in the\n attributes_before_type_cast  hash with their field names: Note that for numeric fields, any class that defines  to_i  for Integer\nfields,  to_f  for Floats, and  to_d  for BigDecimals, is castable.\nStrings are the exception and will only call the corresponding  to_* \nmethod if the string is numeric. If a class only defines  to_i  and not\n to_f  and is being assigned to a Float field, this is uncastable, and Mongoid\nwill not perform a two-step conversion (i.e.  to_i  and then  to_f ). When documents in the database contain values of different types than their\nrepresenations in Mongoid, if Mongoid cannot coerce them into the correct type,\nit will replace the value with  nil . Consider the following model and document in the\ndatabase: Reading this document from the database will result in the model's name field\ncontaining  nil : The database value of type array cannot be stored in the attribute, since the\narray can't be coerced to an Integer. Note that the original uncastable values\nwill be stored in the  attributes_before_type_cast  hash with their field\nnames: The  demongoize  methods on container objects (i.e. Hash, Array) have not\nbeen changed to permit automatic persistence of mutated container attributes.\nSee  MONGOID-2951  for a\nlonger discussion of this topic. Mongoid offers several ways to customize the behavior of fields. You may override getters and setters for fields to modify the values\nwhen they are being accessed or written. The getters and setters use the\nsame name as the field. Use  read_attribute  and  write_attribute \nmethods inside the getters and setters to operate on the raw attribute\nvalues. For example, Mongoid provides the  :default  field option to write a\ndefault value into the field. If you wish to have a field default value\nin your application but do not wish to persist it, you can override the\ngetter as follows: To give another example, a field which converts empty strings to nil values\nmay be implemented as follows: You can define custom types in Mongoid and determine how they are serialized\nand deserialized. In this example, we define a new field type  Point , which we\ncan use in our model class as follows: Then make a Ruby class to represent the type. This class must define methods\nused for MongoDB serialization and deserialization as follows: The instance method  mongoize  takes an instance of your custom type object, and\nconverts it into a represenation of how it will be stored in the database, i.e. to pass\nto the MongoDB Ruby driver. In our example above, we want to store our  Point \nobject as an  Array  in the form  [ x, y ] . The class method  mongoize  is similar to the instance method, however it must handle\nobjects of all possible types as inputs. The  mongoize  method is used when calling the\nsetter methods for fields of your custom type. The class method  demongoize  does the inverse of  mongoize . It takes the raw object\nfrom the MongoDB Ruby driver and converts it to an instance of your custom type.\nIn this case, the database driver returns an  Array  and we instantiate a  Point  from it.\nThe  demongoize  method is used when calling the getters of fields for your custom type.\nNote that in the example above, since  demongoize  calls  Point.new , a new instance of\n Point  will be generated on each call to the getter. Mongoid will always call the  demongoize  method on values that were\nretrieved from the database, but applications may, in theory, call\n demongoize  with arbitrary input. It is recommended that applications add\nhandling for arbitrary input in their  demongoize  methods. We can rewrite\n Point 's demongoize method as follows: Notice that  demongoize  will only create a new  Point  if given an array\nof length 2, and will return  nil  otherwise. Both the  mongoize  and\n demongoize  methods should be prepared to receive arbitrary input and should\nreturn  nil  on values that are uncastable to your custom type. See the\nsection on  Uncastable Values  for more details. Lastly, the class method  evolve  is similar to  mongoize , however it is used\nwhen transforming objects for use in Mongoid query criteria. The  evolve  method should also be prepared to receive arbitrary input,\nhowever, unlike the  mongoize  and  demongoize  methods, it should return\nthe inputted value on values that are uncastable to your custom type. See the\nsection on  Uncastable Values  for more details. The custom field type may perform conversions from user-visible attribute\nvalues to the values stored in the database when the user-visible attribute\nvalue type is different from the declared field type. For example, this\ncan be used to implement a mapping from one enumeration to another, to\nhave more descriptive values in the application and more compact values stored\nin the database: You may define custom options for the  field  macro function\nwhich extend its behavior at the your time model classes are loaded. As an example, we will define a  :max_length  option which will add a length\nvalidator for the field. First, declare the new field option in an initializer,\nspecifiying its handler function as a block: Then, use it your model class: Note that the handler function will be invoked whenever the option is used\nin the field definition, even if the option's value is false or nil. By default, Mongoid requires all fields that may be set on a document to\nbe explicitly defined using  field  declarations. Mongoid also supports\ncreating fields on the fly from an arbitrary hash or documents stored in\nthe database. When a model uses fields not explicitly defined, such fields\nare called  dynamic fields . To enable dynamic fields, include  Mongoid::Attributes::Dynamic  module\nin the model: It is possible to use  field  declarations and dynamic fields in the same\nmodel class. Attributes for which there is a  field  declaration will be\ntreated according to the  field  declaration, with remaining attributes\nbeing treated as dynamic fields. Attribute values in the dynamic fields must initially be set by either\npassing the attribute hash to the constructor, mass assignment via\n attributes= , mass assignment via  []= , using  write_attribute ,\nor they must already be present in the database. If an attribute is not present in a particular model instance's attributes\nhash, both the reader and the writer for the corresponding field are not\ndefined, and invoking them raises  NoMethodError : Attributes can always be read using mass attribute access or  read_attribute \n(this applies to models not using dynamic fields as well): The values returned from the  read_attribute  method, and those stored in\nthe  attributes  hash, are the  mongoized  values. Mongoid permits dynamic field names to include spaces and punctuation: Mongoid supports localized fields via  i18n . By telling the field to  localize , Mongoid will under the covers store the field\nas a hash of locale/value pairs, but normal access to it will behave like a string. You can get and set all the translations at once by using the corresponding  _translations  method. Localized fields can be used with any field type. For example, they can be used\nwith float fields for differences with currency: By creating the model in this way, we can separate the price from the currency\ntype, which allows you to use all of the number-related functionalities on the\nprice when querying or aggregating that field (provided that you index into the\nstored translations hash). We can create an instance of this model as follows: Mongoid supports the  :present  option when creating a localized field: This option automatically removes  blank  values (i.e. those that return true\nfor the  blank?  method) from the  _translations  hash: When the empty string is written for the  :de  locale, the  \"de\"  key is\nremoved from the  _translations  hash instead of writing the empty string. Mongoid integrates with\n i18n fallbacks .\nTo use the fallbacks, the respective functionality must be explicitly enabled. In a Rails application, set the  config.i18n.fallbacks  configuration setting\nto  true  in your environment and specify the fallback languages: In a non-Rails application, include the fallbacks module into the I18n backend\nyou are using and specify the fallback languages: When fallbacks are enabled, if a translation is not present in the active\nlanguage, translations will be looked up in the fallback languages: Mongoid also defines a  :fallbacks  option on fields, which can be used to\ndisable fallback functionality on a specific field: Note that this option defaults to  true . In i18n 1.1, the behavior of fallbacks  changed \nto always require an explicit list of fallback locales rather than falling\nback to the default locale when no fallback locales have been provided. When querying for localized fields using Mongoid's criteria API, Mongoid will automatically\nalter the criteria to match the current locale. If you plan to be querying extensively on localized fields, you should index each of the\nlocales that you plan on searching on. You can tell Mongoid that certain attributes are read-only. This will allow\ndocuments to be created with these attributes, but changes to them will be\nignored when using mass update methods such as  update_attributes : If you explicitly try to update or remove a read-only attribute by itself,\na  ReadonlyAttribute  exception will be raised: Assignments to read-only attributes using their setters will be ignored: Calls to atomic persistence operators, like  bit  and  inc , will persist\nchanges to read-only fields. Mongoid supplies a timestamping module in  Mongoid::Timestamps  which\ncan be included to get basic behavior for  created_at  and\n updated_at  fields. You may also choose to only have specific timestamps for creation or\nmodification. If you want to turn off timestamping for specific calls, use the timeless\nmethod: If you'd like shorter timestamp fields with aliases on them to save space,\nyou can include the short versions of the modules. Using dots/periods ( . ) in fields names and starting a field name with\na dollar sign ( $ ) is not recommended, as Mongoid provides limited support\nfor retrieving and operating on the documents stored in those fields. Both Mongoid and MongoDB query language (MQL) generally use the dot/period\ncharacter ( . ) to separate field names in a field path that traverses\nembedded documents, and words beginning with the dollar sign ( $ ) as\noperators. MongoDB provides  limited support \nfor using field names containing dots and starting with the dollar sign\nfor interoperability with other software,\nhowever, due to this support being confined to specific operators\n(e.g.  getField ,\n setField ) and\nrequiring the usage of the aggregation pipeline for both queries and updates,\napplications should avoid using dots in field names and starting field names\nwith the dollar sign if possible. Mongoid, starting in version 8, now allows users to access fields that begin with\ndollar signs and that contain dots/periods. They can be accessed using the  send \nmethod as follows: It is also possible to use  read_attribute  to access these fields: Due to  server limitations ,\nupdating and replacing fields containing dots and dollars requires using special\noperators. For this reason, calling setters on these fields is prohibited and\nwill raise an error:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :name, type: String\n  field :date_of_birth, type: Date\n  field :weight, type: Float\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :first_name\n  field :middle_name\n  field :last_name\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n\n  field :status, type: StringifiedSymbol\nend\n\npost = Post.new(status: :hello)\n# status is stored as \"hello\" on the database, but returned as a Symbol\npost.status\n# => :hello\n\n# String values can be assigned also:\npost = Post.new(status: \"hello\")\n# status is stored as \"hello\" on the database, but returned as a Symbol\npost.status\n# => :hello"
                },
                {
                    "lang": "ruby",
                    "value": "post = Post.new(status: 42)\npost.status\n# => :\"42\""
                },
                {
                    "lang": "ruby",
                    "value": "class Symbol\n  def bson_type\n    BSON::String::BSON_TYPE\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :first_name\n  field :url, type: Hash\n\n  # will update the fields properly and save the values\n  def set_vals\n    self.first_name = 'Daniel'\n    self.url = {'home_page' => 'http://www.homepage.com'}\n    save\n  end\n\n  # all data will fail to save due to the illegal hash key\n  def set_vals_fail\n    self.first_name = 'Daniel'\n    self.url = {'home.page' => 'http://www.homepage.com'}\n    save\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Voter\n  include Mongoid::Document\n\n  field :registered_at, type: Time\nend\n\nVoter.new(registered_at: Date.today)\n# => #<Voter _id: 5fdd80392c97a618f07ba344, registered_at: 2020-12-18 05:00:00 UTC>"
                },
                {
                    "lang": "ruby",
                    "value": "class Ticket\n  include Mongoid::Document\n  field :opened_at, type: DateTime\nend\n\nMongoid.use_activesupport_time_zone = true\nTime.zone = 'Berlin'\n\nticket = Ticket.create!(opened_at: '2018-02-18 07:00:08 -0500')\n\n ticket.opened_at\n # => Sun, 18 Feb 2018 13:00:08 +0100\n ticket\n # => #<Ticket _id: 5c13d4b9026d7c4e7870bb2f, opened_at: 2018-02-18 12:00:08 UTC>\n\n Time.zone = 'America/New_York'\n ticket.opened_at\n # => Sun, 18 Feb 2018 07:00:08 -0500\n\n Mongoid.use_utc = true\n ticket.opened_at\n # => Sun, 18 Feb 2018 12:00:08 +0000"
                },
                {
                    "lang": "ruby",
                    "value": "ticket.opened_at = 1544803974\nticket.opened_at\n# => Fri, 14 Dec 2018 16:12:54 +0000"
                },
                {
                    "lang": "ruby",
                    "value": "Time.zone = 'America/New_York'\nticket.opened_at = 'Mar 4, 2018 10:00:00'\nticket.opened_at\n# => Sun, 04 Mar 2018 15:00:00 +0000"
                },
                {
                    "lang": "ruby",
                    "value": "ticket.opened_at = 'Mar 4, 2018 10:00:00 +01:00'\nticket.opened_at\n# => Sun, 04 Mar 2018 09:00:00 +0000"
                },
                {
                    "lang": "ruby",
                    "value": "class Token\n  include Mongoid::Document\n\n  field :pattern, type: Regexp\nend\n\ntoken = Token.create!(pattern: /hello.world/m)\ntoken.pattern\n# => /hello.world/m\n\ntoken.reload\ntoken.pattern\n# => #<BSON::Regexp::Raw:0x0000555f505e4a20 @pattern=\"hello.world\", @options=\"ms\">"
                },
                {
                    "lang": "ruby",
                    "value": "token.pattern.compile\n# => /hello.world/m"
                },
                {
                    "lang": "ruby",
                    "value": "BSON::Regexp::Raw.new('hello$', 's')\n# => #<BSON::Regexp::Raw:0x0000555f51441640 @pattern=\"hello$\", @options=\"s\">"
                },
                {
                    "lang": "ruby",
                    "value": "BSON::Regexp::Raw.new('hello$', 's').compile =~ \"hello\\nworld\"\n# => 0"
                },
                {
                    "lang": "javascript",
                    "value": "db.bands.updateMany({\n  \"field\": { \"$exists\": true }\n}, [\n  {\n    \"$set\": {\n      \"field\": { \"$toDecimal\": \"$field\" }\n    }\n  }\n])"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.map_big_decimal_to_decimal128 = true\nbig_decimal = BigDecimal('2E9')\nBand.in(sales: [big_decimal, big_decimal.to_s]).to_a"
                },
                {
                    "lang": "ruby",
                    "value": "class Order\n  include Mongoid::Document\n\n  field :state, type: :integer\n  # Equivalent to:\n  field :state, type: \"integer\"\n  # Equivalent to:\n  field :state, type: Integer\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Order\n  include Mongoid::Document\n\n  field :state, type: String, default: 'created'\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Order\n  include Mongoid::Document\n\n  field :fulfill_by, type: Time, default: ->{ Time.now + 3.days }\nend"
                },
                {
                    "lang": "ruby",
                    "value": "field :fulfill_by, type: Time, default: ->{\n  # Order should be fulfilled in 2 business hours.\n  if (7..8).include?(self.submitted_at.hour)\n    self.submitted_at + 4.hours\n  elsif (9..3).include?(self.submitted_at.hour)\n    self.submitted_at + 2.hours\n  else\n    (self.submitted_at + 1.day).change(hour: 11)\n  end\n}"
                },
                {
                    "lang": "ruby",
                    "value": "field :fulfill_by, type: Time, default: ->{ Time.now + 3.days },\n  pre_processed: true"
                },
                {
                    "lang": "ruby",
                    "value": "field :_id, type: String, default: -> { 'hello' }, pre_processed: true"
                },
                {
                    "lang": "ruby",
                    "value": "field :submitted_at, type: Time, default: Time.now\nfield :submitted_at, type: Time, default: ->{ Time.now }"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :n, as: :name, type: String\nend\n\nband = Band.new(name: \"Placebo\")\nband.attributes # { \"n\" => \"Placebo\" }\n\ncriteria = Band.where(name: \"Placebo\")\ncriteria.selector # { \"n\" => \"Placebo\" }"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  alias_attribute :n, :name\nend\n\nband = Band.new(n: 'Astral Projection')\n# => #<Band _id: 5fc1c1ee2c97a64accbeb5e1, name: \"Astral Projection\">\n\nband.attributes\n# => {\"_id\"=>BSON::ObjectId('5fc1c1ee2c97a64accbeb5e1'), \"name\"=>\"Astral Projection\"}\n\nband.n\n# => \"Astral Projection\""
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  unalias_attribute :n\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  unalias_attribute :id\n  field :id, type: String\nend\n\nBand.new(id: '42')\n# => #<Band _id: 5fc1c3f42c97a6590684046c, id: \"42\">"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :name\n\n  field :name, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :name\n\n  field :name, type: String, overwrite: true\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :_id, type: String, default: ->{ name }\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :_id, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!\n=> #<Band _id: , >\nband.id\n=> nil\nband.reload\n# raises Mongoid::Errors::DocumentNotFound\nBand.last\n=> #<Band _id: 5fc681c22c97a6791f324b99, >"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n\n  field :name, type: Integer\nend\n\nUser.new(name: [ \"hello\" ])"
                },
                {
                    "lang": null,
                    "value": "user = User.new(name: [ \"Mike\", \"Trout\" ])\n# => #<User _id: 62b222d43282a47bf73e3264, name: nil>"
                },
                {
                    "lang": null,
                    "value": "user.attributes_before_type_cast[\"name\"]\n# => [\"Mike\", \"Trout\"]"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n\n  field :name, type: Integer\nend"
                },
                {
                    "lang": null,
                    "value": "{ _id: ..., name: [ \"Mike\", \"Trout\" ] }"
                },
                {
                    "lang": null,
                    "value": "User.first.name\n# => nil"
                },
                {
                    "lang": null,
                    "value": "user.attributes_before_type_cast[\"name\"]\n# => [\"Mike\", \"Trout\"]"
                },
                {
                    "lang": "ruby",
                    "value": "class DistanceMeasurement\n  include Mongoid::Document\n\n  field :value, type: Float\n  field :unit, type: String\n\n  def unit\n    read_attribute(:unit) || \"m\"\n  end\n\n  def to_s\n    \"#{value} #{unit}\"\n  end\nend\n\nmeasurement = DistanceMeasurement.new(value: 2)\nmeasurement.to_s\n# => \"2.0 m\"\nmeasurement.attributes\n# => {\"_id\"=>BSON::ObjectId('613fa0b0a15d5d61502f3447'), \"value\"=>2.0}"
                },
                {
                    "lang": "ruby",
                    "value": "class DistanceMeasurement\n  include Mongoid::Document\n\n  field :value, type: Float\n  field :unit, type: String\n\n  def unit=(value)\n    if value.blank?\n      value = nil\n    end\n    write_attribute(:unit, value)\n  end\nend\n\nmeasurement = DistanceMeasurement.new(value: 2, unit: \"\")\nmeasurement.attributes\n# => {\"_id\"=>BSON::ObjectId('613fa15aa15d5d617216104c'), \"value\"=>2.0, \"unit\"=>nil}"
                },
                {
                    "lang": "ruby",
                    "value": "class Profile\n  include Mongoid::Document\n  field :location, type: Point\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Point\n\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x, @y = x, y\n  end\n\n  # Converts an object of this instance into a database friendly value.\n  # In this example, we store the values in the database as array.\n  def mongoize\n    [ x, y ]\n  end\n\n  class << self\n\n    # Takes any possible object and converts it to how it would be\n    # stored in the database.\n    def mongoize(object)\n      case object\n      when Point then object.mongoize\n      when Hash then Point.new(object[:x], object[:y]).mongoize\n      else object\n      end\n    end\n\n    # Get the object as it was stored in the database, and instantiate\n    # this custom class from it.\n    def demongoize(object)\n      Point.new(object[0], object[1])\n    end\n\n    # Converts the object that was supplied to a criteria and converts it\n    # into a query-friendly form.\n    def evolve(object)\n      case object\n      when Point then object.mongoize\n      else object\n      end\n    end\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "point = Point.new(12, 24)\nvenue = Venue.new(location: point) # This uses the Point#mongoize instance method.\nvenue = Venue.new(location: [ 12, 24 ]) # This uses the Point.mongoize class method."
                },
                {
                    "lang": "ruby",
                    "value": "def demongoize(object)\n  if object.is_a?(Array) && object.length == 2\n    Point.new(object[0], object[1])\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "point = Point.new(12, 24)\nVenue.where(location: point) # This uses Point.evolve"
                },
                {
                    "lang": "ruby",
                    "value": "class ColorMapping\n\n  MAPPING = {\n    'black' => 0,\n    'white' => 1,\n  }.freeze\n\n  INVERSE_MAPPING = MAPPING.invert.freeze\n\n  class << self\n\n    # Takes application-scope value and converts it to how it would be\n    # stored in the database. Converts invalid values to nil.\n    def mongoize(object)\n      MAPPING[object]\n    end\n\n    # Get the value as it was stored in the database, and convert to\n    # application-scope value. Converts invalid values to nil.\n    def demongoize(object)\n      INVERSE_MAPPING[object]\n    end\n\n    # Converts the object that was supplied to a criteria and converts it\n    # into a query-friendly form. Returns invalid values as is.\n    def evolve(object)\n      MAPPING.fetch(object, object)\n    end\n  end\nend\n\nclass Profile\n  include Mongoid::Document\n  field :color, type: ColorMapping\nend\n\nprofile = Profile.new(color: 'white')\nprofile.color\n# => \"white\"\n\n# Writes 0 to color field\nprofile.save!"
                },
                {
                    "lang": "ruby",
                    "value": "# in /config/initializers/mongoid_custom_fields.rb\n\nMongoid::Fields.option :max_length do |model, field, value|\n  model.validates_length_of field.name, maximum: value\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :name, type: String, max_length: 10\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  include Mongoid::Attributes::Dynamic\nend\n\nbob = Person.new(name: 'Bob', age: 42)\nbob.name\n# => \"Bob\""
                },
                {
                    "lang": "ruby",
                    "value": "# OK\nbob = Person.new(name: 'Bob')\n\n# OK\nbob = Person.new\nbob.attributes = {age: 42}\n\n# OK\nbob = Person.new\nbob['age'] = 42\n\n# Raises NoMethodError: undefined method age=\nbob = Person.new\nbob.age = 42\n\n# OK\nbob = Person.new\n# OK - string access\nbob.write_attribute('age', 42)\n# OK - symbol access\nbob.write_attribute(:name, 'Bob')\n\n# OK, initializes attributes from whatever is in the database\nbob = Person.find('123')"
                },
                {
                    "lang": "ruby",
                    "value": "bob = Person.new\nbob.attributes = {age: 42}\n\nbob.age\n# => 42\n\n# raises NoMethodError\nbob.name\n\n# raises NoMethodError\nbob.name = 'Bob'\n\n# OK\nbob['name'] = 'Bob'\n\nbob.name\n# => \"Bob\""
                },
                {
                    "lang": "ruby",
                    "value": "bob = Person.new(age: 42)\n\n# OK - string access\nbob['name']\n# => nil\n\n# OK - symbol access\nbob[:name]\n# => nil\n\n# OK - string access\nbob['age']\n# => 42\n\n# OK - symbol access\nbob[:age]\n# => 42\n\n# OK\nbob.attributes['name']\n# => nil\n\n# OK\nbob.attributes['age']\n# => 42\n\n# Returns nil - keys are always strings\nbob.attributes[:age]\n# => nil\n\n# OK\nbob.read_attribute('name')\n# => nil\n\n# OK\nbob.read_attribute(:name)\n# => nil\n\n# OK - string access\nbob.read_attribute('age')\n# => 42\n\n# OK - symbol access\nbob.read_attribute(:age)\n# => 42"
                },
                {
                    "lang": "ruby",
                    "value": "bob = Person.new('hello world' => 'MDB')\nbob.send('hello world')\n# => \"MDB\"\n\nbob.write_attribute(\"hello%world\", 'MDB')\nbob[:\"hello%world\"]\n# => \"MDB\""
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n  field :description, type: String, localize: true\nend"
                },
                {
                    "lang": "ruby",
                    "value": "I18n.default_locale = :en\nproduct = Product.new\nproduct.description = \"Marvelous!\"\nI18n.locale = :de\nproduct.description = \"Fantastisch!\"\n\nproduct.attributes\n# { \"description\" => { \"en\" => \"Marvelous!\", \"de\" => \"Fantastisch!\" }"
                },
                {
                    "lang": "ruby",
                    "value": "product.description_translations\n# { \"en\" => \"Marvelous!\", \"de\" => \"Fantastisch!\" }\nproduct.description_translations =\n  { \"en\" => \"Marvelous!\", \"de\" => \"Wunderbar!\" }"
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n\n  field :price, type: Float, localize: true\n  field :currency, type: String, localize: true\nend"
                },
                {
                    "lang": "ruby",
                    "value": "product = Product.new\nI18n.locale = :en\nproduct.price = 1.00\nproduct.currency = \"$\"\nI18n.locale = :he\nproduct.price = 3.24\nproduct.currency = \"\u20aa\"\n\nproduct.attributes\n# => { \"price\" => { \"en\" => 1.0, \"he\" => 3.24 }, \"currency\" => { \"en\" => \"$\", \"he\" => \"\u20aa\"  } }"
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n  field :description, localize: :present\nend"
                },
                {
                    "lang": "ruby",
                    "value": "I18n.default_locale = :en\nproduct = Product.new\nproduct.description = \"Marvelous!\"\nI18n.locale = :de\nproduct.description = \"Fantastisch!\"\n\nproduct.description_translations\n# { \"en\" => \"Marvelous!\", \"de\" => \"Fantastisch!\" }\n\nproduct.description = \"\"\nproduct.description_translations\n# { \"en\" => \"Marvelous!\" }"
                },
                {
                    "lang": "ruby",
                    "value": "config.i18n.fallbacks = true\nconfig.after_initialize do\n  I18n.fallbacks[:de] = [ :en, :es ]\nend"
                },
                {
                    "lang": "ruby",
                    "value": "require \"i18n/backend/fallbacks\"\nI18n::Backend::Simple.send(:include, I18n::Backend::Fallbacks)\nI18n.fallbacks[:de] = [ :en, :es ]"
                },
                {
                    "lang": "ruby",
                    "value": "product = Product.new\nI18n.locale = :en\nproduct.description = \"Marvelous!\"\nI18n.locale = :de\nproduct.description # \"Marvelous!\""
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n  field :description, type: String, localize: true, fallbacks: false\nend\n\nproduct = Product.new\nI18n.locale = :en\nproduct.description = \"Marvelous!\"\nI18n.locale = :de\nproduct.description # nil"
                },
                {
                    "lang": "ruby",
                    "value": "# Match all products with Marvelous as the description. Locale is en.\nProduct.where(description: \"Marvelous!\")\n# The resulting MongoDB query filter: { \"description.en\" : \"Marvelous!\" }"
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n  field :description, localize: true\n\n  index \"description.de\" => 1\n  index \"description.en\" => 1\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :origin, type: String\n\n  attr_readonly :name, :origin\nend\n\nband = Band.create(name: \"Placebo\")\nband.update_attributes(name: \"Tool\") # Filters out the name change."
                },
                {
                    "lang": "ruby",
                    "value": "band.update_attribute(:name, \"Tool\") # Raises the error.\nband.remove_attribute(:name) # Raises the error."
                },
                {
                    "lang": "ruby",
                    "value": "b = Band.create!(name: \"The Rolling Stones\")\n# => #<Band _id: 6287a3d5d1327a5292535383, name: \"The Rolling Stones\", origin: nil>\nb.name = \"The Smashing Pumpkins\"\n# => \"The Smashing Pumpkins\"\nb.name\n# => \"The Rolling Stones\""
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  include Mongoid::Timestamps\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  include Mongoid::Timestamps::Created\nend\n\nclass Post\n  include Mongoid::Document\n  include Mongoid::Timestamps::Updated\nend"
                },
                {
                    "lang": "ruby",
                    "value": "person.timeless.save\nPerson.timeless.create!"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  include Mongoid::Timestamps::Short # For c_at and u_at.\nend\n\nclass Band\n  include Mongoid::Document\n  include Mongoid::Timestamps::Created::Short # For c_at only.\nend\n\nclass Band\n  include Mongoid::Document\n  include Mongoid::Timestamps::Updated::Short # For u_at only.\nend"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n  field :\"first.last\", type: String\n  field :\"$_amount\", type: Integer\nend\n\nuser = User.first\nuser.send(:\"first.last\")\n# => Mike.Trout\nuser.send(:\"$_amount\")\n# => 42650000"
                },
                {
                    "lang": null,
                    "value": "user.read_attribute(\"first.last\")\n# => Mike.Trout"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n  field :\"first.last\", type: String\n  field :\"$_amount\", type: Integer\nend\n\nuser = User.new\nuser.send(:\"first.last=\", \"Shohei.Ohtani\")\n# raises a InvalidDotDollarAssignment error\nuser.send(:\"$_amount=\", 8500000)\n# raises a InvalidDotDollarAssignment error"
                }
            ],
            "preview": "MongoDB stores underlying document data using\nBSON types, and\nMongoid converts BSON types to Ruby types at runtime in your application.\nFor example, a field defined with type: :float will use the Ruby Float\nclass in-memory and will persist in the database as the the BSON double type.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/persistence-configuration",
            "title": "Persistence Configuration",
            "headings": [
                "Document Storage",
                "Persistence Context Attributes",
                "Custom",
                "Model-Level Persistence Options",
                "Runtime Persistence Options",
                "Global Override",
                "Client and Collection Access"
            ],
            "paragraphs": "Mongoid by default stores documents in a collection that is the pluralized form of the class name.\nFor the following  Person  class, the collection the document would get stored in would be named  people . Model class names cannot end with \"s\", because it will be considered as the pluralized form of\nthe word. For example \"Status\" would be considered as the plural form of \"Statu\",\nwhich will cause a few known problems. This is a limitation of the  ActiveSupport::Inflector#classify  which Mongoid uses to convert\nfrom filenames and collection names to class names. You can overcome this by specifying a custom\ninflection rule for your model class. For example, the following code will take care of the model\nnamed  Status . The collection for the model's documents can be changed at the class level if you would like\nthem persisted elsewhere. You can also change the database and client the model gets persisted\nin from the defaults. The  store_in  macro can also take lambdas - a common case for this is multi-tenant applications. When a document is stored in the database the ruby object will get serialized into BSON\nand have a structure like so: Mongoid provides  client_name ,  database_name  and  collection_name \nmethods on model classes to determine the client, database and collection names\nused for persistence: There may be cases where you want to persist documents to different sources from their\ndefaults, or with different options from the default. Mongoid provides run-time support\nfor this as well as support on a per-model basis. On a per-model basis, you can tell it to store in a custom collection name, a different\ndatabase, or a different client. The following example would store the Band class by\ndefault into a collection named \"artists\" in the database named \"music\", with the client \"analytics\". Note that the value supplied to the  client  option must be configured under  clients \nin your mongoid.yml. If no  store_in  macro would have been provided, Mongoid would store the model in a\ncollection named \"bands\" in the default database in the default client. It is possible to change the client, database and collection, as well as\nany of the MongoDB client options, used for persistence for a group of\noperations by using the  with  method on a model class or instance: The  with  method creates a temporary persistence context and a MongoDB\nclient to be used for operations in the context. For the duration of the block,\nthe persistence context on the model class or instance that  with  was\ncalled on is changed to the temporary persistence context. For convenience,\nthe model class or instance that  with  was called on is yielded to the\nblock. The temporary persistence context applies to both queries and writes. Care should be taken when performing persistence operations across different\npersistence contexts. For example, if a document is saved in a temporary\npersistence context, it may not exist in the default persistence context,\nfailing subsequent updates: As of Mongoid 6.0, the  with  method must always be called with a block,\nand the temporary persistence context exists only for the duration of the block.\nThis is because a new client is created under the covers with the options\npassed to  with . To ensure that this client is closed and its associated\nresources are freed, the scope when this client could be used must be\nwell-defined. If you want to switch the persistence context for all operations at runtime, but don't want\nto be using with all over your code, Mongoid provides the ability to do this as the client\nand database level globally. The methods for this are  Mongoid.override_client  and\n Mongoid.override_database . A useful case for this are internationalized applications\nthat store information for different locales in different databases or clients, but the\nschema in each remains the same. In the above example, all persistence operations would be stored in the alternative\ndatabase for all remaining operations on this thread. This is why the after request\nset the override back to nil - it ensures subsequent requests with no local params\nuse the default option. Persistence context applies to both read and write operations. For example,\nsecondary reads can be performed as follows: If you want to drop down to the driver level to perform operations, you can grab\nthe Mongo client or collection from the model or document instance: From here you also have the same runtime persistence options using the client's  #with : You can also override the :read or :write options on the collection using the collections  #with :",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\nend"
                },
                {
                    "lang": "ruby",
                    "value": "ActiveSupport::Inflector.inflections do |inflect|\n  inflect.singular(\"status\", \"status\")\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  store_in collection: \"citizens\", database: \"other\", client: \"analytics\"\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  store_in database: ->{ Thread.current[:database] }\nend"
                },
                {
                    "lang": "ruby",
                    "value": "{\n  \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7e9\"),\n  \"title\" : \"Sir\",\n  \"name\" : {\n    \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7ff\"),\n    \"first_name\" : \"Durran\"\n  },\n  \"addresses\" : [\n    {\n      \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7e0\"),\n      \"city\" : \"Berlin\",\n      \"country\" : \"Deutschland\"\n    }\n  ]\n}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.client_name\n# => :default\n\nBand.database_name\n# => \"mongoid\"\n\nBand.collection_name\n# => :bands"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  store_in collection: \"artists\", database: \"music\", client: \"analytics\"\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.with(database: \"music-non-stop\") do |klass|\n  klass.create(...)\n\n  band = Band.first\n\n  Band.create(...)\nend\n\nBand.with(collection: \"artists\") do |klass|\n  klass.delete_all\n\n  Band.delete_all\nend\n\nband.with(client: :tertiary) do |band_object|\n  band_object.save!\n\n  band.save!\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.new(name: \"Scuba\")\nband.with(collection: \"artists\") do |band_object|\n  band_object.save!\nend\n\n# This will not save - updates the collection \"bands\" which does not have\n# the Scuba band\nband.update_attribute(likes: 1000)\n\n# This will update the document.\nband.with(collection: \"artists\") do |band_object|\n  band_object.update_attribute(likes: 1000)\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class BandsController < ApplicationController\n  before_action :switch_database\n  after_action :reset_database\n\n  private\n\n  def switch_database\n    I18n.locale = params[:locale] || I18n.default_locale\n    Mongoid.override_database(\"my_db_name_#{I18n.locale}\")\n  end\n\n  def reset_database\n    Mongoid.override_database(nil)\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.with(read: {mode: :secondary}) do\n  Band.count\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.mongo_client\nband.mongo_client\nBand.collection\nband.collection"
                },
                {
                    "lang": "ruby",
                    "value": "client = Band.mongo_client.with(write: { w: 0 }, database: \"musik\")\nclient[:artists].find(...)"
                },
                {
                    "lang": "ruby",
                    "value": "collection_w_0 = Band.collection.with(write: { w: 0 })\ncollection_w_0[:artists].find(...)"
                }
            ],
            "preview": "Mongoid by default stores documents in a collection that is the pluralized form of the class name.\nFor the following Person class, the collection the document would get stored in would be named people.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/sharding",
            "title": "Sharding Configuration",
            "headings": [
                "Declaring Shard Keys",
                "Sharding Management Rake Tasks"
            ],
            "paragraphs": "Mongoid can assist with setting up collection sharding in sharded environments. Shard keys can be declared on models using the  shard_key  macro: Note that in order to shard a collection, the collection must have an index\nthat starts with the shard key. Mongoid provides  index management  functionality, which the examples here take\nadvantage of. Mongoid supports two syntaxes for declaring shard keys. The standard syntax\nfollows the format of MongoDB  shardCollection shell helper \nand allows specifying ranged and hashed shard keys, compound shard keys and\ncollection sharding options: The alternative is the shorthand syntax, in which only the keys are given.\nThis syntax only supports ranged shard keys and does not allow options to\nbe specified: shard_key  macro can take the name of a  belongs_to  association in\nplace of a field name, in which case Mongoid will use the foreign key\nconfigured in the association as the field name: The shard key may also reference a field in an embedded document, by using\nthe \".\" character to delimit the field names: Because the \".\" character is used to delimit fields in embedded documents,\nMongoid does not currently support shard key fields that themselves\nliterally contain the \".\" character. If a model declares a shard key, Mongoid expects the respective collection\nto be sharded with the specified shard key. When reloading models, Mongoid\nwill provide the shard key in addition to the  id  field value to the\n find  command to improve query performance, especially on  geographically\ndistributed sharded clusters .\nIf the collection is not sharded with the specified shard key, queries\nmay produce incorrect results. To shard collections in the database according to the shard keys defined in\nthe models, run the  db:mongoid:shard_collections  Rake task.\nIf necessary, run the  db:mongoid:create_indexes  Rake task prior to\nsharding collections: Like with index management rake tasks, sharding management rake tasks\ngenerally do not stop and fail when they encounter the problem with a\nparticular model class. Instead they log the problem (to the configured\nMongoid logger) at an appropriate level and continue with the next model.\nWhen Mongoid is used in a Rails application, this means the results of\nthe rake task execution will generally be found in the per-environment\nlog file like  log/development.log . When performing schema-related operations in a sharded cluster, such as\nsharding collections as described in this document, or creating or dropping\ncollections or databases, cluster nodes may end up with out of date local\nconfiguration-related cache data. Execute the  flushRouterConfig \ncommand on each  mongos  node to clear these caches.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :ssn\n\n  shard_key ssn: 1\n\n  # The collection must also have an index that starts with the shard key.\n  index ssn: 1\nend"
                },
                {
                    "lang": "ruby",
                    "value": "shard_key ssn: 1\n\nshard_key ssn: 1, country: 1\n\nshard_key ssn: :hashed\n\nshard_key {ssn: :hashed}, unique: true"
                },
                {
                    "lang": "ruby",
                    "value": "shard_key :ssn\n\nshard_key :ssn, :country"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  belongs_to :country\n\n  # Shards by country_id.\n  shard_key country: 1\n\n  # The collection must also have an index that starts with the shard key.\n  index country: 1\nend"
                },
                {
                    "lang": "ruby",
                    "value": "shard_key \"location.x\" => 1, \"location.y\" => 1\n\nshard_key \"location.x\", \"location.y\""
                },
                {
                    "lang": "bash",
                    "value": "rake db:mongoid:create_indexes\nrake db:mongoid:shard_collections"
                }
            ],
            "preview": "Mongoid can assist with setting up collection sharding in sharded environments.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/indexes",
            "title": "Index Management",
            "headings": [
                "Specifying Indexes",
                "Index Management Rake Tasks",
                "Using Rake Tasks With Non-Rails Applications"
            ],
            "paragraphs": "You can define indexes on documents using the index macro. Provide the key for\nthe index along with a direction. Additional options can be supplied in the\nsecond options hash parameter: You can define indexes on embedded document fields as well: You can index on multiple fields and provide direction: Indexes can be sparse: For geospatial indexes, make sure the field being indexed is of type Array: Indexes can be scoped to a specific database: Mongoid can define indexes on \"foreign key\" fields for associations.\nThis only works on the association macro that the foreign key is stored on: Deprecated:  In MongoDB 4.0 and earlier, users could control whether to build indexes\nin the foreground (blocking) or background (non-blocking, but less efficient) using the\n background  option. The default value of  background  is controlled by Mongoid's\n background_indexing   configuration option . The  background  option has  no effect as of MongoDB 4.2 . When you want to create the indexes in the database, use the provided\n db:mongoid:create_indexes  Rake task: Mongoid also provides a Rake task to delete all secondary indexes. Note: the output of these Rake tasks goes to the default logger configured\nby Rails. This is usually a file like  log/development.log  and not standard\noutput. These create/remove indexes commands also works for just one model by running\nin Rails console: Mongoid's Rake tasks are automatically loaded in Rails applications using\nMongoid. When using Mongoid with a non-Rails application, these tasks must\nbe loaded manually. This can be achieved by loading them in the Rakefile and\nproviding an  :environment  task to load your application's models: If your application uses Bundler, you can require  bundler/setup  instead of\nexplicitly requiring  mongoid :",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :ssn\n\n  index({ ssn: 1 }, { unique: true, name: \"ssn_index\" })\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  embeds_many :addresses\n  index \"addresses.street\" => 1\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :first_name\n  field :last_name\n\n  index({ first_name: 1, last_name: 1 }, { unique: true })\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :ssn\n\n  index({ ssn: -1 }, { sparse: true })\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :location, type: Array\n\n  index({ location: \"2d\" }, { min: -200, max: 200 })\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :ssn\n  index({ ssn: 1 }, { database: \"users\", unique: true, background: true })\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Comment\n  include Mongoid::Document\n  belongs_to :post, index: true\n  has_and_belongs_to_many :preferences, index: true\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  field :ssn\n  index({ ssn: 1 }, { unique: true, background: true })\nend"
                },
                {
                    "lang": "bash",
                    "value": "$ rake db:mongoid:create_indexes"
                },
                {
                    "lang": "bash",
                    "value": "$ rake db:mongoid:remove_indexes"
                },
                {
                    "lang": "ruby",
                    "value": "# Create indexes for Model\nModel.create_indexes\n\n# Remove indexes for Model\nModel.remove_indexes"
                },
                {
                    "lang": "ruby",
                    "value": "# Rakefile\n\nrequire 'mongoid'\nload 'mongoid/tasks/database.rake'\n\ntask :environment do\n  # Require/load your application's models here\nend"
                },
                {
                    "lang": "ruby",
                    "value": "# Rakefile\n\nrequire 'bundler/setup'\nload 'mongoid/tasks/database.rake'\n\ntask :environment do\n  # Require/load your application's models here\nend"
                }
            ],
            "preview": "You can define indexes on documents using the index macro. Provide the key for\nthe index along with a direction. Additional options can be supplied in the\nsecond options hash parameter:",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/transactions",
            "title": "Transactions",
            "headings": [
                "Using Transactions"
            ],
            "paragraphs": "Version 4.0 of the MongoDB server introduces\n multi-document transactions .\n(Updates to multiple fields within a single document are atomic in all\nversions of MongoDB). Transactions require Mongoid version 6.4 or higher and Ruby driver version\n2.6 or higher. In order to start a transaction, the application must have a  session . A transaction can be started by calling the  start_transaction  method on a session, which can be\nobtained by calling the  with_session  method on either a model class or instance: It is also possible to specify read concern, write concern and read preference\nwhen starting a transaction: A transaction may be committed or aborted. The corresponding methods to do so are\n commit_transaction  and  abort_transaction , again on the session instance: If a session ends with an open transaction,\n the transaction is aborted . The transaction commit  can be retried \nif it fails. Here is the Ruby code to do so: Note that in order to perform operations within the transaction, operations must use the same client\nthat the session was initiated on. By default, all operations will be done on the default client: To explicitly use a different client, use the  with  method:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\nend\n\nPerson.with_session do |session|\n  session.start_transaction\nend\n\nperson = Person.new\nperson.with_session do |session|\n  session.start_transaction\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Person.with_session do |session|\n  session.start_transaction(\n    read_concern: {level: :majority},\n    write_concern: {w: 3},\n    read: {mode: :primary})\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Person.with_session do |session|\n  session.commit_transaction\nend\n\nPerson.with_session do |session|\n  session.abort_transaction\nend"
                },
                {
                    "lang": "ruby",
                    "value": "begin\n  session.commit_transaction\nrescue Mongo::Error => e\n  if e.label?(Mongo::Error::UNKNOWN_TRANSACTION_COMMIT_RESULT_LABEL)\n    retry\n  else\n    raise\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\nend\n\nclass Post\n  include Mongoid::Document\nend\n\nPerson.with_session do |s|\n  s.start_transaction\n  Person.create!\n  Person.create!\n  Post.create!\n  s.commit_transaction\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Post.with(client: :other) do\n  Person.with(client: :other) do\n    Person.with_session do |s|\n      s.start_transaction\n      Person.create!\n      Person.create!\n      Post.create!\n      s.commit_transaction\n    end\n  end\nend"
                }
            ],
            "preview": "Version 4.0 of the MongoDB server introduces\nmulti-document transactions.\n(Updates to multiple fields within a single document are atomic in all\nversions of MongoDB). Transactions require Mongoid version 6.4 or higher and Ruby driver version\n2.6 or higher.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/rails-integration",
            "title": "Rails Integration",
            "headings": [
                "Configuration",
                "Model Preloading",
                "Exceptions",
                "Controller Runtime Instrumentation",
                "Rake Tasks"
            ],
            "paragraphs": "Mongoid seamlessly integrates into Ruby on Rails applications.\nThis page describes features that are automatically enabled in the context\nof a Rails application and Rails-related functionality which can be\nmanually enabled. You can set Mongoid configuration options in your  application.rb  along with other Rails\nenvironment specific options by accessing config.mongoid. Options set here will override\nthose set in your  config/mongoid.yml . In order to properly set up single collection inheritance, Mongoid needs to preload all\nmodels before every request in development mode. This can get slow, so if you are not\nusing any inheritance it is recommended you turn this feature off. Similarly to ActiveRecord, Mongoid configures Rails to automatically convert\ncertain exceptions to well-known HTTP status codes, as follows: Mongoid provides time spent executing MongoDB commands (obtained via a\ndriver command monitoring subscription) to Rails' instrumentation event\n process_action.action_controller . This time is logged together with view\ntime like so: This logging is set up automatically. Note: the time indicated is the time taken by MongoDB cluster to execute\nMongoDB operations, plus the time taken to send commands and receive\nresults from MongoDB over the network. It does not include time taken by\nthe driver and Mongoid to generate the queries or type cast and otherwise\nprocess the results. Mongoid provides the following rake tasks when used in a Rails environment: db:create : Exists only for dependency purposes, does not actually do anything. db:create_indexes : Reads all index definitions from the models and attempts to create them in the database. db:remove_indexes : Reads all secondary index definitions from the models. db:drop : Drops all collections in the database with the exception of the system collections. db:migrate : Exists only for dependency purposes, does not actually do anything. db:purge : Deletes all data, including indexes, from the database. Since 3.1.0 db:schema:load : Exists only for framework dependency purposes, does not actually do anything. db:seed : Seeds the database from db/seeds.rb db:setup : Creates indexes and seeds the database. db:test:prepare : Exists only for framework dependency purposes, does not actually do anything.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "module MyApplication\n  class Application < Rails::Application\n    config.mongoid.logger = Logger.new(STDERR, :warn)\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "config.mongoid.preload_models = false"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid::Errors::DocumentNotFound : 404\nMongoid::Errors::Validations : 422"
                },
                {
                    "lang": "none",
                    "value": "Completed 200 OK in 2739ms (Views: 12.6ms | MongoDB: 0.2ms)"
                }
            ],
            "preview": "Mongoid seamlessly integrates into Ruby on Rails applications.\nThis page describes features that are automatically enabled in the context\nof a Rails application and Rails-related functionality which can be\nmanually enabled.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/collection-configuration",
            "title": "Collection Configuration",
            "headings": [
                "Configuring a Document Collection",
                "Time Series Collection",
                "Capped Collections",
                "Set a Default Collation on a Collection",
                "Collection Management Rake Task"
            ],
            "paragraphs": "You can specify collection options for documents using the  store_in  macro.\nThis macro accepts  :collection_options  argument, which can contain any collection\noptions that are supported by the driver. Please refer to  the driver collections page \nfor the more information about collection options. In order to apply the options, the collection must be explicitly created up-front.\nThis should be done using   Collection Management Rake Task . Collection options depend on the driver version and MongoDB server version.\nIt is possible that some options, like time series collections, are not available\non older server versions. If you specify collection options for a document, then the corresponding collection\nmust be explicitly created prior to use. To do so, use the provided\n db:mongoid:create_collections  Rake task: The create collections command also works for just one model by running\nin Rails console:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Measurement\n  include Mongoid::Document\n\n  field :temperature, type: Integer\n  field :timestamp, type: Time\n\n  store_in collection_options: {\n    time_series: {\n      timeField: \"timestamp\",\n      granularity: \"minutes\"\n    },\n    expire_after: 604800\n  }\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Name\n  include Mongoid::Document\n\n  store_in collection_options: {\n    capped: true,\n    size: 1024\n  }\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Name\n  include Mongoid::Document\n\n  store_in collection_options: {\n    collation: {\n      locale: 'fr'\n    }\n  }\nend"
                },
                {
                    "lang": "bash",
                    "value": "$ rake db:mongoid:create_collections"
                },
                {
                    "lang": "ruby",
                    "value": "# Create collection for Model\nModel.create_collection"
                }
            ],
            "preview": "You can specify collection options for documents using the store_in macro.\nThis macro accepts :collection_options argument, which can contain any collection\noptions that are supported by the driver.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/map-reduce",
            "title": "Map/Reduce",
            "headings": [
                "Execution",
                "Raw Results",
                "Statistics"
            ],
            "paragraphs": "Mongoid provides a DSL around MongoDB's map/reduce framework, for performing\ncustom map/reduce jobs or simple aggregations. The map-reduce operation is deprecated.\nThe  aggregation framework  provides better\nperformance and usability than map-reduce operations, and should be\npreferred for new development. You can tell Mongoid off the class or a criteria to perform a map/reduce\nby calling  map_reduce  and providing map and reduce javascript\nfunctions. Just like criteria, map/reduce calls are lazily evaluated. So nothing will\nhit the database until you iterate over the results, or make a call on the\nwrapper that would need to force a database hit. The only required thing you provide along with a map/reduce is where to\noutput the results. If you do not provide this an error will be raised.\nValid options to  #out  are: inline: 1 : Don't store the output in a collection. replace: \"name\" : Store in a collection with the\nprovided name, and overwrite any documents that exist in it. merge: \"name\" : Store in a collection with the\nprovided name, and merge the results with the existing documents. reduce: \"name\" : Store in a collection with the\nprovided name, and reduce all existing results in that collection. Results of Map/Reduce execution can be retrieved via the  execute  method\nor its aliases  raw  and  results : MongoDB servers 4.2 and lower provide Map/Reduce execution statistics. As of\nMongoDB 4.4, Map/Reduce is implemented via the aggregation pipeline and\nstatistics described in this section are not available. The following methods are provided on the  MapReduce  object: The following code illustrates retrieving the statistics: counts : Number of documents read, emitted, reduced and output through\nthe pipeline. input ,  emitted ,  reduced ,  output : individual count methods.\nNote that  emitted  and  reduced  methods are named differently from\nhash keys in  counts . time : The time, in milliseconds, that Map/Reduce pipeline took to execute. Each statistics method invocation re-executes the Map/Reduce pipeline.\nThe results of execution are not stored by Mongoid. Consider using the\n execute  method to retrieve the raw results and obtaining the statistics\nfrom the raw results if multiple statistics are desired.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "map = %Q{\n  function() {\n    emit(this.name, { likes: this.likes });\n  }\n}\n\nreduce = %Q{\n  function(key, values) {\n    var result = { likes: 0 };\n    values.forEach(function(value) {\n      result.likes += value.likes;\n    });\n    return result;\n  }\n}\n\nBand.where(:likes.gt => 100).map_reduce(map, reduce).out(inline: 1)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.map_reduce(map, reduce).out(replace: \"mr-results\").each do |document|\n  p document # { \"_id\" => \"Tool\", \"value\" => { \"likes\" => 200 }}\nend"
                },
                {
                    "lang": "ruby",
                    "value": "mr = Band.where(:likes.gt => 100).map_reduce(map, reduce).out(inline: 1)\n\nmr.execute\n# => {\"results\"=>[{\"_id\"=>\"Tool\", \"value\"=>{\"likes\"=>200.0}}],\n      \"timeMillis\"=>14,\n      \"counts\"=>{\"input\"=>4, \"emit\"=>4, \"reduce\"=>1, \"output\"=>1},\n      \"ok\"=>1.0,\n      \"$clusterTime\"=>{\"clusterTime\"=>#<BSON::Timestamp:0x00005633c2c2ad20 @seconds=1590105400, @increment=1>, \"signature\"=>{\"hash\"=><BSON::Binary:0x12240 type=generic data=0x0000000000000000...>, \"keyId\"=>0}},\n      \"operationTime\"=>#<BSON::Timestamp:0x00005633c2c2aaf0 @seconds=1590105400, @increment=1>}"
                },
                {
                    "lang": "ruby",
                    "value": "mr = Band.where(:likes.gt => 100).map_reduce(map, reduce).out(inline: 1)\n\nmr.counts\n# => {\"input\"=>4, \"emit\"=>4, \"reduce\"=>1, \"output\"=>1}\n\nmr.input\n# => 4\n\nmr.emitted\n# => 4\n\nmr.reduced\n# => 1\n\nmr.output\n# => 1\n\nmr.time\n# => 14"
                }
            ],
            "preview": "Mongoid provides a DSL around MongoDB's map/reduce framework, for performing\ncustom map/reduce jobs or simple aggregations.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/aggregation",
            "title": "Aggregation Pipeline",
            "headings": [
                "Basic Usage",
                "Querying Across Multiple Collections",
                "Builder DSL",
                "group",
                "project",
                "unwind"
            ],
            "paragraphs": "Mongoid exposes  MongoDB's aggregation pipeline ,\nwhich is used to construct flows of operations that process and return results.\nThe aggregation pipeline is a superset of the deprecated\n map/reduce framework  functionality. The aggregation pipeline may be used for queries involving multiple\nreferenced associations at the same time: To retrieve bands that toured since 2000 and have at least one award, one\ncould do the following: Note that the aggregation pipeline, since it is implemented by the Ruby driver\nfor MongoDB and not Mongoid, returns raw  BSON::Document  objects rather than\n Mongoid::Document  model instances. The above example projects only\nthe  _id  field which is then used to load full models. An alternative is\nto not perform such a projection and work with raw fields, which would eliminate\nhaving to send the list of document ids to Mongoid in the second query\n(which could be large). Mongoid provides limited support for constructing the aggregation pipeline\nitself using a high-level DSL. The following aggregation pipeline operators\nare supported: To construct a pipeline, call the corresponding aggregation pipeline methods\non a  Criteria  instance. Aggregation pipeline operations are added to the\n pipeline  attribute of the  Criteria  instance. To execute the pipeline,\npass the  pipeline  attribute value to  Collection#aggragegate  method. For example, given the following models: We can find out which states a participant visited: $group $project $unwind The  group  method adds a  $group aggregation pipeline stage . The field expressions support Mongoid symbol-operator syntax: Alternatively, standard MongoDB aggregation pipeline syntax may be used: The  project  method adds a  $project aggregation pipeline stage . The argument should be a Hash specifying the projection: The  unwind  method adds an  $unwind aggregation pipeline stage . The argument can be a field name, specifiable as a symbol or a string, or\na Hash or a  BSON::Document  instance:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  has_many :tours\n  has_many :awards\n  field :name, type: String\nend\n\nclass Tour\n  include Mongoid::Document\n  belongs_to :band\n  field :year, type: Integer\nend\n\nclass Award\n  include Mongoid::Document\n  belongs_to :band\n  field :name, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band_ids = Band.collection.aggregate([\n  { '$lookup' => {\n    from: 'tours',\n    localField: '_id',\n    foreignField: 'band_id',\n    as: 'tours',\n  } },\n  { '$lookup' => {\n    from: 'awards',\n    localField: '_id',\n    foreignField: 'band_id',\n    as: 'awards',\n  } },\n  { '$match' => {\n    'tours.year' => {'$gte' => 2000},\n    'awards._id' => {'$exists' => true},\n  } },\n  {'$project' => {_id: 1}},\n])\nbands = Band.find(band_ids.to_a)"
                },
                {
                    "lang": "ruby",
                    "value": "class Tour\n  include Mongoid::Document\n\n  embeds_many :participants\n\n  field :name, type: String\n  field :states, type: Array\nend\n\nclass Participant\n  include Mongoid::Document\n\n  embedded_in :tour\n\n  field :name, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "criteria = Tour.where('participants.name' => 'Serenity',).\n  unwind(:states).\n  group(_id: 'states', :states.add_to_set => '$states').\n  project(_id: 0, states: 1)\n\npp criteria.pipeline\n# => [{\"$match\"=>{\"participants.name\"=>\"Serenity\"}},\n#     {\"$unwind\"=>\"$states\"},\n#     {\"$group\"=>{\"_id\"=>\"states\", \"states\"=>{\"$addToSet\"=>\"$states\"}}},\n#     {\"$project\"=>{\"_id\"=>0, \"states\"=>1}}]\n\nTour.collection.aggregate(criteria.pipeline).to_a"
                },
                {
                    "lang": "ruby",
                    "value": "criteria = Tour.all.group(_id: 'states', :states.add_to_set => '$states')\ncriteria.pipeline\n# => [{\"$group\"=>{\"_id\"=>\"states\", \"states\"=>{\"$addToSet\"=>\"$states\"}}}]"
                },
                {
                    "lang": "ruby",
                    "value": "criteria = Tour.all.group(_id: 'states', states: {'$addToSet' => '$states'})"
                },
                {
                    "lang": "ruby",
                    "value": "criteria = Tour.all.project(_id: 0, states: 1)\ncriteria.pipeline\n# => [{\"$project\"=>{\"_id\"=>0, \"states\"=>1}}]"
                },
                {
                    "lang": "ruby",
                    "value": "criteria = Tour.all.unwind(:states)\ncriteria = Tour.all.unwind('states')\ncriteria.pipeline\n# => [{\"$unwind\"=>\"$states\"}]\n\ncriteria = Tour.all.unwind(path: '$states')\ncriteria.pipeline\n# => [{\"$unwind\"=>{:path=>\"$states\"}}]"
                }
            ],
            "preview": "Mongoid exposes MongoDB's aggregation pipeline,\nwhich is used to construct flows of operations that process and return results.\nThe aggregation pipeline is a superset of the deprecated\nmap/reduce framework functionality.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/inheritance",
            "title": "Inheritance",
            "headings": [
                "Changing the Discriminator Key",
                "Changing the Discriminator Value",
                "Querying Subclasses",
                "Associations",
                "Persistence Contexts"
            ],
            "paragraphs": "Mongoid supports inheritance in both top level and embedded documents. When\na child document inherits from a parent document, the parent document's\nfields, associations, validations and scopes are copied to the child document. In the above example,  Canvas ,  Browser  and  Firefox  will all save in the canvases\ncollection. An additional attribute  _type  is stored in order to make sure when loaded\nfrom the database the correct document is returned. This also holds true for the embedded\ndocuments  Circle ,  Rectangle , and  Shape . When searching for a  Circle , the query will only return documents in the shape collection\nwhere the  _type  (or whatever the discriminator key was set to) field has the value  Circle  (or\nwhatever the discriminator value was set to), all other discriminator values will be considered an object\nof the Shape class. Similarly, when querying by parent classes ( Canvas  in this example), any documents in the collection\nthat do not have a discriminator value, or whose discriminator value does not map to either the parent\nor any of its descendants, will be returned as instances of the parent class. Mongoid supports changing the discriminator key from the default  _type . There are a few\ncases where one might want to do this: There are two ways to change the discriminator key, on the class level and on the global level.\nTo change the discriminator key on the class level the user can set it directly on the parent class using\nthe  discriminator_key=  method.\nTake the above example: Here a call to the  discriminator_key=  setter was added to the parent class. Now, on\ncreation of a Rectangle or Circle, a  shape_type  field will be added. Note that the discriminator key can only be modified in the parent class, and an error\nwill be raised if trying to set it on the child class. If the discriminator key is changed after the child class is created, a new field is\nadded with the new discriminator key value, and the old field will remain unchanged.\nFor example: In this case, on creation of a Rectangle or Circle, there will be both a  shape_type \nand a  _type  field that both default to  Rectangle  or  Circle  respectively. The discriminator key can also be set on the global level. Meaning, all classes will\nuse the globally set discriminator key instead of  _type . Take the above example: After setting the global discriminator key, all classes will use  _the_type  as\nthe discriminator key and will not contain a  _type  field. Note that when defining the discriminator key on the global level, it must be set before the\nchild class is defined for the child class to use that global value.\nOn the global level, however, if the user does not set the discriminator key before defining a child\nclass, the discriminator field will use the default  _type  and not the new global setting in\nthat child class. For optimization: The user might want to use a shorter key like  _t . When trying to work with an existing system: It's possible the user is working with an existing system or dataset that has predefined keys. Mongoid also supports changing the discriminator value from the default value, which is the class name.\nOne can change the discriminator value by using the  discriminator_value=  method on that specific class. Take the above example: Here, a call to the  discriminator_value=  setter was added to  Circle .\nNow, on creation of a  Circle , the document will contain a field with the key  _type  (or whatever the  discriminator_key  was changed to)\nand the value \"round thing.\" Because the discriminator value overrides are declared in child classes,\nthe child classes potentially found by a query must be loaded prior to\nsending that query. In the above example, the  Circle  class definition\nmust be loaded when querying on  Shape  if the returned documents could\npotentially be instances of  Circle  (since autoloading wouldn't resolve\n \"round thing\"  to  Circle ). Querying for subclasses is handled in the normal manner, and although the documents are\nall in the same collection, queries will only return documents of the correct type,\nsimilar to Single Table Inheritance in ActiveRecord. You can add any type of subclass to a has one or has many association, through\neither normal setting or through the build and create methods on the association: Mongoid allows the persistence context of a subclass to be changed from the\npersistence context of its parent. This means that, using the  store_in \nmethod, we can store the documents of the subclasses in different collections\n(as well as different databases, clients) than their parents: Setting the collection on the children causes the documents for those children\nto be stored in the set collection, instead of in the parent's collection: If the collection is set on some of the subclasses and not others, the subclasses\nwith set collections will store documents in those collections, and the\nsubclasses without set collections will be store documents in the parent's\ncollection. Note that changing the collection that a subclass is stored in will cause\ndocuments of that subclass to no longer be found in the results of querying\nits parent class.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Canvas\n  include Mongoid::Document\n  field :name, type: String\n  embeds_many :shapes\nend\n\nclass Browser < Canvas\n  field :version, type: Integer\n  scope :recent, ->{ where(:version.gt => 3) }\nend\n\nclass Firefox < Browser\nend\n\nclass Shape\n  include Mongoid::Document\n  field :x, type: Integer\n  field :y, type: Integer\n  embedded_in :canvas\nend\n\nclass Circle < Shape\n  field :radius, type: Float\nend\n\nclass Rectangle < Shape\n  field :width, type: Float\n  field :height, type: Float\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Shape\n  include Mongoid::Document\n  field :x, type: Integer\n  field :y, type: Integer\n  embedded_in :canvas\n\n  self.discriminator_key = \"shape_type\"\nend\n\nclass Circle < Shape\n  field :radius, type: Float\nend\n\nclass Rectangle < Shape\n  field :width, type: Float\n  field :height, type: Float\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Shape\n  include Mongoid::Document\n  field :x, type: Integer\n  field :y, type: Integer\n  embedded_in :canvas\nend\n\nclass Circle < Shape\n  field :radius, type: Float\nend\n\nclass Rectangle < Shape\n  field :width, type: Float\n  field :height, type: Float\nend\n\nShape.discriminator_key = \"shape_type\""
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.discriminator_key = \"_the_type\"\n\nclass Shape\n  include Mongoid::Document\n  field :x, type: Integer\n  field :y, type: Integer\n  embedded_in :canvas\nend\n\nclass Circle < Shape\n  field :radius, type: Float\nend\n\nclass Rectangle < Shape\n  field :width, type: Float\n  field :height, type: Float\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Shape\n  include Mongoid::Document\n  field :x, type: Integer\n  field :y, type: Integer\n  embedded_in :canvas\nend\n\nclass Circle < Shape\n  field :radius, type: Float\n\n  self.discriminator_value = \"round thing\"\nend\n\nclass Rectangle < Shape\n  field :width, type: Float\n  field :height, type: Float\nend"
                },
                {
                    "lang": "ruby",
                    "value": "# Returns Canvas documents and subclasses\nCanvas.where(name: \"Paper\")\n# Returns only Firefox documents\nFirefox.where(name: \"Window 1\")"
                },
                {
                    "lang": "ruby",
                    "value": "firefox = Firefox.new\n# Builds a Shape object\nfirefox.shapes.build({ x: 0, y: 0 })\n# Builds a Circle object\nfirefox.shapes.build({ x: 0, y: 0 }, Circle)\n# Creates a Rectangle object\nfirefox.shapes.create({ x: 0, y: 0 }, Rectangle)\n\nrect = Rectangle.new(width: 100, height: 200)\nfirefox.shapes"
                },
                {
                    "lang": "ruby",
                    "value": "class Shape\n  include Mongoid::Document\n  store_in collection: :shapes\nend\n\nclass Circle < Shape\n  store_in collection: :circles\nend\n\nclass Square < Shape\n  store_in collection: :squares\nend\n\nShape.create!\nCircle.create!\nSquare.create!"
                },
                {
                    "lang": "javascript",
                    "value": "> db.shapes.find()\n{ \"_id\" : ObjectId(\"62fe9a493282a43d6b725e10\"), \"_type\" : \"Shape\" }\n> db.circles.find()\n{ \"_id\" : ObjectId(\"62fe9a493282a43d6b725e11\"), \"_type\" : \"Circle\" }\n> db.squares.find()\n{ \"_id\" : ObjectId(\"62fe9a493282a43d6b725e12\"), \"_type\" : \"Square\" }"
                }
            ],
            "preview": "Mongoid supports inheritance in both top level and embedded documents. When\na child document inherits from a parent document, the parent document's\nfields, associations, validations and scopes are copied to the child document.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/configuration",
            "title": "Configuration",
            "headings": [
                "Generating Default Configuration",
                "Loading Mongoid Configuration",
                "Mongoid Configuration Options",
                "Version Based Defaults",
                "ERb Preprocessing",
                "Logging",
                "In Ruby on Rails Application",
                "Standalone",
                "Time Zones",
                "Configuring SSLContext",
                "Client-Side Encryption",
                "Usage with Forking Servers",
                "Puma",
                "Unicorn",
                "Passenger",
                "Query Cache Middleware",
                "Development Configuration"
            ],
            "paragraphs": "Mongoid is customarily configured through a  mongoid.yml  file that specifies\noptions and clients. The simplest configuration is as follows, which configures\nMongoid to talk to a MongoDB server at \"localhost:27017\" and use the database\nnamed \"mongoid\". The top level key in the configuration file,  development  in the above\nexample, refers to the environment name which the application is executing in,\ni.e.  development ,  test  or  production . The third level key,\n default  in the above example, refers to the Mongo client name.\nMost applications will use a single client named  default . If you are using Ruby on Rails, you can have Mongoid generate a default\nconfiguration file for you by running the following command: The configuration file will be placed in  config/mongoid.yml . If you are not using Ruby on Rails, you can copy the minimal configuration\ngiven above and save it as  config/mongoid.yml . If you are using Ruby on Rails, Mongoid configuration is automatically loaded\nfor the current environment as stored in  Rails.env  when the application\nloads. You may need to configure the ORM for your application to be Mongoid by\nadding the following to  application.rb : If you are not using Ruby on Rails, Mongoid configuration must be loaded\nmanually. This can be done via the  Mongoid.load!  method, which takes\nthe configuration file path as its argument, as follows: When Mongoid is asked to automatically detect the environment name,\nit does so by examining the following sources, in order: It is also possible to configure Mongoid directly in Ruby, without using\na configuration file. This configuration style does not support the concept\nof environments - whatever configuration is provided, it is applied to the\ncurrent environment - but it does support defining multiple clients. If  Rails  top level constant is defined,  Rails.env . If  Sinatra  top level constant is defined,  Sinatra::Base.environment . The  RACK_ENV  environment variable. The  MONGOID_ENV  environment variable. Mongoid must be configured  before  any component of it is used or referenced.\nOnce a component is used or referenced, changing configuration may not apply\nchanges to already instantiated components. The following annotated example  mongoid.yml  demonstrates how Mongoid\ncan be configured. Mongoid delegates to the Ruby driver for client configuration. Please review\n the driver documentation \nfor details on driver options. Mongoid supports setting the configuration options to the defaults for specific\nversions. This is useful for upgrading to a new Mongoid version. When upgrading\nyour Mongoid version, the following should be set on  Mongoid::Config : This way, when upgrading to a new version of Mongoid, your code will run with\nthe configuration options from the previous version of Mongoid. Then,\none-by-one, you can change the feature flags for the new version, and test that\nyour code still acts as expected. Once all of the new feature flags have been\naccounted for, the call to  load_defaults  can be changed to take in the  new \nversion, and all of the changed feature flags can be removed. For example, say\nwe're upgrading from 7.5 to 8.0. Between these two versions, only two feature\nflags were added:  legacy_attributes  and  map_big_decimal_to_decimal128 .\nBefore upgrading to Mongoid 8, the following line can be added: Now, after upgrading, those two feature flags will default to their 7.5\nfunctionality ( legacy_attributes: true, map_big_decimal_to_decimal128: false ).\nNow you can set these feature flags one-by-one and flip them to their 8.0\nbehavior: It is advised to do these one at a time, so I have left the second flag\ncommented out. After verifying your code works as expected with the\n legacy_attributes  flag turned off, the  map_big_decimal_to_decimal128 \nsetting can be uncommented. Once that functionality is verified as well, both\nof those lines can be removed and the  load_defaults  replaced with: When loading a configuration file, Mongoid processes it with ERb before\nparsing it as YAML. This allows, for example, constructing the contents of\nthe configuration file at runtime based on environment variables: When outputting values from ERb, ensure the values are valid YAML and\nescape them as needed. Since ERb rendering is performed prior to YAML parsing, all ERb directives\nin the configuration file are evaluated, including those occurring in YAML\ncomments. When configuring logging, it is important to keep in mind that Mongoid\nprovides a model layer on top of the MongoDB Ruby driver, and the driver\ndispatches the CRUD operations to the MongoDB deployment. Therefore, some\nof the logging output in an application using Mongoid comes from Mongoid\nitself, and some comes from the driver. The Mongo client is a Ruby driver client instance, therefore\nthe logger of a Mongo client is the Ruby driver logger, not the Mongoid\nlogger. In other words: Depending on whether Mongoid is used in a Ruby on Rails application, and how\nboth Mongoid and Ruby driver are configured, they may use the same logger\ninstance or different instances, potentially with different configurations. When used in a Ruby on Rails application, Mongoid by default inherits\nthe logger and the log level from Rails, and sets the driver's logger\nto the same logger instance: To change the log level, use  standard Rails configuration .\nPlace the following in one of environment configuration files, such as\n config/environments/production.rb : To configure either Mongoid or driver logger differently from the Rails logger,\nuse an initializer as follows: The  log_level  Mongoid configuration option is not used when Mongoid operates\nin a Rails application, because Mongoid inherits Rails' log level in this case. There is currently no provision in the Ruby standard library  Logger \nto return the log device (i.e. the  IO  object) that a logger is using.\nTo have, for example, Mongoid and/or the Ruby driver log to the\nstandard Rails log file (e.g.  log/development.log ) but with a\ndifferent level from standard Rails logger ( Rails.logger ), the\nfile must be opened separately and the resulting  IO  object passed to\nthe  Logger  constructor. Since by default Mongoid sets its own logger and the driver's logger to the\nsame instance as the Rails logger, modifying any of the instances affects\nall of them. For example the following changes log level for all three\nloggers, unless the application assigned a separate  Logger  instance\nto  Mongo::Logger.logger  as described above: When not loaded in a Ruby on Rails application, Mongoid respects the\n log_level  top level configuration option. It can be given in the\nconfiguration file as follows: ... or when configuring Mongoid inline: The default log destination in Mongoid 7.1 and higher is standard error.\nThe default log destination in Mongoid 7.0 and lower is standard output.\nTo change the log destination, create a new logger instance as follows: To change the Ruby driver log level or destination: To set the driver logger to be the same as the Mongoid logger: Mongoid does not alter the driver's logger when running in\nstandalone mode. Ruby has limited time zone support in the standard library. ActiveSupport\n(which Mongoid depends on) offers more comprehensive time zone support.\nImportantly, Ruby and ActiveSupport may be configured with different default\ntime zones. While a thorough treatment of time zones in Ruby is outside the scope\nof this tutorial, the easiest and most reliable way of achieving correct\ntime zone handling is as follows: Applications using Mongoid should generally configure ActiveSupport's\ntime zone as described above, and then use  Time.zone  rather than  Time \n(for example,  Time.zone.now  instead of  Time.now ) to invoke the\nActiveSupport time zone machinery. This also helps achieve correct results\nwhen the system time zone is not UTC, as is common in development environments. Note that MongoDB stores all times in UTC without time zone information. Mongoid offers the following time zone-related configuration options: Note that  use_activesupport_time_zone  and  use_utc  options do not\nthrow away time zone information when it is available. For example, a Time\ninstance does have an associated time zone, and this time zone will be used\neven if it is different from ActiveSupport's configured time zone when\n use_activesupport_time_zone  is true. Set the operating system's time zone to UTC. For example, on Linux: Set ActiveSupport's time zone to UTC: Store and persist all times in UTC. Perform all calculations on times\nin UTC. When working with user input in local time, convert such user input to UTC\ntimes as soon as possible, and then work with the UTC times. When rendering or otherwise presenting times, convert them to local time\nafter performing all calculations, when actually rendering. Date to time (for example, the time when a particular day starts or ends)\nconversions are a common source of errors. Such conversions should generally\nbe performed while explicitly specifying the time zone in which the date\nis understood to be. use_activesupport_time_zone :\nThis option is deprecated and will be removed in Mongoid 9.0,\nalways behaving as true. If true (default), prefer to work with times using\n ActiveSupport::TimeWithZone . Values in fields of type  Time \nwill be returned as instances of  ActiveSupport::TimeWithZone .\nWhen parsing times without time zone information (such as when\nmongoizing strings or arrays to time), assume the times are specified\nin ActiveSupport's time zone. This is the default. If false, prefer to work with times using Ruby standard library  Time  class.\nValues in fields of type  Time  will be returned as  Time  instances.\nWhen parsing times without time zone information, assume the times\nare specified in the Ruby time zone. Note that the  use_activesupport_time_zone  setting does not affect\nfields of types  Date  or  DateTime , which use  Date  and\n DateTime  classes for their values, respectively. Also note that Mongoid may still utilize both  Time  and\n ActiveSupport::TimeWithZone  classes internally, as appropriate,\nregardless of the  use_activesupport_time_zone  setting. use_utc :\nIf true, times stored in MongoDB will be returned in UTC.\nIf false, times stored in MongoDB will be returned in local time\n(as instances of either  Time  or  ActiveSupport::TimeWithZone ,\nrespectively in the Ruby default time zone or the ActiveSupport time zone,\nbased on the value of  use_activesupport_time_zone  setting).\nThe default is false. The  use_utc  setting does not affect how times are parsed - parsing\nis always done in local time when the input being parsed does not\ninclude time zone information. To parse dates in UTC, set the\nsystem/Ruby or ActiveSupport time zone to UTC (as mentioned above,\nsetting all three to UTC leads to the fewest headaches). Setting  use_activesupport_time_zone  to true and  Time.zone  to\nUTC (and using ActiveSupport time machinery for all time-related\noperations) is recommended over setting  use_utc  to true. It may be desirable to further configure TLS options in your application, for\nexample by enabling or disabling certain ciphers. This can be done by setting TLS context hooks on the Ruby driver -- TLS context\nhooks are user-provided  Proc``s that will be invoked before any TLS socket\nconnection in the driver and can be used to modify the underlying\n``OpenSSL::SSL::SSLContext  object used by the socket. To set TLS context hooks, add  Proc``s to the ``Mongo.tls_context_hooks \narray. This can be done in an initializer. The example below adds a hook\nthat only enables the \"AES256-SHA\" cipher. Every  Proc  in  Mongo.tls_context_hooks  will be passed an\n OpenSSL::SSL::SSLContext  object as its sole argument. These procs will\nbe executed sequentially during socket creation. For more information about TLS context hooks, including best practices for\nassigning and removing them, see  the Ruby driver documentation . TLS context hooks are global and will affect all  Mongo::Client  instances\nin an application. When loading the configuration file, Mongoid permits the file to contain\n BSON::Binary  instances which are used for specifying  keyId  in\nthe schema map for  client-side encryption ,\nas the following example shows: When using Mongoid with a forking web server such as Puma, Unicorn or\nPassenger, it is recommended to not perform any operations on Mongoid models\nin the parent process prior to the fork. When a process forks, Ruby threads are not transferred to the child processes\nand the Ruby driver Client objects lose their background monitoring. The\napplication will typically seem to work just fine until the deployment\nstate changes (for example due to network errors, a maintenance event) at\nwhich point the application is likely to start getting  NoServerAvailable \nexception when performing MongoDB operations. If the parent process needs to perform operations on the MongoDB database,\nreset all clients in the workers after they forked. How to do so depends\non the web server being used. If the parent process does not need to perform operations on the MongoDB\ndatabase after child processes are forked, close the clients in the parent\nprior to forking children. If the parent process performs operations on a Mongo\nclient and does not close it, the parent process will continue consuming a\nconnection slot in the cluster and will continue monitoring the cluster for\nas long as the parent remains alive. The close/reconnect pattern described here should be used with Ruby driver\nversion 2.6.2 or higher. Previous driver versions did not recreate\nmonitoring threads when reconnecting. Use the  on_worker_boot  hook to reconnect clients in the workers and\nthe  before_fork  hook to close clients in the parent process\n( Puma documentation ): Use the  after_fork  hook to reconnect clients in the workers and\nthe  before_fork  hook to close clients in the parent process\n( Unicorn documentation ): Use the  starting_worker_process  hook to reconnect clients in the workers\n( Passenger documentation ).\nPassenger does not appear to have a hook that is invoked in the parent process\nbefore the workers are forked. Mongoid provides a Rack middleware which enables the  Query Cache  for the duration of each web request. Below is an example of\nhow to enable the Query Cache Middleware in a Ruby on Rails application: Please refer to the  Rails on Rack guide \nfor more information about using Rack middleware in Rails applications. When used with Ruby driver version 2.15 or newer, Mongoid's Query Cache\nMiddleware delegates to  the driver's Query Cache Middleware . Driver's default configuration is suitable for production deployment.\nIn development, some settings can be adjusted to provide a better developer\nexperience. Sample recommended development configuration: :server_selection_timeout : set this to a low value (e.g.,  1 )\nif your MongoDB server is running locally and you start it manually. A low\nserver selection timeout will cause the driver to fail quickly when there is\nno server running.",
            "code": [
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      database: mongoid\n      hosts:\n        - localhost:27017"
                },
                {
                    "lang": "bash",
                    "value": "rails g mongoid:config"
                },
                {
                    "lang": "ruby",
                    "value": "config.generators do |g|\n  g.orm :mongoid\nend"
                },
                {
                    "lang": "ruby",
                    "value": "# Use automatically detected environment name\nMongoid.load!(\"path/to/your/mongoid.yml\")\n\n# Specify environment name manually\nMongoid.load!(\"path/to/your/mongoid.yml\", :production)"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.clients.default = {\n    hosts: ['localhost:27017'],\n    database: 'my_db',\n  }\n\n  config.log_level = :warn\nend"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  # Configure available database clients. (required)\n  clients:\n    # Define the default client. (required)\n    default:\n      # A uri may be defined for a client:\n      # uri: 'mongodb://user:password@myhost1.mydomain.com:27017/my_db'\n      # Please see driver documentation for details. Alternatively, you can\n      # define the following:\n      #\n      # Define the name of the default database that Mongoid can connect to.\n      # (required).\n      database: my_db\n      # Provide the hosts the default client can connect to. Must be an array\n      # of host:port pairs. (required)\n      hosts:\n        - myhost1.mydomain.com:27017\n        - myhost2.mydomain.com:27017\n        - myhost3.mydomain.com:27017\n      options:\n        # These options are Ruby driver options, documented in\n        # https://mongodb.com/docs/ruby-driver/current/reference/create-client/\n\n        # Change the default write concern. (default = { w: 1 })\n        write:\n          w: 1\n\n        # Change the default read preference. Valid options for mode are: :secondary,\n        # :secondary_preferred, :primary, :primary_preferred, :nearest\n        # (default: primary)\n        read:\n          mode: :secondary_preferred\n          tag_sets:\n            - use: web\n\n        # The name of the user for authentication.\n        user: 'user'\n\n        # The password of the user for authentication.\n        password: 'password'\n\n        # The user's database roles.\n        roles:\n          - 'dbOwner'\n\n        # Change the default authentication mechanism. Please see the\n        # driver documentation linked above for details on how to configure\n        # authentication. Valid options are :aws, :gssapi, :mongodb_cr,\n        # :mongodb_x509, :plain, :scram and :scram256 (default on 3.0\n        # and higher servers is :scram, default on 2.6 servers is :plain)\n        auth_mech: :scram\n\n        # Specify the auth source, i.e. the database or other source which\n        # contains the user's login credentials. Allowed values for auth source\n        # depend on the authentication mechanism, as explained in the server documentation:\n        # https://mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource\n        # If no auth source is specified, the default auth source as\n        # determined by the driver will be used. Please refer to:\n        # https://mongodb.com/docs/ruby-driver/current/reference/authentication/#auth-source\n        auth_source: admin\n\n        # Connect directly to and perform all operations on the specified\n        # server, bypassing replica set node discovery and monitoring.\n        # Exactly one host address must be specified. (default: false)\n        #direct_connection: true\n\n        # Deprecated. Force the driver to connect in a specific way instead\n        # of automatically discovering the deployment type and connecting\n        # accordingly. To connect directly to a replica set node bypassing\n        # node discovery and monitoring, use direct_connection: true instead\n        # of this option. Possible values: :direct, :replica_set, :sharded.\n        # (default: none)\n        #connect: :direct\n\n        # Change the default time in seconds the server monitors refresh their status\n        # via hello commands. (default: 10)\n        heartbeat_frequency: 10\n\n        # The time in seconds for selecting servers for a near read preference. (default: 0.015)\n        local_threshold: 0.015\n\n        # The timeout in seconds for selecting a server for an operation. (default: 30)\n        server_selection_timeout: 30\n\n        # The maximum number of connections in the connection pool. (default: 5)\n        max_pool_size: 5\n\n        # The minimum number of connections in the connection pool. (default: 1)\n        min_pool_size: 1\n\n        # The time to wait, in seconds, in the connection pool for a connection\n        # to be checked in before timing out. (default: 1)\n        wait_queue_timeout: 1\n\n        # The time to wait to establish a connection before timing out, in seconds.\n        # (default: 10)\n        connect_timeout: 10\n\n        # How long to wait for a response for each operation sent to the\n        # server. This timeout should be set to a value larger than the\n        # processing time for the longest operation that will be executed\n        # by the application. Note that this is a client-side timeout;\n        # the server may continue executing an operation after the client\n        # aborts it with the SocketTimeout exception.\n        # (default: nil, meaning no timeout)\n        socket_timeout: 5\n\n        # The name of the replica set to connect to. Servers provided as seeds that do\n        # not belong to this replica set will be ignored.\n        replica_set: my_replica_set\n\n        # Whether to connect to the servers via ssl. (default: false)\n        ssl: true\n\n        # The certificate file used to identify the connection against MongoDB.\n        ssl_cert: /path/to/my.cert\n\n        # The private keyfile used to identify the connection against MongoDB.\n        # Note that even if the key is stored in the same file as the certificate,\n        # both need to be explicitly specified.\n        ssl_key: /path/to/my.key\n\n        # A passphrase for the private key.\n        ssl_key_pass_phrase: password\n\n        # Whether or not to do peer certification validation. (default: true)\n        ssl_verify: true\n\n        # The file containing a set of concatenated certification authority certifications\n        # used to validate certs passed from the other end of the connection.\n        ssl_ca_cert: /path/to/ca.cert\n\n        # Compressors to use. (default is to not use compression)\n        compressors: [zlib]\n\n  # Configure Mongoid-specific options. (optional)\n  options:\n    # Application name that is printed to the MongoDB logs upon establishing\n    # a connection in server versions 3.4 or greater. Note that the name\n    # cannot exceed 128 bytes in length. It is also used as the database name\n    # if the database name is not explicitly defined. (default: nil)\n    app_name: MyApplicationName\n\n    # Type of executor for queries scheduled using ``load_async`` method.\n    #\n    # There are two possible values for this option:\n    #\n    #   - :immediate - Queries will be immediately executed on a current thread.\n    #       This is the default option.\n    #   - :global_thread_pool - Queries will be executed asynchronously in\n    #       background using a thread pool.\n    #async_query_executor: :immediate\n\n    # Mark belongs_to associations as required by default, so that saving a\n    # model with a missing belongs_to association will trigger a validation\n    # error. (default: true)\n    belongs_to_required_by_default: true\n\n    # (Deprecated) Maintain broken behavior of sum over empty result sets for backwards\n    # compatibility. When calculating a sum on a field with a null context,\n    # for example:\n    #\n    # Product.none.sum(:price)\n    #\n    # ... return field name (`:price') instead of 0.\n    #\n    # When calculating a sum via a database query with an empty result set,\n    # for example:\n    #\n    # Product.where(impossible_condition: true).sum(:price)\n    #\n    # ... return nil instead of 0.\n    # (default: false)\n    #broken_aggregables: true\n\n    # (Deprecated) Ignore aliased fields in embedded documents when performing pluck and\n    # distinct operations, for backwards compatibility.\n    # (default: false)\n    #broken_alias_handling: true\n\n    # (Deprecated) Maintain broken `and' method behavior that existed in Mongoid 7.3\n    # and earlier for backwards compatibility: in some situations, conditions\n    # already present in a Criteria object would be replaced by newer\n    # conditions when `and' method is used instead of the new conditions\n    # being added to the existing conditions. This would happen when using\n    # the same operator on the same field multiple times. For example:\n    #\n    # Band.where(id: 1).and({year: {'$in' => [2020]}}, {year: {'$in' => [2021]}}).where(id: 2)\n    #\n    # yields the following criteria:\n    #\n    # <Mongoid::Criteria\n    # selector: {\"_id\"=>1, \"year\"=>{\"$in\"=>[2020]}, \"$and\"=>[{\"_id\"=>2}]}\n    # options:  {}\n    # class:    Band\n    # embedded: false>\n    #\n    # This is obviously incorrect as the {\"$in\"=>[2021]} clause is lost.\n    # Notice that the clause is only lost when both clauses are added using\n    # the #and method.\n    # (default: false)\n    #broken_and: true\n\n    # (Deprecated) When exiting a nested `with_scope' block, set the current scope to\n    # nil instead of the parent scope for backwards compatibility.\n    # (default: false)\n    #broken_scoping: true\n\n    # (Deprecated) Maintain broken update behavior in some cases for backwards\n    # compatibility.\n    #\n    # In Mongoid 7.3 and earlier, when assigning a value to an embedded\n    # document, then setting it to nil, then assigning the original value\n    # to it again, the second update would not work and the value for the\n    # embedded document would remain nil. Take this case:\n    #\n    # canvas.palette = palette\n    # canvas.palette = nil\n    # canvas.palette = palette\n    #\n    # ... where canvas embeds_one palette.\n    #\n    # In Mongoid 7.3 and earlier, canvas.palette would be nil when we would\n    # expect it to be palette. Set this option to true to keep this behavior,\n    # set the option to false to perform the second update correctly.\n    # (default: false)\n    #broken_updates: true\n\n    # (Deprecated) Time objects in Ruby have nanosecond precision, whereas MongoDB server\n    # can only store times with millisecond precision. Set this option to\n    # true to truncate times to millisecond precision when performing\n    # queries on already loaded embedded associations (this is also called\n    # \"embedded matching\" and is done completely in Ruby), to obtain the\n    # same query results when performing time comparisons regardless of\n    # which documents are being queried. Setting this option to false will\n    # produce different results for queries on embedded associations that\n    # are already loaded into memory vs queries on unloaded associations and\n    # top-level models. (default: true)\n    #compare_time_by_ms: false\n\n    # Set the global discriminator key. (default: \"_type\")\n    discriminator_key: \"_type\"\n\n    # Raise an exception when a field is redefined. (default: false)\n    duplicate_fields_exception: false\n\n    # Defines how many asynchronous queries can be executed concurrently.\n    # This option should be set only if `async_query_executor` option is set\n    # to `:global_thread_pool`.\n    #global_executor_concurrency: nil\n\n    # Include the root model name in json serialization. (default: false)\n    include_root_in_json: false\n\n    # Include the _type field in serialization. (default: false)\n    include_type_for_serialization: false\n\n    # Whether to join nested persistence contexts for atomic operations\n    # to parent contexts by default. (default: false)\n    join_contexts: false\n\n    # (Deprecated) When this flag is true, the attributes method on a document will return\n    # a BSON::Document when that document is retrieved from the database, and\n    # a Hash otherwise. When this flag is false, the attributes method will\n    # always return a Hash. (default: false)\n    #legacy_attributes: true\n\n    # (Deprecated) Maintain legacy behavior of pluck and distinct, which does not demongoize\n    # values on returning them. Setting this option to false will cause\n    # pluck and distinct to return demongoized values. Setting this option to\n    # false will also allow retrieving *_translations fields from pluck and\n    # distinct and will return embedded values themselves (i.e. without\n    # putting them in a hash).\n    # (default: false)\n    #legacy_pluck_distinct: true\n\n    # When this flag is false, a document will become read-only only once the\n    # #readonly! method is called, and an error will be raised on attempting\n    # to save or update such documents, instead of just on delete. When this\n    # flag is true, a document is only read-only if it has been projected\n    # using #only or #without, and read-only documents will not be\n    # deletable/destroyable, but will be savable/updatable.\n    # When this feature flag is turned on, the read-only state will be reset on\n    # reload, but when it is turned off, it won't be.\n    # (default: false)\n    #legacy_readonly: true\n\n    # (Deprecated) Maintain legacy behavior of === on Mongoid document classes, which\n    # returns true in a number of cases where Ruby's === implementation would\n    # return false. Note that the behavior of === on Mongoid document\n    # instances differs from both the behavior of === on document classes\n    # and from Ruby's behavior of === on simple object instances regardless\n    # of the value of this option.\n    # (default: false)\n    #legacy_triple_equals: true\n\n    # Set the Mongoid and Ruby driver log levels when Mongoid is not using\n    # Ruby on Rails logger instance. (default: :info)\n    log_level: :info\n\n    # When using the BigDecimal field type, store the value in the database\n    # as a BSON::Decimal128 instead of a string. (default: true)\n    #map_big_decimal_to_decimal128: true\n\n    # (Deprecated) Force ``BSON::ObjectId#as_json`` method to return the hash\n    # { \"$oid\" => id.to_s }. When this option is false, and bson-ruby 5\n    # is used, the return value will be the hexadecimal ObjectId string only.\n    # (default: false)\n    #object_id_as_json_oid: true\n\n    # (Deprecated) When chaining the same operators that use the same field, setting this\n    # feature flag to false will cause those operators to be combined using an\n    # and. Setting this feature flag to true will cause the later chained\n    # operators to overwrite the earlier ones. (default: false)\n    #overwrite_chained_operators: false\n\n    # Preload all models in development, needed when models use\n    # inheritance. (default: false)\n    preload_models: false\n\n    # Raise an error when performing a #find and the document is not found.\n    # (default: true)\n    raise_not_found_error: true\n\n    # Raise an error when defining a scope with the same name as an\n    # existing method. (default: false)\n    scope_overwrite_exception: false\n\n    # (Deprecated) Use ActiveSupport's time zone in time operations instead of\n    # the Ruby default time zone. See the time zone section below for\n    # further information. (default: true)\n    use_activesupport_time_zone: true\n\n    # Return stored times as UTC. See the time zone section below for\n    # further information. Most applications should not use this option.\n    # (default: false)\n    use_utc: false\n\n    # (Deprecated) In MongoDB 4.0 and earlier, set whether to create\n    # indexes in the background by default. (default: false)\n    background_indexing: false\n\n  # Configure driver-specific options. (optional)\n  driver_options:\n    # When this flag is turned off, inline options will be correctly\n    # propagated to Mongoid and Driver finder methods. When this flag is turned\n    # on those options will be ignored. For example, with this flag turned\n    # off, Band.all.limit(1).count will take the limit into account, while\n    # when this flag is turned on, that limit is ignored. The affected driver\n    # methods are: aggregate, count, count_documents, distinct, and\n    # estimated_document_count. The corresponding Mongoid methods are also\n    # affected. (default: false, driver version: 2.18.0+)\n    #broken_view_options: false\n\n    # Validates that there are no atomic operators (those that start with $)\n    # in the root of a replacement document, and that there are only atomic\n    # operators at the root of an update document. If this feature flag is on,\n    # an error will be raised on an invalid update or replacement document,\n    # if not, a warning will be output to the logs. This flag does not affect\n    # Mongoid as of 8.0, but will affect calls to driver update/replace\n    # methods. (default: false, driver version: 2.18.0+)\n    #validate_update_replace: false"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.load_defaults <OLD VERSION>\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.load_defaults 7.5\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.load_defaults 7.5\n  config.legacy_attributes = false\n  # config.map_big_decimal_to_decimal128 = true\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.load_defaults 8.0\nend"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      uri: \"<%= ENV['MONGODB_URI'] %>\""
                },
                {
                    "lang": "ruby",
                    "value": "# Ruby driver logger, not Mongoid logger\nMongoid.client(:default).logger"
                },
                {
                    "lang": "ruby",
                    "value": "Rails.logger === Mongoid.logger\n# => true\n\nMongoid.logger === Mongo::Logger.logger\n# => true"
                },
                {
                    "lang": "ruby",
                    "value": "Rails.application.configure do\n  config.log_level = :debug\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Rails.application.configure do\n  config.after_initialize do\n    # Change Mongoid log destination and/or level\n    Mongoid.logger = Logger.new(STDERR).tap do |logger|\n      logger.level = Logger::DEBUG\n    end\n\n    # Change driver log destination and/or level\n    Mongo::Logger.logger = Logger.new(STDERR).tap do |logger|\n      logger.level = Logger::DEBUG\n    end\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid::Logger.logger.level = Logger::DEBUG"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      # ...\n  options:\n    log_level: :debug"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.log_level = :debug\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.logger = Logger.new(STDERR).tap do |logger|\n  logger.level = Logger::DEBUG\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongo::Logger.logger = Logger.new(STDERR).tap do |logger|\n  logger.level = Logger::DEBUG\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Mongo::Logger.logger = Mongoid.logger"
                },
                {
                    "lang": "bash",
                    "value": "cp /usr/share/zoneinfo/UTC /etc/localtime"
                },
                {
                    "lang": "ruby",
                    "value": "# If using Rails, in application.rb:\nclass Application < Rails::Application\n  config.time_zone = 'UTC'\nend\n\n# If not using Rails:\nTime.zone = 'UTC'"
                },
                {
                    "lang": "ruby",
                    "value": "Mongo.tls_context_hooks.push(\n  Proc.new { |context|\n    context.ciphers = [\"AES256-SHA\"]\n  }\n)\n\n# Only the AES256-SHA cipher will be enabled from this point forward"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      database: blog_development\n      hosts: [localhost:27017]\n      options:\n        auto_encryption_options:\n          key_vault_namespace: 'keyvault.datakeys'\n          kms_providers:\n            local:\n              key: \"z7iYiYKLuYymEWtk4kfny1ESBwwFdA58qMqff96A8ghiOcIK75lJGPUIocku8LOFjQuEgeIP4xlln3s7r93FV9J5sAE7zg8U\"\n          schema_map:\n            blog_development.comments:\n              properties:\n                message:\n                  encrypt:\n                    keyId:\n                      - !ruby/object:BSON::Binary\n                        data: !binary |-\n                          R/AgNcxASFiiJWKXqWGo5w==\n                        type: :uuid\n                    bsonType: \"string\"\n                    algorithm: \"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\"\n              bsonType: \"object\""
                },
                {
                    "lang": "ruby",
                    "value": "on_worker_boot do\n  if defined?(Mongoid)\n    Mongoid::Clients.clients.each do |name, client|\n      client.close\n      client.reconnect\n    end\n  else\n    raise \"Mongoid is not loaded. You may have forgotten to enable app preloading.\"\n  end\nend\n\nbefore_fork do\n  if defined?(Mongoid)\n    Mongoid.disconnect_clients\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "after_fork do |server, worker|\n  if defined?(Mongoid)\n    Mongoid::Clients.clients.each do |name, client|\n      client.close\n      client.reconnect\n    end\n  else\n    raise \"Mongoid is not loaded. You may have forgotten to enable app preloading.\"\n  end\nend\n\nbefore_fork do |server, worker|\n  if defined?(Mongoid)\n    Mongoid.disconnect_clients\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "if defined?(PhusionPassenger)\n  PhusionPassenger.on_event(:starting_worker_process) do |forked|\n    if forked\n      Mongoid::Clients.clients.each do |name, client|\n        client.close\n        client.reconnect\n      end\n    end\n  end\nend"
                },
                {
                    "lang": "ruby",
                    "value": "# config/application.rb\n\n# Add Mongoid::QueryCache::Middleware at the bottom of the middleware stack\n# or before other middleware that queries MongoDB.\nconfig.middleware.use Mongoid::QueryCache::Middleware"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  clients:\n    default:\n      database: mongoid\n      hosts:\n        - localhost:27017\n      options:\n        server_selection_timeout: 1"
                }
            ],
            "preview": "Mongoid is customarily configured through a mongoid.yml file that specifies\noptions and clients. The simplest configuration is as follows, which configures\nMongoid to talk to a MongoDB server at \"localhost:27017\" and use the database\nnamed \"mongoid\".",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/queries",
            "title": "Queries",
            "headings": [
                "Condition Syntax",
                "Field Syntax",
                "MQL Syntax",
                "Symbol Operator Syntax",
                "Embedded Documents",
                "Field Types",
                "Aliases",
                "Logical Operations",
                "Operator Combinations",
                "and Behavior",
                "any_of Behavior",
                "none_of Behavior",
                "not Behavior",
                "Incremental Query Construction",
                "Merge Strategies",
                "Supported Operator Methods",
                "Operator Value Expansion",
                "Query Methods",
                "elem_match",
                "Projection",
                "only",
                "without",
                "Ordering",
                "Pagination",
                "limit",
                "skip",
                "batch_size",
                "Finding By _id",
                "Additional Query Methods",
                "Eager Loading",
                "Regular Expressions",
                "Conditions On Fields",
                "Scoping",
                "Named Scopes",
                "Default Scopes",
                "Runtime Default Scope Override",
                "Class Methods",
                "Queries + Persistence",
                "Query Cache",
                "Enabling Query Cache",
                "Enabling Query Cache Automatically",
                "Enabling Query Cache Manually",
                "Caching the Result of #first",
                "Asynchronous Queries",
                "Configuring asynchronous query execution"
            ],
            "paragraphs": "Mongoid provides a rich query DSL inspired by ActiveRecord. A trivial query\nlooks as follows: A more complex query utilizing various Mongoid features could be as follows: The query methods return  Mongoid::Criteria  objects, which are chainable\nand lazily evaluated wrappers for MongoDB query language (MQL).\nThe queries are executed when their result sets are iterated. For example: Methods like  first  and  last  return the individual documents immediately.\nOtherwise, iterating a Criteria object with methods like  each  or  map \nretrieves the documents from the server.  to_a  can be used to force\nexecution of a query that returns an array of documents, literally converting\na Criteria object to an Array. When a query method is called on a Criteria instance, the method returns a new\nCriteria instance with the new conditions added to the existing conditions: Mongoid supports three ways of specifying individual conditions: All syntaxes support querying embedded documents using the dot notation.\nAll syntaxes respect field types, if the field being queried is defined in the\nmodel class, and field aliases. The examples in this section use the following model definition: Field syntax. MQL syntax. Symbol operator syntax. The simplest querying syntax utilizes the basic Ruby hashes. Keys can be\nsymbols or strings, and correspond to field names in MongoDB documents: An MQL operator may be specified on any field using the hash syntax: MQL operators may be specified as methods on symbols for the respective field\nname, as follows: To match values of fields of embedded documents, use the dot notation: Queries always return top-level model instances, even if all of the\nconditions are referencing embedded documents. In order to query on a field, it is not necessary to add the field to\n the model class definition . However, if a field is defined in\nthe model class, the type of the field is taken into account when constructing\nthe query: Queries take into account  storage field names \nand  field aliases : Since  id  and  _id  fields are aliases, either one can be used for queries: Mongoid supports  and ,  or ,  nor  and  not  logical operations on\n Criteria  objects. These methods take one or more hash of conditions\nor another  Criteria  object as their arguments, with  not  additionally\nhaving an argument-free version. For backwards compatibility with earlier Mongoid versions, all of the logical\noperation methods also accept arrays of parameters, which will be flattened\nto obtain the criteria. Passing arrays to logical operations is deprecated and\nmay be removed in a future version of Mongoid. The following calls all produce the same query conditions: As of Mongoid 7.1, logical operators ( and ,  or ,  nor  and  not )\nhave been changed to have the the same semantics as  those of ActiveRecord .\nTo obtain the semantics of  or  as it behaved in Mongoid 7.0 and earlier,\nuse  any_of  which is described below. When conditions are specified on the same field multiple times, all\nconditions are added to the criteria: any_of ,  none_of ,  nor  and  not  behave similarly, with  not  producing\ndifferent query shapes as described below. When  and ,  or  and  nor  logical operators are used, they\noperate on the criteria built up to that point and its argument.\n where  has the same meaning as  and : The  and  method will add new simple conditions to the top level of the\ncriteria, unless the receiving criteria already has a condition on the\nrespective fields, in which case the conditions will be combined with  $and . As of Mongoid 7.1, specifying multiple criteria on the same field with  and \ncombines all criteria so specified, whereas in previous versions of Mongoid\nconditions on a field sometimes replaced previously specified conditions on\nthe same field, depending on which form of  and  was used. or / nor  Behavior\n_---------------------- or  and  nor  produce  $or  and  $nor  MongoDB operators, respectively,\nusing the receiver and all of the arguments as operands. For example: If the only condition on the receiver is another  or / nor , the new\nconditions are added to the existing list: Use  any_of  to add a disjunction to a Criteria object while maintaining\nall of the conditions built up so far as they are. any_of  adds a disjunction built from its arguments to the existing\nconditions in the criteria. For example: The conditions are hoisted to the top level if possible: none_of  adds a negated disjunction (\"nor\") built from its arguments to\nthe existing conditions in the criteria. For example: not  method can be called without arguments, in which case it will negate\nthe next condition that is specified.  not  can also be called with one\nor more hash conditions or  Criteria  objects, which will all be negated and\nadded to the criteria. Similarly to  and ,  not  will negate individual conditions for simple\nfield criteria. For complex conditions and when a field already has a condition\ndefined on it, since MongoDB server only supports the  $not  operator on\na per-field basis rather than globally, Mongoid emulates  $not  by using\nan  {'$and' => [{'$nor' => ...}]}  construct: If using  not  with arrays or regular expressions, please note the\ncaveats/limitations of  $not   stated in the MongoDB server documentation . $not  in MongoDB server cannot be used with a string argument.\nMongoid uses  $ne  operator to achieve such a negation: By default, when conditions are added to a query, Mongoid considers each\ncondition complete and independent from any other conditions potentially\npresent in the query. For example, calling  in  twice adds two separate\n $in  conditions: Some operator methods support building the condition incrementally. In this\ncase, when an condition on a field which uses one of the supported operators\nis being added, if there already is a condition on the same field using the\nsame operator, the operator expressions are combined according to the\nspecified  merge strategy . Mongoid provides three merge strategies: The following snippet demonstrates all of the strategies, using  in  as the\nexample operator: The strategy is requested by calling  override ,  intersect  or  union \non a  Criteria  instance. The requested strategy applies to the next\ncondition method called on the query. If the next condition method called does\nnot support merge strategies, the strategy is reset, as shown in the following\nexample: Since  ne  does not support merge strategies, the  union  strategy was\nignored and reset and when  in  was invoked the second time there was no\nstrategy active. Override : the new operator instance replaces any existing conditions on\nthe same field using the same operator. Intersect : if there already is a condition using the same operator on the\nsame field, the values of the existing condition are intersected with the\nvalues of the new condition and the result is stored as the operator value. Union : if there already is a condition using the same operator on the\nsame field, the values of the new condition are added to the values of the\nexisting condition and the result is stored as the operator value. Merge strategies currently assume the previous condition(s) have been added\nto the top level of the query, however this is not always the case\n(conditions may be nested under an  $and  clause). Using merge strategies\nwith complex criteria may cause incorrect queries to be constructed.\nThis misbehavior is  intended to be fixed in the future . The following operator methods support merge strategies: The set of methods may be expanded in future releases of Mongoid. For\nfuture compatibility, only invoke a strategy method when the next method call\nis an operator that supports merge strategies. Note that the merge strategies are currently only applied when conditions are\nadded through the designated methods. In the following example merge strategy\nis not applied because the second condition is added via  where , not via\n in : This behavior may change in a future release of Mongoid and should not be\nrelied upon. In contrast, it does not matter how the existing query was built when a\nmerge strategy-supporting operator method is invoked. In the following\nexample, the first condition was added through  where  but the strategy\nmechanism still applies: all in nin Operator methods that support merge strategies all take  Array  as their value\ntype. Mongoid expands  Array -compatible types, such as a  Range ,\nwhen they are used with these operator methods: Additionally, Mongoid has historically wrapped non- Array  values in arrays,\nas the following example demonstrates: This matcher finds documents with array fields where one of the array values\nmatches all of the conditions. For example: elem_match  also works with embedded associations: elem_match  does not work with non-embedded associations because MongoDB\ndoes not have joins - the conditions would be added to the collection\nthat is the source of a non-embedded association rather than the collection\nof the association's target. elem_match  can also be used with recursively embedded associations,\nas the following example shows: Mongoid provides two projection operators:  only  and  without . The  only  method retrieves only the specified fields from the database. This\noperation is sometimes called \"projection\". Attempting to reference attributes which have not been loaded results in\n ActiveModel::MissingAttributeError . Even though Mongoid currently allows writing to attributes that have not\nbeen loaded, such writes will not be persisted\n( MONGOID-4701 ) and\nshould therefore be avoided. only  can also be used with embedded associations: only  can be specified with referenced associations (has_one, has_many,\nhas_and_belongs_to_many) but is currently ignored for referenced associations -\nall fields of referenced associations will be loaded\n( MONGOID-4704 ). Note that if a document has  has_one  or  has_and_belongs_to_many  associations,\nthe fields with foreign keys must be included in the list of attributes\nloaded with  only  for those associations to be loaded. For example: Server versions 4.2 and lower allowed projecting both an association and\nthe association's fields in the same query, as follows: The most recent projection specification overrides the earlier one.\nFor example, the above query was equivalent to: Server versions 4.4 and higher prohibit specifying an association and its\nfields in projection in the same query. The opposite of  only ,  without  causes the specified fields to be omitted: Because Mongoid requires the  _id  field for various operations, it (as well\nas its  id  alias) cannot be omitted via  without : Mongoid provides the  order  method on  Criteria  objects and its alias,\n order_by , to specify the ordering of documents. These methods take a\nhash indicating which fields to order the documents by, and whether to use\nascending or descending order for each field. The direction may be specified as integers  1  and  -1  for ascending\nand descending, respectively, or as symbols  :asc  and  :desc , or as\nstrings  \"asc\"  and  \"desc\" . Alternatively,  order  accepts an array of two-element arrays specifying\nthe ordering. Field names and directions may be strings or symbols. Another way of providing the order is to use  #asc  and  #desc  methods\non symbols, as follows: The arguments can be provided as a string using SQL syntax: Finally, there are  asc  and  desc  methods that can be used instead of\n order / order_by : order  calls can be chained, in which case the oldest calls define the\nmost significant criteria and the newest calls define the least significant\nones (since in Ruby hashes maintain the order of their keys): This can sometimes lead to surprising results if there are scopes, including\nthe default scope, that use  order / order_by . For example, in the\nfollowing snippet bands are ordered by name first because the order in the\ndefault scope takes precedence over the order given in the query, due to\nthe default scope being evaluated first: Mongoid provides the pagination operators  limit ,  skip , and  batch_size  on  Criteria . limit  sets the total number of documents to be returned by a query: skip  (alias:  offset ) sets the number of query results to skip\nbefore returning documents. The  limit  value, if specified, will be applied\nafter documents are skipped. When performing pagination,  skip  is recommended\nto be combined with  ordering  to ensure consistent results. When executing large queries, or when iterating over query results with an enumerator method such as\n Criteria#each , Mongoid automatically uses the  MongoDB getMore command  to load results in batches.\nThe default  batch_size  is 1000, however you may set it explicitly: Mongoid provides the  find  method on  Criteria  objects to find documents\nby their  _id  values: The  find  method performs type conversion, if necessary, of the argument\nto the type declared in the model being queried for the  _id  field.\nBy default, the  _id  type is  BSON::ObjectId , thus the query above\nis equivalent to: The  find  method can accept multiple arguments, or an array of arguments.\nIn either case each of the arguments or array elements is taken to be an  _id \nvalue, and documents with all of the specified  _id  values are returned in\nan array: If the same  _id  value is given more than once, the corresponding document\nis only returned once: The documents returned are  not  ordered, and may be returned in a different\norder from the order of provided  _id  values, as illustrated in the above\nexamples. If any of the  _id  values are not found in the database, the behavior of\n find  depends on the value of the  raise_not_found_error  configuration\noption. If the option is set to  true ,  find  raises\n Mongoid::Errors::DocumentNotFound  if any of the  _id``s are not found.\nIf the option is set to ``false  and  find  is given a single  _id  to\nfind and there is no matching document,  find  returns  nil . If the\noption is set to  false  and  find  is given an array of ids to find\nand some are not found, the return value is an array of documents that were\nfound (which could be empty if no documents were found at all). When querying collections directly using the driver, type conversion is not\nautomatically performed: Mongoid also has some helpful methods on criteria. Operation Example Criteria#count Get the total number of documents matching a filter, or the total\nnumber of documents in a collection. Note this will always hit\nthe database for the count. As of Mongoid 7.2, the   count   method uses the \n count_documents   driver helper to obtain the accurate count.\npreviously the   count   driver helper was used which used\ncollection metadata and was thus not necessarily accurate (but\nmay have returned the result faster). Use   estimated_count \n method to obtain an approximate number of documents in the collection\nquickly. Criteria#estimated_count Get an approximate number of documents in the collection using the\ncollection metadata. The   estimated_count   method does not accept\nquery conditions; if any are given, it will raise \n Mongoid::Errors::InvalidEstimatedCountCriteria .\n If a model defines a default scope,   estimated_count   must be\ncalled on the unscoped model . Criteria#distinct Get a list of distinct values for a single field. Note this will always hit\nthe database for the distinct values. This method accepts the dot notation, thus permitting referencing\nfields in embedded associations. This method respects :ref:`field aliases <field-aliases>`,\nincluding those defined in embedded documents. Criteria#each Iterate over all matching documents in the criteria. Criteria#exists? Determine if any matching documents exist. Will return true if there\nare 1 or more. #exists?   now takes a number of argument types: Hash :  A hash of conditions. Object :  An _id to search for. false / nil :  Always returns false. Criteria#fifth Get the fifth document for the given criteria. This method automatically adds a sort on _id if no sort is given. Criteria#fifth! Get the fifth document for the given criteria, or raise an error if\nnone exist. This method automatically adds a sort on _id if no sort is given. Criteria#find_by Find a document by the provided attributes. If not found,\nraise an error or return nil depending on the value of the \n raise_not_found_error   configuration option. Criteria#find_or_create_by Find a document by the provided attributes, and if not found\ncreate and return a newly persisted one. Note that attributes provided in the arguments to\nthis method will override any set in ``create_with`` . find_or_create_by  can be used on any scope, but in this case\nthe criteria given by the scope and by  find_or_create_by  are\ncombined. The following creates three bands: Criteria#find_or_initialize_by Find a document by the provided attributes, and if not found\nreturn a new one. Criteria#first|last Finds a single document given the provided criteria. Get a list of\ndocuments by passing in a limit argument. This method automatically adds\na sort on _id. This can cause performance issues, so if the sort is\nundesirable, Criteria#take can be used instead. Criteria#first!|last! Finds a single document given the provided criteria, or raises an error\nif none are found. This method automatically adds a sort on _id if no\nsort is given. This can cause performance issues, so if the sort is\nundesirable, Criteria#take! can be used instead. Criteria#first_or_create Find the first document by the provided attributes, and if not found\ncreate and return a newly persisted one. Criteria#first_or_create! Find the first document by the provided attributes, and if not found\ncreate and return a newly persisted one using   create! . Criteria#first_or_initialize Find the first document by the provided attributes, and if not found\nreturn a new one. Criteria#for_js Find documents for a provided JavaScript expression, optionally with\nthe specified variables added to the evaluation scope. The scope\nargument is supported in MongoDB 4.2 and lower. \n In MongoDB 3.6 and higher, prefer   $expr   over   for_js . Criteria#fourth Get the fourth document for the given criteria. This method automatically adds a sort on _id if no sort is given. Criteria#fourth! Get the fourth document for the given criteria, or raise an error if\nnone exist. This method automatically adds a sort on _id if no sort is given. Criteria#length|size Same as count but caches subsequent calls to the database Criteria#pick Get the values from one document for the provided fields.\nReturns nil for unset fields and for non-existent fields. This method does not apply a sort to the documents, so it\nwill not necessarily return the values from the first document. This method accepts the dot notation, thus permitting referencing\nfields in embedded associations. This method respects :ref:`field aliases <field-aliases>`,\nincluding those defined in embedded documents. Criteria#pluck Get all the values for the provided field.\nReturns nil for unset fields and for non-existent fields. This method accepts the dot notation, thus permitting referencing\nfields in embedded associations. This method respects :ref:`field aliases <field-aliases>`,\nincluding those defined in embedded documents. Criteria#second Get the second document for the given criteria. This method automatically adds a sort on _id if no sort is given. Criteria#second! Get the second document for the given criteria, or raise an error if\nnone exist. This method automatically adds a sort on _id if no sort is given. Criteria#second_to_last Get the second to last document for the given criteria. This method automatically adds a sort on _id if no sort is given. Criteria#second_to_last! Get the second to last document for the given criteria, or raise an\nerror if none exist. This method automatically adds a sort on _id if no sort is given. Criteria#take Get a list of n documents from the database or just one if no parameter\nis provided. This method does not apply a sort to the documents, so it can return\ndifferent document(s) than #first and #last. Criteria#take! Get a document from the database or raise an error if none exist. This method does not apply a sort to the documents, so it can return\ndifferent document(s) than #first and #last. Criteria#tally Get a mapping of values to counts for the provided field. This method accepts the dot notation, thus permitting referencing\nfields in embedded associations. This method respects :ref:`field aliases <field-aliases>`,\nincluding those defined in embedded documents. Criteria#third Get the third document for the given criteria. This method automatically adds a sort on _id if no sort is given. Criteria#third! Get the third document for the given criteria, or raise an error if\nnone exist. This method automatically adds a sort on _id if no sort is given. Criteria#third_to_last Get the third to last document for the given criteria. This method automatically adds a sort on _id if no sort is given. Criteria#third_to_last! Get the third to last document for the given criteria, or raise an\nerror if none exist. This method automatically adds a sort on _id if no sort is given. Mongoid provides a facility to eager load documents\nfrom associations to prevent the n+1 issue when\niterating over documents with association access. Eager loading is supported on\nall associations with the exception of polymorphic  belongs_to \nassociations. MongoDB, and Mongoid, allow querying documents by regular expressions. Given the following model definitions: ... we can query using simple Ruby regular expressions in a natural way: It is also possible to query using PCRE syntax by constructing\n BSON::Regexp::Raw  objects explicitly: When a condition uses a field defined in the model, the value being specified\nin the condition is converted according to the rules of the field, if any.\nFor example, consider the following model definition that contains a  Time \nfield, a  Date  field and an implicit  Object  field, and also\nintentionally does not define a field called  deregistered_at : Queries on  born_on  and  registered_at  fields using  Date  and  Time \nvalues, respectively, are straightforward: But, note the differences in behavior when providing a  Date  instance\nin all possible scenarios: When using the  registered_at  field which is of type  Time , the date\nwas interpreted to be in local time (as per the  configured time zone ). When using the  born_on  field which is of type  Date ,\nthe date was interpreted to be in UTC. When using the  voted_at  field\nwhich was defined without a type (hence implicitly as an  Object ),\nthe date was used unmodified in the constructed query. When using a\nnonexistent field  deregistered_at  the date was interpreted to be in UTC\nand converted to a time, matching the behavior of querying a  Date  field. Scopes provide a convenient way to reuse common criteria with more\nbusiness domain style syntax. Named scopes are simply criteria defined at class load that are referenced\nby a provided name. Just like normal criteria, they are lazy and chainable. Named scopes can take procs and blocks for accepting parameters or\nextending functionality. By default, Mongoid allows defining a scope that would shadow an existing\nclass method, as the following example shows: To have Mongoid raise an error when a scope would overwrite an existing class\nmethod, set the  scope_overwrite_exception   configuration option  to  true . Default scopes can be useful when you find yourself applying the same\ncriteria to most queries, and wish to specify these criteria as the default.\nDefault scopes are procs that return criteria objects. Specifying a default scope also initializes the fields of new models to\nthe values given in the default scope, if the values are simple literals: Note that if a default value is provided both in the field definition and\nin the default scope, the value in the default scope takes precedence: Because a default scope initializes fields in new models as just described,\ndefining a default scope with a dotted key and a simple literal value, while\npossible, is not recommended: Mongoid 8 allows dotted keys to be used in Mongoid, and when creating a document,\nthe scope is added as a dotted key in the attributes: Whereas when querying, Mongoid looks for an embedded document: A workaround is to define the default scope as a complex query: You can tell Mongoid not to apply the default scope by using\n unscoped , which can be inline or take a block. You can also tell Mongoid to explicitly apply the default scope\nagain later to always ensure it's there. If you are using a default scope on a model that is part of an association,\nyou must reload the association to have scoping reapplied.\nThis is important to note if you change a value of a document in the association\nthat would affect its visibility within the scoped association. After the default scope is applied, it is no longer distinguished from\nother query conditions. This can lead to surprising behavior when using\n or  and  nor  operators in particular: In the last example, you might expect the two conditions\n( active: true  and  touring: true ) to be combined with an  $and ,\nbut because the  Band  class already has the scope applied to it,\nit becomes one of the disjunction branches of the  or . You can use the  with_scope  method to change the default scope in a block\nat runtime: If with_scope calls are nested, when the nested with_scope block completes\nMongoid 7 sets the current scope to nil instead of the parent scope.\nMongoid 8 will set the current scope to the correct parent scope.\nTo get Mongoid 8 behavior in Mongoid 7.4 and higher, set the\n Mongoid.broken_scoping  global option to false. Class methods on models that return criteria objects are also\ntreated like scopes, and can be chained as well. Mongoid supports persistence operations off of criteria\nin a light capacity for when you want to expressively perform multi\ndocument inserts, updates, and deletion. Criteria ordering and pagination conditions, including  order ,  limit ,\n offset , and  batch_size , will be ignored on the following operations. Operation Example Criteria#create Create a newly persisted document. Criteria#create! Create a newly persisted document and raise an exception on validation failure. Criteria#build|new Create a new (unsaved) document. Criteria#update Update attributes of the first matching document. Criteria#update_all Update attributes of all matching documents. Criteria#add_to_set Perform an $addToSet on all matching documents. Criteria#bit Perform a $bit on all matching documents. Criteria#inc Perform an $inc on all matching documents. Criteria#pop Perform a $pop on all matching documents. Criteria#pull Perform a $pull on all matching documents. Criteria#pull_all Perform a $pullAll on all matching documents. Criteria#push Perform a $push on all matching documents. Criteria#push_all Perform a $push with $each on all matching documents. Criteria#rename Perform a $rename on all matching documents. Criteria#set Perform a $set on all matching documents. Criteria#unset Perform a $unset on all matching documents. Criteria#delete Deletes all matching documents in the database. Criteria#destroy Deletes all matching documents in the database while running callbacks for all.\nThis loads all documents into memory and can be an expensive operation. The Ruby MongoDB driver provide query caching functionality. When enabled, the\nquery cache saves the results of previously executed find and aggregation\nqueries and reuses them in the future instead of performing the queries again,\nthus increasing application performance and reducing database load. The query cache has historically been provided by Mongoid but as of driver\nversion 2.14.0, the query cache implementation has been moved into the driver.\nWhen Mongoid is used with driver version 2.14.0 or later, Mongoid delegates\nall work to the driver's query cache implementation. Please review the  driver query cache documentation \nfor details about the driver's query cache behavior. The rest of this section assumes that driver 2.14.0 or later is being used and\nMongoid delegates to the driver's query cache. The query cache may be enabled by using the driver's namespace or Mongoid's\nnamespace. The MongoDB Ruby Driver provides middleware to automatically enable the query cache for\nRack web requests and ActiveJob job runs. Please see the  Query Cache Rack Middleware  section on the configuration page for instructions. Note that the Query Cache Middleware does not apply to code executed outside web requests\nand/or jobs. To enable the Query Cache manually for a code segment, use: The Query Cache can also be explicitly enabled and disabled, although we\nrecommend to use the block form described above: Calling the  first  method on a model class imposes an ascending sort by\nthe  _id  field on the underlying query. This may produce unexpected behavior\nwith query caching. For example, when calling  all  on a model class and then  first ,\none would expect the second query to use the cached results from the first.\nHowever, because of the sort imposed on the second query, both methods\nwill query the database and separately cache their results. To use the cached results, call  all.to_a.first  on the model class. Mongoid allows running database queries asynchronously in the background.\nThis can be beneficial when there is a need to get documents from different\ncollections. In order to schedule an asynchronous query call the  load_async  method on a\n Criteria : In the above example three queries will be scheduled for asynchronous execution.\nResults of the queries can be later accessed as usual: Even if a query is scheduled for asynchronous execution, it might be executed\nsynchronously on the caller's thread. There are three possible scenarios depending\non when the query results are being accessed: If the scheduled asynchronous task has been already executed, the results are returned. If the task has been started, but not finished yet, the caller's thread blocks until the task is finished. If the task has not been started yet, it is removed from the execution queue, and the query is executed synchronously on the caller's thread. Even though  load_async  method returns a  Criteria  object, you should not\ndo any operations on this object except accessing query results. The query is\nscheduled for execution immediately after calling  load_async , therefore\nlater changes to the  Criteria  object may not be applied. Asynchronous queries are disabled by default. When asynchronous queries are\ndisabled,  load_async  will execute the query immediately on the current thread,\nblocking as necessary. Therefore, calling  load_async  on criteria in this case\nis roughly the equivalent of calling  to_a  to force query execution. In order to enable asynchronous query execution, the following config options\nmust be set:",
            "code": [
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Depeche Mode\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.\n  where(:founded.gte => \"1980-01-01\").\n  in(name: [ \"Tool\", \"Deftones\" ]).\n  union.\n  in(name: [ \"Melvins\" ])"
                },
                {
                    "lang": "ruby",
                    "value": "# Construct a Criteria object:\n\nBand.where(name: 'Deftones')\n# => #<Mongoid::Criteria\n#   selector: {\"name\"=>\"Deftones\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\n# Evaluate the query and get matching documents:\n\nBand.where(name: 'Deftones').to_a\n# => [#<Band _id: 5ebdeddfe1b83265a376a760, name: \"Deftones\", description: nil>]"
                },
                {
                    "lang": "ruby",
                    "value": "scope = Band.where(:founded.gte => \"1980-01-01\")\n# => #<Mongoid::Criteria\n#   selector: {\"founded\"=>{\"$gte\"=>\"1980-01-01\"}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nscope.where(:founded.lte => \"2020-01-01\")\n# => #<Mongoid::Criteria\n#   selector: {\"founded\"=>{\"$gte\"=>\"1980-01-01\", \"$lte\"=>\"2020-01-01\"}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nscope\n# => #<Mongoid::Criteria\n#   selector: {\"founded\"=>{\"$gte\"=>\"1980-01-01\"}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  field :founded, type: Integer\n  field :m, as: :member_count, type: Integer\n\n  embeds_one :manager\nend\n\nclass Manager\n  include Mongoid::Document\n\n  embedded_in :band\n\n  field :name, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Depeche Mode\")\n#   => #<Mongoid::Criteria\n#   selector: {\"name\"=>\"Depeche Mode\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\n# Equivalent to:\n\nBand.where(\"name\" => \"Depeche Mode\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(founded: {'$gt' => 1980})\n# => #<Mongoid::Criteria\n#   selector: {\"founded\"=>{\"$gt\"=>1980}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\n# Equivalent to:\n\nBand.where('founded' => {'$gt' => 1980})"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(:founded.gt => 1980)\n# => #<Mongoid::Criteria\n#   selector: {\"founded\"=>{\"$gt\"=>1980}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where('manager.name' => 'Smith')\n# => #<Mongoid::Criteria\n#   selector: {\"manager.name\"=>\"Smith\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(:'manager.name'.ne => 'Smith')\n# => #<Mongoid::Criteria\n#   selector: {\"manager.name\"=>{\"$ne\"=>\"Smith\"}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: 2020)\n#   => #<Mongoid::Criteria\n#   selector: {\"name\"=>\"2020\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(founded: 2020)\n# => #<Mongoid::Criteria\n#   selector: {\"founded\"=>2020}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: 'Astral Projection')\n#   => #<Mongoid::Criteria\n#   selector: {\"n\"=>\"Astral Projection\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(id: '5ebdeddfe1b83265a376a760')\n# => #<Mongoid::Criteria\n#   selector: {\"_id\"=>BSON::ObjectId('5ebdeddfe1b83265a376a760')}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "# and with conditions\nBand.where(label: 'Trust in Trance').and(name: 'Astral Projection')\n\n# or with scope\nBand.where(label: 'Trust in Trance').or(Band.where(name: 'Astral Projection'))\n\n# not with conditions\nBand.not(label: 'Trust in Trance', name: 'Astral Projection')\n\n# argument-less not\nBand.not.where(label: 'Trust in Trance', name: 'Astral Projection')"
                },
                {
                    "lang": "ruby",
                    "value": "# Condition hashes passed to separate and invocations\nBand.and(name: 'SUN Project').and(member_count: 2)\n\n# Multiple condition hashes in the same and invocation\nBand.and({name: 'SUN Project'}, {member_count: 2})\n\n# Multiple condition hashes in an array - deprecated\nBand.and([{name: 'SUN Project'}, {member_count: 2}])\n\n# Condition hash in where and a scope\nBand.where(name: 'SUN Project').and(Band.where(member_count: 2))\n\n# Condition hash in and and a scope\nBand.and({name: 'SUN Project'}, Band.where(member_count: 2))\n\n# Scope as an array element, nested arrays - deprecated\nBand.and([Band.where(name: 'SUN Project'), [{member_count: 2}]])\n\n# All produce:\n# => #<Mongoid::Criteria\n#   selector: {\"name\"=>\"SUN Project\", \"member_count\"=>2}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: 1).where(name: 2).selector\n# => {\"name\"=>\"1\", \"$and\"=>[{\"name\"=>\"2\"}]}\n\nBand.where(name: 1).or(name: 2).selector\n# => {\"$or\"=>[{\"name\"=>\"1\"}, {\"name\"=>\"2\"}]}"
                },
                {
                    "lang": "ruby",
                    "value": "# or joins the two conditions\nBand.where(name: 'Sun').or(label: 'Trust').selector\n# => {\"$or\"=>[{\"name\"=>\"Sun\"}, {\"label\"=>\"Trust\"}]}\n\n# or applies only to the first condition, the second condition is added\n# to the top level as $and\nBand.or(name: 'Sun').where(label: 'Trust').selector\n# => {\"$or\"=>[{\"name\"=>\"Sun\"}], \"label\"=>\"Trust\"}\n\n# Same as previous example - where and and are aliases\nBand.or(name: 'Sun').and(label: 'Trust').selector\n# => {\"$or\"=>[{\"name\"=>\"Sun\"}], \"label\"=>\"Trust\"}\n\n# Same operator can be stacked any number of times\nBand.or(name: 'Sun').or(label: 'Trust').selector\n# => {\"$or\"=>[{\"name\"=>\"Sun\"}, {\"label\"=>\"Trust\"}]}\n\n# The label: Foo condition is added to the top level as $and\nBand.where(name: 'Sun').or(label: 'Trust').where(label: 'Foo').selector\n# => {\"$or\"=>[{\"name\"=>\"Sun\"}, {\"label\"=>\"Trust\"}], \"label\"=>\"Foo\"}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(label: 'Trust in Trance').and(name: 'Astral Projection').selector\n# => {\"label\"=>\"Trust in Trance Records\", \"name\"=>\"Astral Projection\"}\n\nBand.where(name: /Best/).and(name: 'Astral Projection').selector\n# => {\"name\"=>/Best/, \"$and\"=>[{\"name\"=>\"Astral Projection\"}]}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: /Best/).or(name: 'Astral Projection')\n# => {\"$or\"=>[{\"name\"=>/Best/}, {\"name\"=>\"Astral Projection\"}]}\n\nBand.where(name: /Best/).and(name: 'Astral Projection').\n  or(Band.where(label: /Records/)).and(label: 'Trust').selector\n# => {\"$or\"=>[{\"name\"=>/Best/, \"$and\"=>[{\"name\"=>\"Astral Projection\"}]}, {\"label\"=>/Records/}], \"label\"=>\"Trust\"}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: /Best/).or(name: 'Astral Projection').\n  or(Band.where(label: /Records/)).selector\n# => {\"$or\"=>[{\"name\"=>/Best/}, {\"name\"=>\"Astral Projection\"}, {\"label\"=>/Records/}]}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(label: /Trust/).any_of({name: 'Astral Projection'}, {name: /Best/})\n# => {\"label\"=>/Trust/, \"$or\"=>[{\"name\"=>\"Astral Projection\"}, {\"name\"=>/Best/}]}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(label: /Trust/).any_of({name: 'Astral Projection'})\n# => {\"label\"=>/Trust/, \"name\"=>\"Astral Projection\"}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(label: /Trust/).none_of({name: 'Astral Projection'}, {name: /Best/})\n# => {\"label\"=>/Trust/, \"$nor\"=>[{\"name\"=>\"Astral Projection\"}, {\"name\"=>/Best/}]}"
                },
                {
                    "lang": "ruby",
                    "value": "# not negates subsequent where\nBand.not.where(name: 'Best').selector\n# => {\"name\"=>{\"$ne\"=>\"Best\"}}\n\n# The second where is added as $and\nBand.not.where(name: 'Best').where(label: /Records/).selector\n# => {\"name\"=>{\"$ne\"=>\"Best\"}, \"label\"=>/Records/}\n\n# not negates its argument\nBand.not(name: 'Best').selector\n# => {\"name\"=>{\"$ne\"=>\"Best\"}}"
                },
                {
                    "lang": "ruby",
                    "value": "# Simple condition\nBand.not(name: /Best/).selector\n# => {\"name\"=>{\"$not\"=>/Best/}}\n\n# Complex conditions\nBand.where(name: /Best/).not(name: 'Astral Projection').selector\n# => {\"name\"=>/Best/, \"$and\"=>[{\"$nor\"=>[{\"name\"=>\"Astral Projection\"}]}]}\n\n# Symbol operator syntax\nBand.not(:name.ne => 'Astral Projection')\n# => #<Mongoid::Criteria\n#   selector: {\"$and\"=>[{\"$nor\"=>[{\"name\"=>{\"$ne\"=>\"Astral Projection\"}}]}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "# String negation - uses $ne\nBand.not.where(name: 'Best').selector\n# => {\"name\"=>{\"$ne\"=>\"Best\"}}\n\n# Regexp negation - uses $not\nBand.not.where(name: /Best/).selector\n# => {\"name\"=>{\"$not\"=>/Best/}}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.in(name: ['a']).in(name: ['b'])\n=> #<Mongoid::Criteria\n  selector: {\"name\"=>{\"$in\"=>[\"a\"]}, \"$and\"=>[{\"name\"=>{\"$in\"=>[\"b\"]}}]}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.in(name: ['a']).override.in(name: ['b'])\n=> #<Mongoid::Criteria\n  selector: {\"name\"=>{\"$in\"=>[\"b\"]}}\n  options:  {}\n  class:    Band\n  embedded: false>\n\nBand.in(name: ['a', 'b']).intersect.in(name: ['b', 'c'])\n=> #<Mongoid::Criteria\n  selector: {\"name\"=>{\"$in\"=>[\"b\"]}}\n  options:  {}\n  class:    Band\n  embedded: false>\n\nBand.in(name: ['a']).union.in(name: ['b'])\n=> #<Mongoid::Criteria\n  selector: {\"name\"=>{\"$in\"=>[\"a\", \"b\"]}}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.in(name: ['a']).union.ne(name: 'c').in(name: ['b'])\n=> #<Mongoid::Criteria\n  selector: {\"name\"=>{\"$in\"=>[\"a\"], \"$ne\"=>\"c\"}, \"$and\"=>[{\"name\"=>{\"$in\"=>[\"b\"]}}]}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.in(foo: ['a']).union.where(foo: {'$in' => 'b'})\n=> #<Mongoid::Criteria\n  selector: {\"foo\"=>{\"$in\"=>[\"a\"]}, \"$and\"=>[{\"foo\"=>{\"$in\"=>\"b\"}}]}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(foo: {'$in' => ['a']}).union.in(foo: ['b'])\n=> #<Mongoid::Criteria\n  selector: {\"foo\"=>{\"$in\"=>[\"a\", \"b\"]}}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.in(year: 1950..1960)\n=> #<Mongoid::Criteria\n  selector: {\"year\"=>{\"$in\"=>[1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960]}}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.in(year: 1950)\n=> #<Mongoid::Criteria\n  selector: {\"year\"=>{\"$in\"=>[1950]}}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :tours, type: Array\nend\n\naerosmith = Band.create!(name: 'Aerosmith', tours: [\n  {city: 'London', year: 1995},\n  {city: 'New York', year: 1999},\n])\n\nBand.elem_match(tours: {city: 'London'}).to_a # => [aerosmith]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  embeds_many :tours\nend\n\nclass Tour\n  include Mongoid::Document\n  field :city, type: String\n  field :year, type: Integer\n  embedded_in :band\nend\n\ndm = Band.create!(name: 'Depeche Mode')\naerosmith = Band.create!(name: 'Aerosmith')\nTour.create!(band: aerosmith, city: 'London', year: 1995)\nTour.create!(band: aerosmith, city: 'New York', year: 1999)\n\nBand.elem_match(tours: {city: 'London'}).to_a # => [aerosmith]"
                },
                {
                    "lang": "ruby",
                    "value": "class Tag\n  include Mongoid::Document\n  field :name, type: String\n  recursively_embeds_many\nend\n\nroot = Tag.create!(name: 'root')\nsub1 = Tag.new(name: 'sub1', child_tags: [Tag.new(name: 'subsub1')])\nroot.child_tags << sub1\nroot.child_tags << Tag.new(name: 'sub2')\nroot.save!\n\nTag.elem_match(child_tags: {name: 'sub1'}).to_a # => [root]\n\nroot.child_tags.elem_match(child_tags: {name: 'subsub1'}).to_a # => [sub1]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  field :label, type: String\n\n  embeds_many :tours\nend\n\nclass Tour\n  include Mongoid::Document\n\n  field :city, type: String\n  field :year, type: Integer\n\n  embedded_in :band\nend\n\nband = Band.only(:name).first"
                },
                {
                    "lang": "ruby",
                    "value": "band.label\n# ActiveModel::MissingAttributeError (Missing attribute: 'label'.)"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.only(:name, 'tours.year').last\n# => #<Band _id: 5c59afb1026d7c034dba46ac, name: \"Aerosmith\">\n\nband.tours.first\n# => #<Tour _id: 5c59afdf026d7c034dba46af, city: nil, year: 1995>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n\n  has_and_belongs_to_many :managers\nend\n\nclass Manager\n  include Mongoid::Document\n\n  has_and_belongs_to_many :bands\nend\n\nband = Band.create!(name: 'Astral Projection')\nband.managers << Manager.new\n\nBand.where(name: 'Astral Projection').only(:name).first.managers\n# => []\n\nBand.where(name: 'Astral Projection').only(:name, :manager_ids).first.managers\n# => [#<Manager _id: 5c5dc2f0026d7c1730969843, band_ids: [BSON::ObjectId('5c5dc2f0026d7c1730969842')]>]"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.only(:tours, 'tours.year').last"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.only('tours.year').last"
                },
                {
                    "lang": "ruby",
                    "value": "Band.without(:name)\n# =>\n# #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:fields=>{\"name\"=>0}}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.without(:name, :id)\n# =>\n# #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:fields=>{\"name\"=>0}}\n#   class:    Band\n#   embedded: false>\n\nBand.without(:name, :_id)\n# =>\n# #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:fields=>{\"name\"=>0}}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.order(name: 1)\n# => #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:sort=>{\"name\"=>1}}\n#   class:    Band\n#   embedded: false>\n\nBand.order_by(name: -1, description: 1)\n# => #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:sort=>{\"name\"=>-1, \"description\"=>1}}\n#   class:    Band\n#   embedded: false>\n\nBand.order_by(name: :desc, description: 'asc')\n# => #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:sort=>{\"name\"=>-1, \"description\"=>1}}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.order([['name', 'desc'], ['description', 'asc']])\n\nBand.order([[:name, :desc], [:description, :asc]])"
                },
                {
                    "lang": "ruby",
                    "value": "Band.order(:name.desc, :description.asc)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.order('name desc, description asc')"
                },
                {
                    "lang": "ruby",
                    "value": "Band.asc('name').desc('description')\n# => #<Mongoid::Criteria\n  selector: {}\n  options:  {:sort=>{\"name\"=>1, \"description\"=>-1}}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.order('name desc').order('description asc')\n# => #<Mongoid::Criteria\n  selector: {}\n  options:  {:sort=>{\"name\"=>-1, \"description\"=>1}}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  field :year, type: Integer\n\n  default_scope -> { order(name: :asc) }\nend\n\nBand.order(year: :desc)\n# => #<Mongoid::Criteria\n  selector: {}\n  options:  {:sort=>{\"name\"=>1, \"year\"=>-1}}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.limit(5)\n# =>\n# #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:limit=>5}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.skip(10)\n# =>\n# #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:skip=>10}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.batch_size(500)\n# =>\n# #<Mongoid::Criteria\n#   selector: {}\n#   options:  {:batch_size=>500}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find('5f0e41d92c97a64a26aabd10')\n# => #<Band _id: 5f0e41d92c97a64a26aabd10, name: \"Juno Reactor\">"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find(BSON::ObjectId.from_string('5f0e41d92c97a64a26aabd10'))\n# => #<Band _id: 5f0e41d92c97a64a26aabd10, name: \"Juno Reactor\">"
                },
                {
                    "lang": "ruby",
                    "value": "Band.collection.find(_id: BSON::ObjectId.from_string('5f0e41d92c97a64a26aabd10')).first\n# => {\"_id\"=>BSON::ObjectId('5f0e41d92c97a64a26aabd10'), \"name\"=>\"Juno Reactor\"}\n\nBand.collection.find(_id: '5f0e41d92c97a64a26aabd10').first\n# => nil"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find('5f0e41d92c97a64a26aabd10', '5f0e41b02c97a64a26aabd0e')\n# => [#<Band _id: 5f0e41b02c97a64a26aabd0e, name: \"SUN Project\", description: nil, likes: nil>,\n  #<Band _id: 5f0e41d92c97a64a26aabd10, name: \"Juno Reactor\", description: nil, likes: nil>]\n\nBand.find(['5f0e41d92c97a64a26aabd10', '5f0e41b02c97a64a26aabd0e'])\n# => [#<Band _id: 5f0e41b02c97a64a26aabd0e, name: \"SUN Project\", description: nil, likes: nil>,\n  #<Band _id: 5f0e41d92c97a64a26aabd10, name: \"Juno Reactor\", description: nil, likes: nil>]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find('5f0e41b02c97a64a26aabd0e', '5f0e41b02c97a64a26aabd0e')\n# => [#<Band _id: 5f0e41b02c97a64a26aabd0e, name: \"SUN Project\", description: nil, likes: nil>]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.count\nBand.where(name: \"Photek\").count"
                },
                {
                    "lang": "ruby",
                    "value": "Band.count\nBand.where(name: \"Photek\").count\n\nclass Contract\n  include Mongoid::Document\n\n  field :active, type: Boolean\n\n  default_scope -> { where(active: true) }\nend\n\nContract.estimated_count\n# => raises Mongoid::Errors::InvalidEstimatedCountCriteria\n\nContract.unscoped.estimated_count\n# => 0"
                },
                {
                    "lang": "ruby",
                    "value": "Band.distinct(:name)\nBand.where(:fans.gt => 100000).\n  distinct(:name)\n\nBand.distinct('cities.name')\n\n# Assuming an aliased field:\nclass Manager\n  include Mongoid::Document\n  embedded_in :band\n  field :name, as: :n\nend\n\n# Expands out to \"managers.name\" in the query:\nBand.distinct('managers.n')"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(members: 1).each do |band|\n  p band.name\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.exists?\nBand.where(name: \"Photek\").exists?\nBand.exists?(name: \"Photek\")\nBand.exists?(BSON::ObjectId('6320d96a3282a48cfce9e72c'))\nBand.exists?('6320d96a3282a48cfce9e72c')\nBand.exists?(false)\nBand.exists?(nil)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.fifth"
                },
                {
                    "lang": "ruby",
                    "value": "Band.fifth!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find_by(name: \"Photek\")\n\nBand.find_by(name: \"Tool\") do |band|\n  band.impressions += 1\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find_or_create_by(name: \"Photek\")\nBand.where(:likes.gt => 10).find_or_create_by(name: \"Photek\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find_or_create_by(name: \"Photek\")\nBand.where(name: \"Photek\").find_or_create_by(name: \"Aerosmith\")\n# creates Aerosmith again because there is no band whose name\n# is Photek and Aerosmith at the same time\nBand.where(name: \"Photek\").find_or_create_by(name: \"Aerosmith\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.find_or_initialize_by(name: \"Photek\")\nBand.where(:likes.gt => 10).find_or_initialize_by(name: \"Photek\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.first\nBand.where(:members.with_size => 3).first\nBand.where(:members.with_size => 3).last\nBand.first(2)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.first!\nBand.where(:members.with_size => 3).first!\nBand.where(:members.with_size => 3).last!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").first_or_create"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").first_or_create!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").first_or_initialize"
                },
                {
                    "lang": "ruby",
                    "value": "# All MongoDB versions\nBand.for_js(\"this.name = 'Tool'\")\n\n# MongoDB 4.2 and lower\nBand.for_js(\"this.name = param\", param: \"Tool\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.fourth"
                },
                {
                    "lang": "ruby",
                    "value": "Band.fourth!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.length\nBand.where(name: \"FKA Twigs\").size"
                },
                {
                    "lang": "ruby",
                    "value": "Band.all.pick(:name)\n\nBand.all.pick('cities.name')\n\n# Using the earlier definition of Manager,\n# expands out to \"managers.name\" in the query:\nBand.all.pick('managers.n')"
                },
                {
                    "lang": "ruby",
                    "value": "Band.all.pluck(:name)\n  #=> [\"Daft Punk\", \"Aphex Twin\", \"Ween\"]\n\nBand.all.pluck('address.city')\n  #=> [\"Paris\", \"Limerick\", \"New Hope\"]\n\n# Using the earlier definition of Manager,\n# expands out to \"managers.name\" in the query:\nBand.all.pluck('managers.n')\n  #=> [ [\"Berry Gordy\", \"Tommy Mottola\"], [], [\"Quincy Jones\"] ]\n\n# Accepts multiple field arguments, in which case\n# the result will be returned as an Array of Arrays.\nBand.all.pluck(:name, :likes)\n  #=> [ [\"Daft Punk\", 342], [\"Aphex Twin\", 98], [\"Ween\", 227] ]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.second"
                },
                {
                    "lang": "ruby",
                    "value": "Band.second!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.second_to_last"
                },
                {
                    "lang": "ruby",
                    "value": "Band.second_to_last!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.take\nBand.take(5)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.take!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.all.tally(:name)\n\nBand.all.tally('cities.name')\n\n# Using the earlier definition of Manager,\n# expands out to \"managers.name\" in the query:\nBand.all.tally('managers.n')"
                },
                {
                    "lang": "ruby",
                    "value": "Band.third"
                },
                {
                    "lang": "ruby",
                    "value": "Band.third!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.third_to_last"
                },
                {
                    "lang": "ruby",
                    "value": "Band.third_to_last!"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  has_many :albums\nend\n\nclass Album\n  include Mongoid::Document\n  belongs_to :band\nend\n\nBand.includes(:albums).each do |band|\n  p band.albums.first.name # Does not hit the database again.\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, type: String\n  field :description, type: String\nend\n\nBand.create!(name: 'Sun Project', description: \"Sun\\nProject\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: /project/i).first\n# => #<Band _id: 5dc9f7d5ce4ef34893354323, name: \"Sun Project\", description: \"Sun\\nProject\">"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(description: /\\AProject/).first\n# => #<Band _id: 5dc9f7d5ce4ef34893354323, name: \"Sun Project\", description: \"Sun\\nProject\">\n\nBand.where(description: BSON::Regexp::Raw.new('^Project')).first\n# => nil\n\nBand.where(description: BSON::Regexp::Raw.new('^Project', 'm')).first\n# => #<Band _id: 5dc9f7d5ce4ef34893354323, name: \"Sun Project\", description: \"Sun\\nProject\">"
                },
                {
                    "lang": "ruby",
                    "value": "class Voter\n  include Mongoid::Document\n\n  field :born_on, type: Date\n  field :registered_at, type: Time\n  field :voted_at\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Voter.where(born_on: Date.today).selector\n# => {\"born_on\"=>2020-12-18 00:00:00 UTC}\n\nVoter.where(registered_at: Time.now).selector\n# => {\"registered_at\"=>2020-12-19 04:33:36.939788067 UTC}"
                },
                {
                    "lang": "ruby",
                    "value": "Voter.where(born_on: Date.today).selector\n# => {\"born_on\"=>2020-12-18 00:00:00 UTC}\n\nVoter.where(registered_at: Date.today).selector\n# => {\"registered_at\"=>2020-12-18 00:00:00 -0500}\n\nVoter.where(voted_at: Date.today).selector\n# => {\"voted_at\"=>Fri, 18 Dec 2020}\n\nVoter.where(deregistered_at: Date.today).selector\n# => {\"deregistered_at\"=>2020-12-18 00:00:00 UTC}"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :country, type: String\n  field :genres, type: Array\n\n  scope :english, ->{ where(country: \"England\") }\n  scope :rock, ->{ where(:genres.in => [ \"rock\" ]) }\nend\n\nBand.english.rock # Get the English rock bands."
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :country, type: String\n  field :active, type: Boolean, default: true\n\n  scope :named, ->(name){ where(name: name) }\n  scope :active, ->{\n    where(active: true) do\n      def deutsch\n        tap do |scope|\n          scope.selector.store(\"origin\" => \"Deutschland\")\n        end\n      end\n    end\n  }\nend\n\nBand.named(\"Depeche Mode\") # Find Depeche Mode.\nBand.active.deutsch # Find active German bands."
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n\n  def self.fresh\n    true\n  end\n\n  scope :fresh, ->{ where(fresh: true) }\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :active, type: Boolean\n\n  default_scope ->{ where(active: true) }\nend\n\nBand.each do |band|\n  # All bands here are active.\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :active, type: Boolean\n  field :num_tours, type: Integer\n\n  default_scope ->{ where(active: true, num_tours: {'$gt' => 1}) }\nend\n\n# active is set, num_tours is not set\nBand.new # => #<Band _id: 5c3f7452ce4ef378295ca5f5, name: nil, active: true, num_tours: nil>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :active, type: Boolean, default: true\n\n  default_scope ->{ where(active: false) }\nend\n\nBand.new # => #<Band _id: 5c3f74ddce4ef3791abbb088, name: nil, active: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :tags, type: Hash\n\n  default_scope ->{ where('tags.foo' => 'bar') }\nend\n\nBand.create!\n# => Created document: {\"_id\"=>BSON::ObjectId('632de48f3282a404bee1877b'), \"tags.foo\"=>\"bar\"}\nBand.create!(tags: { 'foo' => 'bar' })\n# => Created document: {\"_id\"=>BSON::ObjectId('632de4ad3282a404bee1877c'), \"tags.foo\"=>\"bar\", \"tags\"=>{\"foo\"=>\"bar\"}}\nBand.all.to_a\n# => [ #<Band _id: 632de4ad3282a404bee1877c, tags: {\"foo\"=>\"bar\"}> ]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.new.attribute\n# => {\"_id\"=>BSON::ObjectId('632de97d3282a404bee1877d'), \"tags.foo\"=>\"bar\"}"
                },
                {
                    "lang": "ruby",
                    "value": "Band.create!\n# => Created document: {\"_id\"=>BSON::ObjectId('632de48f3282a404bee1877b'), \"tags.foo\"=>\"bar\"}\nBand.where\n# => #<Mongoid::Criteria\n       selector: {\"tags.foo\"=>\"bar\"}\n       options:  {}\n       class:    Band\n       embedded: false>\n# This looks for something like: { tags: { \"foo\" => \"bar\" } }\nBand.count\n# => 0"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :tags, type: Hash\n\n  default_scope ->{ where('tags.foo' => {'$eq' => 'bar'}) }\nend\n\nBand.create!(tags: { hello: 'world' })\nBand.create!(tags: { foo: 'bar' })\n# does not add a \"tags.foo\" dotted attribute\nBand.count\n# => 1"
                },
                {
                    "lang": "ruby",
                    "value": "Band.unscoped.where(name: \"Depeche Mode\")\nBand.unscoped do\n  Band.where(name: \"Depeche Mode\")\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.unscoped.where(name: \"Depeche Mode\").scoped"
                },
                {
                    "lang": "ruby",
                    "value": "class Label\n  include Mongoid::Document\n  embeds_many :bands\nend\n\nclass Band\n  include Mongoid::Document\n  field :active, default: true\n  embedded_in :label\n  default_scope ->{ where(active: true) }\nend\n\nlabel.bands.push(band)\nlabel.bands # [ band ]\nband.update_attribute(:active, false)\nlabel.bands # [ band ] Must reload.\nlabel.reload.bands # []"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name\n  field :active\n  field :touring\n\n  default_scope ->{ where(active: true) }\nend\n\nBand.where(name: 'Infected Mushroom')\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"active\"=>true, \"name\"=>\"Infected Mushroom\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(name: 'Infected Mushroom').or(touring: true)\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$or\"=>[{\"active\"=>true, \"name\"=>\"Infected Mushroom\"}, {\"touring\"=>true}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.or(touring: true)\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$or\"=>[{\"active\"=>true}, {\"touring\"=>true}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :country, type: String\n  field :genres, type: Array\n\n  scope :english, ->{ where(country: \"England\") }\nend\n\ncriteria = Band.with_scope(Band.english) do\n  Band.all\nend\n\ncriteria\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"country\"=>\"England\"}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :active, type: Boolean, default: true\n\n  def self.active\n    where(active: true)\n  end\nend\n\nBand.active"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").create"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").create!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").build\nBand.where(name: \"Photek\").new"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").update(label: \"Mute\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(members: 2).update_all(label: \"Mute\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").add_to_set(label: \"Mute\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").bit(likes: { and: 14, or: 4 })"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").inc(likes: 123)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Photek\").pop(members: -1)\nBand.where(name: \"Photek\").pop(members: 1)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").pull(members: \"Maynard\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").\n  pull_all(:members, [ \"Maynard\", \"Danny\" ])"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").push(members: \"Maynard\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").\n  push_all(members: [ \"Maynard\", \"Danny\" ])"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").rename(name: :title)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").set(likes: 10000)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(name: \"Tool\").unset(:likes)"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(label: \"Mute\").delete"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(label: \"Mute\").destroy"
                },
                {
                    "lang": "ruby",
                    "value": "Mongo::QueryCache.cache do\n  # ...\nend"
                },
                {
                    "lang": "ruby",
                    "value": "begin\n  Mongo::QueryCache.enabled = true\n  # ...\nensure\n  Mongo::QueryCache.enabled = false\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.all.to_a\n#=> Queries the database and caches the results\n\nBand.first\n#=> Queries the database again because of the sort"
                },
                {
                    "lang": "ruby",
                    "value": "class PagesController < ApplicationController\n  def index\n    @active_bands = Band.where(active: true).load_async\n    @best_events = Event.best.load_async\n    @public_articles = Article.where(public: true).load_async\n  end\nend"
                },
                {
                    "lang": "html",
                    "value": "<ul>\n  <%- @active_bands.each do -%>\n    <li><%= band.name %></li>\n  <%- end -%>\n</ul>"
                },
                {
                    "lang": "yaml",
                    "value": "development:\n  ...\n  options:\n    # Execute asynchronous queries using a global thread pool.\n    async_query_executor: :global_thread_pool\n    # Number of threads in the pool. The default is 4.\n    # global_executor_concurrency: 4"
                }
            ],
            "preview": "Mongoid provides a rich query DSL inspired by ActiveRecord. A trivial query\nlooks as follows:",
            "tags": null,
            "facets": null
        },
        {
            "slug": "release-notes/mongoid-7.4",
            "title": "Mongoid 7.4",
            "headings": [
                "Ruby Version Support",
                "Support for MongoDB 3.4 and Earlier Servers Deprecated",
                "Feature Flags Summary",
                "Change === Operator To Match Ruby Semantics",
                "Return String _id Value (Hexadecimal) from BSON::ObjectId#as_json",
                "Scoped Associations",
                "Compare Times With Millisecond Precision When Embedded Matching",
                "count, sum, avg, min, max Ignore Sort If Not Limiting/Skipping",
                "Return 0 When Aggregating Empty Result Sets",
                "Correct Update Behavior When Replacing Association",
                "Correct Logical and Query Generation",
                "Restore Parent Scope When Exiting with_scope Block",
                "Changes to distinct and pluck",
                "Respect Field Aliases In Embedded Documents When Using distinct and pluck",
                "Demongoize Values Returned from pluck and distinct",
                "Localized Fields with pluck and distinct",
                "Embedded Fields with pluck",
                "update_one Warnings in upsert"
            ],
            "paragraphs": "This page describes significant changes and improvements in Mongoid 7.4.\nThe complete list of releases is available  on GitHub  and  in JIRA ;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes. All behavior changes in Mongoid 7.4 must be explicitly requested by changing\nthe value of configuration options as detailed below. By default,\nMongoid 7.4 behaves the same as Mongoid 7.3. As of version 7.4, Mongoid supports Ruby 2.5+.\nSupport for Ruby 2.4 and earlier has been dropped. Mongoid 7.4 deprecates support for MongoDB 3.4 and earlier.\nMongoid 8 will require MongoDB 3.6 or newer. To ensure a stable upgrade path from Mongoid 7.3, Mongoid 7.4\nintroduces feature flags which are further explained in the\nsections below. To enable all new behavior in Mongoid 7.4, please use the following\n configuration options  in your mongoid.yml file.\nWe recommend newly created apps to do this as well. In Mongoid 7.4, the  ===  operator on  Mongoid::Document  classes and\ninstances can be configured to behave the same way as it does in Ruby,\nand is equivalent to calling  is_a?  on the right hand\nside with the left hand side as the argument: In order to get this functionality, the  Mongoid.legacy_triple_equals \noption must be set to false. If it is set to true, which is the default for\nMongoid 7.4, the  ===  operator will function as it did in Mongoid 7.3:\n ===  returned  true  for some cases when the equivalent Ruby\n ===  implementation returned false, as per the examples below. Mongoid 7.4 with  Mongoid.legacy_triple_equals  set to  false  behavior: Mongoid 7.3 and 7.4 with  Mongoid.legacy_triple_equals  set to  true \nbehavior: The standard invocation of  === , that is having the class on the left and\nthe instance on the right, works the same in Mongoid 7.4 as it did previously\nand matches the core Ruby behavior: In Mongoid 8.0, the default value of the  Mongoid.legacy_triple_equals  option will\nchange to  false . Mongoid 7.4 permits configuring the  BSON::ObjectId#as_json  method\nto return the  _id  value as a hexadecimal string instead of the\n {\"$oid\" => \"...\"}  hash it has returned in Mongoid 7.3 and previous\nversions. When  Mongoid.object_id_as_json_oid  is set to  false , Mongoid will\ndelegate to  bson-ruby  implementation of  BSON::ObjectId#as_json .\nIn  bson-ruby  4 the  BSON::ObjectId#as_json  method will continue\nto return the hash  {\"$oid\" => \"...\"}  for backwards compatibility, but\nin  bson-ruby  5 the  BSON::ObjectId#as_json  method will return only\nthe hexadecimal ObjectId string. When  Mongoid.object_id_as_json_oid  is set to  true , Mongoid will\ninstall an implementation of  BSON::ObjectId#as_json  which returns\nthe hash  {\"$oid\" => \"...\"}  as it did in Mongoid 7.3 and earlier. The behavior of  as_json  is summarized in the following table: Mongoid.object_id_as_json_oid  value true false bson-ruby  4 {\"$oid\"=>\"621ed7fda15d5d231594627c\"} {\"$oid\"=>\"621ed7fda15d5d231594627c\"} bson-ruby  5 {\"$oid\"=>\"621ed7fda15d5d231594627c\"} \"621ed7fda15d5d231594627c\" In Mongoid 8.0, the default value of the  Mongoid.object_id_as_json_oid  option will\nchange to  false . Associations now support the  :scope  argument, yielding\n scoped associations . Mongoid 7.4 with the  Mongoid.compare_time_by_ms  option set to  true \nwill truncate the times to millisecond precision when comparing them while\nperforming embedded matching. Time objects in Ruby have nanosecond precision, whereas MongoDB server\ncan only store times with millisecond precision. Set the\n Mongoid.compare_time_by_ms  option to  true  to truncate times to\nmillisecond precision when performing queries on already loaded embedded\nassociations (this is also called \"embedded matching\" and is done completely\nin Ruby), to obtain the same query results when performing time comparisons\nregardless of which documents are being queried. Setting this option to\n false  will produce different results for queries on embedded associations\nthat are already loaded into memory vs queries on unloaded associations and\ntop-level models. The  Mongoid.compare_time_by_ms  option is set to  false  by default\nin Mongoid 7.4 for backwards compatibility. In Mongoid 8.0, the default value of the  Mongoid.compare_time_by_ms  option will\nchange to  true . The  count ,  sum ,  avg ,  min  and  max  methods now omit the\nsort stage from the generated aggregation pipeline if no skip or limit\nis specified, because the results aren't affected by the sort order.\nExample call that will now omit the sort stage and would potentially use\nan index where it wouldn't before: Mongoid 7.4 with the  Mongoid.broken_aggregables  option set to  false \nwill return  0  from the  sum  method over an empty result set, for example: Mongoid 7.3 and Mongoid 7.4 with the  Mongoid.broken_aggregables  option\nset to  true  (the default) returns  nil  in this case. In Mongoid 8.0, the default value of the  Mongoid.broken_aggregables  option will\nchange to  false . Mongoid 7.4 with the  Mongoid.broken_updates  option set to  false \nwill correctly persist an  embeds_one  association target that is set to nil\nand then to a non-nil value, for example: In Mongoid 7.3 and earlier, and in 7.4 with the  Mongoid.broken_aggregables \noption set to  true  (the default),  canvas.palette  would be  nil  when\nwe would expect it to be  palette . In Mongoid 8.0, the default value of the  Mongoid.broken_updates  option will\nchange to  false Mongoid 7.4 with the  Mongoid.broken_and  option set to  false \nwill preserve existing conditions when using  and  to add new conditions\nto a query when the same operator is used on the same field multiple times.\nFor example, in the following query: Mongoid 7.4 with the  Mongoid.broken_and  option set to  false  will\ngenerate the following criteria: In Mongoid 7.3 and earlier, and in 7.4 with the  Mongoid.broken_and \noption set to  true  (the default), the following criteria would be\ngenerated instead which omit the {\"$in\" => [2021]} condition: In Mongoid 8.0, the default value of the  Mongoid.broken_and  option will\nchange to  false . Mongoid 7.4 with the  Mongoid.broken_scoping  option set to  false \nwill restore the parent scope when exiting a  with_scope  block.\nFor example: In Mongoid 7.3 and earlier, and in 7.4 with the  Mongoid.broken_scoping \noption set to  true  (the default), once any  with_scope  block finishes,\nall scopes are cleared: In Mongoid 8.0, the default value of the  Mongoid.broken_scoping  option will\nchange to  false . When  distinct  and  pluck  are used with aliased fields in embedded\ndocuments, the aliases can be expanded if the  Mongoid.broken_alias_handling \noption is set to  false . By default, for backwards compatibility, in\nMongoid 7.4 this option is set to true, yielding Mongoid 7.3 and earlier\nbehavior. Given the following definitions: Mongoid 7.4 behavior with  Mongoid.broken_alias_handling  set to  false : Mongoid 7.3 and 7.4 with  Mongoid.broken_alias_handling  set to  true  behavior: The alias expansion for top-level fields has already been done by Mongoid 7.3. In Mongoid 8.0, the default value of the  Mongoid.broken_alias_handling  option will\nchange to  false . Mongoid 7.4 with the  Mongoid.legacy_pluck_distinct  option set to  false \nwill demongoize values returned from the  pluck  and  distinct  methods.\nGiven the following definitions: Mongoid 7.4 behavior with  Mongoid.legacy_pluck_distinct  set to  false : In Mongoid 7.3 and earlier, and in 7.4 with the  Mongoid.legacy_pluck_distinct \noption set to  true  (the default), the value returned from the pluck and\ndistinct methods will not be demongoized. For example: In Mongoid 8.0, the default value of the  Mongoid.legacy_pluck_distinct  option will\nchange to  false . Mongoid 7.4 with the  Mongoid.legacy_pluck_distinct  option set to  false \nchanges the behavior of using  pluck  and  distinct  with localized fields.\nNow, when retrieving a localized field using these methods, the translation for\nthe current locale will be returned. To get the full translations hash the\n _translations  field can be used. Given the following definitions: Mongoid 7.4 behavior with  Mongoid.legacy_pluck_distinct  set to  false : In Mongoid 7.3 and earlier, and in 7.4 with the  Mongoid.legacy_pluck_distinct \noption set to  true  (the default), inputting a localized field returns the\nfull translations hash. Inputting the  _translations  field will return  nil .\nFor example: In Mongoid 8.0, the default value of the  Mongoid.legacy_pluck_distinct  option will\nchange to  false . Mongoid 7.4 with the  Mongoid.legacy_pluck_distinct  option set to  false \nreturns the embedded values themselves, i.e. not inside a hash. Given the\nfollowing definitions: Mongoid 7.4 behavior with  Mongoid.legacy_pluck_distinct  set to  false : In Mongoid 7.3 and earlier, and in 7.4 with the  Mongoid.legacy_pluck_distinct \noption set to  true  (the default), plucking embedded attributes returns them\ninside a hash. For example: In Mongoid 8.0, the default value of the  Mongoid.legacy_pluck_distinct  option will\nchange to  false . Mongoid 7.4.1 fixes incorrect usage of the driver's  update_one  method from\nMongoid's  upsert  method. Mongoid's  upsert  actually performs a\nreplacing upsert, and Mongoid 7.4.1 and later correctly call  replace_one .",
            "code": [
                {
                    "lang": "yaml",
                    "value": "development:\n  ...\n  options:\n    # Enable all new behavior in Mongoid 7.4\n    legacy_triple_equals: false\n    object_id_as_json_oid: false\n    compare_time_by_ms: true\n    broken_aggregables: false\n    broken_updates: false\n    broken_and: false\n    broken_scoping: false\n    broken_alias_handling: false\n    legacy_pluck_distinct: false"
                },
                {
                    "lang": "ruby",
                    "value": "ModelClass === instance\n\n# equivalent to:\ninstance.is_a?(ModelClass)"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :members\nend\n\nclass CoverBand < Band\nend\n\nclass Member\n  include Mongoid::Document\n\n  belongs_to :band\nend\n\nband = Band.new\ncover_band = CoverBand.new\n\nband === Band\n# => false\n\ncover_band === Band\n# => false\n\nBand === Band\n# => false\n\nCoverBand === Band\n# => false\n\nband.members === Array\n# => false\n\nband.members === Mongoid::Association::Referenced::HasMany::Enumerable\n# => false"
                },
                {
                    "lang": "ruby",
                    "value": "band === Band\n# => true\n\ncover_band === Band\n# => true\n\nBand === Band\n# => true\n\nCoverBand === Band\n# => true\n\nband.members === Array\n# => true\n\nband.members === Mongoid::Association::Referenced::HasMany::Enumerable\n# => true"
                },
                {
                    "lang": "ruby",
                    "value": "Band === band\n# => true\n\nBand === cover_band\n# => true"
                },
                {
                    "lang": "ruby",
                    "value": "Band.desc(:name).count"
                },
                {
                    "lang": "ruby",
                    "value": "Product.where(impossible_condition: true).sum(:price)\n# => 0"
                },
                {
                    "lang": "ruby",
                    "value": "class Canvas\n  include Mongoid::Document\n\n  embeds_one :palette\nend\n\ncanvas.palette = palette\ncanvas.palette = nil\ncanvas.palette = palette"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(id: 1).and({year: {'$in' => [2020]}}, {year: {'$in' => [2021]}}).where(id: 2)"
                },
                {
                    "lang": "ruby",
                    "value": "#<Mongoid::Criteria\n  selector: {\"_id\"=>1, \"year\"=>{\"$in\"=>[2020]}, \"$and\"=>[{\"year\"=>{\"$in\"=>[2021]}}, {\"_id\"=>2}]}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "<Mongoid::Criteria\n  selector: {\"_id\"=>1, \"year\"=>{\"$in\"=>[2020]}, \"$and\"=>[{\"_id\"=>2}]}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.with_scope(year: 2020) do\n  Band.with_scope(active: true) do\n    # ...\n  end\n\n  # {year: 2020} condition is applied here\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.with_scope(year: 2020) do\n  Band.with_scope(active: true) do\n    # ...\n  end\n\n  # No scope is applied here\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_many :managers\nend\n\nclass Manager\n  include Mongoid::Document\n  embedded_in :band\n\n  field :name, as: :n\nend"
                },
                {
                    "lang": "ruby",
                    "value": "# Expands out to \"managers.n\" in the query:\nBand.distinct('managers.name')\nBand.pluck('managers.name')"
                },
                {
                    "lang": "ruby",
                    "value": "# Sends \"managers.name\" without expanding the alias:\nBand.distinct('managers.name')\nBand.pluck('managers.name')"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :sales, type: BigDecimal\nend\n\nBand.create!(sales: \"1E2\")\nBand.create!(sales: \"2E2\")"
                },
                {
                    "lang": "ruby",
                    "value": "Band.pluck(:sales)\n# => [0.1e3, 0.2e3]\nBand.distinct(:sales)\n# => [0.1e3, 0.2e3]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.pluck(:sales)\n# => [\"1E2\", \"2E2\"]\nBand.distinct(:sales)\n# => [\"1E2\", \"2E2\"]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name, localize: true\nend\n\nI18n.locale = :en\nband = Band.create!(name: 'english-name')\nI18n.locale = :de\nband.name = 'deutsch-name'\nband.save!"
                },
                {
                    "lang": "ruby",
                    "value": "Band.pluck(:name)\n# => [\"deutsch-name\"]\nBand.pluck(:name_translations)\n# => [{\"en\"=>\"english-name\", \"de\"=>\"deutsch-name\"}, {\"en\"=>\"english-name\", \"de\"=>\"deutsch-name\"}]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.pluck(:name)\n# => [{\"en\"=>\"english-name\", \"de\"=>\"deutsch-name\"}, {\"en\"=>\"english-name\", \"de\"=>\"deutsch-name\"}]\nBand.pluck(:name_translations)\n# => [nil, nil]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  embeds_one :label\nend\n\nclass Label\n  include Mongoid::Document\n\n  embedded_in :band\n  field :sales, type: BigDecimal\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.pluck(\"label.sales\")\n# => [0.1e3]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.pluck(\"label.sales\")\n# => [{\"sales\"=>\"1E2\"}]"
                }
            ],
            "preview": "This page describes significant changes and improvements in Mongoid 7.4.\nThe complete list of releases is available on GitHub and in JIRA;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "release-notes/mongoid-8.1",
            "title": "Mongoid 8.1",
            "headings": [
                "Deprecated Mongoid::QueryCache module",
                "Deprecated use_activesupport_time_zone config option",
                "Added load_async method on Criteria to asynchronously load documents",
                "Added attribute_before_last_save, saved_change_to_attribute, saved_change_to_attribute?, and will_save_change_to_attribute?  methods",
                "Configuration DSL No Longer Requires an Argument to its Block",
                "Added Mongoid::Criteria finder methods",
                "Added :touch option to #save",
                "Added Version Based Default Configuration",
                "Added :present option to localized fields",
                "Added :to and :from options to attribute_changed?",
                "Allowed store_in to be called on subclasses",
                "Added readonly! method and legacy_readonly feature flag",
                "Added method parameters to #exists?",
                "Added :replace option to #upsert",
                "Allow Hash Assignment to embedded_in",
                "Added none_of Query Method",
                "Added Mongoid::Config.immutable_ids",
                "BSON 5 and BSON::Decimal128 Fields"
            ],
            "paragraphs": "This page describes significant changes and improvements in Mongoid 8.1.\nThe complete list of releases is available  on GitHub  and  in JIRA ;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes. The  Mongoid::QueryCache  module has been deprecated. Please replace any usages 1-for-1 with  Mongo::QueryCache .\nNote the method  Mongoid::QueryCache#clear_cache  should be replaced with  Mongo::QueryCache#clear .\nAll other methods and submodules are identically named. The config option  use_activesupport_time_zone  has been deprecated.\nBeginning in Mongoid 9.0, it will be ignored and always behave as true.\nSince  use_activesupport_time_zone  currently defaults to true, it is\nsafe to remove from your config file at this time. The new  load_async  method on  Criteria  allows  running database queries asynchronously . These new methods behave identically to corresponding methods\nfrom  ActiveRecord::AttributeMethods::Dirty . The methods are particularly useful in\ncallbacks: For all of the new methods there are also shorter forms created dynamically, e.g.\n attribute_before_last_save(:name)  is equivalent to  name_before_last_save ,\n saved_change_to_attribute(:name)  is equivalent to  saved_change_to_name ,\n saved_change_to_attribute?(:name)  is equivalent to  saved_change_to_name? ,\nand  will_save_change_to_attribute?(:name)  is equivalent to  will_save_change_to_name? . It is now possible to use  Mongoid.configure  without\nproviding an argument to its block: Note that  configure  will continue to support a block argument.\nThe following is equivalent to the above: Mongoid 8.1 implements several finder methods on  Mongoid::Criteria : When no documents are found, methods without a bang (!) return nil, and methods\nwith a bang (!) raise an error: first! last! second/second! third/third! fourth/fourth! fifth/fifth! second_to_last/second_to_last! third_to_last/third_to_last! Support for the  :touch  option has been added to the  #save  and  #save! \nmethods. When this option is false, the  updated_at  field on the saved\ndocument and all of it's embedded documents will not be updated with the\ncurrent time. When this option is true or unset, the  updated_at  field will\nbe updated with the current time. If the document being saved is a new document (i.e. it has not yet been\npersisted to the database), then the  :touch  option will be ignored, and the\n updated_at  (and  created_at ) fields will be updated with the current\ntime. Mongoid 8.1 has added the ability to set the default configurations for a\nspecific version: This is helpful for upgrading between versions. See the section on\n Version Based Default Configuration  for more details on\nhow to use this feature to make upgrading between Mongoid versions easier. The  :present  option was added to localized fields for removing blank values\nfrom the  _translations  hash: See the section on  Localize :present Field Option  for\nmore details on how these are used. Mongoid 8.1 adds the  :to  and  :from  options on the  attribute_changed? \nmethod. These options can be used to inquire whether the attribute has been changed\nto or from a certain value: Starting in Mongoid 8.1, subclasses can now specify which collection its\ndocuments should be stored in using the  store_in  macro: Previously, an error was raised if this was done. See the section on\n Inheritance Persistence Context \nfor more details. Mongoid 8.1 changes the meaning of read-only documents. In Mongoid 8.1 with\nthis feature flag turned off ( false ), a document becomes read-only when calling the\n readonly!  method: With this feature flag turned off, a  ReadonlyDocument  error will be\nraised when destroying or deleting, as well as when saving or updating. Prior to Mongoid 8.1 and in 8.1 with the  legacy_readonly  feature flag\nturned on ( true ), documents become read-only when they are projected (i.e. using\n #only  or  #without ). Note that with this feature flag on, a  ReadonlyDocument  error will only be\nraised when destroying or deleting, and not on saving or updating. See the\nsection on  Read-only Documents  for more details. Mongoid 8.1 introduces method paramters to the  Contextual#exists?  method.\nAn _id, a hash of conditions, or  false / nil  can now be included: Mongoid 8.1 adds the  :replace  option to the  #upsert  method. This option\nis  true  by default. In Mongoid 8 and earlier, and in Mongoid 8.1 when passing  replace: true \n(the default) the upserted document will overwrite the current document in the\ndatabase if it exists. Consider the following example: As you can see, the value for the  :age  field was dropped, because the\nupsert replaced the entire document instead of just updating it. If we take the\nsame example and set  :replace  to  false , however: This time, the value for the  :age  field is maintained. The default for the  :replace  option will be changed to  false  in\nMongoid 9.0, therefore it is recommended to explicitly specify this option\nwhile using  #upsert  in 8.1 for easier upgradability. Mongoid 8.1 allows the assignment of a hash to an  embedded_in  association.\nOn assignment, the hash will be coerced into a document of the class of the\nassociation that it is being assigned to. This functionality already exists\nfor  embeds_one  and  embeds_many  associations. Consider the following\nexample: See the section on  Hash Assignment on Embedded Associations \nfor more details With the addition of  none_of , Mongoid 8.1 allows queries to exclude\nconditions in bulk. The emitted query will encapsulate the specified\ncriteria in a  $nor  operation. For example: This would query all buildings in Portland, excluding apartments, buildings less than\n100 units tall, and buildings with an occupancy greater than 2500 people. Coming in Mongoid 9.0, the  _id  field will be immutable in both top-level\nand embedded documents. This addresses some inconsistency in how mutations\nto the  _id  field are treated currently. To prepare for this potentially\nbreaking change, the  Mongoid::Config.immutable_ids  flag has been added. It\ndefaults to  false , preserving the existing behavior, but you may set it to\n true  to prepare your apps for Mongoid 9.0. When this is set to  true ,\nattempts to mutate the  _id  of a document will raise an exception. When BSON 4 or earlier is present, any field declared as BSON::Decimal128 will\nreturn a BSON::Decimal128 value. When BSON 5 is present, however, any field\ndeclared as BSON::Decimal128 will return a BigDecimal value by default. If you need literal BSON::Decimal128 values with BSON 5, you may instruct\nMongoid to allow literal BSON::Decimal128 fields: The  allow_bson5_decimal128  option only has any effect under\nBSON 5 and later. BSON 4 and earlier ignore the setting entirely.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  field :name, type: String\n\n  before_save do\n    puts \"attribute_was(:name): #{attribute_was(:name)}\"\n    puts \"attribute_before_last_save(:name): #{attribute_before_last_save(:name)}\"\n    puts \"will_save_change_to_attribute?(:name): #{will_save_change_to_attribute?(:name)}\"\n  end\n\n  after_save do\n    puts \"attribute_was(:name): #{attribute_was(:name)}\"\n    puts \"attribute_before_last_save(:name): #{attribute_before_last_save(:name)}\"\n    puts \"saved_change_to_attribute(:name): #{saved_change_to_attribute(:name)}\"\n    puts \"attribute_changed?(:name): #{attribute_changed?(:name)}\"\n    puts \"saved_change_to_attribute?(:name): #{saved_change_to_attribute?(:name)}\"\n  end\nend\n\nperson = Person.create(name: 'John')\n#\n# before_save\n#\n## attribute_was(:name): nil\n## attribute_before_last_save(:name): nil\n## will_save_change_to_attribute?(:name): true\n#\n# after_save\n#\n## attribute_was(:name): John => New value\n## attribute_before_last_save(:name): nil => Value before save\n## saved_change_to_attribute(:name): [nil, \"John\"] => Both values\n## attribute_changed?(:name): false\n## saved_change_to_attribute?(:name): true => Correctly indicates that the change for :name was saved\n\nperson.name = 'Jane'\nperson.save\n#\n# before_save\n#\n## attribute_was(:name): John => attribute_was not look back before the last save\n## attribute_before_last_save(:name): nil => value before the last save\n## will_save_change_to_attribute?(:name): true\n#\n# after_save\n#\n## attribute_was(:name): Jane => New value\n## attribute_before_last_save(:name): John => Value before save\n## saved_change_to_attribute(:name): [\"John\", \"Jane\"] => Both values\n## attribute_changed?(:name): false\n## saved_change_to_attribute?(:name): true => Correctly indicates that the change for :name was saved"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do\n  connect_to(\"mongoid_test\")\n\n  # Use config method when assigning variables\n  config.preload_models = true"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.connect_to(\"mongoid_test\")\n\n  config.preload_models = true"
                },
                {
                    "lang": "ruby",
                    "value": "Band.none.first\n# => nil\n\nBand.none.first!\n# => raise Mongoid::Errors::DocumentNotFound"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.configure do |config|\n  config.load_defaults 8.0\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n  field :description, localize: :present\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Shape\n  include Mongoid::Document\n  store_in collection: :shapes\nend\n\nclass Circle < Shape\n  store_in collection: :circles\nend\n\nclass Square < Shape\n  store_in collection: :squares\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.first\nband.readonly? # => false\nband.readonly!\nband.readonly? # => true\nband.name = \"The Rolling Stones\"\nband.save # => raises ReadonlyDocument error"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  field :genre, type: String\nend\n\nband = Band.only(:name).first\nband.readonly? # => true\nband.destroy # => raises ReadonlyDocument error"
                },
                {
                    "lang": "ruby",
                    "value": "Band.exists?\nBand.exists?(name: \"The Rolling Stones\")\nBand.exists?(BSON::ObjectId('6320d96a3282a48cfce9e72c'))\nBand.exists?(false) # always false\nBand.exists?(nil) # always false"
                },
                {
                    "lang": "ruby",
                    "value": "existing = Player.create!(name: \"Juan Soto\", age: 23, team: \"WAS\")\n\nplayer = Player.new(name: \"Juan Soto\", team: \"SD\")\nplayer.id = existing.id\nplayer.upsert # :replace defaults to true in 8.1\n\np Player.find(existing.id)\n# => <Player _id: 633b42f43282a45fadfaaf9d, name: \"Juan Soto\", age: nil, team: \"SD\">"
                },
                {
                    "lang": "ruby",
                    "value": "player.upsert(replace: false)\n\np Player.find(existing.id)\n# => <Player _id: 633b42f43282a45fadfaaf9d, name: \"Juan Soto\", age: 23, team: \"SD\">"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\n  embeds_many :albums\nend\n\nclass Album\n  include Mongoid::Document\n  embedded_in :band\nend\n\nalbum = Album.new\nalbum.band = { name: \"Death Cab For Cutie\" }\np album.band\n# => <Band _id: 633c74113282a438a15d2b56, name: \"Death Cab For Cutie\">"
                },
                {
                    "lang": "ruby",
                    "value": "class Building\n  include Mongoid::Document\n  field :city, type: String\n  field :height, type: Integer\n  field :purpose, type: String\n  field :occupancy, type: Integer\nend\n\nBuilding.where(city: 'Portland').\n  none_of(:height.lt => 100,\n          :purpose => 'apartment',\n          :occupancy.gt => 2500)"
                },
                {
                    "lang": "ruby",
                    "value": "# The default in Mongoid 8.1\nMongoid::Config.immutable_ids = false\n\n# The default in Mongoid 9.0\nMongoid::Config.immutable_ids = true"
                },
                {
                    "lang": "ruby",
                    "value": "class Model\n  include Mongoid::Document\n\n  field :decimal_field, type: BSON::Decimal128\nend\n\n# under BSON <= 4\nModel.first.decimal_field.class #=> BSON::Decimal128\n\n# under BSON >= 5\nModel.first.decimal_field.class #=> BigDecimal"
                },
                {
                    "lang": "ruby",
                    "value": "Model.first.decimal_field.class #=> BigDecimal\n\nMongoid.allow_bson5_decimal128 = true\nModel.first.decimal_field.class #=> BSON::Decimal128"
                }
            ],
            "preview": "This page describes significant changes and improvements in Mongoid 8.1.\nThe complete list of releases is available on GitHub and in JIRA;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "release-notes/mongoid-7.3",
            "title": "Mongoid 7.3",
            "headings": [
                "delete Method Does Not Trigger Association Dependent Behavior",
                "::Boolean Removed",
                "Selector Key Stringification",
                "Condition Combination Using $eq / $regex",
                "New Embedded Matching Operators",
                "Unaliasing id Field",
                "Mongoid.purge! and Mongoid.truncate take the global overrides into account",
                "update_one Warnings in upsert"
            ],
            "paragraphs": "This page describes significant changes and improvements in Mongoid 7.3.\nThe complete list of releases is available  on GitHub  and  in JIRA ;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes. Breaking change:  In Mongoid 7.3,\n dependent behavior  is not invoked\nwhen the parent association is deleted using the  delete  method.\nFor example, after the following code snippet executes, in Mongoid 7.3 the\nalbum will remain in the database: Previous versions of Mongoid invoked dependent behavior when deleting parents. To invoke dependent behavior, use the  destroy  method: The behavior of Mongoid 7.3 is consistent with how ActiveRecord behaves. Breaking change:  Mongoid 7.3 removes the global  ::Boolean  class. This change should have no impact on classes that simply use  Boolean \nfields, as the  Boolean  class is aliased from  Mongoid::Fields \n(which is included in  Mongoid::Document ). The following field definition\ncontinues to work in 7.3 as it did in 7.2: However, code that is not executed in the context of a class including\n Mongoid::Document  may need to explicitly qualify  Boolean  references.\nThe following snippet fails with Mongoid 7.3 due to  Boolean  being\nunqualified: To fix it, use the fully-qualified  Mongoid::Boolean  class: Note that  class_eval  is executed in the scope of the caller, not in\nthe scope of the class being modified. Thus even when using  class_eval \nit is necessary to fully qualify  Mongoid::Boolean : Additionally, in Mongoid 7.2  ::Boolean  and  Mongoid::Boolean  were\ndifferent classes. In Mongoid 7.3 there is only one class which is\n Mongoid::Boolean . It is possible to restore the global  ::Boolean  class by executing in\nyour application: Note that this aliases  Mongoid::Boolean  to  ::Boolean  such that there\nis still only a single Boolean class: Minor change: Mongoid now converts symbol keys to string keys in the\n Criteria  selectors. This applies to operators as well as hash literals. Mongoid 7.3 behavior: Mongoid 7.2 behavior: Minor change: when using the  where ,  and ,  or , and  nor  methods\non  Criteria  objects and providing multiple conditions on the same field\nin the same argument using the symbol operator syntax, conditions may be\ncombined using  $eq  or  $regex  operators, as appropriate, instead of\n $and . Mongoid 7.3 behavior: Mongoid 7.2 behavior: The  $regex  operator is used when the value is a regular expression, i.e.\nan instance of  Regexp  or  BSON::Regexp::Raw  classes. When using the  not  method with multiple conditions provided in the same\nargument, the conditions are kept together and negated as a group. Mongoid 7.3 behavior: Mongoid 7.2 behavior: Mongoid 7.3 adds support for bitwise operators,  $comment ,  $mod  and\n $type  operators when  embedded matching . It is now possible to  remove the id alias in models ,\nto make  id  a regular field. Minor change:  Mongoid.purge!  and  Mongoid.truncate!  now consider global\noverrides set with  Mongoid.override_database  and  Mongoid.override_client . Mongoid 7.3 behavior: Mongoid 7.2 behavior: Mongoid 7.3.5 fixes incorrect usage of the driver's  update_one  method from\nMongoid's  upsert  method. Mongoid's  upsert  actually performs a\nreplacing upsert, and Mongoid 7.3.5 and later correctly call  replace_one .",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :albums, dependent: :destroy\nend\n\nclass Album\n  include Mongoid::Document\n\n  belongs_to :band\nend\n\nband = Band.create!\nalbum = Album.create!(band: band)\n\n# Does not delete the album from the database\nband.delete"
                },
                {
                    "lang": "ruby",
                    "value": "# Deletes the album from the database\nband.destroy"
                },
                {
                    "lang": "ruby",
                    "value": "class User\n  include Mongoid::Document\n\n  field :verified, type: Boolean\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class User\n  include Mongoid::Document\nend\n\nUser.field :verified, type: Boolean"
                },
                {
                    "lang": "ruby",
                    "value": "User.field :verified, type: Mongoid::Boolean"
                },
                {
                    "lang": "ruby",
                    "value": "User.class_eval do\n  field :verified, type: Mongoid::Boolean\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Boolean = Mongoid::Boolean"
                },
                {
                    "lang": "ruby",
                    "value": "# With Mongoid 7.3:\nBoolean = Mongoid::Boolean\nBoolean == Mongoid::Boolean\n# => true\n\n# With Mongoid 7.2:\nBoolean == Mongoid::Boolean\n# => false"
                },
                {
                    "lang": "ruby",
                    "value": "Band.and(year: {'$in': [2020]})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"year\"=>{\"$in\"=>[2020]}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(tag: {city: 1})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"tag\"=>{\"city\"=>1}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.and(year: {'$in': [2020]})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"year\"=>{:$in=>[2020]}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(tag: {city: 1})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"tag\"=>{:city=>1}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(year: 2020, :year.gt => 1960)\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"year\"=>{\"$eq\"=>2020, \"$gt\"=>1960}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(name: /A/, :name.ne => 'Astral')\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"name\"=>{\"$regex\"=>/A/, \"$ne\"=>\"Astral\"}}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.where(year: 2020, :year.gt => 1960)\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"year\"=>2020, \"$and\"=>[{\"year\"=>{\"$gt\"=>1960}}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.where(name: /A/, :name.ne => 'Astral')\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"name\"=>/A/, \"$and\"=>[{\"name\"=>{\"$ne\"=>\"Astral\"}}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.not(year: 2020, :year.gt => 1960)\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$and\"=>[{\"$nor\"=>[{\"year\"=>{\"$eq\"=>2020, \"$gt\"=>1960}}]}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.not(year: 2020, :year.gt => 1960)\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"year\"=>{\"$ne\"=>2020}, \"$and\"=>[{\"$nor\"=>[{\"year\"=>{\"$gt\"=>1960}}]}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.override_database(\"some_other_db\")\nBand.create!(name: \"Garage\")\nBand.count # => 1\nMongoid.purge! # or Mongoid.truncate!\nBand.count # => 0"
                },
                {
                    "lang": "ruby",
                    "value": "Mongoid.override_database(\"some_other_db\")\nBand.create!(name: \"Garage\")\nBand.count # => 1\nMongoid.purge! # or Mongoid.truncate!\nBand.count # => 1"
                }
            ],
            "preview": "This page describes significant changes and improvements in Mongoid 7.3.\nThe complete list of releases is available on GitHub and in JIRA;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "release-notes/mongoid-7.5",
            "title": "Mongoid 7.5",
            "headings": [
                "Ruby, JRuby and Rails Version Support",
                "Implemented Criteria#take/take! Method",
                "Force the attributes Method to Always Return a Hash",
                "Deprecate :id_sort Option and Support limit on #first/last",
                "Combine Chained Operators Using and Instead of override",
                "pluck Usage of map Deprecated",
                "Mongoid::Criteria cache deprecated",
                "Array#update_values and Hash#update_values deprecated",
                "Document#to_a deprecated",
                "update_one Warnings in upsert"
            ],
            "paragraphs": "This page describes significant changes and improvements in Mongoid 7.5.\nThe complete list of releases is available  on GitHub  and  in JIRA ;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes. Mongoid 7.5 deprecates support for Ruby 2.5, JRuby 9.2 and Rails 5.1.\nMongoid 8 will require Ruby 2.6 or newer, JRuby 9.3 or newer and Rails 5.2 or\nnewer. Mongoid 7.5 introduces the  #take  method which returns a document\nor a set of documents from the database without ordering by  _id : If a parameter is given to  #take , an array of documents is returned. If no parameter is\ngiven, a singular document is returned. The  #take!  method functions the same as calling  #take  without arguments,\nbut raises an DocumentNotFound error instead of returning nil if no documents\nare found. Note that the  #take/take!  methods do not apply a sort to the view before\nretrieving the documents from the database, and therefore they may return different\nresults than the  #first  and  #last  methods.  #take  is equivalent to\ncalling  #first  or  #last  with the  { id_sort: :none }  option. This\noption has been deprecated in Mongoid 7.5 and it is recommended to use  #take \ninstead going forward. Support for the  :id_sort  option will be dropped in\nMongoid 8. Mongoid 7.5 with the  Mongoid.legacy_attributes  option set to  false \nwill always return a  Hash  when calling the  attributes  method.\nFor example: In Mongoid 7.4 and earlier, and in 7.5 with the  Mongoid.legacy_attributes \noption set to  true , the  attributes  method on a document will return a\n BSON::Document  when retrieving that document from the database, but will\nreturn a  Hash  when instantiating a new document: Mongoid 7.5 deprecates the  :id_sort  keyword argument for the\n Criteria#first  and  Criteria#last  methods. Please use  Criteria#take \nto retrieve documents without sorting by id. The  first  and  last  methods now take the number of documents to return\nas a positional argument, mirroring the functionality of Ruby's  Enumerable \nmethod and ActiveRecord's  first  and  last  methods. Both invocations\n(with limit as a positional arguments and with the  :id_sort  option) remain\nsupported in Mongoid 7.x, but the  :id_sort  invocation will be removed in\nMongoid 8. When providing a limit,  #first/last  will return a list of documents, and\nwhen not providing a limit (or providing  nil ), a single document will be\nreturned. Note that the  #first/last  methods apply a sort on  _id , which can\ncause performance issues. To get a document without sorting first, use the\n Critera#take  method. Mongoid 7.5 with the  Mongoid.overwrite_chained_operators  option set to  false \nwill combine conditions that use the same operator and field using an  and .\nFor example, in the following query: Mongoid 7.5 with the  Mongoid.overwrite_chained_operators  option set to  false \nwill generate the following criteria: In Mongoid 7.4 and earlier, and in 7.5 with the  Mongoid.overwrite_chained_operators \noption set to  true , the following criteria would be generated instead which\noverwrites the first condition: The following functions are affected by this change: eq elem_match gt gte lt lte mod ne near near_sphere In Mongoid 7.5 with the  Mongoid.overwrite_chained_operators  option set to\n false , nested keys in the generated selector will always be strings,\nwhereas in Mongoid 7.4 and earlier, and in 7.5 with the\n Mongoid.overwrite_chained_operators  option set to  true , nested keys in\nthe selector can be strings or symbols, depending on what was passed to the\noperator. Mongoid 7.5 deprecates the usage of  map  as pluck, as in the following\nexample: This usage will no longer be supported in Mongoid 8, which will not accept\narguments to  map . The ability to cache individual criteria objects has been deprecated in Mongoid\n7.5 and will be dropped in Mongoid 8. In order to get caching functionality, enable the Mongoid QueryCache. See the\nsection on  QueryCache  for more details. The  Array#update_values  and  Hash#update_values  methods are deprecated in\nMongoid 7.5. It is recommended to use ActiveSupport's  transform_values! \nmethod instead. The  Document#to_a  method is deprecated in Mongoid 7.5. Mongoid 7.5 fixes incorrect usage of the driver's  update_one  method from\nMongoid's  upsert  method. Mongoid's  upsert  actually performs a\nreplacing upsert, and Mongoid 7.5 correctly calls  replace_one .",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\nend\n\nBand.create!\nBand.create!\n\nBand.take\n# => #<Band _id: 62c835813282a4470c07d530, >\nBand.take(2)\n# => [ #<Band _id: 62c835813282a4470c07d530, >, #<Band _id: 62c835823282a4470c07d531, > ]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.take!\n# => #<Band _id: 62c835813282a4470c07d530, >"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  field :name\nend\n\nband = Band.create!(name: \"The Rolling Stones\")\np band.attributes.class\n# => Hash\n\nband = Band.first\np band.attributes.class\n# => Hash"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!(name: \"The Rolling Stones\")\np band.attributes.class\n# => Hash\n\nband = Band.first\np band.attributes.class\n# => BSON::Document"
                },
                {
                    "lang": "ruby",
                    "value": "Band.first\n# => #<Band _id: 62c835813282a4470c07d530, >\nBand.first(2)\n# => [ #<Band _id: 62c835813282a4470c07d530, >, #<Band _id: 62c835823282a4470c07d531, > ]\nBand.last\n# => #<Band _id: 62c835823282a4470c07d531, >\nBand.last(2)\n# => [#<Band _id: 62c835813282a4470c07d530, >, #<Band _id: 62c835823282a4470c07d531, >]"
                },
                {
                    "lang": "ruby",
                    "value": "Band.ne(name: \"The Rolling Stones\").ne(name: \"The Beatles\")"
                },
                {
                    "lang": "ruby",
                    "value": "#<Mongoid::Criteria\n  selector: {\"name\"=>{\"$ne\"=>\"The Rolling Stones\"}, \"$and\"=>[{\"name\"=>{\"$ne\"=>\"The Beatles\"}}]}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "#<Mongoid::Criteria\n  selector: {\"name\"=>{\"$ne\"=>\"The Beatles\"}}\n  options:  {}\n  class:    Band\n  embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.all.map(:name)\n\n# Equivalent to:\nBand.pluck(:name)"
                }
            ],
            "preview": "This page describes significant changes and improvements in Mongoid 7.5.\nThe complete list of releases is available on GitHub and in JIRA;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "release-notes/mongoid-8.0",
            "title": "Mongoid 8.0",
            "headings": [
                "Support for MongoDB 3.4 and Earlier Servers Dropped",
                "Support for Ruby 2.5 Dropped",
                "Support for Rails 5.1 Dropped",
                "Default Option Values Changed",
                "Decimal128-backed BigDecimal Fields",
                "Storing/Retrieving/Evolving Uncastable Values",
                "Changes to the attributes_before_type_cast Hash",
                "Order of Callback Invocation",
                "Changeable Module Behavior Made Compatible With ActiveModel::Dirty",
                "*_previously_was, previously_new_record?, and previously_persisted? helpers",
                "Unknown Field Type Symbols/Strings Prohibited",
                "any_of Adds Multiple Arguments As Top-Level Conditions",
                "#pluck on Embedded Criteria Returns nil Values",
                "Replaced Mongoid::Criteria#geo_spacial with #geo_spatial",
                "Implemented .tally method on Mongoid#Criteria",
                "Implemented .pick method on Mongoid#Criteria",
                "find delegates to Enumerable#find when given a block",
                "No Longer Persisting Documents with Invalid belongs_to Associations",
                "Update Local HABTM Association Correctly",
                "Repaired Storing Strings in BSON::Binary fields",
                "Removed Document#to_a Method",
                "Removed :drop_dups Option from Indexes",
                "Removed Mongoid::Errors::EagerLoad Exception Class",
                "Removed Deprecated Constants",
                "Removed Array#update_values and Hash#update_values methods",
                "Deprecated the geoHaystack, geoSearch Options",
                ":id_sort Option on #first/last Removed",
                "Mongoid::Criteria Cache Removed"
            ],
            "paragraphs": "This page describes significant changes and improvements in Mongoid 8.0.\nThe complete list of releases is available  on GitHub  and  in JIRA ;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes. Mongoid 8 requires MongoDB 3.6 or newer. Earlier server versions are not\nsupported. Mongoid 8 requires Ruby 2.6 or newer. Earlier Ruby versions are not supported. Mongoid 8 requires Rails 5.2 or newer. Earlier Rails versions are not supported. Breaking change:  The following options have had their default values\nchanged in Mongoid 8.0: Please refer to  configuration option  for\nthe description and effects of each of these options. :broken_aggregables  =>  false :broken_alias_handling  =>  false :broken_and  =>  false :broken_scoping  =>  false :broken_updates  =>  false :compare_time_by_ms  =>  true :legacy_attributes  => true :legacy_pluck_distinct  =>  false :legacy_triple_equals  =>  false :object_id_as_json_oid  =>  false :overwrite_chained_operators  =>  false Mongoid 8 introduces the  map_big_decimal_to_decimal128  feature flag, which\nallows values assigned to a field of type  BigDecimal  to be stored as type\n String  in the database for compatibility with Mongoid 7 and earlier. In\nMongoid 8 by default (with this feature flag turned on), values assigned to\nfields of type  BigDecimal  are stored in the database as type\n BSON::Decimal128 . In Mongoid 7 and earlier, and in Mongoid 8 with this\nfeature flag turned off, values assigned to fields of type  BigDecimal  are\nstored as Strings. See the section on  BigDecimal Fields \nfor more details. Breaking change:  In Mongoid 8, Mongoid standardizes the storing, retrieving\nand evolving of \"uncastable values.\" On attempting to read or write an\nuncastable value, a  nil  is returned or written instead. When attempting to\nevolve an uncastable value, the inputted value is returned. See the section on\n Uncastable Values  for more details. Some  mongoize ,  demongoize  and  evolve  methods were also changed to\nperform consistently with rails and the other  mongoize ,  demongoize  and\n evolve  methods. The following table shows the changes in functionality: Field Type Situation Previous Functionality New Functionality Array/Hash When a value that is not an array or hash is assigned raise  InvalidValue  error return  nil Regexp When persisting and reading a Regexp from the database return a  BSON::Regexp::Raw return a  Regexp Time/DateTime When demongoizing a non-Time value: \"bogus\",  Date.today raise  NoMethodError  Exception: undefined method  getlocal  for \"bogus\":String \"bogus\": return  nil Date.today : return  Time/DateTime Time/DateTime/Date When demongoizing a valid string: \"2022-07-14 14:45:51 -0400\" raise  NoMethodError  Exception: undefined method  getlocal  for \"2022-07-14 14:45:51 -0400\":String return a  Time/DateTime/Date All Types When an uncastable value is evolved undefined behavior, occasionally raise  NoMethodError return inputted value The  demongoize  methods on container objects (i.e. Hash, Array) have not\nchanged to prevent bugs when modifying and saving those objects. See\n https://jira.mongodb.org/browse/MONGOID-2951  for a longer discussion on these\nbugs. The  attributes_before_type_cast  hash has been changed to function more like\nActiveRecord: On instantiation of a new model (without parameters), the\n attributes_before_type_cast  hash has the same contents as the\n attributes  hash. If parameters are passed to the initializer, those\nvalues will be stored in the  attributes_before_type_cast  hash before\nthey are  mongoized . When assigning a value to the model, the  mongoized  value (i.e. when\nassiging '1' to an Integer field, it is  mongoized  to 1) is stored in\nthe  attributes  hash, whereas the raw value (i.e. '1') is stored in the\n attributes_before_type_cast  hash. When saving, creating (i.e. using the  create!  method), or reloading the\nmodel, the  attributes_before_type_cast  hash is reset to have the same\ncontents as the  attributes  hash. When reading a document from the database, the  attributes_before_type_cast \nhash contains the attributes as they appear in the database, as opposed to\ntheir  demongoized  form. Breaking change:  Mongoid 8.0 changes the order of _create and _save callback\ninvocation for documents with associations. Referenced associations ( has_one  and  has_many ): Embedded associations ( embeds_one  and  embeds_many ): Mongoid 8.0 Mongoid 7 Parent :around_save_open Parent :around_save_open Parent :around_create_open Parent :around_create_open Child :before_save Parent :around_create_close Child :before_create Child :before_save Child :before_create Child persisted in MongoDB Child persisted in MongoDB Child :after_create Child :after_create Child :after_save Child :after_save Parent :after_create Parent :after_save Parent :after_save Mongoid 8.0 Mongoid 7 Parent :around_save_open Child :around_save_open Parent :around_create_open Child :after_save Child :around_save_open Parent :around_save_open Child :around_create_open Child :around_create_open Child :after_create Parent :around_create_open Child :around_create_close Child :around_save_close Parent :around_create_close Parent :around_create_close Parent :around_save_close Parent :around_save_close When updating documents, it is now possible to get updated attribute values\nin  after_*  callbacks. This follows ActiveRecord/ActiveModel behavior. Mongoid 8.0 output: Mongoid 7 output: Notice that in 7  attribute_was(:age)  returns the old attribute value,\nwhile in 8.0  attribute_was(:age)  returns the new value. Mongoid 8.0 introduces ActiveModel-compatible  *_previously_was  helpers,\nas well as ActiveRecord-compatible  previously_new_record?  and\n previously_persisted?  helpers: Breaking change:  Mongoid 8 prohibits using symbols and strings as field\ntypes when these symbols and strings do not map to a known type. Previously\nsuch usage would create a field of type  Object . Mongoid 8 behavior: Mongoid 7 behavior: Breaking change:  When  any_of  is invoked with multiple conditions, the\nconditions are now added to the top level of the criteria, same as when\n any_of  is invoked with a single condition. Previously when multiple\nconditions were provided, and the criteria already had an  $or  operator,\nthe new conditions would be added to the existing  $or  as an additional\nbranch. Mongoid 8.0 behavior: Mongoid 7 behavior: Mongoid 8 fixes a bug where calling  #pluck  on a Mongoid::Criteria\nfor embedded documents discarded nil values. This behavior was\ninconsistent with both the  #pluck  method in ActiveSupport and\nwith how  #pluck  works when reading documents from the database. Mongoid 8.0 behavior: Mongoid 7 behavior, given the same setup: For clarity, the following behavior is unchanged from Mongoid 7 to Mongoid 8.0: The previously deprecated  Mongoid::Criteria#geo_spacial  method has been\nremoved in Mongoid 8. It has been replaced one-for-one with  #geo_spatial \nwhich was added in Mongoid 7.2.0. Mongoid 8 implements the  .tally  method on  Mongoid#Criteria .  tally \ntakes a field name as a parameter and returns a mapping from values to their\ncounts. For example, take the following model: and the following documents in the database: Calling  tally  on the age field yields the following: The  tally  method accepts the dot notation and field aliases. It also\nallows for tallying localized fields. Mongoid 8 implements the  .pick  method on  Mongoid#Criteria .  pick \ntakes one or more field names as a parameter and returns the values for those\nfields from one document. Consider the following model: and the following documents in the database: Calling  pick  on the age field yields the following: This method does not apply a sort to the documents, so it will not necessarily\nreturn the values from the first document. The  pick  method accepts the dot notation and field aliases. It also\nallows for picking localized fields. When given a block, without  _id  arguments,  find  delegates to\n Enumerable#find . Consider the following model: Calling  find  with a block returns the first document for which the block\nreturns  true : In Mongoid 8, if an invalid document is assigned to a  belongs_to  association,\nand the base document is saved, if the  belongs_to  association had the\noption  optional: false  or  optional  is unset and the global flag\n belongs_to_required_by_default  is true, neither the document nor the\nassociated document will be persisted. For example, given the following\nmodels: In this case, both the child and the parent will not be persisted. If optional is false, then the Child will be persisted with a parent_id, but the\nparent will not be persisted: If you want the functionality of neither document being persisted in Mongoid 7 or 8\nand earlier, the  validate: true  option can be set on the association. If\nyou want the functionality of only the Child being persisted, the  validate:\nfalse  option can be set on the association. In Mongoid 8, when pushing persisted elements to a HABTM association, the\nassociation will now update correctly without requiring a reload.\nFor example: As you can see from this example, after pushing  user2  to the users array,\nMongoid 8 correctly updates the number of elements without requiring a reload. Breaking change:  In Mongoid 8, storing a String in a field of type\n BSON::Binary  will be stored in and returned from the database as a\n BSON::Binary . Prior to Mongoid 8 it was stored and returned as a String: The previously deprecated  Document#to_a  method has been removed in\nMongoid 8. The  :drop_dups  option has been removed from the  index  macro. This option\nwas specific to MongoDB server 2.6 and earlier, which Mongoid no longer supports. The previously deprecated  Mongoid::Errors::EagerLoad  exception class\nhas been removed in Mongoid 8. It has not been used by Mongoid since\nversion 7.1.1 when eager loading for polymorphic  belongs_to  associations\nwas implemented. Mongoid 8 removes the following deprecated constants that are not expected\nto have been used outside of Mongoid: Mongoid::Extensions::Date::EPOCH Mongoid::Extensions::Time::EPOCH Mongoid::Factory::TYPE The previously deprecated  Array#update_values  and  Hash#update_values \nmethods have been removed in Mongoid 8. The  geoHaystack  and  geoSearch  options on indexes have been deprecated. Support for the  :id_sort  option on the  #first  and  #last  options has\nbeen dropped. These methods now only except a limit as a positional argument. Support for individually caching criteria objects has been dropped in Mongoid 8. In order to get caching functionality, enable the Mongoid Query Cache. See the\nsection on  Query Cache  for more details.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Cat\n  include Mongoid::Document\n\n  field :age, type: Integer\n\n  after_save do\n    p self\n    p attribute_was(:age)\n  end\nend\n\na = Cat.create!\na.age = 2\na.save!"
                },
                {
                    "lang": "ruby",
                    "value": "#<Cat _id: 60aef1652c97a617438dc9bb, age: 2>\n2"
                },
                {
                    "lang": "ruby",
                    "value": "#<Cat _id: 60aef1652c97a617438dc9bb, age: 2>\nnil"
                },
                {
                    "lang": "ruby",
                    "value": "class User\n  include Mongoid::Document\n\n  field :name, type: String\n  field :age, type: Integer\nend\n\nuser = User.create!(name: 'Sam', age: 18)\nuser.previously_new_record?     # => true\n\nuser.name = \"Nick\"\nuser.save!\nuser.name_previously_was        # => \"Sam\"\nuser.age_previously_was         # => 18\nuser.previously_new_record?     # => false\n\nuser.destroy\nuser.previously_persisted?   # => true"
                },
                {
                    "lang": "ruby",
                    "value": "class User\n  include Mongoid::Document\n\n  field :name, type: :bogus\n  # => raises Mongoid::Errors::InvalidFieldType\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class User\n  include Mongoid::Document\n\n  field :name, type: :bogus\n  # Equivalent to:\n  field :name\nend"
                },
                {
                    "lang": "ruby",
                    "value": "Band.any_of({name: 'The Rolling Stones'}, {founded: 1990}).\n  any_of({members: 2}, {last_tour: 1995})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$or\"=>[{\"name\"=>\"The Rolling Stones\"}, {\"founded\"=>1990}],\n#     \"$and\"=>[{\"$or\"=>[{\"members\"=>2}, {\"last_tour\"=>1995}]}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.any_of({name: 'The Rolling Stones'}, {founded: 1990}).any_of({members: 2})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$or\"=>[{\"name\"=>\"The Rolling Stones\"}, {\"founded\"=>1990}], \"members\"=>2}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "Band.any_of({name: 'The Rolling Stones'}, {founded: 1990}).\n  any_of({members: 2}, {last_tour: 1995})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$or\"=>[{\"name\"=>\"The Rolling Stones\"}, {\"founded\"=>1990},\n#     {\"members\"=>2}, {\"last_tour\"=>1995}]}\n#   options:  {}\n#   class:    Band\n#   embedded: false>\n\nBand.any_of({name: 'The Rolling Stones'}, {founded: 1990}).any_of({members: 2})\n# =>\n# #<Mongoid::Criteria\n#   selector: {\"$or\"=>[{\"name\"=>\"The Rolling Stones\"}, {\"founded\"=>1990}], \"members\"=>2}\n#   options:  {}\n#   class:    Band\n#   embedded: false>"
                },
                {
                    "lang": "ruby",
                    "value": "class Address\n  include Mongoid::Document\n\n  embedded_in :mall\n\n  field :street, type: String\nend\n\nclass Mall\n  include Mongoid::Document\n\n  embeds_many :addresses\nend\n\nmall = Mall.create!\nmall.addresses.create!(street: \"Elm Street\")\nmall.addresses.create!(street: nil)\n\n# Pluck from embedded document criteria\nmall.addresses.all.pluck(:street)\n  #=> ['Elm Street', nil]"
                },
                {
                    "lang": "ruby",
                    "value": "# Pluck from embedded document criteria\nmall.addresses.all.pluck(:street)\n  #=> ['Elm Street']"
                },
                {
                    "lang": "ruby",
                    "value": "# Pluck from database\nMall.all.pluck('addresses.street')\n  #=> [ ['Elm Street', nil] ]\n\n# Pluck using ActiveSupport Array#pluck\nmall.addresses.pluck(:street)\n  #=> ['Elm Street', nil]"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n  field :age\nend"
                },
                {
                    "lang": null,
                    "value": "{ _id: 1, age: 21 }\n{ _id: 2, age: 21 }\n{ _id: 3, age: 22 }"
                },
                {
                    "lang": null,
                    "value": "User.tally(\"age\")\n# => { 21 => 2, 22 => 1 }"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n  field :age\nend"
                },
                {
                    "lang": null,
                    "value": "{ _id: 1, age: 21 }\n{ _id: 2, age: 21 }\n{ _id: 3, age: 22 }"
                },
                {
                    "lang": null,
                    "value": "User.pick(:age)\n# => 21"
                },
                {
                    "lang": null,
                    "value": "class Band\n  include Mongoid::Document\n  field :name, type: String\nend\n\nBand.create!(name: \"Depeche Mode\")\nBand.create!(name: \"The Rolling Stones\")"
                },
                {
                    "lang": null,
                    "value": "Band.find do |b|\n  b.name == \"Depeche Mode\"\nend\n# => #<Band _id: 62c58e383282a4cbe82bd74b, name: \"Depeche Mode\">"
                },
                {
                    "lang": null,
                    "value": "class Parent\n  include Mongoid::Document\n  has_one :child\n  field :name\n  validates :name, presence: true\nend\n\nclass Child\n  include Mongoid::Document\n\n  belongs_to :parent, autosave: true, validate: false, optional: false\nend\n\nchild = Child.new\nparent = Parent.new\nchild.parent = parent # parent is invalid, it does not have a name\nchild.save"
                },
                {
                    "lang": null,
                    "value": "child = Child.new\nparent = Parent.new\nchild.parent = parent # parent is invalid, it does not have a name\nchild.save\n\np Child.first\n# => <Child _id: 629a50b0d1327aad89d214d2, parent_id: BSON::ObjectId('629a50b0d1327aad89d214d3')>\np Parent.first\n# => nil"
                },
                {
                    "lang": null,
                    "value": "class User\n  include Mongoid::Document\n  has_and_belongs_to_many :posts\nend\n\nclass Post\n  include Mongoid::Document\n  has_and_belongs_to_many :users\nend\n\nuser1 = User.create!\nuser2 = User.create!\n\npost = user1.posts.create!\n\np post.users.length\n# => 1\n\npost.users << user2\n\np post.users.length\n# => 1 in Mongoid 7, 2 in Mongoid 8\n\np post.reload.users.length\n# => 2"
                },
                {
                    "lang": null,
                    "value": "class Registry\n  include Mongoid::Document\n  field :data, type: BSON::Binary\nend\n\nregistry = Registry.create!(data: \"data!\")\np registry.data\n# => Mongoid 7: \"data!\"\n# => Mongoid 8: <BSON::Binary:0x2580 type=generic data=0x6461746121...>\n\nregistry = Registry.find(registry.id)\np registry.data\n# => Mongoid 7: \"data!\"\n# => Mongoid 8: <BSON::Binary:0x2600 type=generic data=0x6461746121...>"
                }
            ],
            "preview": "This page describes significant changes and improvements in Mongoid 8.0.\nThe complete list of releases is available on GitHub and in JIRA;\nplease consult GitHub releases for detailed release notes and JIRA for\nthe complete list of issues fixed in each release, including bug fixes.",
            "tags": null,
            "facets": null
        },
        {
            "slug": "reference/associations",
            "title": "Associations",
            "headings": [
                "Referenced Associations",
                "Has One",
                "Has Many",
                "Queries",
                "any?",
                "exists?",
                "Belongs To",
                "Has And Belongs To Many",
                "Querying Referenced Associations",
                "Embedded Associations",
                "Embeds One",
                "Defining",
                "Storage",
                "Embeds Many",
                "Defining",
                "Storage",
                "Recursive Embedding",
                "Referencing Vs Embedding",
                "Setting Stale Values on Referenced Associations",
                "Querying Embedded Associations",
                "Querying Loaded Associations",
                "Embedded Matching Vs Server Behavior",
                "Omitting _id Fields",
                "Deleting",
                "clear",
                "delete_all",
                "destroy_all",
                "Hash Assignment",
                "Common Behavior",
                "Extensions",
                "Custom Association Names",
                "Custom Primary & Foreign Keys",
                "Custom Scopes",
                "Validations",
                "Polymorphism",
                "Cascading Callbacks",
                "Dependent Behavior",
                "Autosaving",
                "Existence Predicates",
                "Autobuilding",
                "Touching",
                "The counter_cache Option",
                "Association Proxies",
                "Association Metadata",
                "Attributes",
                "The Association Object"
            ],
            "paragraphs": "Mongoid supports the  has_one ,  has_many ,  belongs_to  and\n has_and_belongs_to_many  associations familiar to ActiveRecord users. Use the  has_one  macro to declare that the parent has a child stored in\na separate collection. The child is optional by default: When using  has_one , the child model must use  belongs_to  to declare the\nassociation with the parent: Given the above definitions, every child document contains a reference to\nits respective parent document: Use validations to require that the child is present: Use the  has_many  association to declare that the parent has zero or more\nchildren stored in a separate collection: Like with  has_one , the child model must use  belongs_to  to declare the\nassociation with the parent: Also as with  has_one , the child documents contain references to their\nrespective parents: Use validations to require that at least one child is present: Use the  any?  method on the association to efficiently determine whether\nthe association contains any documents, without retrieving the entire set\nof documents from the database: any?  also implements the  Enumerable#any? API , allowing\nfiltering with a block: ... or by a class name which can be useful for polymorphic associations: If the association is already loaded,  any?  inspects the loaded\ndocuments and does not query the database: Note that simply calling  any?  would  not  load the association\n(since  any?  only retrieves the _id field of the first matching document). The  exists?  method on the association determines whether there are\nany  persisted  documents in the association. Unlike the  any?  method: The following example illustrates the difference between  exists?  and\n any? : exists?  always queries the database, even if the association is already\nloaded. exists?  does not consider non-persisted documents. exists?  does not allow filtering in the application like  any?  does,\nand does not take any arguments. Use the  belongs_to  macro to associate a child with a parent stored in a\nseparate collection. The  _id  of the parent (if a parent is associated)\nis stored in the child. By default, if a  belongs_to  association is defined on a model, it must be\nprovided a value for a model instance to be saved. Use the  optional: true` \noption to make the instances persistable without specifying the parent: To change the default behavior of  belongs_to  associations to not require\ntheir respective parents globally, set the  belongs_to_required_by_default \n configuration option  to  false . Although  has_one  and  has_many  associations require the\ncorresponding  belongs_to  association to be defined on the child,\n belongs_to  may also be used without a corresponding  has_one  or\n has_many  macro. In this case the child is not accessible from the parent\nbut the parent is accessible from the child: For clarity it is possible to add the  inverse_of: nil  option in cases when\nthe parent does not define the association: Use the  has_and_belongs_to_many  macro to declare a many-to-many\nassociation: Both model instances store a list of ids of the associated models, if any: You can create a one-sided  has_and_belongs_to_many  association to store\nthe ids only in one document using the  inverse_of: nil  option: A one-sided  has_and_belongs_to_many  association is, naturally, only\nusable from the model where it is defined. Given two models, A and B where A  has_and_belongs_to_many  B,\nwhen adding a document of type B to the HABTM association on a document of\ntype A, Mongoid will not update the  updated_at  field for the document of\ntype A, but will update the  updated_at  field for the document of type B. In most cases, efficient queries across referenced associations (and in general\ninvolving data or conditions or multiple collections) are performed using\nthe aggregation pipeline. Mongoid helpers for constructing aggregation pipeline\nqueries are described in the  aggregation pipeline \nsection. For simple queries, the use of aggregation pipeline may be avoided and\nassociations may be queried directly. When querying associations directly,\nall conditions must be on that association's collection only (which typically\nmeans association in question and any associations embedded in it). For example, given the following models: One could retrieve all bands that have toured since 2000 as follows: The conditions on  Tour  can be arbitrarily complex, but they must all\nbe on the same  Tour  document (or documents embedded in  Tour ). To find awards for bands that have toured since 2000: Thanks to MongoDB's document model, Mongoid also offers embedded associations\nwhich allow documents of different types to be stored hierarchically\nin the same collection. Embedded associations are defined using\n embeds_one ,  embeds_many  and  embedded_in  macros, plus\n recursively_embeds_one  and  recursively_embeds_many  for recursive\nembedding. One to one associations where the children are embedded in the parent\ndocument are defined using Mongoid's  embeds_one  and  embedded_in  macros. The parent document of the association should use the  embeds_one  macro to\nindicate is has one embedded child, where the document that is embedded uses\n embedded_in . Definitions are required on both sides to the association\nin order for it to work properly. Documents that are embedded using the  embeds_one  macro are stored as a\nhash inside the parent in the parent's database collection. You can optionally tell Mongoid to store the embedded document in a different\nattribute other than the name, by providing the  :store_as  option. One to many relationships where the children are embedded in the parent\ndocument are defined using Mongoid's  embeds_many  and  embedded_in  macros. The parent document of the association should use the  embeds_many  macro\nto indicate it has many embedded children, where the document that is\nembedded uses  embedded_in . Definitions are required on both sides of\nthe association in order for it to work properly. Documents that are embedded using the  embeds_many  macro are stored as\nan array of hashes inside the parent in the parent's database collection. You can optionally tell Mongoid to store the embedded document in a different\nattribute other than the name, by providing the  :store_as  option. A document can recursively embed itself using  recursively_embeds_one  or\n recursively_embeds_many , which provides accessors for the parent and\nchildren via  parent_  and  child_  methods. While a complete discussion of referencing vs embedding is beyond the scope\nof this tutorial, here are some high level considerations for choosing\none over the other. When an association is embedded, both parent and child documents are stored\nin the same collection. This permits efficient persistence and retrieval\nwhen both are used/needed. For example, if the navigation bar on a web site\nshows attributes of a user that are stored in documents themselves, it is\noften a good idea to use embedded associations. Using embedded associations allows using MongoDB tools like the\n aggregation pipeline  to query\nthese documents in a powerful way. Because embedded documents are stored as part of their parent top-level\ndocuments, it is not possible to persist an embedded document by itself,\nnor is it possible to retrieve embedded documents directly. However,\nembedded documents can still be efficiently queried and retrieved with the\nhelp of MongoDB projection operation: Setting a stale value to a referenced association can sometimes result in\na  nil  value being persisted to the database. Take the following case: At this point,  post.comment  is set to  comment1 , however since a reload\nhappened,  post.comment  does not refer to the same object as  comment1 .\nMeaning, updating one object does not implicitly update the other. This matters\nfor the next operation: Now,  post.comment  is set to  comment2 , and the  post_id  of the old\ncomment is set to  nil . However, the value that was assigned to\n post.comment  did not refer to the same object as  comment1 , therefore,\nwhile the old value of  post.comment  was updated to have a  nil \n post_id ,  comment1  still has the  post_id  set. Finally, this last assignment attempts to set the  post_id  on  comment1 ,\nwhich should be  nil  at this point, but is set to the old  post_id .\nDuring this operation, the  post_id  is cleared from  comment2 , and the\nnew  post_id  is set on  comment1 . However, since the  post_id  was\nalready set on  comment1 , nothing is persisted, and we end up with both\ncomments having a  nil   post_id . At this point, running  post.comment \nreturns  nil . When querying top-level documents, conditions can be specified on documents\nin embedded associations using the dot notation. For example, given the\nfollowing models: To retrieve bands based on tour attributes, use the dot notation as follows: To retrieve only documents of embedded associations, without retrieving\ntop-level documents, use the  pluck  projection method: Mongoid query methods can be used on embedded associations of documents which\nare already loaded in the application. This mechanism is sometimes called\n\"embedded matching\" or \"embedded document matching\" and it is implemented\nentirely in Mongoid - the queries are NOT sent to the server. Embedded matching is supported for most general-purpose query operators. It\nis not implemented for  text search ,  geospatial query\noperators ,\noperators that execute JavaScript code ( $where )\nand operators that are implemented via other server functionality such as\n $expr \nand  $jsonSchema . The following operators are supported: For example, using the model definitions just given, we could query\ntours on a loaded band: Bitwise operators Comparison operators Logical operators $comment $exists $mod $type $regex  ( $options  field\nis only supported when the  $regex  argument is a string) Array query operators Mongoid aims to provide the same semantics when performing embedded matching\nas those of MongoDB server. This means, for example, when the server only\naccepts arguments of particular types for a particular operator, Mongoid\nwould also only accept arguments of the corresponding types. The following deviations are known: In general, Mongoid adopts the behavior of current server versions and validates more strictly. Mongoid embedded matchers, because they are implemented on the client side,\nbehave the same regardless of the server version that backs the application.\nAs such, it is possible for Mongoid to deviate from server behavior if\nthe server itself behaves differently in different versions. All operators are implemented in\nMongoid regardless of backing deployment's server version. As of this writing, the known cases of such deviation are: 3.2 and earlier servers not validating  $size  arguments as strictly as newer versions do. 4.0 and earlier servers not validating  $type  arguments as strictly as newer versions\ndo (allowing invalid arguments like 0, for example). 3.2 and earlier servers not supporting  Decimal128  for  $type , as well as allowing invalid\narguments such as negative numbers (smaller than -1) and numbers that are greater than 19\n(not including 127, the argument for the  MaxKey  type). 3.4 and earlier servers not supporting arrays for  $type . 3.0 and earlier servers not supporting bitwise operators. Mongoid DSL expands  Range  arguments to hashes with  $gte  and  $lte \nconditions.  In some cases \nthis creates bogus queries. Embedded matchers raise the  InvalidQuery \nexception in these cases. The operators that are known to be affected are\n $elemMatch ,  $eq ,  $gt ,  $gte ,  $lt ,  $lte  and  $ne . When performing embedded matching with  $regex ,  it is not currently\npossible  to specify a\nregular expression object as the pattern and also provide options. By default, Mongoid adds an  _id  field to each embedded document. This\npermits easy referencing of and operations on the embedded documents. These  _id  fields may be omitted to save storage space. To do so,\n override the _id field definition in the child documents \nand remove the default value: In the current version of Mongoid the field definition is required, but\nwithout a default value specified no value will be stored in the database.\nA future version of Mongoid may allow removing previously defined fields. Removing the  _id  field means that embedded documents must be identified\nby their content attribute values during queries, updates and deletes. Mongoid provides three methods for deleting children from  embeds_many \nassociations:  clear ,  destroy_all  and  delete_all . The  clear  method uses the  $unset operator  to remove the entire association from the\nhost document. It does not run destroy callbacks on the documents being removed,\nacting like  delete_all  in this regard: If  clear  is called on an association in an unsaved host document, it will\nstill try to remove the association from the database based on the host\ndocument's  _id : The  delete_all  method removes the documents that are in the association\nusing the  $pullAll operator .\nUnlike  clear ,  delete_all : delete_all  does not run destroy callbacks on the documents being removed. Example: Loads the association, if it wasn't yet loaded; Only removes the documents that exist in the application. The  delete_all  method removes the documents that are in the association\nusing the  $pullAll operator \nwhile running the destroy callbacks. Like  delete_all ,  destroy_all \nloads the entire association if it wasn't yet loaded and it only removes\ndocuments that exist in the application: Embedded associations allow the user to assign a  Hash  instead of a document\nto an association. On assignment, this hash is coerced into a document of the\nclass of the association that it's being assigned to. Take the following\nexample: This works for  embeds_one ,  embeds_many , and  embedded_in  associations.\nNote that you cannot assign hashes to referenced associations. All associations can have extensions, which provides a way to add application specific\nfunctionality to the association. They are defined by providing a block to the association definition. You can name your associations whatever you like, but if the class cannot be inferred by\nMongoid from the name, and neither can the opposite side you'll want to provide the\nmacro with some additional options to tell Mongoid how to hook them up. The fields used when looking up associations can be explicitly specified.\nThe default is to use  id  on the \"parent\" association and  #{association_name}_id \non the \"child\" association, for example with a has_many/belongs_to: Specify a different  primary_key  to change the field name on the \"parent\"\nassociation and  foreign_key  to change the field name on the \"child\"\nassociation: With a has_and_belongs_to_many association, since the data is stored on both\nsides of the association, there are 4 fields configurable when the association\nis defined: An example might make this more clear: Note that just like with the default  #{association_name}_id  field,\nMongoid automatically adds a field for the custom foreign key  c_ref  to\nthe model. However, since Mongoid doesn't know what type of data should be\nallowed in the field, the field is created with a type of Object. It is a\ngood idea to explicitly define the field with the appropriate type. :primary_key  is the field on the remote model that contains the value\nby which the remote model is looked up. :foreign_key  is the field on the local model which stores the\n :primary_key  values. :inverse_primary_key  is the field on the local model that the remote\nmodel uses to look up the local model documents. :inverse_foreign_key  is the field on the remote model storing the\nvalues in  :inverse_primary_key . You may set a specific scope on an association using the  :scope  parameter.\nThe scope is an additional filter that restricts which objects are considered\nto be a part of the association - a scoped association will return only\ndocuments which satisfy the scope condition.. The scope may be either: a  Proc  with arity zero, or a  Symbol  which references a  named scope  on the\nassociated model. It is possible to add documents that do not satisfy an association's scope\nto that association. In this case, such documents will appear associated\nin memory, and will be saved to the database, but will not be present when\nthe association is queried in the future. For example: Mongoid's syntax for scoped association differs from that of ActiveRecord.\nMongoid uses the  :scope  keyword argument for consistency with other\nassociation options, whereas in ActiveRecord the scope is a positional\nargument. It is important to note that by default, Mongoid will validate the children of any\nassociation that are loaded into memory via a  validates_associated . The associations that\nthis applies to are: If you do not want this behavior, you may turn it off when defining the association. embeds_many embeds_one has_many has_one has_and_belongs_to_many One to one and one to many associations support polymorphism, which is\nhaving a single association potentially contain objects of different classes.\nFor example, we could model an organization in which departments and teams\nhave managers as follows: To provide another example, suppose we want to track price history for\nproducts and bundles. This can be achieved via an embedded one to many\npolymorphic association: To define a polymorphic association, specify the  polymorphic: true  option\non the child association and add the  as: :association_name  option to the\nparent association. Note that Mongoid currently supports polymorphism only in one direction - from\nthe child to the parent. For example, polymorphism cannot be used to specify\nthat a bundle may contain other bundles or products: has_and_belongs_to_many  associations do not support polymorphism. If you want the embedded document callbacks to fire when calling a persistence\noperation on its parent, you will need to provide the cascade callbacks option\nto the association. You can provide dependent options to referenced associations to instruct Mongoid\nhow to handle situations where one side of the association is deleted, or is attempted\nto be deleted. The options are as follows: If no  :dependent  option is provided, deleting the parent document leaves the child document unmodified\n(in other words, the child document continues to reference the now deleted parent document via the foreign key field).\nThe child may become orphaned if it is ordinarily only referenced via the parent. :delete_all : Delete the child document(s) without running any of the model callbacks. :destroy : Destroy the child document(s) and run all of the model callbacks. :nullify : Set the foreign key field of the child document to nil. The child may become orphaned if it is ordinarily only referenced via the parent. :restrict_with_exception :  raise  an error if the child is not empty. :restrict_with_error : Cancel operation and return false if the child is not empty. One core difference between Mongoid and ActiveRecord is that Mongoid does not\nautomatically save associated documents for referenced (i.e., non-embedded)\nassociations when the parent is saved, for performance reasons. If autosaving is not used, it is possible to create dangling references\nto non-existent documents via associations: To make referenced associations save automatically when the parent is saved,\nadd the  :autosave  option to the association: The autosaving functionality is automatically added to an association when\nusing  accepts_nested_attributes_for , so that the application does not\nneed to track which associations were modified when processing a form\nsubmission. Embedded associations always autosave, because they are stored as part of the\nparent document. Some operations on associations always save the parent and the child documents\nas part of the operation, regardless of whether autosaving is enabled.\nA non-exhaustive list of these operations is as follows: Assignment to the association: push ,  << : All associations have existence predicates on them in the form of  name?  and  has_name? \nto check if the association is blank. One to one associations ( embeds_one ,  has_one ) have an autobuild option which tells\nMongoid to instantiate a new document when the association is accessed and it is  nil . Any  belongs_to  association can take an optional  :touch  option which\nwill cause the parent document to be touched whenever the child document is\nupdated: :touch  can also take a string or symbol argument specifying a field to\nbe touched on the parent association in addition to updated_at: When an embedded document is touched, its parents are recursively touched\nthrough the composition root (because all of the parents are necessarily saved\nwhen the embedded document is saved). The  :touch  attribute therefore is\nunnecessary on  embedded_in  associations. Mongoid currently  does not support specifying an additional field to be\ntouched on an embedded_in association . :touch  should not be set to  false  on an  embedded_in  association,\nsince composition hierarchy is always updated upon a touch of an embedded\ndocument. This is currently not enforced but enforcement is  intended in the\nfuture . As with ActiveRecord, the  :counter_cache  option can be used on an association\nto make finding the number of belonging objects more efficient. Also similar\nto ActiveRecord, you must take into account that there will be an extra\nattribute on the associated model. This means that with Mongoid,\nyou need to include  Mongoid::Attributes::Dynamic  on the associated model.\nFor example: Associations employ transparent proxies to the target objects. This can\ncause surprising behavior in some situations. The method visibility may be lost when methods on association targets are\naccessed, depending on the association: All associations in Mongoid contain metadata that holds information about the association in\nquestion, and is a valuable tool for third party developers to use to extend Mongoid. You can access the association metadata of the association in a few different ways. All associations contain a  _target , which is the proxied document or documents, a  _base \nwhich is the document the association hangs off, and  _association  which provides information\nabout the association. The association object itself contains more information than one might know what to do\nwith, and is useful for developers of extensions to Mongoid. Method Description Association#as Returns the name of the parent to a polymorphic child. Association#as? Returns whether or not an as option exists. Association#autobuilding? Returns whether or not the association is autobuilding. Association#autosaving? Returns whether or not the association is autosaving. Association#cascading_callbacks? Returns whether the association has callbacks cascaded down from the parent. Association#class_name Returns the class name of the proxied document. Association#cyclic? Returns whether the association is a cyclic association. Association#dependent Returns the association's dependent option. Association#destructive? Returns true if the association has a dependent delete or destroy. Association#embedded? Returns whether the association is embedded in another document. Association#forced_nil_inverse? Returns whether the association has a nil inverse defined. Association#foreign_key Returns the name of the foreign key field. Association#foreign_key_check Returns the name of the foreign key field dirty check method. Association#foreign_key_setter Returns the name of the foreign key field setter. Association#indexed? Returns whether the foreign key is auto indexed. Association#inverses Returns the names of all inverse association. Association#inverse Returns the name of a single inverse association. Association#inverse_class_name Returns the class name of the association on the inverse side. Association#inverse_foreign_key Returns the name of the foreign key field on the inverse side. Association#inverse_klass Returns the class of the association on the inverse side. Association#inverse_association Returns the metadata of the association on the inverse side. Association#inverse_of Returns the explicitly defined name of the inverse association. Association#inverse_setter Returns the name of the method used to set the inverse. Association#inverse_type Returns the name for the polymorphic type field of the inverse. Association#inverse_type_setter Returns the name for the polymorphic type field setter of the inverse. Association#key Returns the name of the field in the attributes hash to use to get the association. Association#klass Returns the class of the proxied documents in the association. Association#name Returns the association name. Association#options Returns self, for API compatibility with ActiveRecord. Association#order Returns the custom sorting options on the association. Association#polymorphic? Returns whether the association is polymorphic. Association#setter Returns the name of the field to set the association. Association#store_as Returns the name of the attribute to store an embedded association in. Association#touchable? Returns whether or not the association has a touch option. Association#type Returns the name of the field to get the polymorphic type. Association#type_setter Returns the name of the field to set the polymorphic type. Association#validate? Returns whether the association has an associated validation.",
            "code": [
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_one :studio\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Studio\n  include Mongoid::Document\n\n  belongs_to :band\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!(studio: Studio.new)\n# => #<Band _id: 600114fa48966848ad5bd392, >\n\nband.studio\n# => #<Studio _id: 600114fa48966848ad5bd391, band_id: BSON::ObjectId('600114fa48966848ad5bd392')>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_one :studio\n\n  validates_presence_of :studio\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :members\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Member\n  include Mongoid::Document\n\n  belongs_to :band\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!(members: [Member.new])\n# => #<Band _id: 6001166d4896684910b8d1c5, >\n\nband.members\n# => [#<Member _id: 6001166d4896684910b8d1c6, band_id: BSON::ObjectId('6001166d4896684910b8d1c5')>]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :members\n\n  validates_presence_of :members\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.first\nband.members.any?"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.first\nband.members.any? { |member| member.instrument == 'piano' }"
                },
                {
                    "lang": "ruby",
                    "value": "class Drummer < Member\nend\n\nband = Band.first\nband.members.any?(Drummer)"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.first\n# Queries the database\nband.members.any?\n\nband.members.to_a\n\n# Does not query the database\nband.members.any?"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!\n# Member is not persisted.\nband.members.build\n\nband.members.any?\n# => true\nband.members.exists?\n# => false\n\n# Persist the member.\nband.members.map(&:save!)\n\nband.members.any?\n# => true\nband.members.exists?\n# => true"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_one :studio\nend\n\nclass Studio\n  include Mongoid::Document\n\n  belongs_to :band, optional: true\nend\n\nstudio = Studio.create!\n# => #<Studio _id: 600118184896684987aa884f, band_id: nil>"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\nend\n\nclass Studio\n  include Mongoid::Document\n\n  belongs_to :band\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\nend\n\nclass Studio\n  include Mongoid::Document\n\n  belongs_to :band, inverse_of: nil\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_and_belongs_to_many :tags\nend\n\nclass Tag\n  include Mongoid::Document\n\n  has_and_belongs_to_many :bands\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.create!(tags: [Tag.create!])\n# => #<Band _id: 60011d554896684b8b910a2a, tag_ids: [BSON::ObjectId('60011d554896684b8b910a29')]>\n\nband.tags\n# => [#<Tag _id: 60011d554896684b8b910a29, band_ids: [BSON::ObjectId('60011d554896684b8b910a2a')]>]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_and_belongs_to_many :tags, inverse_of: nil\nend\n\nclass Tag\n  include Mongoid::Document\nend\n\nband = Band.create!(tags: [Tag.create!])\n# => #<Band _id: 60011dbc4896684bbbaa9255, tag_ids: [BSON::ObjectId('60011dbc4896684bbbaa9254')]>\n\nband.tags\n# => [#<Tag _id: 60011dbc4896684bbbaa9254, >]"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :tours\n  has_many :awards\n\n  field :name, type: String\nend\n\nclass Tour\n  include Mongoid::Document\n\n  belongs_to :band\n\n  field :year, type: Integer\nend\n\nclass Award\n  include Mongoid::Document\n\n  belongs_to :band\n\n  field :name, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band_ids = Tour.where(year: {'$gte' => 2000}).pluck(:band_id)\nbands = Band.find(band_ids)"
                },
                {
                    "lang": "ruby",
                    "value": "band_ids = Tour.where(year: {'$gte' => 2000}).pluck(:band_id)\nawards = Award.where(band_id: {'$in' => band_ids})"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_one :label\nend\n\nclass Label\n  include Mongoid::Document\n  field :name, type: String\n  embedded_in :band\nend"
                },
                {
                    "lang": "ruby",
                    "value": "{\n  \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7e9\"),\n  \"label\" : {\n    \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7e0\"),\n    \"name\" : \"Mute\",\n  }\n}"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_one :label, store_as: \"lab\"\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_many :albums\nend\n\nclass Album\n  include Mongoid::Document\n  field :name, type: String\n  embedded_in :band\nend"
                },
                {
                    "lang": "ruby",
                    "value": "{\n  \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7e9\"),\n  \"albums\" : [\n    {\n      \"_id\" : ObjectId(\"4d3ed089fb60ab534684b7e0\"),\n      \"name\" : \"Violator\",\n    }\n  ]\n}"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_many :albums, store_as: \"albs\"\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Tag\n  include Mongoid::Document\n  field :name, type: String\n  recursively_embeds_many\nend\n\nroot = Tag.new(name: \"programming\")\nchild_one = root.child_tags.build\nchild_two = root.child_tags.build\n\nroot.child_tags # [ child_one, child_two ]\nchild_one.parent_tag # [ root ]\nchild_two.parent_tag # [ root ]\n\nclass Node\n  include Mongoid::Document\n  recursively_embeds_one\nend\n\nroot = Node.new\nchild = Node.new\nroot.child_node = child\n\nroot.child_node # child\nchild.parent_node # root"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :started_on, type: Date\n  embeds_one :label\nend\n\nclass Label\n  include Mongoid::Document\n  field :name, type: String\n  embedded_in :band\nend\n\n# Retrieve labels for bands started in the last year.\n#\n# Sends a find query like this:\n# {\"find\"=>\"bands\",\n#  \"filter\"=>{\"started_on\"=>{\"$gt\"=>2018-07-01 00:00:00 UTC}},\n#  \"projection\"=>{\"_id\"=>1, \"label\"=>1}}\nBand.where(started_on: {'$gt' => Time.now - 1.year}).only(:label).map(&:label).compact.uniq"
                },
                {
                    "lang": "ruby",
                    "value": "class Post\n  include Mongoid::Document\n\n  has_one :comment, inverse_of: :post\nend\n\nclass Comment\n  include Mongoid::Document\n\n  belongs_to :post, inverse_of: :comment, optional: true\nend\n\npost.comment = comment1\npost.reload"
                },
                {
                    "lang": "ruby",
                    "value": "post.comment = comment2\npost.reload"
                },
                {
                    "lang": "ruby",
                    "value": "post.comment = comment1\npost.reload"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_many :tours\n  embeds_many :awards\n  field :name, type: String\nend\n\nclass Tour\n  include Mongoid::Document\n  embedded_in :band\n  field :year, type: Integer\nend\n\nclass Award\n  include Mongoid::Document\n  embedded_in :band\n  field :name, type: String\nend"
                },
                {
                    "lang": "ruby",
                    "value": "# Get all bands that have toured since 2000\nBand.where('tours.year' => {'$gte' => 2000})"
                },
                {
                    "lang": "ruby",
                    "value": "# Get awards for bands that have toured since 2000\nBand.where('tours.year' => {'$gte' => 2000}).pluck(:awards)"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.where(name: 'Astral Projection').first\ntours = band.tours.where(year: {'$gte' => 2000})"
                },
                {
                    "lang": "ruby",
                    "value": "class Order\n  include Mongoid::Document\n\n  embeds_many :line_items\nend\n\nclass LineItem\n  include Mongoid::Document\n\n  embedded_in :order\n\n  field :_id, type: Object\nend"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.find(...)\nband.tours.clear"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.find(...)\nband.tours << Tour.new(...)\n\nunsaved_band = Band.new(id: band.id, tours: [Tour.new])\n# Removes all tours from the persisted band due to _id match.\nunsaved_band.tours.clear\n\nband.tours\n# => []"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.find(...)\nband.tours.delete_all"
                },
                {
                    "lang": "ruby",
                    "value": "band = Band.find(...)\nband.tours.destroy_all"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_many :albums\nend\n\nclass Album\n  include Mongoid::Document\n  field :name, type: String\n  embedded_in :band\nend\n\nband = Band.create!\nband.albums = [ { name: \"Narrow Stairs\" }, { name: \"Transatlanticism\" } ]\np band.albums\n# => [ #<Album _id: 633c71e93282a4357bb608e5, name: \"Narrow Stairs\">, #<Album _id: 633c71e93282a4357bb608e6, name: \"Transatlanticism\"> ]"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  embeds_many :addresses do\n    def find_by_country(country)\n      where(country: country).first\n    end\n    def chinese\n      _target.select { |address| address.country == \"China\" }\n    end\n  end\nend\n\nperson.addresses.find_by_country(\"Mongolia\") # returns address\nperson.addresses.chinese # returns [ address ]"
                },
                {
                    "lang": "ruby",
                    "value": "class Car\n  include Mongoid::Document\n  embeds_one :engine, class_name: \"Motor\", inverse_of: :machine\nend\n\nclass Motor\n  include Mongoid::Document\n  embedded_in :machine, class_name: \"Car\", inverse_of: :engine\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Company\n  include Mongoid::Document\n  has_many :emails\nend\n\nclass Email\n  include Mongoid::Document\n  belongs_to :company\nend\n\ncompany = Company.find(id)\n# looks up emails where emails.company_id == company.id\ncompany.emails"
                },
                {
                    "lang": "ruby",
                    "value": "class Company\n  include Mongoid::Document\n  field :c, type: String\n  has_many :emails, foreign_key: 'c_ref', primary_key: 'c'\nend\n\nclass Email\n  include Mongoid::Document\n  # This definition of c_ref is automatically generated by Mongoid:\n  # field :c_ref, type: Object\n  # But the type can also be specified:\n  field :c_ref, type: String\n  belongs_to :company, foreign_key: 'c_ref', primary_key: 'c'\nend\n\ncompany = Company.find(id)\n# looks up emails where emails.c_ref == company.c\ncompany.emails"
                },
                {
                    "lang": "ruby",
                    "value": "class Company\n  include Mongoid::Document\n\n  field :c_id, type: Integer\n  field :e_ids, type: Array\n\n  has_and_belongs_to_many :employees,\n    primary_key: :e_id, foreign_key: :e_ids,\n    inverse_primary_key: :c_id, inverse_foreign_key: :c_ids\nend\n\nclass Employee\n  include Mongoid::Document\n\n  field :e_id, type: Integer\n  field :c_ids, type: Array\n\n  has_and_belongs_to_many :companies,\n    primary_key: :c_id, foreign_key: :c_ids,\n    inverse_primary_key: :e_id, inverse_foreign_key: :e_ids\nend\n\ncompany = Company.create!(c_id: 123)\n# => #<Company _id: 5c565ece026d7c461d8a9d4e, c_id: 123, e_ids: nil>\n\nemployee = Employee.create!(e_id: 456)\n# => #<Employee _id: 5c565ee8026d7c461d8a9d4f, e_id: 456, c_ids: nil>\n\ncompany.employees << employee\n\ncompany\n# => #<Company _id: 5c565ece026d7c461d8a9d4e, c_id: 123, e_ids: [456]>\n\nemployee\n# => #<Employee _id: 5c5883ce026d7c4b9e244c0c, e_id: 456, c_ids: [123]>"
                },
                {
                    "lang": "ruby",
                    "value": "class Trainer\n  has_many :pets, scope: -> { where(species: 'dog') }\n  has_many :toys, scope: :rubber\nend\n\nclass Pet\n  belongs_to :trainer\nend\n\nclass Toy\n  scope :rubber, where(material: 'rubber')\n  belongs_to :trainer\nend"
                },
                {
                    "lang": "ruby",
                    "value": "trainer = Trainer.create!\ndog = Pet.create!(trainer: trainer, species: 'dog')\ncat = Pet.create!(trainer: trainer, species: 'cat')\n\ntrainer.pets #=> [dog, cat]\n\ntrainer.reload.pets #=> [dog]"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n\n  embeds_many :addresses, validate: false\n  has_many :posts, validate: false\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Department\n  include Mongoid::Document\n\n  has_one :manager, as: :unit\nend\n\nclass Team\n  include Mongoid::Document\n\n  has_one :manager, as: :unit\nend\n\nclass Manager\n  include Mongoid::Document\n\n  belongs_to :unit, polymorphic: true\nend\n\ndept = Department.create!\nteam = Team.create!\n\nalice = Manager.create!(unit: dept)\nalice.unit == dept\n# => true\ndept.manager == alice\n# => true"
                },
                {
                    "lang": "ruby",
                    "value": "class Product\n  include Mongoid::Document\n\n  field :name, type: String\n  has_and_belongs_to_many :bundles\n\n  embeds_many :prices, as: :item\nend\n\nclass Bundle\n  include Mongoid::Document\n\n  field :name, type: String\n  has_and_belongs_to_many :products\n\n  embeds_many :prices, as: :item\nend\n\nclass Price\n  include Mongoid::Document\n\n  embedded_in :item, polymorphic: true\nend\n\npants = Product.create!(name: 'Pants',\n  prices: [Price.new, Price.new])\ncostume = Bundle.create!(name: 'Costume', products: [pants],\n  prices: [Price.new, Price.new])"
                },
                {
                    "lang": "ruby",
                    "value": "class Bundle\n  include Mongoid::Document\n\n  # Does not work:\n  has_many :items, polymorphic: true\nend"
                },
                {
                    "lang": "ruby",
                    "value": " class Band\n   include Mongoid::Document\n   embeds_many :albums, cascade_callbacks: true\n   embeds_one :label, cascade_callbacks: true\n end\n\nband.save # Fires all save callbacks on the band, albums, and label."
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  has_many :albums, dependent: :delete_all\n  belongs_to :label, dependent: :nullify\nend\n\nclass Album\n  include Mongoid::Document\n  belongs_to :band\nend\n\nclass Label\n  include Mongoid::Document\n  has_many :bands, dependent: :restrict_with_exception\nend\n\nlabel = Label.first\nlabel.bands.push(Band.first)\nlabel.delete # Raises an error since bands is not empty.\n\nBand.first.destroy # Will delete all associated albums."
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :albums\nend\n\nclass Album\n  include Mongoid::Document\n\n  belongs_to :band\nend\n\nband = Band.new\nalbum = Album.create!(band: band)\n\n# The band is not persisted at this point.\n\nalbum.reload\n\nalbum.band_id\n# => BSON::ObjectId('6257699753aefe153121a3d5')\n\n# Band does not exist.\nalbum.band\n# => nil"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n\n  has_many :albums\nend\n\nclass Album\n  include Mongoid::Document\n\n  belongs_to :band, autosave: true\nend\n\nband = Band.new\nalbum = Album.create!(band: band)\n\n# The band is persisted at this point.\n\nalbum.reload\n\nalbum.band_id\n# => BSON::ObjectId('62576b4b53aefe178b65b8e3')\n\nalbum.band\n# => #<Band _id: 62576b4b53aefe178b65b8e3, >"
                },
                {
                    "lang": "ruby",
                    "value": "# Saves the band and the album.\nband.albums = [Album.new]"
                },
                {
                    "lang": "ruby",
                    "value": "band.albums << Album.new\nband.albums.push(Album.new)"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_one :label\n  embeds_many :albums\nend\n\nband.label?\nband.has_label?\nband.albums?\nband.has_albums?"
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  embeds_one :label, autobuild: true\n  has_one :producer, autobuild: true\nend\n\nband = Band.new\nband.label # Returns a new empty label.\nband.producer # Returns a new empty producer."
                },
                {
                    "lang": "ruby",
                    "value": "class Band\n  include Mongoid::Document\n  field :name\n  belongs_to :label, touch: true\nend\n\nband = Band.first\nband.name = \"The Rolling Stones\"\nband.save! # Calls touch on the parent label.\nband.touch # Calls touch on the parent label."
                },
                {
                    "lang": "ruby",
                    "value": "class Label\n  include Mongoid::Document\n  include Mongoid::Timestamps\n  field :bands_updated_at, type: Time\n  has_many :bands\nend\n\nclass Band\n  include Mongoid::Document\n  belongs_to :label, touch: :bands_updated_at\nend\n\nlabel = Label.create!\nband = Band.create!(label: label)\n\nband.touch # Updates updated_at and bands_updated_at on the label."
                },
                {
                    "lang": "ruby",
                    "value": "class Order\n  include Mongoid::Document\n  belongs_to :customer, counter_cache: true\nend\n\nclass Customer\n  include Mongoid::Document\n  include Mongoid::Attributes::Dynamic\n  has_many :orders\nend"
                },
                {
                    "lang": "ruby",
                    "value": "class Order\n  include Mongoid::Document\n  belongs_to :customer\n\n  private\n\n  def internal_status\n    'new'\n  end\nend\n\nclass Customer\n  include Mongoid::Document\n  has_many :orders\n\n  private\n\n  def internal_id\n    42\n  end\nend\n\norder = Order.new\ncustomer = Customer.create!(orders: [order])\n\n# has_many does not permit calling private methods on the target\ncustomer.orders.first.internal_status\n# NoMethodError (private method `internal_status' called for #<Order:0x000055af2ec46c50>)\n\n# belongs_to permits calling private methods on the target\norder.customer.internal_id\n# => 42"
                },
                {
                    "lang": "ruby",
                    "value": "# Get the metadata for a named association from the class or document.\nModel.reflect_on_association(:association_name)\nmodel.reflect_on_association(:association_name)\n\n# Get the metadata with a specific association itself on a specific\n# document.\nmodel.associations[:association_name]"
                },
                {
                    "lang": "ruby",
                    "value": "class Person\n  include Mongoid::Document\n  embeds_many :addresses\nend\n\nperson.addresses = [ address ]\nperson.addresses._target # returns [ address ]\nperson.addresses._base # returns person\nperson.addresses._association # returns the association metadata"
                }
            ],
            "preview": "Mongoid supports the has_one, has_many, belongs_to and\nhas_and_belongs_to_many associations familiar to ActiveRecord users.",
            "tags": null,
            "facets": null
        }
    ]
}