{
    "url": "http://mongodb.com/docs/drivers/csharp/v2.23",
    "includeInGlobalSearch": false,
    "documents": [
        {
            "slug": "quick-start",
            "title": "Quick Start",
            "headings": [
                "Create a MongoDB Cluster",
                "Set Up a Free Tier Cluster in Atlas",
                "Set Your Connection String",
                "Set Up Your Project",
                "Create the Project",
                "Add MongoDB as a Dependency",
                "Query Your MongoDB Cluster from Your Application",
                "Next steps"
            ],
            "paragraphs": "This guide shows you how to create an application that uses the  .NET/C# Driver \nto connect to a  MongoDB Atlas cluster . If you prefer to connect to MongoDB\nusing a different driver or programming language, see our\n list of official MongoDB drivers . The .NET/C# driver lets you connect to and communicate with MongoDB clusters\nfrom a .NET application. MongoDB Atlas is a fully-managed cloud database service that hosts your data\non MongoDB clusters. In this guide, we show you how to get started with your\nown free (no credit card required) cluster. Follow the steps below to connect your .NET application with a MongoDB Atlas\ncluster. To set up your Atlas Free Tier Cluster required for this guide, complete the guide on\n MongoDB Atlas Setup . After completing the steps in the Atlas guide, you have a new MongoDB\ncluster deployed in Atlas, a new database user, and\n sample datasets loaded  into your cluster. You also have\na connection string similar to the following in your copy buffer: Run the following code at the command prompt to save your MongoDB connection string to an\nenvironment variable. This method is safer than including your credentials in your source\ncode. Make sure to replace the  <username>  and  <password>  sections of the connection\nstring with the username and password of your Atlas user. Create a new directory and initialize your project with the  dotnet new  command, as follows: Use the  dotnet add  command to add the .NET/C# Driver to your project as a dependency. In this step, you'll use the .NET/C# Driver\nto connect to your MongoDB cluster and run a query on the sample data. Open the file named  Program.cs  in the base directory of your project. Copy the\nfollowing sample code into  Program.cs This sample code runs a query against your sample dataset in MongoDB Atlas. Run it\nfrom your command line by using the following command: After completing this step, you should have a working application that uses\nthe .NET/C# Driver to connect to your MongoDB cluster, run a query on the\nsample data, and print out the result. To learn more about connecting to Atlas with the .NET/C# Driver, see\nthe  Atlas driver connection  guide\nand select  C#  from the  Select your language  dropdown. When you run  Program.cs , it should output the details of the following movie from\nthe sample dataset: If your output is empty, ensure you have loaded the\n sample datasets  into your cluster. Learn how to read and modify data using the .NET/C# Driver in the CRUD Operations\nguide or how to perform common operations in Usage Examples.",
            "code": [
                {
                    "lang": "bash",
                    "value": "\"mongodb+srv://<username>:<password>@cluster0.abc.mongodb.net/?retryWrites=true&w=majority\""
                },
                {
                    "lang": "bash",
                    "value": "export MONGODB_URI='<your MongoDB URI>'"
                },
                {
                    "lang": "shell",
                    "value": "mkdir csharp-quickstart\ncd csharp-quickstart\ndotnet new console"
                },
                {
                    "lang": "shell",
                    "value": "dotnet add package MongoDB.Driver"
                },
                {
                    "lang": "bash",
                    "value": "dotnet run csharp-quickstart.csproj"
                },
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\nusing MongoDB.Bson;\n\nvar connectionString = Environment.GetEnvironmentVariable(\"MONGODB_URI\");\nif (connectionString == null)\n{\n    Console.WriteLine(\"You must set your 'MONGODB_URI' environment variable. To learn how to set it, see https://www.mongodb.com/docs/drivers/csharp/current/quick-start/#set-your-connection-string\");\n    Environment.Exit(0);\n}\n\nvar client = new MongoClient(connectionString);\n\nvar collection = client.GetDatabase(\"sample_mflix\").GetCollection<BsonDocument>(\"movies\");\n\nvar filter = Builders<BsonDocument>.Filter.Eq(\"title\", \"Back to the Future\");\n\nvar document = collection.Find(filter).First();\n\nConsole.WriteLine(document);\n"
                },
                {
                    "lang": "json",
                    "value": "{\n    \"_id\": \"573a1398f29313caabce9682\",\n    ...\n    \"title\": \"Back to the Future\",\n    ...\n}"
                }
            ],
            "preview": "In this step, you'll use the .NET/C# Driver\nto connect to your MongoDB cluster and run a query on the sample data.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "issues-and-help",
            "title": "Issues & Help",
            "headings": [
                "Bugs / Feature Requests",
                "Pull Requests"
            ],
            "paragraphs": "We are lucky to have a vibrant community of MongoDB .NET/C# Driver\nusers. We recommend seeking support for general\nquestions through the  MongoDB Community Forums . To report a bug or to request a new feature in the .NET/C# Driver,\nplease open an issue in JIRA, our issue management tool, using the\nfollowing steps: Bug reports in JIRA for the CSHARP Driver project can be viewed by everyone. If you identify a security vulnerability in the driver or in any other\nMongoDB project, please report it according to the instructions found in\n Create a Vulnerability Report . Create a JIRA account . Navigate to  the CSHARP Driver project . Click  Create Issue . Please provide as much information as possible about the\nissue and the steps to reproduce it. We are happy to accept contributions to help improve the driver. To\ncontribute to the official driver, follow the  development and testing\nguidelines .\nWe will guide user contributions to ensure they meet the standards of the codebase.",
            "code": [],
            "preview": "We are lucky to have a vibrant community of MongoDB .NET/C# Driver\nusers. We recommend seeking support for general\nquestions through the MongoDB Community Forums.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "whats-new",
            "title": "What's New",
            "headings": [
                "What's New in 2.23",
                "What's New in 2.22",
                "What's New in 2.21",
                "What's New in 2.20",
                "What's New in 2.19"
            ],
            "paragraphs": "Learn what's new in: Version 2.23 Version 2.22 Version 2.21 Version 2.20 Version 2.19 The 2.23 driver release includes the following new features: Improvements and bug fixes to the LINQ3 integration. Added support for aggregation bitwise operators. Added support for the  $out  operator in MongoDB time series collections. Added  ChangeStreamSplitLargeEvent \nto handle change stream events greater than 16 MB. The 2.22 driver release includes the following new features: Improvements and bug fixes to the LINQ3 integration. Added support for  $set  and  $vectorSearch  aggregation stages. Added synonym support for Atlas Search. Reduced memory allocation when using encryption. Added logging messages for server discovery and monitoring (SDAM) events. For more\ninformation on these events, see the\n MongoDB SDAM Logging and Monitoring specification. The 2.21 driver release includes the following new features: The v2.21 driver contains breaking changes. See  Version 2.21.0 Breaking Changes \nfor more information. Improvements and bug fixes to the LINQ3 integration. Accepts options for Atlas Search sorting, tracking, and scoring. Supports the Atlas Search  embeddedDocument  operator. Offers an API for Atlas Search index management. Accepts anonymous types in the  ObjectSerializer.DefaultAllowedTypes  method. The 2.20 driver release includes the following new features: Added full support for MongoDB Server version 7.0.0. Added support for equality query types in Queryable Encryption GA. Improvements to LINQ3 integration. Improvements to serialization features. Improvements to the logging framework. The 2.19 driver release includes the following new features: The  ObjectSerializer  allows deserialization of only safe types, as determined by\nthe configurable  AllowedTypes  function. Changed the default  LinqProvider  to LINQ3. Added Atlas Search ( $search ) support to builders, aggregation pipelines, and LINQ3. Added support for  $bucket  and  $bucketAuto  aggregation pipeline stages in LINQ3. Added support for automatic KMS credentials for Azure VM Managed Identities. Added native support for AWS IAM roles.",
            "code": [],
            "preview": "Learn what's new in:",
            "tags": "update, new feature, deprecation, upgrade, driver v2.19, driver v2.20, driver v2.21, driver v2.22, driver v2.23",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "previous-versions",
            "title": "Previous Versions",
            "headings": [],
            "paragraphs": "The following links direct you to documentation for previous versions of the\ndriver. Version 2.18 Version 2.17 Version 2.16 Version 2.15 Version 2.14 Version 2.13 Version 2.12 Version 2.11 Version 2.10 Version 2.9 Version 2.8 Version 2.7 Version 2.6 Version 2.5 Version 2.4 Version 2.3 Version 2.2 Version 2.1 Version 2.0 Version 1.11",
            "code": [],
            "preview": "The following links direct you to documentation for previous versions of the\ndriver.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "faq",
            "title": "FAQ",
            "headings": [
                "Why Am I Getting Errors While Connecting to MongoDB?",
                "How Does Connection Pooling Work in the .NET/C# Driver?",
                "Why Does the Driver Throw a Timeout During Server Selection?",
                "Why are Certain LINQ or Builder Expressions Unsupported?",
                "What Object Types Can Be Serialized?"
            ],
            "paragraphs": "This page contains frequently asked questions and their corresponding answers. If you can't find an answer to your problem on this page,\nsee the  Issues & Help  page for next steps and more\nresources. If you have trouble connecting to a MongoDB deployment, see\nthe  Connection Troubleshooting Guide \nfor possible solutions. Every  MongoClient  instance has a built-in connection pool for each server\nin your MongoDB topology. Connection pools open sockets on demand to\nsupport concurrent MongoDB operations in your multi-threaded application. The maximum size of each connection pool is set by the  MaxConnectionPoolSize  option, which\ndefaults to  100 . If the number of in-use connections to a server reaches\nthe value of  MaxConnectionPoolSize , the next request to that server will wait\nuntil a connection becomes available. In addition to the sockets needed to support your application's threads,\neach  MongoClient  instance opens two additional sockets per server\nin your MongoDB topology for monitoring the server's state.\nFor example, a client connected to a three-node replica set opens six\nmonitoring sockets. If the application uses the default setting for\n MaxConnectionPoolSize  and only queries the primary (default) node, then\nthere can be at most  106  total connections in use. If the\napplication uses a  read preference  to query the\nsecondary nodes, those connection pools grow and there can be\n 306  total connections. To support high numbers of concurrent MongoDB threads\nwithin one process, you can increase  MaxConnectionPoolSize . The driver has a wait queue that limits the number of threads that can\nwait for a connection. The size of the wait queue is determined by the\n WaitQueueMultiple  option, which defaults to  5 . To calculate the\nmaximum wait queue size, the driver multiplies  WaitQueueMultiple  by\n MaxConnectionPoolSize . If you use the default value for each option,\nthe wait queue size will be  500 . You can also set the wait queue\nsize by specifying the  WaitQueueSize  option, which overrides the\nother settings. However, we do not recommend changing the wait queue\nsize from the default. Connection pools are rate-limited. The  MaxConnecting  setting\ndetermines the number of connections that the pool can create in\nparallel at any time. For example, if the value of  MaxConnecting  is\n 2 , the third thread that attempts to concurrently check out a\nconnection succeeds only in one of the following cases: You can set the minimum number of concurrent connections to\neach server by using the  MinConnectionPoolSize  option, which\ndefaults to  0 . The connection pool will be initialized with this\nnumber of sockets. If errors cause any sockets to close and the\ntotal number of sockets (both in-use and idle) drops below the minimum,\nthe driver opens more sockets until the number reaches the minimum. You can set the maximum number of milliseconds that a connection can\nremain idle in the pool by using the  MaxConnectionIdleTime  option.\nOnce a connection is idle for  MaxConnectionIdleTime , the driver\nremoves it. This option defaults to 10 minutes. If the pool size falls\nbelow  MinConnectionPoolSize , the driver removes  and  replaces the\nidle connection. MongoClient  also has the  MaxConnectionLifeTime  option, which\nspecifies the length of time, 30 minutes by default, that a connection\ncan be pooled before expiring. The following default configuration for a  MongoClient  works for most\napplications: Create a client once for each process, and reuse it for all\noperations. It is a common mistake to create a new client for each\nrequest, which is very inefficient. There is no supported way to terminate a  MongoClient  in the driver. One of the first two threads finishes creating a connection. An existing connection is checked back into the pool. The driver's ability to reuse existing connections improves due to\nrate-limits on connection creation. Each driver operation requires that you choose a healthy server\nsatisfying the  server selection criteria . If you do not select an appropriate\nserver within the  server selection timeout , the driver throws a\nserver selection timeout exception. The exception looks similar to the\nfollowing: The error message consists of multiple parts: The server selection timeout (30000 ms). The server selectors considered ( CompositeServerSelector \ncontaining  AreSessionsSupportedServerSelector ,\n LatencyLimitingServerSelector , and\n OperationsCountServerSelector ). The driver\u2019s current view of the cluster topology. The list of\nservers that the driver is aware of is a key part of this view. Each\nserver description contains an exhaustive description of its current\nstate including information about an endpoint, a server version, a\nserver type, and its current health state. If the server encounters issues in\nreporting its health,  HeartbeatException  contains the exception from the\nlast failed heartbeat. Analyzing the  HeartbeatException  on each\ncluster node can assist in diagnosing most server selection issues.\nThe following heartbeat exceptions are common: No connection could be made because the target machine actively\nrefused it : The driver cannot see this cluster node. This can be\nbecause the cluster node has crashed, a firewall is preventing\nnetwork traffic from reaching the cluster node or port, or some other\nnetwork error is preventing traffic from being successfully routed to\nthe cluster node. Attempted to read past the end of the stream : This error\nhappens when the driver cannot connect to the cluster nodes due to a\nnetwork error, misconfigured firewall, or other network issue. To\naddress this exception, ensure that all cluster nodes are reachable.\nThis error commonly occurs when the client machine\u2019s IP address is\nnot configured in the Atlas IPs Access List, which can be found under\nthe  Network Access  tab for your Atlas Project. The remote certificate is invalid according to the validation\nprocedure : This error typically indicates a TLS/SSL-related problem\nsuch as an expired/invalid certificate or an untrusted root CA. You\ncan use tools like  openssl s_client  to debug TLS/SSL-related\ncertificate problems. Each LINQ or Builder expression must be available in the Query API. This is not\nalways possible for the following reasons: If you receive an  Unsupported filter ...  or  Expression not\nsupported ...  exception message, try the following\nsteps: You can combine the raw and typed forms in the same query, as the\nfollowing code demonstrates: You are attempting to use a .NET/C# feature that does not have an\nequivalent MongoDB representation. For example, .NET/C# and MongoDB have\ndifferent semantics around collations. The driver does not support a particular transformation from LINQ or\nBuilder expression into MQL (MongoDB Query Language). This may happen because the\nprovided query has no MQL translation or because a feature has not been\nimplemented yet in the driver. Try configuring the new  LINQ3 \nprovider. The LINQ3 provider contains many fixes and new features\nover the LINQ2 provider. Use the  MongoDB Analyzer  to analyze your\nexpressions. Try to simplify your query where possible. Provide a query as a  BsonDocument  or JSON string. All driver\ndefinition classes such as  FilterDefinition ,\n ProjectionDefinition , and  PipelineDefinition  support implicit\nconversion from  BsonDocument  or JSON string. For example, the\nfollowing filters are equivalent when used in a query or\naggregation: If you use  BsonDocument  or JSON string, then  BsonClassMap ,\nBSON serialization attributes, and serialization conventions are not\ntaken into account in the Query API. Field names must match the\nnames and casing as stored by the server. For example, when referencing\nthe  _id  field, you must refer to it using  _id  in\n BsonDocument  or JSON string definitions. Similarly, if a document\nhas a field  FirstName  annotated with  [BsonElement(\"first_name\")] , you\nmust refer to it as  first_name  in  BsonDocument  or JSON string\ndefinitions. The  ObjectSerializer  allows serialization and deserialization only of types\nthat are considered safe. When you construct an  ObjectSerializer ,\nyou can pass in a delegate of type  Func<Type, bool> . This delegate\naccepts an object type and returns a boolean value indicating whether the\ntype is safe for serialization. In most cases, you should pass in the  ObjectSerializer.DefaultAllowedTypes() \ndelegate. This method returns true for a number of well-known\nframework types that we have deemed safe. To serialize custom types,\ncreate a boolean expression that evaluates to  true  for the\ntypes you want to include. Then, add this expression to the end of the\ndelegate you pass to the  ObjectSerializer  constructor. In the following example,\nthe  ObjectSerializer  will serialize and deserialize any type that is allowed by\n ObjectSerializer.DefaultAllowedTypes()  or whose full name begins with\n \"MyNamespace\" : To allow anonymous types to be serialized, add the boolean expression\n type.FullName.StartsWith(\"<>f__AnonymousType\"))  to your delegate,\nas shown in the following example: You should create and register your  ObjectSerializer  at the start of your program,\nbefore doing anything else.",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var client = new MongoClient(\"<connection string>\");"
                },
                {
                    "lang": "none",
                    "value": "A timeout occurred after 30000ms selecting a server using CompositeServerSelector{ Selectors = MongoDB.Driver.MongoClient+AreSessionsSupportedServerSelector, LatencyLimitingServerSelector{ AllowedLatencyRange = 00:00:00.0150000 }, OperationsCountServerSelector }.\nClient view of cluster state is\n{\n    ClusterId : \"1\",\n    Type : \"Unknown\",\n    State : \"Disconnected\",\n    Servers :\n    [{\n        ServerId: \"{ ClusterId : 1, EndPoint : \"Unspecified/localhost:27017\" }\",\n        EndPoint: \"Unspecified/localhost:27017\",\n        ReasonChanged: \"Heartbeat\",\n        State: \"Disconnected\",\n        ServerVersion: ,\n        TopologyVersion: ,\n        Type: \"Unknown\",\n        HeartbeatException: \"<exception details>\"\n    }]\n}."
                },
                {
                    "lang": "csharp",
                    "value": "FilterDefinition<Entity> typedFilter = Builders<Entity>.Filter.Eq(e => e.A, 1);\nFilterDefinition<Entity> bsonFilter = new BsonDocument {{ \"a\", 1 }};\nFilterDefinition<Entity> jsonFilter = \"{ a : 1 }\";"
                },
                {
                    "lang": "csharp",
                    "value": "FilterDefinition<Entity> filter = Builders<Entity>.Filter\n    .And(Builders<Entity>.Filter\n        .Eq(e => e.A, 1), BsonDocument\n        .Parse(\"{ b : 2 }\"));"
                },
                {
                    "lang": "csharp",
                    "value": "var objectSerializer = new ObjectSerializer(type => ObjectSerializer.DefaultAllowedTypes(type)\n    || type.FullName.StartsWith(\"MyNamespace\"));\nBsonSerializer.RegisterSerializer(objectSerializer);"
                },
                {
                    "lang": "csharp",
                    "value": "var objectSerializer = new ObjectSerializer(type => ObjectSerializer.DefaultAllowedTypes(type)\n    || type.FullName.StartsWith(\"<>f__AnonymousType\"));\nBsonSerializer.RegisterSerializer(objectSerializer);"
                }
            ],
            "preview": "This page contains frequently asked questions and their corresponding answers.",
            "tags": ".NET, questions, errors, problems",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "",
            "title": "MongoDB C# Driver",
            "headings": [
                "Introduction",
                "Previous Versions",
                "Connect to a Compatible MongoDB Deployment",
                "Quick Start",
                "Quick Reference",
                "What's New",
                "Usage Examples",
                "Fundamentals",
                "API Documentation",
                "Take the Free Online Course Taught by MongoDB",
                "FAQ",
                "Connection Troubleshooting",
                "Issues & Help",
                "Compatibility",
                "Upgrade Driver Versions",
                "Entity Framework Provider",
                "MongoDB Analyzer"
            ],
            "paragraphs": "Welcome to the documentation site for the official MongoDB .NET/C# Driver.\nYou can add the driver to your application to work with MongoDB in C#.\nDownload the driver using  NuGet , or set up a runnable\nproject by following our  Quick Start guide . For documentation on versions of the driver v2.18 and earlier, see the  Previous Versions  section. You can use the .NET/C# Driver to connect to MongoDB\ndeployments running on one of the following hosted services or editions: MongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud MongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB MongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB Learn how to establish a connection to MongoDB Atlas and begin\nworking with data in the  Quick Start  section. See driver syntax examples for common MongoDB commands in the\n Quick Reference  section. For a list of new features and changes in each version, see the  What's New \nsection. For fully runnable code snippets and explanations for common\nmethods, see  Usage Examples . For detailed information on key concepts of using the .NET/C# Driver, see\n Fundamentals . For detailed information about types and methods in the .NET/C# Driver, see\nthe  MongoDB .NET/C# Driver API documentation . Using MongoDB with C# Learn the essentials of C# & ASP.NET application development with MongoDB. For answers to commonly asked questions about the MongoDB .NET/C# Driver, see the  FAQ \nsection. For solutions to issues you might encounter when using the driver to connect to\na MongoDB deployment, see the  Connection Troubleshooting  section. Learn how to report bugs, contribute to the driver, and find\nadditional resources for asking questions in the  Issues & Help  section. For the compatibility charts that show the recommended .NET/C# Driver version\nfor each MongoDB Server version, see  Compatibility . Learn what changes you may need to make to your application to upgrade\ndriver versions in the  Upgrade Driver Versions \nsection. The MongoDB Entity Framework Provider is an object-relational mapper (ORM) that lets you\nuse Microsoft's Entity Framework to work with MongoDB data. ORMs provide an\nobject-oriented interface for data management. To learn more, see the\n MongoDB Entity Framework Provider documentation . The MongoDB Analyzer is a tool that helps you understand how your\n.NET/C# Driver code translates into the MongoDB Query API and if your code\nincludes any unsupported LINQ or builder expressions. To learn more, see the\n MongoDB Analyzer documentation .",
            "code": [],
            "preview": "Welcome to the documentation site for the official MongoDB .NET/C# Driver.\nYou can add the driver to your application to work with MongoDB in C#.\nDownload the driver using NuGet, or set up a runnable\nproject by following our Quick Start guide.",
            "tags": "dotnet",
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "upgrade",
            "title": "Upgrade Driver Versions",
            "headings": [
                "Overview",
                "Breaking Changes",
                "Version 2.21.0 Breaking Changes",
                "Version 2.19.0 Breaking Changes",
                "Version 2.14.0 Breaking Changes",
                "Version 2.13.0 Breaking Changes",
                "Server Release Compatibility Changes",
                "Version 2.14 Release Support Changes"
            ],
            "paragraphs": "In this section, you can identify essential changes you must make to your\napplication when you upgrade your driver to a new version. Before you upgrade, perform the following actions: Ensure the new version is compatible with the MongoDB Server versions\nyour application connects to and the .NET framework version your\napplication runs on. See the  .NET/C# Driver Compatibility \npage for this information. Address any breaking changes between the current version of the driver\nyour application is using and your planned upgrade version in the\n Breaking Changes  section. To learn\nmore about the MongoDB Server release compatibility changes, see the\n Server Release Compatibility Changes  section. To minimize the number of changes your application may require when\nupgrading driver versions in the future, use the\n Stable API . A breaking change is a modification of a convention or a behavior starting in\na specific version of the driver. This type of change may prevent your application from\nworking properly if not addressed before upgrading the driver. The breaking changes in this section are categorized by the driver version that\nintroduced them. When upgrading driver versions, address all the breaking\nchanges between the current and upgrade versions. For example, if you\nare upgrading the driver from v2.0 to v2.20, address all breaking changes from\nthe version after v2.0 including any listed under v2.20. The function signature of  Render  methods in the Atlas Search builders\nchanged. The following code snippet shows the function signature prior\nto the change and after the change: The  ObjectSerializer  only allows deserialization of\ntypes that are considered safe. If not specified otherwise, the\n ObjectSerializer  uses the types returned by\n ObjectSerializer.DefaultAllowedTypes . To learn more about the  ObjectSerializer , visit the\n FAQ . For more information on\n DefaultAllowedTypes , visit the  API Documentation . The default  LinqProvider  has been changed to LINQ3. The  LinqProvider \ncan be configured for LINQ2 in  MongoClientSettings  as shown in the\nfollowing code example: This MongoDB .NET/C# Driver version removed support for .NET framework v4.5.2 or earlier; the minimum\n.NET framework supported is v4.7.2. This version of the MongoDB .NET/C# Driver does not support .NET Standard v1.5; the minimum .NET\nStandard supported is v2.0. The  slave0k  connection string option was removed; the\n readPreference  option is now used instead. A server release compatibility change is a modification\nto the MongoDB .NET/C# Driver that discontinues support for a set of\nMongoDB Server versions. The driver discontinues support for a MongoDB Server version after it\nreaches end-of-life (EOL). To learn more about the MongoDB support for EOL products see the  Legacy\nSupport Policy . To learn more about the compatibility between .NET/C# driver versions\nand MongoDB Server versions, visit the\n Compatibility  page. The v2.14 driver drops support for MongoDB Server v3.4 and earlier. To\nuse any driver from v2.14 and later, your MongoDB Server must be v3.6 or\nlater. To learn how to upgrade your MongoDB Server to v3.6, follow the\nlink that corresponds to your MongoDB deployment configuration: Upgrade a Replica Set to 3.6 Upgrade a Standalone to 3.6 Upgrade a Sharded Cluster to 3.6",
            "code": [
                {
                    "lang": "csharp",
                    "value": "// Render function signature prior to v2.21.0\nRender(IBsonSerializer<TDocument> documentSerializer, IBsonSerializerRegistry serializerRegistry);\n\n// Render function signature in v2.21.0 and later\nRender(SearchDefinitionRenderContext<TDocument> renderContext);"
                },
                {
                    "lang": "csharp",
                    "value": "var connectionString = \"<connection string>\";\nvar clientSettings = MongoClientSettings\n   .FromConnectionString(connectionString);\nclientSettings.LinqProvider = LinqProvider.V2;\nvar client = new MongoClient(clientSettings);"
                }
            ],
            "preview": "In this section, you can identify essential changes you must make to your\napplication when you upgrade your driver to a new version.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "connection-troubleshooting",
            "title": "Connection Troubleshooting",
            "headings": [
                "Connection Error",
                "Check Your Connection String",
                "Configure Your Firewall",
                "Authentication Error",
                "Check Your Connection String",
                "Verify the MongoClientSettings Properties",
                "Verify the User Is in the Authentication Database",
                "Error Sending Message",
                "Check the User Permissions",
                "Configure Your Firewall",
                "Check the Number of Connections",
                "Too Many Open Connections",
                "Check the Number of Connections",
                "Timeout Error",
                "Set connectTimeoutMS",
                "Check the Number of Connections"
            ],
            "paragraphs": "This page offers potential solutions to issues you might encounter when\nusing the MongoDB .NET/C# Driver to connect to a MongoDB deployment. This page addresses only connection issues. If you encounter any other issues\nwith MongoDB or the driver, visit the following resources: The  Frequently Asked Questions (FAQ)  for the\n.NET/C# Driver The  Issues & Help  page, which has\ninformation about reporting bugs, contributing to the driver, and\nfinding additional resources The  MongoDB Community Forums  for\nquestions, discussions, or general technical support The following error message indicates that the driver cannot connect to a server\non the specified hostname or port. Multiple situations can generate this error\nmessage. In this sample error message, the hostname is  127.0.0.1  and the\nport is  27017 : The following sections describe actions you can take to potentially resolve the\nissue. Verify that the hostname and port number in the connection string are both\naccurate. The default port value for a MongoDB instance is\n 27017 , but you can configure MongoDB to communicate on another port. Verify that the ports your MongoDB deployment listens on are not blocked by a\nfirewall on the same network. MongoDB uses port  27017  by default. To learn\nmore about the default ports MongoDB uses and how to change them, see\n Default MongoDB Port . Do not open a port in your firewall unless you are sure it's the port\nused by your MongoDB deployment. The .NET/C# Driver can fail to connect to a MongoDB instance if\nthe authentication mechanism is not configured correctly. If you are using  SCRAM-SHA-256 \nor  SCRAM-SHA-1  for authentication and the driver fails to connect, the\ndriver might raise an error message similar to one of the following messages: The following sections describe actions you can take to potentially resolve the\nissue. An invalid connection string is the most common cause of authentication\nissues when attempting to connect to MongoDB using connection strings and\n SCRAM-SHA-256  or  SCRAM-SHA-1 . If your connection string contains a username and password, ensure that they\nare in the correct format. If the username or password includes any of the\nfollowing characters, they must be\n percent encoded : The following example shows how to percent encode \"#MyPassword?\": This results in the following output: For more information about connection strings,\nsee  Connection URI  in the Connection Guide. You can use a  MongoClientSettings  object to configure the settings when\nattempting to connect to a MongoDB deployment. You can use the  Credential \nproperty to set authentication information. If the credential information is not\ncorrect, you will receive authentication errors when you attempt to connect to\nyour MongoDB deployment. To successfully authenticate a connection by using a username and password with\n SCRAM-SHA-256  or  SCRAM-SHA-1 , the username must be defined in the\nauthentication database. The default authentication database is the  admin \ndatabase. To use a different database for authentication, specify the\n authSource  option in the connection string. The following example instructs the\ndriver to use  users  as the authentication database: You can also set configuration settings by creating a  MongoClientSettings \nobject and passing that to the  MongoClient  constructor. You can use the\n Credential  property to set the login credentials including specifying the\nauthentication database. For more information about using  MongoClientSettings \nas well as some examples, see\n Using MongoClientSettings . You can check if this is the issue by attempting to connect to a MongoDB\ninstance hosted on the local machine with the same code. A deployment on\nthe same machine doesn't require any authorization to connect. When the driver fails to send a command after you make a request,\nit may display the following error message: The following sections describe actions you can take to potentially resolve the\nissue. Verify that you've accessed the MongoDB deployment with the correct user. The\nterm \"message\" in the error can be a command sent by the driver.\nIf you are using a user that doesn't have permissions to send the command, the\ndriver could generate this error. Also ensure that the user has the appropriate permissions for the message you\nare sending. MongoDB uses Role-Based Access Control (RBAC) to control access\nto a MongoDB deployment. For more information about how to configure RBAC in MongoDB,\nsee  Default MongoDB Port . The firewall needs to have an open port for communicating with the MongoDB\ninstance. For more information about configuring the firewall, see\n Configure Your Firewall  in\nthe Connection Error section. Each  MongoClient  instance supports a maximum number of concurrent open\nconnections in its connection pool. You can configure the parameter  MaxConnectionPoolSize \nwhich defines this limit. The default value is  100 . If there are already a\nnumber of open connections equal to  MaxConnectionPoolSize , the server waits until\na connection becomes available. If this wait time exceeds the  MaxConnectionIdleTime \nvalue, the driver responds with an error. For more information about how connection pooling works, see\n How Does Connection Pooling Work in the .NET/C# Driver? \nin the FAQ. The driver creates the following error message when it attempts to open a\nconnection, but it's reached the maximum number of connections: The following section describes a method that may help resolve the issue. If you need to create more open connections, increase  MaxConnectionPoolSize . For more\ninformation about checking the number of connections, see\n Check the Number of Connections \nin the Error Sending Message section. When the network is not able to deliver a request from the driver to the server\nquickly enough, it can time out. When this happens, you might receive an error message\nsimilar to the following message: If you receive this error, try the following action to resolve the\nissue. The driver may hang when it's unable to establish a connection because the driver\ntakes too long attempting to reach unreachable replica set nodes. You can limit the\ntime the driver spends attempting to establish the connection by using the\n connectTimeMS  setting. To learn more about this setting, see the\n Timeout Options  in\nthe Server manual. You should ensure the  connectTimeoutMS  setting is not lower than\nthe highest network latency you have to a member of the set. If one of the\nsecondary members has a latency of 10000 milliseconds, setting the\n connectTimeoutMS  to 9000 prevents the driver from ever connecting to that\nmember. You can set this option on the connection string. The following example sets\n connectTimeoutMS  to 10000 milliseconds. You can also set configuration settings by creating a  MongoClientSettings \nobject and passing that to the  MongoClient  constructor. For more information\nabout using  MongoClientSettings  as well as some examples, see\n Using MongoClientSettings . The number of connections to the server may exceed  MaxConnectionPoolSize . For more\ninformation about checking the number of connections, see\n Check the Number of Connections \nin the Error Sending Message section.",
            "code": [
                {
                    "lang": "none",
                    "value": "Error: couldn't connect to server 127.0.0.1:27017"
                },
                {
                    "lang": "none",
                    "value": "Command failed with error 18 (AuthenticationFailed): 'Authentication\nfailed.' on server <hostname>:<port>."
                },
                {
                    "lang": "none",
                    "value": "Authentication failed\",\"attr\":{\"mechanism\":\"SCRAM-SHA-256\",\"principalName\":\n\"<user>\",\"<auth database>\":\"<user>\",\"client\":\"127.0.0.1:2012\",\n\"result\":\"UserNotFound: Could not find user}}"
                },
                {
                    "lang": "none",
                    "value": "connection() error occurred during connection handshake: auth error:\nsasl conversation error: unable to authenticate using mechanism\n\"SCRAM-SHA-256\": (AuthenticationFailed) Authentication failed."
                },
                {
                    "lang": "none",
                    "value": ": / ? # [ ] @"
                },
                {
                    "lang": "csharp",
                    "value": "Console.WriteLine(System.Web.HttpUtility.UrlEncode(\"#MyPassword?\"));"
                },
                {
                    "lang": "none",
                    "value": "%23MyPassword%3F"
                },
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\n\n// Connection URI\nconst string connectionUri = \"mongodb://<username>:<password>@<hostname>:<port>/?authSource=users\";\n\n// Create a new client and connect to the server\nvar client = new MongoClient(connectionUri);"
                },
                {
                    "lang": "none",
                    "value": "com.mongodb.MongoSocketWriteException: Exception sending message"
                },
                {
                    "lang": "none",
                    "value": "connection refused because too many open connections"
                },
                {
                    "lang": "none",
                    "value": "timed out while checking out a connection from connection pool: context canceled"
                },
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\n\n// Connection URI\nconst string connectionUri = \"mongodb://<username>:<password>@<hostname>:<port>/?connectTimeoutMS=10000\";\n\n// Create a new client and connect to the server\nvar client = new MongoClient(connectionUri);"
                }
            ],
            "preview": "This page offers potential solutions to issues you might encounter when\nusing the MongoDB .NET/C# Driver to connect to a MongoDB deployment.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals",
            "title": "Fundamentals",
            "headings": [],
            "paragraphs": "Connecting to MongoDB CRUD Operations Operations with Builders Atlas Search Stable API Authentication Mechanisms Enterprise Authentication Mechanisms LINQ BSON Operations Serialization Logging Encrypt Fields",
            "code": [],
            "preview": "Learn how to use the (+driver-long+} to run commands on MongoDB.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples",
            "title": "Usage Examples",
            "headings": [
                "Overview",
                "How to Use the Usage Examples",
                "Example Classes"
            ],
            "paragraphs": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following information: A code snippet that shows how to perform the operation in synchronous and\nasynchronous frameworks A link to a fully runnable console application using the operation The expected result after running the example These examples use the  sample datasets \nprovided by Atlas. You can load them into your database on the free tier of\nMongoDB Atlas by following the\n Get Started with Atlas Guide \nor you can\n import the sample dataset into a local MongoDB instance . Once you have imported the dataset, you can copy and paste a usage\nexample into your development environment of choice. You can follow the\n Quick Start  to learn more about getting\nstarted with the MongoDB .NET/C# Driver. Once you've copied a usage example,\nyou'll need to edit the connection URI to get the example connected to\nyour MongoDB instance: For more information about connecting to your MongoDB instance, see the\n Connection Guide . The usage examples in this section show how to perform operations on documents\nin the  restaurants  collection. The examples use the following  Restaurant ,\n Address , and  GradeEntry  classes to model the data in this collection: The documents in the  restaurants  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Restaurant  class. To learn more about custom serialization, see  Custom Serialization .",
            "code": [
                {
                    "lang": "csharp",
                    "value": "// Replace the following with your MongoDB deployment's connection string.\nprivate static string _mongoConnectionString = \"<connection string>\";"
                },
                {
                    "lang": "csharp",
                    "value": "public class Restaurant\n{\n    public ObjectId Id { get; set; }\n\n    public string Name { get; set; }\n\n    [BsonElement(\"restaurant_id\")]\n    public string RestaurantId { get; set; }\n\n    public string Cuisine { get; set; }\n\n    public Address Address { get; set; }\n\n    public string Borough { get; set; }\n\n    public List<GradeEntry> Grades { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Address\n{\n    public string Building { get; set; }\n\n    [BsonElement(\"coord\")]\n    public double[] Coordinates { get; set; }\n\n    public string Street { get; set; }\n\n    [BsonElement(\"zipcode\")]\n    public string ZipCode { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class GradeEntry\n{\n    public DateTime Date { get; set; }\n\n    public string Grade { get; set; }\n\n    public float? Score { get; set; }\n}"
                }
            ],
            "preview": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following information:",
            "tags": "code, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/deleteOne",
            "title": "Delete a Document",
            "headings": [
                "Example",
                "Delete a Document by Using Builders",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can delete a document from a collection by using the synchronous\n DeleteOne()  method, or the asynchronous  DeleteOneAsync()  method. The  DeleteOne()  method deletes only the first document that matches the filter.\nTo delete more than one document, use the  DeleteMany()  method. To learn more about using  DeleteMany() , see  Delete Many Documents . The following example uses  Builders  to delete a document in\nthe  restaurants  collection with the  name  \"Ready Penny Inn\". Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of the  DeleteOne()  method, see the\n Asynchronous Delete One Example . For a fully runnable example of the  DeleteOne()  method, see the\n Synchronous Delete One Example Running either of the preceding full examples prints the following results: To learn more about deleting documents, see the  Delete Documents  guide. To learn more about using builders, see  Operations with Builders . DeleteOne() DeleteOneAsync()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Name, \"Ready Penny Inn\");\n\nreturn await _restaurantsCollection.DeleteOneAsync(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Name, \"Ready Penny Inn\");\n\nreturn _restaurantsCollection.DeleteOne(filter);"
                },
                {
                    "lang": "none",
                    "value": "Deleting a document with builders...\nDeleted documents: 1"
                }
            ],
            "preview": "You can delete a document from a collection by using the synchronous\nDeleteOne() method, or the asynchronous DeleteOneAsync() method.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/insertMany",
            "title": "Insert Multiple Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can insert multiple documents into a collection by using the synchronous\n InsertMany()  method or the asynchronous  InsertManyAsync()  method. The following example inserts multiple documents into\nthe  restaurants  collection. Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of the  InsertManyAsync()  operation, see the\n InsertManyAsync code sample . For a fully runnable example of the  InsertMany()  operation, see the\n InsertMany code sample . After running either of the preceding full examples, the output is as follows: To learn more about using builders, see  Operations with Builders . InsertMany() InsertManyAsync()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "// Helper method to generate 5 new restaurants\nvar restaurants = GenerateDocuments();\n\nawait _restaurantsCollection.InsertManyAsync(restaurants);"
                },
                {
                    "lang": "csharp",
                    "value": "// Helper method to generate 5 new restaurants\nvar restaurants = GenerateDocuments();\n\n_restaurantsCollection.InsertMany(restaurants);"
                },
                {
                    "lang": "none",
                    "value": "Number of restaurants found before insert: 0\n\nInserting documents...\nNumber of restaurants inserted: 5"
                }
            ],
            "preview": "You can insert multiple documents into a collection by using the synchronous\nInsertMany() method or the asynchronous InsertManyAsync() method.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "quick-reference",
            "title": "Quick Reference",
            "headings": [],
            "paragraphs": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation. You can perform many of the operations on this page using LINQ. For more\ninformation on using LINQ with the .NET/C# Driver, see the\n LINQ Fundamentals page. Command Syntax",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Bagels N Buns\");\n\nvar restaurant = _restaurantsCollection.Find(filter).FirstOrDefault();\n\nConsole.WriteLine(restaurant);"
                },
                {
                    "lang": "json",
                    "value": "{ name : \"Bagels N Buns\", restaurant_id : \"40363427\", ... }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Bagels N Buns\");\n\nvar restaurant = await _restaurantsCollection.Find(filter).FirstOrDefaultAsync();\n\nConsole.WriteLine(restaurant);"
                },
                {
                    "lang": "json",
                    "value": "{ name : \"Bagels N Buns\", restaurant_id : \"40363427\", ... }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(r => restaurant.Cuisine, \"Pizza\");\n\nvar restaurants = _restaurantsCollection.Find(filter).ToList();\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { name: \"Como Pizza\", cuisine: \"Pizza\", ... },\n  { name: \"New York Pizza Suprema\", cuisine: \"Pizza\", ... },\n  ...\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(r => restaurant.Cuisine, \"Pizza\");\n\nvar restaurants = await _restaurantsCollection.Find(filter).ToListAsync();\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { name: \"Como Pizza\", cuisine: \"Pizza\", ... },\n  { name: \"New York Pizza Suprema\", cuisine: \"Pizza\", ... },\n  ...\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var insertResult = _restaurantsCollection.InsertOne(new Restaurant { Name = \"Mongo's Pizza\" });"
                },
                {
                    "lang": "csharp",
                    "value": "var insertResult = await _restaurantsCollection.InsertOneAsync(new Restaurant { Name = \"Mongo's Pizza\" });"
                },
                {
                    "lang": "csharp",
                    "value": "_restaurantsCollection.InsertMany(new List<Restaurant>\n{\n    new Restaurant { Name = \"Mongo's Pizza\" },\n    new Restaurant { Name = \"Mongo Grill\" }\n});"
                },
                {
                    "lang": "csharp",
                    "value": "await _restaurantsCollection.InsertManyAsync(new List<Restaurant>\n{\n    new Restaurant { Name = \"Mongo's Pizza\" },\n    new Restaurant { Name = \"Mongo Grill\" }\n});"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Bagels N Buns\");\n\nvar update = Builders<Restaurant>.Update\n  .Set(restaurant => restaurant.Name, \"2 Bagels 2 Buns\");\n\nvar result = _restaurantsCollection.UpdateOne(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Bagels N Buns\");\n\nvar update = Builders<Restaurant>.Update\n  .Set(restaurant => restaurant.Name, \"2 Bagels 2 Buns\");\n\nvar updateResult = await _restaurantsCollection.UpdateOneAsync(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Pizza\");\n\nvar update = Builders<Restaurant>.Update\n  .Set(restaurant => restaurant.Cuisine, \"Pasta and breadsticks\");\n\nvar result = _restaurantsCollection.UpdateMany(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Pizza\");\n\nvar update = Builders<Restaurant>.Update\n  .Set(restaurant => restaurant.Cuisine, \"Pasta and breadsticks\");\n\nvar updateResult = await _restaurantsCollection.UpdateManyAsync(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Bagels N Buns\");\n\nvar update = Builders<Restaurant>.Update\n  .Push(restaurant => restaurant.Grades, new GradeEntry\n  {\n    Date = DateTime.Now.ToUniversalTime(),\n    Grade = \"A\",\n    Score = 10\n  });\n\nvar result = _restaurantsCollection.UpdateOne(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Pizza\");\n\n// Find ID of first pizza restaurant\nvar oldPizzaRestaurant = _restaurantsCollection.Find(filter).First();\nvar oldId = oldPizzaRestaurant.Id;\n\nRestaurant newPizzaRestaurant = new()\n{\n    Id = oldId,\n    Name = \"Mongo's Pizza\",\n    Cuisine = \"Pizza\",\n    Address = new Address\n    {\n        Building = \"123\",\n        Coordinates = [123, 456],\n        Street = \"Pizza St\",\n        ZipCode = \"10003\"\n    },\n    Borough = \"Manhattan\",\n};\n\nvar replaceResult = _restaurantsCollection.ReplaceOne(filter, newPizzaRestaurant);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Pizza\");\n\n// Find ID of first pizza restaurant\nvar oldPizzaRestaurant = _restaurantsCollection.Find(filter).First();\nvar oldId = oldPizzaRestaurant.Id;\n\nRestaurant newPizzaRestaurant = new()\n{\n    Id = oldId,\n    Name = \"Mongo's Pizza\",\n    Cuisine = \"Pizza\",\n    Address = new Address\n    {\n        Building = \"123\",\n        Coordinates = [12.3, 45.6],\n        Street = \"Pizza St\",\n        ZipCode = \"10003\"\n    },\n    Borough = \"Manhattan\",\n};\n\nvar replaceResult = await _restaurantsCollection.ReplaceOneAsync(filter, newPizzaRestaurant);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Ready Penny Inn\");\n\nvar deleteResult = _restaurantsCollection.DeleteOne(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Name, \"Ready Penny Inn\");\n\nvar deleteResult = await _restaurantsCollection.DeleteOneAsync(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Regex(restaurant => restaurant.Name, \"Green\");\n\nvar deleteResult = _restaurantsCollection.DeleteMany(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Regex(restaurant => restaurant.Name, \"Green\");\n\nvar deleteResult = await _restaurantsCollection.DeleteManyAsync(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Afghan)\";\n\nvar cursor = _restaurantsCollection.Find(filter).ToCursor();\nwhile (cursor.MoveNext())\n{\n    foreach (var r in cursor.Current)\n    {\n        Console.WriteLine(r.Name);\n    }\n}"
                },
                {
                    "lang": "json",
                    "value": "[\n  Afghan Kebab House\n  Khyber Pass\n  ...\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Pizza\");\n\nvar count = _restaurantsCollection.Find(filter).CountDocuments();\n\nConsole.WriteLine(count);"
                },
                {
                    "lang": "none",
                    "value": "1163"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Empty;\nvar restaurants = _restaurantsCollection\n  .Distinct(r => r.Cuisine, filter);\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[ Afghan, African, American, Armenian, Asian, ... ]"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Asian\");\nvar restaurants = _restaurantsCollection.Find(filter).Limit(3).ToList();\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { name: \"China Grill\", ... },\n  { name: \"Indo Chine\", ... },\n  { name: \"Le Colonial\", ... }\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Asian\");\n\nvar restaurants = _restaurantsCollection.Find(filter).Skip(2).ToList();\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { name: \"Le Colonial\", ... },\n  { name: \"Citrus Bar & Grill\", ... },\n  { name: \"Mangez Avec Moi\", ... },\n  ...\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Brazilian\");\n\nvar restaurants =  _restaurantsCollection.Find(filter)\n  .SortBy(r => r.Name).ToList();\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { name: \"Barzinho\", ... },\n  { name: \"Beco\", ... },\n  { name: \"Beija-Flor\", ... },\n  ...\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n  .Eq(restaurant => restaurant.Cuisine, \"Italian\");\n\nvar projection = Builders<Restaurant>.Projection\n  .Include(restaurant => restaurant.Name)\n  .Include(restaurant => restaurant.Borough)\n  .Exclude(restaurant => restaurant.Id);\n\nvar restaurants = _restaurantsCollection.Find(filter).Project(projection).ToList();\n\nConsole.WriteLine(restaurants);"
                },
                {
                    "lang": "json",
                    "value": "[\n  { borough : \"Brooklyn\", name : \"Philadelphia Grille Express\" }\n  { borough : \"Manhattan\", name : \"Isle Of Capri Restaurant\" }\n  { borough : \"Manhattan\", name : \"Marchis Restaurant\" }\n  ...\n]"
                },
                {
                    "lang": "csharp",
                    "value": "var index = Builders<Restaurant>.IndexKeys\n  .Ascending(restaurant => restaurant.Cuisine);\n\n_restaurantsCollection.Indexes\n  .CreateOne(new CreateIndexModel<Restaurant>(index));"
                }
            ],
            "preview": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/updateOne",
            "title": "Update a Document",
            "headings": [
                "Example",
                "Expected Result",
                "More Information",
                "API Documentation"
            ],
            "paragraphs": "You can update a single document using the  UpdateOne()  method on\na  MongoCollection  object. This method requires a  query filter , which specifies which document to update, and an  update  statement, which specifies the changes the driver should make to the first document matching the query filter. The  UpdateOne()  method updates only the first document that matches the\nfilter. To update more than one document, use the  UpdateMany() method . You can pass an instance of  UpdateOptions  to the  UpdateOne()  method in\norder to customize its behavior. The following example uses  Builders  to update the  name  of the\nfirst document named \"Bagels N Buns\" in the  restaurants  collection  to\n\"2 Bagels 2 Buns\". Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of the  UpdateOneAsync()  operation, see the\n UpdateOneAsync Example . For a fully runnable example of the  UpdateOneAsync()  operation, see the\n UpdateOne Example . After running either of the preceding full examples, each call to  UpdateOne() \nwrites the following to the console: UpdateOne()  returns an  UpdateResult  object. To learn more about updating documents, see the  Modify Documents  guide. To learn more about using builders, see  Operations with Builders . UpdateOne() UpdateOptions UpdateResult",
            "code": [
                {
                    "lang": "csharp",
                    "value": "const string oldValue = \"Bagels N Buns\";\nconst string newValue = \"2 Bagels 2 Buns\";\n\nvar filter = Builders<Restaurant>.Filter\n    .Eq(restaurant => restaurant.Name, oldValue);\n\nvar update = Builders<Restaurant>.Update\n    .Set(restaurant => restaurant.Name, newValue);\n\nreturn await _restaurantsCollection.UpdateOneAsync(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "const string oldValue = \"Bagels N Buns\";\nconst string newValue = \"2 Bagels 2 Buns\";\n\nvar filter = Builders<Restaurant>.Filter\n    .Eq(restaurant => restaurant.Name, oldValue);\n\nvar update = Builders<Restaurant>.Update\n    .Set(restaurant => restaurant.Name, newValue);\n\nreturn _restaurantsCollection.UpdateOne(filter, update);"
                },
                {
                    "lang": "none",
                    "value": "Updated documents: 1"
                }
            ],
            "preview": "You can update a single document using the UpdateOne() method on\na MongoCollection object. This method requires a query filter, which specifies which document to update, and an update statement, which specifies the changes the driver should make to the first document matching the query filter.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/findOne",
            "title": "Find a Document",
            "headings": [
                "Example",
                "Find a Document by Using Builders",
                "Find a Document by Using LINQ",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can retrieve a document by using the  Find()  method on a collection object. The following example uses  Builders  to find a document in the  restaurants \ncollection that has a  name  field with a value of \"Bagels N Buns\". Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of using the  Find()  method\nto asynchronously find one document, see the  Asynchronous Find One Example . For a fully runnable example of using the  Find()  method\nto synchronously find one document, see the  Synchronous Find One Example . The following example uses LINQ to find a document in the  restaurants \ncollection that has a  name  field with a value of \"Bagels N Buns\". Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of using the  Find()  method\nto asynchronously find one document, see the  Asynchronous Find One Example . For a fully runnable example of using the  Find()  method\nto synchronously find one document, see the  Synchronous Find One Example . Running any of the preceding full examples prints results similar to the following: To learn more about retrieving documents, see the  Retrieve Data  guide. To learn more about using builders, see  Operations with Builders . To learn how to find a document using LINQ, see  LINQ . Find() FirstOrDefault() FirstOrDefaultAsync()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Name, \"Bagels N Buns\");\n\nreturn await _restaurantsCollection.Find(filter).FirstOrDefaultAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Name, \"Bagels N Buns\");\n\nvar restaurant = _restaurantsCollection.Find(filter).FirstOrDefault();"
                },
                {
                    "lang": "csharp",
                    "value": "return await _restaurantsCollection.AsQueryable()\n    .Where(r => r.Name == \"Bagels N Buns\").FirstOrDefaultAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var query = _restaurantsCollection.AsQueryable()\n    .Where(r => r.Name == \"Bagels N Buns\").FirstOrDefault();"
                },
                {
                    "lang": "none",
                    "value": "{\n   \"_id\" : ObjectId(\"5eb3d668b31de5d588f42950\"),\n   \"name\" : \"Bagels N Buns\",\n   \"restaurant_id\" : \"40363427\",\n   \"cuisine\" : \"Delicatessen\",\n   \"address\" : {...},\n   \"borough\" : \"Staten Island\",\n   \"grades\" : [...]\n}"
                }
            ],
            "preview": "You can retrieve a document by using the Find() method on a collection object.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/updateMany",
            "title": "Update Many Documents",
            "headings": [
                "Example",
                "Expected Result",
                "More Information",
                "API Documentation"
            ],
            "paragraphs": "You can update more than one document using the  UpdateMany()  method on\na collection object. The following code updates all documents in the  restaurants  collection that have a\n cuisine  field with the value of \"Pizza\". After the update, these documents will\nhave a  cuisine  field with a value of \"Pasta and breadsticks\". Select the  Asynchronous  or  Synchronous  tab to see the corresponding\ncode. For a fully runnable example of the  UpdateManyAsync()  operation, see the\n UpdateManyAsync code sample . For a fully runnable example of the  UpdateMany()  operation, see the\n UpdateMany code sample . Running either of the preceding full examples prints the following results: To learn more about updating documents, see the  Modify Documents  guide. To learn more about using builders, see  Operations with Builders . UpdateMany() UpdateManyAsync() UpdateOptions UpdateResult",
            "code": [
                {
                    "lang": "csharp",
                    "value": "const string oldValue = \"Pizza\";\nconst string newValue = \"Pasta and breadsticks\";\n\n// Creates a filter for all documents with a \"cuisine\" value of \"Pizza\"\nvar filter = Builders<Restaurant>.Filter\n     .Eq(restaurant => restaurant.Cuisine, oldValue);\n\nvar update = Builders<Restaurant>.Update\n    .Set(restaurant => restaurant.Cuisine, newValue);\n\nreturn await _restaurantsCollection.UpdateManyAsync(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "const string oldValue = \"Pizza\";\nconst string newValue = \"Pasta and breadsticks\";\n\n// Creates a filter for all documents with a \"cuisine\" value of \"Pizza\"\nvar filter = Builders<Restaurant>.Filter\n     .Eq(restaurant => restaurant.Cuisine, oldValue);\n\nvar update = Builders<Restaurant>.Update\n    .Set(restaurant => restaurant.Cuisine, newValue);\n\nreturn _restaurantsCollection.UpdateMany(filter, update);"
                },
                {
                    "lang": "none",
                    "value": "Restaurants with cuisine \"Pizza\" found: 1163\nRestaurants modified by update: 1163\nRestaurants with cuisine \"Pasta and breadsticks\" found after update: 1163\nResetting sample data...done."
                }
            ],
            "preview": "You can update more than one document using the UpdateMany() method on\na collection object.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/findMany",
            "title": "Find Multiple Documents",
            "headings": [
                "Example",
                "Find Documents by Using Builders",
                "Find Documents by Using LINQ",
                "Find All Documents",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can retrieve multiple documents from a collection by using the\n Find()  method. The following example uses  Builders  to find documents in\nthe  restaurants  collection with the  cuisine  \"Pizza\". Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of using the  Find()  method to asynchronously\nfind multiple documents, see\n Asynchronous Find Multiple Example . For a fully runnable example of using the  Find()  method to synchronously\nfind multiple documents, see\n Synchronous Find Multiple Example . The following example uses LINQ to find documents in the\n restaurants  collection with the  cuisine  \"Pizza\". Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of using the  Find()  method to asynchronously\nfind multiple documents, see\n Asynchronous Find Multiple Example . For a fully runnable example of using the  Find()  method to synchronously\nfind multiple documents, see\n Synchronous Find Multiple Example . The following example finds all documents in the  restaurants  collection. Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of using the  Find()  method to asynchronously\nfind multiple documents, see\n Asynchronous Find Multiple Example . For a fully runnable example of using the  Find()  method to synchronously\nfind multiple documents, see\n Synchronous Find Multiple Example . Running the preceding full examples prints the following results: These examples use the  sample datasets  provided by Atlas.\nThe number of documents returned may differ depending on the data in your\ncollection. To learn more about retrieving documents, see the  Retrieve Data  guide. To learn more about using builders, see  Operations with Builders . To learn how to find documents using LINQ, see  LINQ . Find()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Cuisine, \"Pizza\");\n\nreturn await _restaurantsCollection.Find(filter).ToListAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(\"cuisine\", \"Pizza\");\n\nreturn _restaurantsCollection.Find(filter).ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "return await _restaurantsCollection.AsQueryable()\n    .Where(r => r.Cuisine == \"Pizza\").ToListAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "return _restaurantsCollection.AsQueryable()\n    .Where(r => r.Cuisine == \"Pizza\").ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Empty;\n\nreturn await _restaurantsCollection.Find(filter)\n    .ToListAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Empty;\n\nreturn _restaurantsCollection.Find(filter)\n    .ToList();"
                },
                {
                    "lang": "none",
                    "value": "Finding documents with builders...:\nNumber of documents found: 1163\n\nFinding documents with LINQ...:\nNumber of documents found: 1163\n\nFinding all documents...:\nNumber of documents found: 25359"
                }
            ],
            "preview": "You can retrieve multiple documents from a collection by using the\nFind() method.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/deleteMany",
            "title": "Delete Many Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can delete more than one document using the  DeleteMany()  synchronous\nmethod or the  DeleteManyAsync()  asynchronous method on a collection object. The following code deletes all documents in the  restaurants  collection whose\n borough  field value equals the word \"Brooklyn\". Select the  Asynchronous  or  Synchronous  tab to see the corresponding\ncode. For a fully runnable example of the  DeleteManyAsync()  operation, see the\n DeleteManyAsync code sample . For a fully runnable example of the  DeleteMany()  operation, see the\n DeleteMany code sample . Running either of the preceding full examples prints the following results: To learn more about deleting documents, see the  Delete Documents  guide. To learn more about using builders, see  Operations with Builders . DeleteMany() DeleteManyAsync()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Borough, \"Brooklyn\");\n\nreturn await _restaurantsCollection.DeleteManyAsync(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Borough, \"Brooklyn\");\n\nreturn _restaurantsCollection.DeleteMany(filter);"
                },
                {
                    "lang": "none",
                    "value": "Deleting documents...\nDeleted documents: 6086\nResetting sample data...done."
                }
            ],
            "preview": "You can delete more than one document using the DeleteMany() synchronous\nmethod or the DeleteManyAsync() asynchronous method on a collection object.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/connection",
            "title": "Connection",
            "headings": [
                "Overview"
            ],
            "paragraphs": "In this section, you'll learn how to use the .NET/C# Driver to connect your application to a MongoDB deployment. Click a link in the following list to jump to a topic: How to Connect to MongoDB Connection Options Enable TLS on a Connection Connect to MongoDB Atlas from AWS Lambda",
            "code": [],
            "preview": "In this section, you'll learn how to use the .NET/C# Driver to connect your application to a MongoDB deployment. Click a link in the following list to jump to a topic:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud",
            "title": "CRUD Operations",
            "headings": [],
            "paragraphs": "Read Operations Write Operations",
            "code": [],
            "preview": "Learn how to run create, read, update, delete (CRUD) MongoDB operations by using the MongoDB .NET/C# Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/replaceOne",
            "title": "Replace a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can replace one document with another by using the  ReplaceOne()  synchronous method\nor the  ReplaceOneAsync()  asynchronous method on a collection object. The following code replaces the first document in the  restaurants  collection that has a\nvalue of \"Pizza\" in the  cuisine  field. After the replacement, this document will\nhave a  name  field with a value of \"Mongo's Pizza\" and new values for the\n address  and  borough  fields. Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of the  ReplaceOneAsync()  operation, see the\n ReplaceOneAsync code sample . For a fully runnable example of the  ReplaceOne()  operation, see the\n ReplaceOne code sample . Running either of the preceding full examples prints the following results: To learn more about replacing documents, see the  Replace Operation \nguide. To learn more about using builders, see  Operations with Builders . ReplaceOne() ReplaceOneAsync() ReplaceOptions ReplaceOneResult",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Cuisine, \"Pizza\");\n\n// Find ID of first pizza restaurant\nvar oldPizzaRestaurant = _restaurantsCollection.Find(filter).First();\nvar oldId = oldPizzaRestaurant.Id;\n\nRestaurant newPizzaRestaurant = new()\n{\n    Id = oldId,\n    Name = \"Mongo's Pizza\",\n    Cuisine = \"Pizza\",\n    Address = new()\n    {\n        Street = \"Pizza St\",\n        ZipCode = \"10003\"\n    },\n    Borough = \"Manhattan\",\n};\n\nreturn await _restaurantsCollection.ReplaceOneAsync(filter, newPizzaRestaurant);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(r => r.Cuisine, \"Pizza\");\n\n// Find ID of first pizza restaurant\nvar oldPizzaRestaurant = _restaurantsCollection.Find(filter).First();\nvar oldId = oldPizzaRestaurant.Id;\n\nRestaurant newPizzaRestaurant = new()\n{\n    Id = oldId,\n    Name = \"Mongo's Pizza\",\n    Cuisine = \"Pizza\",\n    Address = new()\n    {\n        Street = \"Pizza St\",\n        ZipCode = \"10003\"\n    },\n    Borough = \"Manhattan\",\n};\n\nreturn _restaurantsCollection.ReplaceOne(filter, newPizzaRestaurant);"
                },
                {
                    "lang": "none",
                    "value": "First pizza restaurant before replacement: J&V Famous Pizza\nRestaurants modified by replacement: 1\nFirst pizza restaurant after replacement: Mongo's Pizza\nResetting sample data...done."
                }
            ],
            "preview": "You can replace one document with another by using the ReplaceOne() synchronous method\nor the ReplaceOneAsync() asynchronous method on a collection object.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/logging",
            "title": "Logging",
            "headings": [
                "Overview",
                "Configure Logging",
                "Log Messages by Category",
                "Configure Log Verbosity"
            ],
            "paragraphs": "Starting in version 2.18, the .NET/C# Driver uses the standard\n .NET logging API. \nIn this guide, you can learn how to use the driver to configure logging for your\napplication. To specify the logging settings for your application, create a new instance of the\n LoggingSettings  class, then assign it to the  LoggingSettings  property of your\n MongoClientSettings  object. The  LoggingSettings  constructor accepts the following parameters: The following code sample shows how to create a  MongoClient  that\nlogs all debug messages to the console: Property Description LoggerFactory MaxDocumentSize Each message generated by a MongoDB cluster is assigned a  category . This lets you\nspecify different log levels for different types of messages. MongoDB uses the following categories to classify messages: Category Description MongoDB.Command MongoDB.SDAM MongoDB.ServerSelection MongoDB.Connection MongoDB.Internal.* You can specify the minimum verbosity for all logging categories by configuring the\n Default  category. You can configure the log verbosity of each message category by using the standard .NET\nlogging mechanism. The following code sample shows how to configure a  MongoClient \nto log two types of messages: In this example, the configuration is done in-memory. The code creates a\n Dictionary<string, string>  where the key is  \"LogLevel:<category>\"  and the value\nis the minimum log level of messages in that category. The code then adds the\ndictionary to a  ConfigurationBuilder  object, then adds the  ConfigurationBuilder \nto a  LoggerFactory . All messages with log level  Error  or higher from all categories All messages with log level  Debug  or higher from the SDAM category For more information on configuring log verbosity, see the\n Microsoft .NET logging documentation.",
            "code": [
                {
                    "lang": "csharp",
                    "value": "using var loggerFactory = LoggerFactory.Create(b =>\n{\n  b.AddSimpleConsole();\n  b.SetMinimumLevel(LogLevel.Debug);\n});\n\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.LoggingSettings = new LoggingSettings(loggerFactory);\nvar client = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var categoriesConfiguration = new Dictionary<string, string>\n{\n  { \"LogLevel:Default\", \"Error\" },\n  { \"LogLevel:MongoDB.SDAM\", \"Debug\" }\n};\n\nvar config = new ConfigurationBuilder()\n  .AddInMemoryCollection(categoriesConfiguration)\n  .Build();\n\nusing var loggerFactory = LoggerFactory.Create(b =>\n{\n  b.AddConfiguration(config);\n  b.AddSimpleConsole();\n});\n\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.LoggingSettings = new LoggingSettings(loggerFactory);\nvar client = new MongoClient(settings);"
                }
            ],
            "preview": "Starting in version 2.18, the .NET/C# Driver uses the standard\n.NET logging API.\nIn this guide, you can learn how to use the driver to configure logging for your\napplication.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "usage-examples/insertOne",
            "title": "Insert a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can insert a single document into a collection by using the synchronous\n InsertOne()  method, or the asynchronous  InsertOneAsync()  method. The following example inserts a document into the  restaurants  collection. Select the  Asynchronous  or  Synchronous  tab to see the\ncorresponding code. For a fully runnable example of the  InsertOneAsync()  operation, see the\n Asynchronous Insert One Example . For a fully runnable example of the  InsertOne()  operation, see the\n Synchronous Insert One Example . After running either of the preceding full examples, the  InsertOne() \nmethod inserts the document, and the  Find()  method returns\nthe newly inserted document. The output is similar to the following: To learn more about using builders, see  Operations with Builders . InsertOne() InsertOneAsync() Find() FirstOrDefault()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "Restaurant newRestaurant = new()\n{\n    Name = \"Mongo's Pizza\",\n    RestaurantId = \"12345\",\n    Cuisine = \"Pizza\",\n    Address = new()\n    {\n        Street = \"Pizza St\",\n        ZipCode = \"10003\"\n    },\n    Borough = \"Manhattan\",\n};\n\nawait _restaurantsCollection.InsertOneAsync(newRestaurant);"
                },
                {
                    "lang": "csharp",
                    "value": "Restaurant newRestaurant = new()\n{\n    Name = \"Mongo's Pizza\",\n    RestaurantId = \"12345\",\n    Cuisine = \"Pizza\",\n    Address = new()\n    {\n        Street = \"Pizza St\",\n        ZipCode = \"10003\"\n    },\n    Borough = \"Manhattan\",\n};\n\n_restaurantsCollection.InsertOne(newRestaurant);"
                },
                {
                    "lang": "none",
                    "value": "Inserting a document...\nDocument Inserted: { \"_id\" : ObjectId(\"...\"), \"name\" : \"Mongo's Pizza\", \"restaurant_id\" : \"12345\", \"cuisine\" : \"Pizza\", \"address\" : { \"_t\" : \"MongoDB.Bson.BsonDocument, MongoDB.Bson\", \"_v\" : { \"street\" : \"Pizza St\", \"zipcode\" : \"10003\" } }, \"borough\" : \"Manhattan\", \"grades\" : [{ \"_t\" : \"MongoDB.Bson.BsonDocument, MongoDB.Bson\", \"_v\" : { } }] }"
                }
            ],
            "preview": "You can insert a single document into a collection by using the synchronous\nInsertOne() method, or the asynchronous InsertOneAsync() method.",
            "tags": "code example, .NET, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/stable-api",
            "title": "Stable API",
            "headings": [
                "Overview",
                "Enable the Stable API on a MongoDB Client",
                "Stable API Options",
                "API Documentation"
            ],
            "paragraphs": "The Stable API feature requires MongoDB Server 5.0 or later. You should use the Stable API feature only if all of the MongoDB\nservers you're connecting to support this feature. In this guide, you can learn how to specify  Stable API  compatibility when\nconnecting to a MongoDB instance or replica set. The Stable API feature forces the server to run operations with behaviors compatible\nwith the API version you specify. When you update either your driver or server,\nthe API version changes, which can change the way these operations behave.\nUsing the Stable API ensures consistent responses from the server and\nprovides long-term API stability for your application. The following sections describe how you can enable and customize Stable API for\nyour MongoDB client. For more information about the Stable API, including a list of\nthe commands it covers, see the  MongoDB reference page. To enable the Stable API, you must specify an API version in the settings\nof your MongoDB client. Once you instantiate a  MongoClient  instance with\na specified API version, all commands you run with the client use that\nversion of the Stable API. The following example shows how you can instantiate a  MongoClient  with a Stable API version and connect to a server through the following operations: Once you've created a  MongoClient , you can't change its Stable API version.\nIf you need to run commands using more than one version of the\nStable API, instantiate a separate client with that version. If you need to run commands not covered by the Stable API, make sure the\n\"strict\" option is disabled. See the section on\n Stable API Options  for more information. Construct a  ServerApi  instance and specify a Stable API version. Construct a  MongoClientSettings  object and set the  ServerApi  property. Create a  MongoClient  with the  MongoClientSettings  object. If you specify an API version and connect to a MongoDB server that does\nnot support the Stable API, your code might raise an exception when\nexecuting a command on your MongoDB server. If you use a  MongoClient \nthat specifies the API version to query a server that doesn't support that version,\nyour query could fail with an exception message that includes the\nfollowing text: You can use the options in the following table to customize the behavior of the\nStable API. The following example shows how you can set these options when constructing a\n ServerApi  object: Option Name Description Strict DeprecationErrors For more information on using the Stable API with the MongoDB .NET/C# Driver, see the\nfollowing API documentation: MongoClient MongoClientSettings ServerApiVersion ServerApi",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var serverApi = new ServerApi(ServerApiVersion.V1);\nvar settings = new MongoClientSettings { ServerApi = serverApi };\nvar client = new MongoClient(settings);"
                },
                {
                    "lang": "none",
                    "value": "Unrecognized field 'apiVersion' on server..."
                },
                {
                    "lang": "csharp",
                    "value": "var serverApi = new ServerApi(ServerApiVersion.V1, strict: true,\n    deprecationErrors: true);"
                }
            ],
            "preview": "In this guide, you can learn how to specify Stable API compatibility when\nconnecting to a MongoDB instance or replica set.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "compatibility",
            "title": "Compatibility",
            "headings": [
                "MongoDB Compatibility",
                "Compatibility Table Legend",
                "Language Compatibility"
            ],
            "paragraphs": "The following compatibility table specifies the recommended version or versions\nof the MongoDB .NET/C# Driver for use with a specific version of MongoDB. The first column lists the driver version. MongoDB ensures compatibility between the MongoDB Server and the drivers\nfor three years after the server version's end of life (EOL) date. To learn\nmore about the MongoDB release and EOL dates, see\n MongoDB Software Lifecycle Schedules . Icon Explanation \u2713 All features are supported. \u229b The Driver version will work with the MongoDB version, but not all\nnew MongoDB features are supported. No mark The Driver version is not tested with the MongoDB version. The driver doesn't support older versions of MongoDB. .NET/C# Driver Version MongoDB 7.0 MongoDB 6.0 MongoDB 5.0 MongoDB 4.4 MongoDB 4.2 MongoDB 4.0 MongoDB 3.6 MongoDB 3.4 MongoDB 3.2 MongoDB 3.0 MongoDB 2.6 2.24 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.23 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.22 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.21 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.20 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.19 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.18 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.17 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.16 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.15 \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 2.14 \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 2.13 \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.12 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.11 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.10 \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.9 \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.8 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.7 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.6 \u2713 \u2713 \u2713 \u2713 \u2713 2.5 \u2713 \u2713 \u2713 \u2713 \u2713 2.4 \u2713 \u2713 \u2713 \u2713 2.3 \u2713 \u2713 \u2713 2.2 \u2713 \u2713 \u2713 2.0 \u2713 \u2713 1.11 \u2713 \u2713 \u2713 1.10 \u2713 \u2713 The following compatibility table specifies the recommended version of the\nMongoDB .NET/C# Driver for use with a specific version of C#. The first column lists the driver version. For more information on how to read the compatibility tables, see our guide on\n MongoDB Compatibility Tables. Versions 1.10 and 1.11 of the driver are compatible with .NET 3.5\nthrough 4.8 only. .NET/C# Driver Version .NET 8 .NET 7 .NET 6  .NET 4.8 .NET 4.7  .NET 4.6 2.24 \u2713 \u2713 \u2713 \u2713 \u2713 2.23 \u2713 \u2713 \u2713 \u2713 \u2713 2.22 \u2713 \u2713 \u2713 \u2713 \u2713 2.21 \u2713 \u2713 \u2713 \u2713 \u2713 2.20 \u2713 \u2713 \u2713 \u2713 \u2713 2.19 \u2713 \u2713 \u2713 \u2713 \u2713 2.18 \u2713 \u2713 \u2713 \u2713 \u2713 2.17 \u2713 \u2713 \u2713 \u2713 \u2713 2.16 \u2713 \u2713 \u2713 \u2713 \u2713 2.15 \u2713 \u2713 \u2713 \u2713 \u2713 2.14 \u2713 \u2713 \u2713 \u2713 \u2713 2.13 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.12 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.11 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.10 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.9 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.8 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.7 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.6 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.5 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.4 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.3 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 2.2 \u2713 \u2713 \u2713 2.0 \u2713 \u2713 \u2713 When using .NET 6, you can't connect to Atlas clusters running MongoDB 4.0 due to a certificate issue. This does not impact clusters running MongoDB 4.2+. .NET/C# Driver versions 2.14 or later requires .NET Framework 4.7.2 or\nlater.",
            "code": [],
            "preview": "The following compatibility table specifies the recommended version or versions\nof the MongoDB .NET/C# Driver for use with a specific version of MongoDB.",
            "tags": null,
            "facets": {
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/builders",
            "title": "Operations with Builders",
            "headings": [
                "Overview",
                "Sample Class",
                "Construct a Filter",
                "Array Operators",
                "Create a Projection",
                "Lambda Expressions",
                "Define a Sort",
                "Define an Update",
                "Define Index Keys",
                "Build an Aggregation Pipeline",
                "Build an Atlas Search Query",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn about the helper classes, or  builders , that\nthe .NET/C# Driver provides to create types used in your operations.\nUsing builders helps you identify errors at compile time and avoid them\nat runtime. This guide provides information on builder classes that you\ncan use for the following tasks: You should read this guide if you want to learn more about how to\nconstruct definitions and build up syntax using builders. Creating a filter definition Creating a projection Defining a sort order Defining an update operation Selecting index keys The MongoDB Analyzer is a tool that helps you analyze your\nbuilders definitions and understand how your .NET/C# code\ntranslates into the MongoDB Query API. For more information and\ninstallation instructions, see the  MongoDB Analyzer reference page . The code examples in this guide demonstrate how you can use builders to\ncreate types to interact with documents in the sample collection  plants.flowers .\nDocuments in this collection are modeled by the following  Flower  class: Each builder class takes a generic type parameter\n TDocument  which represents the type of document that you are working\nwith. In this guide, the  Flower  class is the document type used in\neach builder class example. The  FilterDefinitionBuilder  class provides a type-safe interface for\nbuilding up queries. Suppose you want to query your collection for\ndocuments matching the following criteria: Use builders to create the filter definition with the typed variant: Using the typed variant form provides compile-time safety. Additionally,\nyour IDE can provide refactoring support. Alternatively, you can use string-based field names to contruct the filter: Price  field value less than 20 Category  field value is \"Perennial\" If your document has properties or fields that serialize to arrays,\nyou can use the methods beginning with  Any , such as  AnyEq()  or\n AnyLt() , to compare the entire array against a single item. Use builders to check which documents in the collection have a\n Season  array that includes \"winter\": The  ProjectionDefinitionBuilder  class provides a type-safe interface for\ndefining a projection. Suppose you want to create a projection on the\n Name  and  Price  fields, but exclude the  Id  field. Use builders to create the projection definition with the typed variant: You can also use string-based field names to define the projection: Finally, you can use the  Expression()  method to define the\nprojection: This definition has a return type of  ProjectionDefinition<TDocument,\nTProjection>  whereas the others return a\n ProjectionDefinition<TDocument> . The driver supports using lambda expressions to render projections. When\nyou define a  Find()  projection with the  Expression()  method to\ncreate a lambda expression, the driver inspects the expression\nto determine which fields are referenced and automatically constructs a\nserver-side projection to return only those fields. You can also use lambda expressions to create new fields by performing\noperations on values in your documents. The following example shows how\nyou can use a lambda expression to project a new  Profit  field\nusing the  Price  and  Stock  fields: When you create a projection using a lambda expression, the output\nautomatically excludes the  Id  field unless you explicitly include\nis as a projection field. The  SortDefinitionBuilder  class provides a type-safe interface for\nbuilding up sort syntax. Suppose you want to define a sort with the\nfollowing order: Use builders to create the sort definition with the typed variant: Alternatively, you can use string-based field names to define the sort: Ascending on  Price Descending on  Category The  UpdateDefinitionBuilder  class provides a type-safe interface for\nbuilding up an update specification. Suppose you want to create an\nupdate specification with the following criteria: Use builders to create the update specification with the typed variant: Alternatively, you can use string-based field names to define the update: Create the new field  SunRequirement Multiply the  Price  field value by 0.9 The  IndexKeysDefinitionBuilder  class provides a type-safe interface for\ndefining index keys. Suppose you want to select  Category  as an\nascending index key. Use builders to select the index key with the typed variant: Alternatively, you can use string-based field names to select the index key: The  IndexKeysDefinitionBuilder  class also provides methods to build\na wildcard index. You can create a wildcard index using  All field paths  or  A\nsingle field path , in this case using  Category : The  PipelineDefinitionBuilder  class provides a type-safe interface for\ndefining an  aggregation pipeline . An aggregation pipeline is a series of\nstages that are used to transform a document. Suppose you want to create a\npipeline that performs the following operations: Use  PipelineDefinitionBuilder  classes to build the pipeline: The preceding example creates the following pipeline: You can add stages to your pipeline that don't have corresponding type-safe\nmethods in the  PipelineDefinitionBuilder  interface by providing your query\nas a  BsonDocument  to the  AppendStage() method . To learn more about the Aggregation Pipeline, see the\n Aggregation Pipeline  server manual page. Matches all documents with \"spring\" in the  Season  field Sorts the results by the  Category  field Groups the documents by category and shows the average price and total\navailable for all documents in that category When using a  BsonDocument  to define your pipeline stage, the driver does\nnot take into account any  BsonClassMap , serialization attributes or\nserialization conventions. The field names used in the  BsonDocument  must\nmatch those stored on the server. For more information on providing a query as a  BsonDocument , see our\n FAQ page . The  Search  class provides a type-safe interface for creating a\n $search \npipeline stage. To learn how to construct search queries with the  Search  class, see\n Atlas Search . Find runnable examples using builders for various operations under\n Usage Examples . To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: FilterDefinitionBuilder ProjectionDefinitionBuilder SortDefinitionBuilder UpdateDefinitionBuilder IndexKeysDefinitionBuilder PipelineDefinitionBuilder",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Flower\n{\n    public ObjectId Id { get; set; }\n    public string Name { get; set; }\n    public string Category { get; set; }\n    public double Price { get; set; }\n    public List<string> Season { get; set; }\n    public double Stock { get; set; }\n    public string Description { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Filter;\nvar filter = builder.Lt(f => f.Price, 20) & builder.Eq(f => f.Category, \"Perennial\");"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Filter;\nvar filter = builder.Lt(\"Price\", 20) & builder.Eq(\"Category\", \"Perennial\");"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Filter;\nvar filter = builder.AnyEq(f => f.Season, \"winter\");"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Projection;\nvar projection = builder.Include(f => f.Name).Include(f => f.Price).Exclude(f => f.Id);"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Projection;\nvar projection = builder.Include(\"Name\").Include(\"Price\").Exclude(\"Id\");"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Projection;\nvar projection = builder.Expression(f => new { Name = f.Name, Price = f.Price });"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Projection;\nvar projection = builder.Expression(f => new { Profit = f.Price * f.Stock });"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Sort;\nvar sort = builder.Ascending(f => f.Price).Descending(f => f.Category);"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Sort;\nvar sort = builder.Ascending(\"Price\").Descending(\"Category\");"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Update;\nvar update = builder.Set(f => f.SunRequirement, \"Full sun\").Mul(f => f.Price, 0.9);"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.Update;\nvar update = builder.Set(\"SunRequirement\", \"Full sun\").Mul(\"Price\", 0.9);"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.IndexKeys;\nvar keys = builder.Ascending(f => f.Category);"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<BsonDocument>.IndexKeys;\nvar keys = builder.Ascending(\"Category\");"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.IndexKeys;\nvar keys = builder.Wildcard();"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Flower>.IndexKeys;\n\n// Using the typed variant\nvar keys = builder.Wildcard(f => f.Category);\n\n// Using string-based field names\nvar keys = builder.Wildcard(\"Category\");"
                },
                {
                    "lang": "csharp",
                    "value": "var sortBuilder = Builders<Flower>.Sort.Ascending(f => f.Category);\nvar matchFilter = Builders<Flower>.Filter.AnyEq(f => f.Season, \"spring\");\n\nvar pipeline = new EmptyPipelineDefinition<Flower>()\n    .Match(matchFilter)\n    .Sort(sortBuilder)\n    .Group(f => f.Category,\n           g => new\n              {\n                 name = g.Key,\n                 avgPrice = g.Average(f => f.Price),\n                 totalAvailable = g.Sum(f => f.Stock)\n               }\n          );"
                },
                {
                    "lang": "json",
                    "value": "[{ \"$match\" : { \"season\" : \"spring\" } }, { \"$sort\" : { \"category\" : 1 } }, { \"$group\" : { \"_id\" : \"$category\", \"avgPrice\" : { \"$avg\" : \"$price\" }, \"totalAvailable\" : { \"$sum\" : \"$stock\" } } }]"
                },
                {
                    "lang": "csharp",
                    "value": "var pipeline = new EmptyPipelineDefinition<BsonDocument>().AppendStage<BsonDocument, BsonDocument, BsonDocument>(\"{ $set: { field1: '$field2' } }\");"
                }
            ],
            "preview": "In this guide, you can learn about the helper classes, or builders, that\nthe .NET/C# Driver provides to create types used in your operations.\nUsing builders helps you identify errors at compile time and avoid them\nat runtime. This guide provides information on builder classes that you\ncan use for the following tasks:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/bson",
            "title": "BSON Operations",
            "headings": [
                "Overview",
                "BSON Data Format",
                "Create a BSON Document",
                "Change a BSON Document",
                "Write BSON to a File",
                "Read BSON from a File",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to create BSON documents, read BSON from a file,\nand write BSON to a file using the .NET/C# Driver. BSON , or Binary JSON, is the data format that MongoDB uses to organize\nand store data. This data format includes all JSON data structure types and\nadds support for types including dates, different size integers, ObjectIds, and\nbinary data. For a complete list of supported types, see the\n BSON Types  server manual page. The code samples in this guide use the following BSON document as an example: To build a BSON document in C#, create an instance of the  BsonDocument  class.\nThe  BsonDocument  constructor accepts  BsonElement  arguments that map to the fields\nand values in the document. Each  BsonElement  can be either an instance of the\n BsonElement  class or a field-value pair inside curly braces (  {}  ). The following code sample shows how to create a  BsonDocument  object to represent the\nexample BSON document. Each key-value pair in the  BsonDocument  object is a\n BsonElement  object. The  BsonDocument  class includes methods that let you change the contents of the\nBSON document. The following code sample makes three changes to the previous\n BsonDocument  object: Adds a new field,  \"restaurant_id\" , with the value  \"12345\" Removes the  \"cuisine\"  field Sets the value of the  \"name\"  field to  \"Mongo's Pizza Palace\" For a full list of methods in the  BsonDocument  class, see the\n API Documentation . You can write BSON to a file using the methods in the  BsonBinaryWriter  class. To\nwrite to a file, perform the following steps: The following code sample shows how to write the sample BSON document to  myFile.bson : The resulting BSON document looks like the following: Open a file stream for the file containing BSON data. Create a  BsonBinaryWriter  using the file stream. For each BSON document and subdocument you want to create, call\n WriteStartDocument() . Within each BSON document and subdocument, call  WriteName()  to set the field\nname and the appropriate  Write*  method to set its value. Each data type has a\ndedicated  Write*  method that you should use. To start and end arrays, use  WriteStartArray()  and  WriteEndArray() . At the end of each document and subdocument, call  WriteEndDocument() . To read a BSON document from a file, follow the same steps used for writing a BSON\ndocument to a file, with two differences: The following code sample shows how to read the fields and values from the sample\nBSON document stored in  myFile.bson : Use  BsonBinaryReader  instead of  BsonBinaryWriter . Use  Read*  methods instead of  Write*  methods. These methods return field names\nand values from the BSON document. If you call  ReadName()  twice in a row without reading a value,\nthe driver will throw an  InvalidOperationException . The  BsonBinaryReader  and  BsonBinaryWriter  constructors accept any\n System.IO.Stream  object. This means that you can read or write any location\nthat can be accessed by a stream. To learn more about any of the methods or types discussed in this\nguide, see the following API documentation: BsonDocument BsonElement BsonBinaryReader BsonBinaryWriter",
            "code": [
                {
                    "lang": "none",
                    "value": "{\n    \"address\" : {\n        \"street\" : \"Pizza St\",\n        \"zipcode\" : \"10003\"\n    },\n    \"coord\" : [-73.982419, 41.579505]\n    \"cuisine\" : \"Pizza\",\n    \"name\" : \"Mongo's Pizza\"\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var newRestaurant = new BsonDocument\n{\n    { \"address\", new BsonDocument\n        {\n            { \"street\", \"Pizza St\" },\n            { \"zipcode\", \"10003\" }\n        }\n    },\n    { \"coord\", new BsonArray\n        {-73.982419, 41.579505 }\n    },\n    { \"cuisine\", \"Pizza\" },\n    { \"name\", \"Mongo's Pizza\"}\n};"
                },
                {
                    "lang": "csharp",
                    "value": "var newRestaurant = new BsonDocument\n{\n    { \"address\", new BsonDocument\n        {\n            { \"street\", \"Pizza St\" },\n            { \"zipcode\", \"10003\" }\n        }\n    },\n    { \"coord\", new BsonArray\n        {-73.982419, 41.579505 }\n    },\n    { \"cuisine\", \"Pizza\" },\n    { \"name\", \"Mongo's Pizza\"}\n};\nnewRestaurant.Add(new BsonElement(\"restaurant_id\", \"12345\"));\nnewRestaurant.Remove(\"cuisine\");\nnewRestaurant.Set(\"name\", \"Mongo's Pizza Palace\");"
                },
                {
                    "lang": "csharp",
                    "value": "string outputFileName = \"myFile.bson\";\n\nusing (var stream = File.OpenWrite(outputFileName))\nusing (var writer = new BsonBinaryWriter(stream))\n{\n    writer.WriteStartDocument();\n\n    //address\n    writer.WriteName(\"address\");\n    writer.WriteStartDocument();\n    writer.WriteName(\"street\");\n    writer.WriteString(\"Pizza St\");\n    writer.WriteName(\"zipcode\");\n    writer.WriteString(\"10003\");\n    writer.WriteEndDocument();\n\n    //coord\n    writer.WriteName(\"coord\");\n    writer.WriteStartArray();\n    writer.WriteDouble(-73.982419);\n    writer.WriteDouble(41.579505);\n    writer.WriteEndArray();\n\n    //cuisine\n    writer.WriteName(\"cuisine\");\n    writer.WriteString(\"Pizza\");\n\n    //name\n    writer.WriteName(\"name\");\n    writer.WriteString(\"Mongo's Pizza\");\n\n    writer.WriteEndDocument();\n}"
                },
                {
                    "lang": "none",
                    "value": "{\n    \"address\" : {\n        \"street\" : \"Pizza St\",\n        \"zipcode\" : \"10003\"\n    },\n    \"coord\" : [-73.982419, 41.579505]\n    \"cuisine\" : \"Pizza\",\n    \"name\" : \"Mongo's Pizza\"\n}"
                },
                {
                    "lang": "csharp",
                    "value": "string inputFileName = \"myFile.bson\";\n\nusing (var stream = File.OpenRead(inputFileName))\nusing (var reader = new BsonBinaryReader(stream))\n{\n    reader.ReadStartDocument();\n\n    //address\n    string addressFieldName = reader.ReadName();\n    reader.ReadStartDocument();\n    string streetFieldName = reader.ReadName();\n    string streetValue = reader.ReadString();\n    string zipFieldName = reader.ReadName();\n    string zipValue = reader.ReadString();\n    reader.ReadEndDocument();\n\n    //coord\n    string coordFieldName = reader.ReadName();\n    reader.ReadStartArray();\n    double coord1 = reader.ReadDouble();\n    double coord2 = reader.ReadDouble();\n    reader.ReadEndArray();\n\n    //cuisine\n    string cuisineFieldName = reader.ReadName();\n    string cuisineValue = reader.ReadString();\n\n    //name\n    string nameFieldName = reader.ReadName();\n    string nameValue = reader.ReadString();\n\n    reader.ReadEndDocument();\n}"
                }
            ],
            "preview": "In this guide, you can learn how to create BSON documents, read BSON from a file,\nand write BSON to a file using the .NET/C# Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/atlas-search",
            "title": "Atlas Search",
            "headings": [
                "Overview",
                "Create an Atlas Search Index",
                "Atlas Search Operators",
                "Autocomplete",
                "Compound",
                "Equals",
                "Exists",
                "GeoShape",
                "GeoWithin",
                "MoreLikeThis",
                "Near",
                "Phrase",
                "QueryString",
                "Range",
                "Regex",
                "Span",
                "Text",
                "Wildcard"
            ],
            "paragraphs": "In this guide you can learn how to use the  Search  builder to build a  $search \naggregation pipeline stage with the MongoDB .NET/C# Driver. To learn more about the  $search  pipeline stage, see  $search . The examples in this guide use the following documents in a collection called\n guitars : The following  Guitar  class models the documents in this collection. The  $search  aggregation-pipeline operator is available only for collections hosted\non  MongoDB Atlas  clusters running MongoDB v4.2 or later that are\ncovered by an  Atlas search index .\nTo earn more about the required setup and the functionality of this operator,\nsee the  Atlas Search  documentation. The documents in the  guitars  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Guitar  class. To learn more about custom serialization, see  Custom Serialization . Before you can perform a search on an Atlas collection, you must first create an  Atlas\nSearch index  on the collection. An Atlas Search index is a data structure that\ncategorizes data in a searchable format. To learn how to create an Atlas Search Index see the\n Create an Atlas Search Index  Atlas guide. The  Search  class contains methods you can use to perform  $search \noperations. For a full list of available  $search  operators, see the  Operators and Collectors  Atlas guide. The  Search  class does not currently support the  $embeddedDocument  operator. Use the  Autocomplete  method to search for a word or phrase that contains a\nsequence of characters from an incomplete input string. The following example performs an autocomplete search on the  guitars \ncollection using the string \"Gib\" in the  make  field. The search returns the following document: To learn more about the  autocomplete  operator, see the  autocomplete \nAtlas guide. Use the  Compound  method to combine two or more operators into a single\nsearch. The following example searches the  guitars  collection for any documents\nthat match all of the following criteria: The search returns the following documents: To learn more about the  compound  operator, see the  compound \nAtlas guide. The  rating  field exists on the document The  in-stock  field is not  false The  establishedYear  field has a value greater than 1940 Use the  Equals  method to check whether a field matches a specified\nvalue. The following example searches the  guitars  collection for any documents in\nwhich the value of the  in-stock  field is  true . The search returns the following documents: To learn more about the  equals  operator, see the  equals \nAtlas guide. Use the  Exists  method to search for documents in which a specified indexed\nfield name exists. If the specified field exists but is not indexed, the\ndocument is not included with the result set. The following example searches the  guitars  collection for any documents in\nwhich the  rating  field exists. The search returns the following documents: To learn more about the  exists  operator, see the  exists \nAtlas guide. Use the  GeoShape  method to search for documents in relation to a given\ngeometry. When specifying the coordinates to search, longitude must be specified\nfirst, followed by latitude. Longitude values can be between  -180  and\n 180 , inclusive. Latitude values can be between  -90  and  90 ,\ninclusive. Consider some documents in the  guitars  collection have added an\n in-stock-location  field. The changed documents in the collection now look as\nfollows: The following example searches for all documents in which the\ncoordinates in the  in-stock-location  field intersect with a specified\npolygon: The search returns the following document: To learn more about the  geoShape  operator, see the  geoShape \nAtlas guide. Atlas Search does not support the following: Non-default coordinate reference system (CRS) Planar XY coordinate system (2 dimensional) Coordinate pairs Point notation (pointFieldName: [12, 34]) Use the  GeoWithin  method to search for documents in which the coordinates of\ntheir specified  GeoJSON  field are within a given\ngeometry. You can search for points that are within a: When specifying the coordinates to search, longitude must be specified\nfirst, followed by latitude. Longitude values can be between  -180  and\n 180 , inclusive. Latitude values can be between  -90  and  90 ,\ninclusive. Consider some documents in the  guitars  collection have added an\n in-stock-location  field. The changed documents in the collection now look as\nfollows: The following example searches for all documents in which the\ncoordinates in the  in-stock-location  field falls within a specified\npolygon: The search returns the following document: To learn more about the  geoWithin  operator, see the  geoWithin \nAtlas guide. Circle Bounding box Polygon Atlas Search does not support the following: Non-default coordinate reference system (CRS) Planar XY coordinate system (2 dimensional) Coordinate pairs Point notation (pointFieldName: [12, 34]) Use the  MoreLikeThis  method to search for documents that are similar to an\ninput document. The following example searches the  guitars  collection for documents that are\nsimilar to an object in which the value of the  Description  field is \"high\nquality.\" The search returns the following documents: To learn more about the  moreLikeThis  operator, see the  moreLikeThis \nAtlas guide. Use the  Near  method to search for documents in which a specified field is\nnear a given value. You can perform the search on: The following example searches the  guitars  collection for documents in which\nthe value of the  rating  field is near  9 . The documents are returned in\norder based on how close the value is to the number  9 . The search returns the following documents: To learn more about the  near  operator, see the  near \nAtlas guide. A number field A date field A geographic point Use the  Phrase  method to search for documents in which a specified field\ncontains an input string. The following example searches the  guitars  collection for documents in which\nthe  description  field contains the phrase \"classic guitars.\" The search returns the following documents: You can also search the collection for documents that match multiple separate\nphrases as follows: This search returns the following documents: To learn more about the  phrase  operator, see the  phrase \nAtlas guide. Use the  QueryString  method to search for documents using a string with\nthe following operators and delimiters: The following example searches the  guitars  collection for documents in which\nthe value of the  description  field matches each of the following criteria: The search returns the following documents: To learn more about the  queryString  operator, see the  queryString \nAtlas guide. AND OR NOT () Contains the string \"classic\"  or  the string \"quality\" Does not contain the string \"custom\" Use the  Range  method to search for documents in which the value of a\nspecified field falls within a given numeric or date range. The following example searches the  guitars  collection for all documents with\nan  establishedYear  value greater than 1980 and less than 2020. The search returns the following results: To learn more about the  range  operator, see the  range \nAtlas guide. Use the  Regex  method to search for documents using a regular expression. The following example searches the  guitars  collection for documents in which\nthe value of the  make  field contains exactly six letters. The search returns the following results: To learn more about the  regex  operator, see the  regex \nAtlas guide. By default the  regex  operator cannot run on an analyzed field. You can\nallow it to run on an analyzed field by setting  allowAnalyzedField  option\nto true, as follows: Setting the  allowAnalyzedField  option to true may lead to unexpected\nsearch results. To learn more, see  regex Behavior . Use the  Span  method to search for text search matches within regions of a\nfield. You can use this method to find strings which are near each other to\nspecified degrees of precision. The following example searches the  guitars  collection for documents in which\nthe value of the  description  field contains the strings \"guitars\" and\n\"quality\" within one word of each other. The search returns the following document: Although the document with  _id: 3  contains the strings \"guitars\" and\n\"quality\", they are separated by more than one word, so the search omits this\ndocument from the results. To learn more about the  span  operator, see the  span \nAtlas guide. The  span  operator is more computationally intensive than other operators\nbecause queries must keep track of positional information. Use the  Text  method to search a document for a given string or array of\nstrings. If there are multiple terms in a given string, Atlas Search also looks\nfor a match for each term in the string separately. The following example searches the  guitars  collection for documents in which\nthe value of the  description  field contains the string \"used by\nprofessionals\". The search returns the following document: To learn more about the  text  operator, see the  text \nAtlas guide. If your search string contains multiple terms, the method also looks for a match\nfor each term in the string separately. Use the  Wildcard  method to search for documents using special characters in\nyour search string that can match any character. You can use the following\ncharacters in your search: The following example searches for documents in which the value of the  make \nfield contains the string \"Strand\" followed by any other characters. The search returns the following document: To learn more about the  wildcard  operator, see the  wildcard \nAtlas guide. Character Description ? Matches any single character * Matches 0 or more characters \\ Escape character By default the  wildcard  operator cannot run on an analyzed field. You can\nallow it to run on an analyzed field by setting  allowAnalyzedField  option\nto true, as follows: Setting the  allowAnalyzedField  option to true may lead to unexpected\nsearch results. To learn more, see  wildcard Behavior .",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"make\": \"Fender\", \"description\": \"Classic guitars known for their versatility.\", \"establishedYear\": 1946, \"in-stock\": true, \"rating\": 9 }\n{ \"_id\": 2, \"make\": \"Gibson\", \"description\": \"Classic guitars known for their rich, full tones.\", \"establishedYear\": 1902, \"in-stock\": true, \"rating\": 8 }\n{ \"_id\": 3, \"make\": \"PRS\", \"description\": \"High-end guitars known for their quality.\", \"establishedYear\": 1985, \"in-stock\": true, \"rating\": 9 }\n{ \"_id\": 4, \"make\": \"Kiesel\", \"description\": \"Quality guitars made only for custom orders.\", \"establishedYear\": 2015, \"in-stock\": false }\n{ \"_id\": 5, \"make\": \"Ibanez\", \"description\": \"Well-crafted guitars used by many professional guitarists.\", \"establishedYear\": 1957, \"in-stock\": true, \"rating\": 7 }\n{ \"_id\": 6, \"make\": \"Strandberg\", \"description\": \"Modern guitars known for their headless models.\", \"establishedYear\": 1982, \"in-stock\": false }"
                },
                {
                    "lang": "csharp",
                    "value": "public class Guitar\n{\n    public int Id { get; set; }\n    public string Make { get; set; }\n    public List<string> Models { get; set; }\n    public int EstablishedYear { get; set; }\n    [BsonElement(\"in-stock\")]\n    public bool InStock { get; set; }\n    public int? Rating { get; set; }\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"Classic guitars known for their rich, full tones.\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Autocomplete(g => g.Make, \"Gib\"))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"...\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"...\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 5, \"make\" : \"Ibanez\", \"description\" : \"...\", \"establishedYear\" : 1957, \"in-stock\" : true, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Compound()\n        .Must(Builders<Guitar>.Search.Exists(g => g.Rating))\n        .MustNot(Builders<Guitar>.Search.Equals(g => g.InStock, false))\n        .Must(Builders<Guitar>.Search.Range(g => g.EstablishedYear, SearchRangeBuilder.Gt(1940))))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"...\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"...\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"...\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 5, \"make\" : \"Ibanez\", \"description\" : \"...\", \"establishedYear\" : 1957, \"in-stock\" : true, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Equals(g => g.InStock, true))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"...\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"...\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"...\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 5, \"make\" : \"Ibanez\", \"description\" : \"...\", \"establishedYear\" : 1957, \"in-stock\" : true, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Exists(g => g.Rating))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"make\": \"Fender\", \"description\": \"...\", \"establishedYear\": 1946, \"in-stock\": true, \"in-stock-location\":  { \"type\": \"Point\", \"coordinates\": [ -73.93615, 40.69791 ]}, \"rating\": 9 }\n{ \"_id\": 2, \"make\": \"Gibson\", \"description\": \"...\", \"establishedYear\": 1902, \"in-stock\": true, \"in-stock-location\":  { \"type\": \"Point\", \"coordinates\": [ 47.6062, 122.321 ]}, \"rating\": 8 }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"...\", \"establishedYear\" : 1946, \"in-stock\" : true, \"in-stock-location\" : { \"type\" : \"Point\", \"coordinates\" : [\"-73.93615\", \"40.69791\"] }, \"rating\" : 9 }"
                },
                {
                    "lang": "csharp",
                    "value": "GeoJsonPolygon<GeoJson2DGeographicCoordinates> searchArea = new(new(new(new GeoJson2DGeographicCoordinates[]\n{\n     new(-72.93615, 41.69791),\n     new(-72.93615, 40.59791),\n     new(-74.93615, 40.59791),\n     new(-74.93615, 41.69791),\n     new(-72.93615, 41.69791),\n})));\n\nvar result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.GeoShape(g => g.InStockLocation, GeoShapeRelation.Intersects, searchArea))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"make\": \"Fender\", \"description\": \"...\", \"establishedYear\": 1946, \"in-stock\": true, \"in-stock-location\":  { \"type\": \"Point\", \"coordinates\": [ -73.93615, 40.69791 ]}, \"rating\": 9 }\n{ \"_id\": 2, \"make\": \"Gibson\", \"description\": \"...\", \"establishedYear\": 1902, \"in-stock\": true, \"in-stock-location\":  { \"type\": \"Point\", \"coordinates\": [ 47.6062, 122.321 ]}, \"rating\": 8 }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"Classic guitars known for their versatility.\", \"establishedYear\" : 1946, \"in-stock\" : true, \"in-stock-location\" : { \"type\" : \"Point\", \"coordinates\" : [\"-73.93615\", \"40.69791\"] }, \"rating\" : 9 }"
                },
                {
                    "lang": "csharp",
                    "value": "GeoJsonPolygon<GeoJson2DGeographicCoordinates> searchArea = new(new(new(new GeoJson2DGeographicCoordinates[]\n{\n     new(-74.3994140625, 40.5305017757),\n     new(-74.7290039063, 40.5805846641),\n     new(-74.7729492188, 40.9467136651),\n     new(-74.0698242188, 41.1290213475),\n     new(-73.65234375, 40.9964840144),\n     new(-72.6416015625, 40.9467136651),\n     new(-72.3559570313, 40.7971774152),\n     new(-74.3994140625, 40.5305017757),\n})));\n\nvar result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.GeoWithin(g => g.InStockLocation, searchArea))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"High-end guitars known for their quality.\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 4, \"make\" : \"Kiesel\", \"description\" : \"Quality guitars made only for custom orders.\", \"establishedYear\" : 2015, \"in-stock\" : false, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var searchDocument = new GuitarSearch()\n{\n    Description = \"high quality\",\n};\n\nvar result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.MoreLikeThis(searchDocument))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"...\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"...\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"...\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }\n{ \"_id\" : 5, \"make\" : \"Ibanez\", \"description\" : \"...\", \"establishedYear\" : 1957, \"in-stock\" : true, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Near(g => g.Rating, 9, 1))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"Classic guitars known for their versatility.\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"Classic guitars known for their rich, full tones.\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"Classic guitars known for their versatility.\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 4, \"make\" : \"Kiesel\", \"description\" : \"Quality guitars made only for custom orders.\", \"establishedYear\" : 2015, \"in-stock\" : false, \"rating\" : null }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"Classic guitars known for their rich, full tones.\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Phrase(g => g.Description, \"classic guitars\"))\n    .ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Phrase(g => g.Description, new List<string>() { \"classic guitars\", \"quality guitars\" }))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"Classic guitars known for their versatility.\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"High-end guitars known for their quality.\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"Classic guitars known for their rich, full tones.\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.QueryString(g => g.Description, \"(classic OR quality) AND NOT custom\"))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 3, \"make\" : \"PRS\", \"description\" : \"High-end guitars known for their quality.\", \"establishedYear\" : 1985, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 4, \"make\" : \"Kiesel\", \"description\" : \"Quality guitars made only for custom orders.\", \"establishedYear\" : 2015, \"in-stock\" : false, \"rating\" : null }\n{ \"_id\" : 6, \"make\" : \"Strandberg\", \"description\" : \"Modern guitars known for their headless models.\", \"establishedYear\" : 1982, \"in-stock\" : false, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Range(g => g.EstablishedYear, SearchRangeBuilder.Gt(1980).Lt(2020)))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"description\" : \"Classic guitars known for their versatility.\", \"establishedYear\" : 1946, \"in-stock\" : true, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"description\" : \"Classic guitars known for their rich, full tones.\", \"establishedYear\" : 1902, \"in-stock\" : true, \"rating\" : 8 }\n{ \"_id\" : 4, \"make\" : \"Kiesel\", \"description\" : \"Quality guitars made only for custom orders.\", \"establishedYear\" : 2015, \"in-stock\" : false, \"rating\" : null }\n{ \"_id\" : 5, \"make\" : \"Ibanez\", \"description\" : \"Well-crafted guitars used by many professional guitarists.\", \"establishedYear\" : 1957, \"in-stock\" : true, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var regex = \"[A-Za-z]{6}\";\n\nvar result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Regex(g => g.Make, regex))\n    .ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n .Search(Builders<Guitar>.Search.Regex(g => g.Make, regex, true))\n .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 4, \"make\" : \"Kiesel\", \"description\" : \"Quality guitars made only for custom orders.\", \"establishedYear\" : 2015, \"in-stock\" : false, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var searchTerms = new[]\n{\n     Builders<Guitar>.SearchSpan.Term(g => g.Description, \"guitars\"),\n     Builders<Guitar>.SearchSpan.Term(g => g.Description, \"quality\")\n };\n\nvar result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Span(Builders<Guitar>.SearchSpan.Near(searchTerms, 1)))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 5, \"make\" : \"Ibanez\", \"description\" : \"Well-crafted guitars used by many professional guitarists.\", \"establishedYear\" : 1957, \"in-stock\" : true, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Text(g => g.Description, \"used by professional\"))\n    .ToList();"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 6, \"make\" : \"Strandberg\", \"description\" : \"Modern guitars known for their headless models.\", \"establishedYear\" : 1982, \"in-stock\" : false, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = guitarsCollection.Aggregate()\n    .Search(Builders<Guitar>.Search.Wildcard(g => g.Make, \"Strand*\"))\n    .ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var result =  guitarsCollection.Aggregate()\n .Search(Builders<Guitar>.Search.Wildcard(g => g.Make, \"Strand*\", true))\n .ToList();"
                }
            ],
            "preview": "In this guide you can learn how to use the Search builder to build a $search\naggregation pipeline stage with the MongoDB .NET/C# Driver.",
            "tags": ".NET, operators, aggregation, pipeline, atlas, code example",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/authentication",
            "title": "Authentication Mechanisms",
            "headings": [
                "Overview",
                "Specify an Authentication Mechanism",
                "Mechanisms",
                "Default",
                "SCRAM-SHA-256",
                "SCRAM-SHA-1",
                "MONGODB-AWS",
                "Specify Your AWS IAM Credentials",
                "Retrieve Credentials Automatically",
                "X.509",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to authenticate with MongoDB using the\n authentication mechanisms  available in the MongoDB Community Edition.\nAuthentication mechanisms are processes by which the driver and server confirm\nthe identity of a client to ensure security before connecting. You can use the following authentication mechanisms with the latest version\nof MongoDB Community Edition: To authenticate using  GSSAPI/Kerberos  or  LDAP , see the\n Enterprise Authentication Mechanisms  fundamentals page. For more\ninformation on establishing a connection to your MongoDB cluster, see the\n Connection Guide . SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-AWS X.509 You can specify your authentication mechanism and credentials when connecting to\nMongoDB using either of the following methods: A  connection string , also known as a  connection URI , which is a string\nthat tells the driver how to connect to a MongoDB deployment and how to behave while\nconnected. A factory method for the supported authentication mechanism, contained in the\n MongoCredential  class. The following examples contain code examples that use the following\nplaceholders: <username>  - MongoDB username. <password>  - MongoDB user's password. <hostname>  - network address of the MongoDB server, accessible by your client. <port>  - port number of the MongoDB server. <authenticationDb>  - MongoDB database that contains the user's authentication\ndata. If you omit this parameter, the driver uses the default value  admin . The default authentication mechanism setting uses one of the following\nauthentication mechanisms, depending on which MongoDB versions your server supports: Select the  Connection String  or  MongoCredential  tab to\nsee the corresponding syntax for specifying the default authentication mechanism: SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-CR MongoDB version 4.0 uses SCRAM as the default mechanism, and no longer\nsupports  MONGODB-CR . SCRAM-SHA-256  is a salted challenge-response authentication mechanism (SCRAM)\nthat uses your username and password, encrypted with the  SHA-256  algorithm,\nto authenticate your user. You can specify the  SCRAM-SHA-256  authentication mechanism with your connection\nstring as follow: MongoDB version 4.0 and later uses  SCRAM-SHA-256  as the default\nauthentication mechanism if the MongoDB server version supports it. To learn more on specifying the default mechanism, see  Default . SCRAM-SHA-1  is s a salted challenge-response mechanism (SCRAM) that uses\nyour username and password, encrypted with the  SHA-1  algorithm, to authenticate\nyour user. You can specify the  SCRAM-SHA-1  authentication mechanism with your connection\nstring as follow: MongoDB version 4.0 uses  SCRAM-SHA-1  as the default authentication mechanism\nif the server does not support  SCRAM-SHA-256 . To learn more on specifying the default mechanism, see  Default . The  MONGODB-AWS  authentication mechanism uses your Amazon Web Services\nIdentity and Access Management (AWS IAM) credentials to authenticate your\nuser. You can either specify your credentials explicitly\nor instruct the driver to retrieve them automatically from an external source. The following sections contain code examples that use the following placeholders: The  MONGODB-AWS  authentication mechanism is available only for\nMongoDB deployments on MongoDB Atlas. <awsKeyId>  - value of the AWS access key ID <awsSecretKey>  - value of the AWS secret access key <awsSessionToken>  - value of the AWS session token To learn more about configuring MongoDB Atlas with AWS IAM, see the\n Set Up Passwordless Authentication with AWS IAM Roles  guide. You can supply your AWS IAM credentials on a  MongoClientSettings  object either by\nusing a  MongoCredential  object or as part of the connection string. Select the\n Connection String  or  MongoCredential  tab to\nsee the corresponding syntax for specifying your credentials: If you're using an AWS session token, include the  authMechanismProperties \nparameter in the connection string as shown below: If you're using an AWS session token, call the  WithMechanismProperty() \nmethod on your  MongoCredential  object as shown below: Instead of specifying your AWS IAM credentials in  MongoClientSettings , you can\ninstruct the .NET/C# Driver to use the AWS SDK to automatically retrieve your\ncredentials from an external source. To instruct the driver to\nretrieve your credentials, perform the following actions: You can specify the authentication mechanism and source either\nby using a  MongoCredential  object or as part of the connection string. Select the\n Connection String  or  MongoCredential  tab to\nsee the corresponding syntax for specifying the  MONGODB-AWS  authentication mechanism\nand external authentication source: After you specify the authentication mechanism and source, you must set\nyour credentials in the location appropriate to the credential type. The .NET/C# Driver\nchecks for credentials in the following locations in the order listed here: You can use an OpenID Connect (OIDC)-compatible  web identity provider  to authenticate\nto Amazon Elastic Kubernetes Service (EKS) or other services.\nTo use a web identity provider, create a file that contains your\nOIDC token, then set the absolute path to this file in an environment variable by using\n bash  or a similar shell as shown in the following example: To authenticate by using a profile in a  shared AWS credentials file , you can use a text\neditor, the AWS SDK for .NET, or the AWS CLI to create the appropriate credential file. To retrieve credentials directly from  environment variables , set the following\nenvironment variables by using  bash  or a similar shell: To authenticate by using  ECS container credentials , set the URI of your ECS\nendpoint in an environment variable by using  bash  or a similar shell.\nSelect the  Full ECS URI  or  Relative ECS URI  tab to\nsee the syntax for specifying the corresponding environment variable: To authenticate by using  EC2 container credentials , make sure none of the\nenvironment variables mentioned earlier are set. The driver obtains the\ncredentials from the default IPv4 EC2 instance metadata endpoint. Specify  MONGODB-AWS  as the authentication mechanism Specify that the authentication source is external to MongoDB Set your credentials in the appropriate location Web identity provider Shared AWS credentials file Environment variables ECS container credentials EC2 container credentials Omit the line containing  AWS_SESSION_TOKEN  if you don't need an AWS\nsession token for that role. The  X.509  authentication mechanism uses  TLS \nwith  X.509  certificates to authenticate your user, identified by the\ndistinguished names of your client certificate. When you specify the\n X.509  authentication mechanism, the server authenticates the connection using\nthe subject name of the client certificate. To learn more about using TLS/SSL, see our  TLS/SSL guide . To learn more about  X.509  certificates, see the  X.509 Server Manual Entry . Select the  Connection String  or  MongoCredential  tab to\nsee the corresponding syntax for specifying the  X.509  authentication mechanism: Your certificate must be a  PKCS #12  type certificate\nwith a  .p12  extension. The username parameter provided to  CreateMongoX509Credential  must\nmatch the distinguished subject name of your  X.509  certificate exactly.\nYou can alternatively pass  null  as the parameter to prompt the MongoDB\nserver to infer the username based on your  X.509  certificate. To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: MongoCredential() MongoClient() MongoClientSettings CreateCredential() CreateMongoX509Credential()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>:<port>/?authSource=<authenticationDb>\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateCredential(\"<authenticationDb>\", \"<username>\", \"<password>\");\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=SCRAM-SHA-256\");"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=SCRAM-SHA-1\");"
                },
                {
                    "lang": "csharp",
                    "value": "var connectionString = \"mongodb+srv://<awsKeyId>:<awsSecretKey>@<hostname>[:<port>]?authSource=$external&authMechanism=MONGODB-AWS\";\nvar mongoClientSettings = MongoClientSettings.FromConnectionString(connectionString);\nvar client = new MongoClient(mongoClientSettings);"
                },
                {
                    "lang": "csharp",
                    "value": "var connectionString = \"mongodb+srv://<awsKeyId>:<awsSecretKey>@<hostname>[:<port>]?authSource=$external&authMechanism=MONGODB-AWS&authMechanismProperties=AWS_SESSION_TOKEN:<awsSessionToken>\";"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClientSettings = MongoClientSettings.FromConnectionString(\"mongodb+srv://<hostname>[:<port>]\");\nmongoClientSettings.Credential = new MongoCredential(\"MONGODB-AWS\", new MongoExternalIdentity(\"<awsKeyId>\"), new PasswordEvidence(\"<awsSecretKey>\"));\nvar client = new MongoClient(mongoClientSettings);"
                },
                {
                    "lang": "csharp",
                    "value": "mongoClientSettings.Credential = new MongoCredential(\"MONGODB-AWS\", new MongoExternalIdentity(\"<awsKeyId>\"), new PasswordEvidence(\"<awsSecretKey>\"))\n    .WithMechanismProperty(\"AWS_SESSION_TOKEN\", \"<awsSessionToken>\");"
                },
                {
                    "lang": "bash",
                    "value": "export AWS_WEB_IDENTITY_TOKEN_FILE=<absolute path to file containing your OIDC token>"
                },
                {
                    "lang": "bash",
                    "value": "export AWS_ACCESS_KEY_ID=<awsKeyId>\nexport AWS_SECRET_ACCESS_KEY=<awsSecretKey>\nexport AWS_SESSION_TOKEN=<awsSessionToken>"
                },
                {
                    "lang": "csharp",
                    "value": "var connectionString = \"mongodb+srv://<hostname>[:<port>]?authMechanism=MONGODB-AWS&authSource=$external\";\nvar mongoClientSettings = MongoClientSettings.FromConnectionString(connectionString);\nvar client = new MongoClient(mongoClientSettings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClientSettings = MongoClientSettings.FromConnectionString(\"mongodb+srv://<hostname>[:<port>]\");\nmongoClientSettings.Credential = new MongoCredential(\"MONGODB-AWS\", new MongoExternalAwsIdentity(), new ExternalEvidence());\nvar client = new MongoClient(mongoClientSettings);"
                },
                {
                    "lang": "bash",
                    "value": "export AWS_CONTAINER_CREDENTIALS_FULL_URI=<full ECS endpoint>"
                },
                {
                    "lang": "bash",
                    "value": "export AWS_CONTAINER_CREDENTIALS_RELATIVE_URI=<relative ECS endpoint>"
                },
                {
                    "lang": "csharp",
                    "value": "var connectionString = \"mongodb://<hostname>/?authMechanism=MONGODB-X509\";\nvar settings = MongoClientSettings.FromConnectionString(connectionString);\n\nsettings.useTls = true;\nsettings.SslSettings = new SslSettings\n{\n   ClientCertificates = new List<X509Certificate>()\n   {\n       new X509Certificate2(\"<path to X.509 certificate>\", \"<X.509 certificate password>\")\n   }\n};"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateMongoX509Credential(\"<X.509 certificate username>\")\nvar settings = new MongoClientSettings\n{\n    Credential =  credential\n    SslSettings = new SslSettings\n    {\n        ClientCertificates = new List<X509Certificate>()\n        {\n            new X509Certificate2(\"<path to X.509 certificate>\", \"<X.509 certificate password>\")\n        },\n    },\n    UseTls = true,\n    Server = new MongoServerAddress(\"<hostname\", \"<port>\"),\n};"
                }
            ],
            "preview": "In this guide, you can learn how to authenticate with MongoDB using the\nauthentication mechanisms available in the MongoDB Community Edition.\nAuthentication mechanisms are processes by which the driver and server confirm\nthe identity of a client to ensure security before connecting.",
            "tags": ".NET, community, security",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/serialization",
            "title": "Serialization",
            "headings": [
                "Overview",
                "Serializers",
                "Serializer Registry",
                "Custom Serializers",
                "Opt-in Interfaces",
                "IBsonIdProvider",
                "IBsonDocumentSerializer",
                "IBsonArraySerializer",
                "Additional Information"
            ],
            "paragraphs": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to perform\nserialization. Serialization is the process of mapping a C# object to a BSON\ndocument for storage in MongoDB. To learn more about serialization, see the  Serialization \narticle on Wikipedia. Serializers are classes that handle the translation of C# objects to and\nfrom BSON documents. Serializers implement the  IBsonSerializer \ninterface. The .NET/C# Driver has many built-in serializers made to handle\nprimitive types, collection types, and custom classes. For a full list of available serializers, see the\n Serializers namespace API documentation . The serializer registry contains all registered serializers that are available\nto your application. Many of the built-in serializers are automatically\nregistered to the serializer registry during startup of your application.\nHowever, before you can use a custom serializer, you must add it to the\nserializer registry, as shown in the following example: To access the serializer registry, use the  SerializerRegistry  property\nof the  BsonSerializer  class as follows: The serializer registry is a global registry. This means that you cannot use\nmultiple registries in a single application. In some cases, you might need to create a custom serializer. When creating a\ncustom serializer, implement the  SerializerBase<T>  abstract base class and\noverride the  Deserialize()  and  Serialize()  methods. The following code example shows a custom  BsonRegularExpression  serializer: The .NET/C# Driver has several optional interfaces that your custom serializer\nclass can implement, depending on the type of data the serializer handles. The  IBsonIdProvider \ninterface provides the  GetDocumentId()  and  SetDocumentId() \nmethods, and is useful if the object you are serializing uses an  _id  type other than  ObjectId . Implementing the  IBsonDocumentSerializer \ninterface enables the driver to access the member\ninformation of the object you are serializing. This allows the driver to\nproperly construct type-safe queries when using a custom serializer. Implementing the  IBsonArraySerializer \ninterface enables the driver to access serialization information for individual\nitems in an array. To learn more about using the .NET/C# Driver to serialize C# objects,\nsee the following pages: To learn more about any of the methods or types discussed in this\nguide, see the following API documentation: Class Mapping POCOs Polymorphic Objects GUIDs SerializerRegistry BsonSerializer IBsonSerializer SerializerBase<T>",
            "code": [
                {
                    "lang": "csharp",
                    "value": "BsonSerializer.RegisterSerializer(new CustomTypeSerializer());"
                },
                {
                    "lang": "csharp",
                    "value": "var intSerializer = BsonSerializer.SerializerRegistry.GetSerializer<int>();"
                },
                {
                    "lang": "csharp",
                    "value": "class CustomRegularExpressionSerializer : SerializerBase<RegularExpression>\n{\n    public override RegularExpression Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args)\n  {\n      var type = context.Reader.GetCurrentBsonType();\n      switch (type)\n      {\n          case BsonType.RegularExpression:\n              return context.Reader.ReadRegularExpression().AsRegex;\n          case BsonType.String:\n              var pattern = context.Reader.ReadString();\n              return new Regex(pattern);\n          default:\n              throw new NotSupportedException($\"Cannot convert a {type} to a RegularExpression.\");\n      }\n  }\n\n  public override void Serialize(BsonSerializationContext context, BsonSerializationArgs args, RegularExpression value)\n  {\n      context.Writer.WriteRegularExpression(value);\n  }\n}"
                }
            ],
            "preview": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to perform\nserialization. Serialization is the process of mapping a C# object to a BSON\ndocument for storage in MongoDB.",
            "tags": "class, map, poco, polymorphism, guid, deserialize",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/linq",
            "title": "LINQ",
            "headings": [
                "Overview",
                "Make A Collection Queryable",
                "Supported Aggregation Stages",
                "$project",
                "$match",
                "$limit",
                "$skip",
                "$unwind",
                "$group",
                "$sort",
                "$lookup",
                "Unsupported Aggregation Stages",
                "Supported Methods"
            ],
            "paragraphs": "In this guide you can learn how to use\n LINQ \nwith the MongoDB .NET/C# Driver. LINQ allows you to construct queries against\nstrongly typed collections of objects by using language keywords and operators.\nThe .NET/C# Driver automatically translates LINQ queries into\n aggregation operations . The examples in this guide use the  restaurants  collection\nin the  sample_restaurants  database provided in the  Atlas sample datasets .\nTo learn how to create a free MongoDB Atlas cluster and load the sample datasets,\nsee the  Quick Start . The following  Restaurant ,  Address  and  GradeEntry  classes model the\ndocuments in this collection: The documents in the  restaurants  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Restaurant  class. To learn more about custom serialization, see  Custom Serialization . To use LINQ to query your collection, you must first create an\nan  IQueryable \nobject that links to the collection. To create the object, use the  AsQueryable()  method\nas follows: The  AsQueryable()  method returns an  IMongoQueryable  instance that\nhas the  IQueryable  extension methods, along with a set of\nMongoDB specific methods. Once you have the queryable object, you can compose a query using\n method syntax . Some pipeline stages also support  query comprehension syntax ,\nwhich resembles SQL query syntax. Select the  Method Syntax  or  Query Syntax  tab to see\nhow to compose a query using LINQ: You can print the results of the preceding example as follows: You can also access the results of your query by using the  ToList()  or\n ToCursor()  methods: You can use LINQ to create an  aggregation pipeline .\nThe .NET/C# Driver automatically translates each LINQ statement into the corresponding\naggregation pipeline stages. In this section you can learn which\naggregation pipeline stages are supported. To learn more about the aggregation pipeline stages, see the\n Aggregation Stages  page in the server manual. The  $project  aggregation stage returns a document containing only the specified\nfields. Select the  Method Syntax  or  Query Syntax  tab to see how\nto generate a  $project  stage using LINQ: The result of the preceding example contains the following document: If you don't include the  _id  field in your LINQ projection, the .NET/C# Driver\nautomatically excludes it from the results. The  $match  aggregation stage returns the documents that match a specified\ncriteria. Select the  Method Syntax  or  Query Syntax  tab to see how\nto generate a  $match  stage using LINQ: The result of the preceding example contains the following document: The  $limit  aggregation stage limits the number of documents returned by the\nquery. The following example shows how to generate a  $limit  stage using LINQ: The result of the preceding example contains the following documents: The  $skip  aggregation stage skips over a specified number of documents returned\nby a query, then returns the rest of the results. The following example shows how to generate\na  $skip  stage using LINQ: The preceding example skips the first two restaurants that match the criteria, and\nreturns the rest. The result contains the following documents: The  $unwind  aggregation stage deconstructs a specified array field and returns\na document for each element in that array. Select the  Method Syntax  or  Query Syntax  tab to see how\nto generate an  $unwind  stage using LINQ: The query in the preceding example finds the document where the  Name  field\nhas the value \"The Movable Feast.\" Then, for each element in this document's\n Grades  array, the query returns a new document. The result contains the\nfollowing documents: The  $group  aggregation stage separates documents into groups according to\nthe criteria you specify. Select the  Method Syntax  or  Query Syntax  tab to see how\nto generate an  $group  stage using LINQ: The preceding example groups each document by the value in its  Cuisine  field,\nthen counts how many documents have each  Cuisine  value. The result contains\nthe following documents: The preceding queries don't always return results in the same order. Running\nthis example may return the results in a different order than shown above. The  $sort  aggregation stage returns the results of your query in the order\nthat you specify. Select the  Method Syntax  or  Query Syntax  tab to see how\nto generate an  $sort  stage using LINQ: The preceding example returns the query results sorted alphabetically by the\n Name  field, with a secondary descending sort on the  RestaurantId  field.\nThe following is a subset of the documents contained in the returned results: The  $lookup  aggregation stage joins documents from one collection to documents\nfrom another collection in the same database. The  $lookup  stage adds a new\narray field to each input document. The new array field contains the matching\ndocuments from the \"joined\" collection. Consider a second collection in the  sample_restaurants  database called\n reviews  that has restaurant reviews. You can join documents from that collection\nto documents with the same  name  value in the  restaurants  collection using\nthe  $lookup  stage. The following  Review  class models the documents in the  reviews  collection: Select the  Method Syntax  or  Query Syntax  tab to see how\nto generate a  $lookup  stage using LINQ: The preceding example returns all documents from the  restaurants  collection. Each\nrestaurant document has an added field called  reviews , which contains all\nreviews for that restaurant. A review matches a restaurant if the value of the\n name  field in the review document matches the  name  field of the restaurant\ndocument. The following is a subset of the returned results: To perform a lookup, you must make both collections queryable using the\n AsQueryable  method. To learn how to make a collection queryable, see  Make A Collection Queryable . The MongoDB .NET/C# Driver implementation of LINQ does not support the following\naggregation stages: $redact $geoNear $out The following are some of the methods supported by the  MongoDB .NET/C# Driver\nimplementation of LINQ: Method Name Description Any Determines if any documents match the specified criteria Average Calculates the average of the specified fields Count Returns an  Int32  that represents the number of documents that match the specified criteria LongCount Returns an  Int64  that represents the number of documents that match the specified criteria Distinct Returns distinct documents that match the specified criteria First Returns the first matching document, and throws an exception if none are found FirstOrDefault Returns the first matching document, or  null  if none are found GroupBy Groups documents based on specified criteria GroupJoin Performs a left outer join to another collection in the same database Max Returns the document with the maximum specified value OfType Returns documents that match the specified type OrderBy ,  OrderByDescending Returns results in a specified sort order ThenBy ,  ThenByDescending Allows a secondary sort to be specified Select Selects documents based on specified criteria SelectMany Projects each element of a sequence and combines the resulting sequences into one document Single Returns the only matching document, and throws an exception if there is not exactly one document SingleOrDefault Returns a single matching document or  null  if no documents match Skip Skips over a specified number of documents and returns the rest of the results Sum Returns the sum of the values in a specified field Take Specifies the number of results to return Where Returns all documents that match your specified criteria",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Restaurant\n{\n    public ObjectId Id { get; set; }\n\n    public string Name { get; set; }\n\n    [BsonElement(\"restaurant_id\")]\n    public string RestaurantId { get; set; }\n\n    public string Cuisine { get; set; }\n\n    public Address Address { get; set; }\n\n    public string Borough { get; set; }\n\n    public List<GradeEntry> Grades { get; set; }\n\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Address\n{\n    public string Building { get; set; }\n\n    [BsonElement(\"coord\")]\n    public float[] Coordinates { get; set; }\n\n    public string Street { get; set; }\n\n    [BsonElement(\"zipcode\")]\n    public string ZipCode { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class GradeEntry\n{\n    public DateTime Date { get; set; }\n\n    public string Grade { get; set; }\n\n    public float Score { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": " var restaurantsCollection = restaurantsDatabase.GetCollection<Restaurant>(\"restaurants\");\n var queryableCollection = restaurantsCollection.AsQueryable();"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .Where(r => r.Name == \"The Movable Feast\")\n    .Select(r => new { r.Name, r.Address });"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from r in queryableCollection\n    where r.Name == \"The Movable Feast\"\n    select new { r.Name, r.Address };"
                },
                {
                    "lang": "csharp",
                    "value": "foreach (var restaurant in query)\n{\n    Console.WriteLine(restaurant.ToJson());\n}"
                },
                {
                    "lang": null,
                    "value": "{ \"name\" : \"The Movable Feast\", \"address\" : { \"building\" : \"284\", \"coord\" : [-73.982923900000003, 40.6580753], \"street\" : \"Prospect Park West\", \"zipcode\" : \"11215\" } }"
                },
                {
                    "lang": "csharp",
                    "value": "var results = query.ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var results = query.ToCursor();"
                },
                {
                    "lang": "json",
                    "value": "{ \"name\" : \"The Movable Feast\", \"address\" : { \"building\" : \"284\", \"coord\" : [-73.982923900000003, 40.6580753], \"street\" : \"Prospect Park West\", \"zipcode\" : \"11215\" } }"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .Select(r => new { r.Name, r.Address });"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from r in queryableCollection\n    select new { r.Name, r.Address };"
                },
                {
                    "lang": "json",
                    "value": "// Results Truncated\n\n{ \"_id\" : ObjectId(...), \"name\" : \"The Movable Feast\", \"restaurant_id\" : \"40361606\", \"cuisine\" : \"American\", \"address\" : {...}, \"borough\" : \"Brooklyn\", \"grades\" : [...] }"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .Where(r => r.Name == \"The Movable Feast\");"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from r in queryableCollection\n    where r.Name == \"The Movable Feast\"\n    select r;"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .Where(r => r.Cuisine == \"Italian\")\n    .Select(r => new {r.Name, r.Cuisine})\n    .Take(5);"
                },
                {
                    "lang": "json",
                    "value": "{ \"name\" : \"Philadelhia Grille Express\", \"cuisine\" : \"Italian\" }\n{ \"name\" : \"Isle Of Capri Resturant\", \"cuisine\" : \"Italian\" }\n{ \"name\" : \"Marchis Restaurant\", \"cuisine\" : \"Italian\" }\n{ \"name\" : \"Crystal Room\", \"cuisine\" : \"Italian\" }\n{ \"name\" : \"Forlinis Restaurant\", \"cuisine\" : \"Italian\" }"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .Where(r => r.Cuisine == \"Italian\")\n    .Select(r => new {r.Name, r.Cuisine})\n    .Skip(2);"
                },
                {
                    "lang": "json",
                    "value": "// Results Truncated\n\n{ \"name\" : \"Marchis Restaurant\", \"cuisine\" : \"Italian\" }\n{ \"name\" : \"Crystal Room\", \"cuisine\" : \"Italian\" }\n{ \"name\" : \"Forlinis Restaurant\", \"cuisine\" : \"Italian\" }\n..."
                },
                {
                    "lang": "json",
                    "value": "{ \"date\" : ISODate(\"2014-11-19T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 11 }\n{ \"date\" : ISODate(\"2013-11-14T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 2 }\n{ \"date\" : ISODate(\"2012-12-05T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 13 }\n{ \"date\" : ISODate(\"2012-05-17T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 11 }"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .Where(r => r.Name == \"The Movable Feast\")\n    .SelectMany(r => r.Grades);"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from r in queryableCollection\n    where r.Name == \"The Movable Feast\"\n    from grade in r.Grades\n    select grade;"
                },
                {
                    "lang": "json",
                    "value": "// Results Truncated\n\n{ \"cuisine\" : \"Caribbean\", \"count\" : 657 }\n{ \"cuisine\" : \"Caf\u00e9/Coffee/Tea\", \"count\" : 1214 }\n{ \"cuisine\" : \"Iranian\", \"count\" : 2 }\n{ \"cuisine\" : \"Nuts/Confectionary\", \"count\" : 6 }\n{ \"cuisine\" : \"Middle Eastern\", \"count\" : 168 }\n..."
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .GroupBy(r => r.Cuisine)\n    .Select(g => new { Cuisine = g.Key, Count = g.Count() });"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from r in queryableCollection\n    group r by r.Cuisine into g\n    select new {Cuisine = g.Key, Count = g.Count()};"
                },
                {
                    "lang": "json",
                    "value": "// Results Truncated\n\n...\n{ \"_id\" : ObjectId(...), \"name\" : \"Aba Turkish Restaurant\", \"restaurant_id\" : \"41548686\", \"cuisine\" : \"Turkish\", \"address\" : {...}, \"borough\" : \"Manhattan\", \"grades\" : [...] }\n{ \"_id\" : ObjectId(...), \"name\" : \"Abace Sushi\", \"restaurant_id\" : \"50006214\", \"cuisine\" : \"Japanese\", \"address\" : { ... }, \"borough\" : \"Manhattan\", \"grades\" : [...] }\n{ \"_id\" : ObjectId(...), \"name\" : \"Abacky Potluck\", \"restaurant_id\" : \"50011222\", \"cuisine\" : \"Asian\", \"address\" : { ... }, \"borough\" : \"Manhattan\", \"grades\" : [...] }\n{ \"_id\" : ObjectId(...), \"name\" : \"Abaleh\", \"restaurant_id\" : \"50009096\", \"cuisine\" : \"Mediterranean\", \"address\" : { ... }, \"borough\" : \"Manhattan\", \"grades\" : [...] }\n..."
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .OrderBy(r => r.Name)\n    .ThenByDescending(r => r.RestaurantId);"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from r in queryableCollection\n    orderby r.Name, r.RestaurantId descending\n    select r;"
                },
                {
                    "lang": "json",
                    "value": "// Results Truncated\n\n{ \"restaurant\" : {\n   \"_id\" : ObjectId(\"...\"),\n   \"name\" : \"The Movable Feast\",\n   \"restaurant_id\" : \"40361606\",\n   \"cuisine\" : \"American\",\n   \"address\" : {...},\n   \"borough\" : \"Brooklyn\",\n   \"grades\" : [...] },\n   \"reviews\" : [\n     { \"_id\" : ObjectId(...), \"restaurant_name\" : \"The Movable Feast\", \"reviewer\" : \"Lazlo Cravensworth\", \"review_text\" : \"Great restaurant! 12/10 stars!\" },\n     { \"_id\" : ObjectId(\"...\"), \"restaurant_name\" : \"The Movable Feast\", \"reviewer\" : \"Michael Scarn\", \"review_text\" : \"It really was a feast\" }\n    ]\n }"
                },
                {
                    "lang": "csharp",
                    "value": "\npublic class Review\n{\n    public ObjectId Id { get; set; }\n\n    [BsonElement(\"restaurant_name\")]\n    public string RestaurantName { get; set; }\n\n    public string Reviewer { get; set; }\n\n    [BsonElement(\"review_text\")]\n    public string ReviewText { get; set; }\n}\n"
                },
                {
                    "lang": "csharp",
                    "value": "var query = queryableCollection\n    .GroupJoin(reviewCollection,\n        restaurant => restaurant.Name,\n        review => review.RestaurantName,\n        (restaurant, reviews) =>\n            new { Restaurant = restaurant, Reviews = reviews }\n    );"
                },
                {
                    "lang": "csharp",
                    "value": "var query = from restaurant in queryableCollection\n    join rv in reviewCollection on restaurant.Name equals rv.RestaurantName into reviews\n    select new { restaurant, reviews };"
                }
            ],
            "preview": "In this guide you can learn how to use\nLINQ\nwith the MongoDB .NET/C# Driver. LINQ allows you to construct queries against\nstrongly typed collections of objects by using language keywords and operators.\nThe .NET/C# Driver automatically translates LINQ queries into\naggregation operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations",
            "title": "Read Operations",
            "headings": [],
            "paragraphs": "Retrieve Data Specify a Query Count Documents",
            "code": [],
            "preview": "Learn about the commands for running MongoDB read operations by using the MongoDB .NET/C# Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/enterprise-authentication",
            "title": "Enterprise Authentication Mechanisms",
            "headings": [
                "Overview",
                "Authenticate with GSSAPI/Kerberos",
                "Additional Properties",
                "Fully Qualified Domain Name",
                "Realm",
                "Service name",
                "Multiple properties",
                "Authenticate with LDAP (PLAIN)",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to authenticate with MongoDB using the\n authentication mechanisms  available only in the MongoDB Enterprise Edition.\nAuthentication mechanisms are processes by which the driver and server confirm\nthe identity of a client to ensure security before connecting. You can use the following authentication mechanisms with the latest version of\nMongoDB Enterprise Edition. To authenticate using another mechanism, see the\n Authentication Mechanisms  fundamentals page. For\nmore information on establishing a connection to your MongoDB cluster, see the\n Connection Guide . You can specify your authentication mechanism and credentials when connecting to\nMongoDB using either of the following methods: GSSAPI/Kerberos LDAP (Plain) A  connection string , also known as a  connection URI , which is a string\nthat tells the driver how to connect to a MongoDB deployment and how to behave while\nconnected. A factory method for the supported authentication mechanism, contained in the\n MongoCredential  class. The Generic Security Services API (GSSAPI) authentication mechanism allows the\nuser to authenticate to a Kerberos service using the user's principal name. The following examples specify the authentication mechanism using the following\nplaceholders: Select the  Connection String  or  MongoCredential  tab to\nsee the corresponding syntax for specifying the GSSAPI/Kerberos authentication\nmechanism: <username> : Your  URL-encoded  principal name; for example \"username%40REALM.ME\" <password> : Your Kerberos user's password <hostname> : The network address of your MongoDB server, accessible by your client You can omit the password if one of the following are true: On Windows, the process owner running the application is the same as the\nuser needing authentication. On Linux, the user has initialized their keytab via  kinit username@REALM.COM . You can specify additional properties with your authentication\nmechanism using the connection string or a factory method in the  MongoCredential \nclass. The following example shows how to use the DNS server to retrieve the fully\nqualified domain name of the host: The following example shows how to specify the user's realm when it is different\nfrom the service's realm: The following example shows how to specify the service name when it is not the\ndefault  mongodb : The following example shows how to specify multiple authentication mechanism\nproperties: You can authenticate to a Lightweight Directory Access Protocol (LDAP) server\nusing your directory-server username and password. The following examples specify the authentication mechanism using the following\nplaceholders: Select the  Connection String  or  MongoCredential  tab to\nsee the corresponding syntax for specifying the LDAP authentication\nmechanism: <username> : Your LDAP username <password> : Your LDAP password <hostname> : The network address of your MongoDB server, accessible by your\nclient <authenticationDb> : The MongoDB database that contains your user's\nauthentication The method refers to PLAIN instead of LDAP since it\nauthenticates using the PLAIN Simple Authentication and Security Layer\n(SASL) defined in  RFC-4616 . To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: MongoCredential() MongoClient() MongoClientSettings CreateGssapiCredential() CreatePlainCredential()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>/?authMechanism=GSSAPI\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateGssapiCredential(\"<username>\", \"<password>\");\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>/?authMechanism=GSSAPI&authMechanismProperties=CANONICALIZE_HOSTNAME:true\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateGssapiCredential(\"<username>\", \"<password>\");\ncredential = credential.WithMechanismProperty(\"CANONICALIZE_HOST_NAME\", \"true\");\n\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>/?authMechanism=GSSAPI&authMechanismProperties=SERVICE_REALM:<user's realm>\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateGssapiCredential(\"<username>\", \"<password>\");\ncredential = credential.WithMechanismProperty(\"SERVICE_REALM\", \"<user's realm>\");\n\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>/?authMechanism=GSSAPI&authMechanismProperties=SERVICE_NAME:<service name>\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateGssapiCredential(\"<username>\", \"<password>\");\ncredential = credential.WithMechanismProperty(\"SERVICE_NAME\", \"<service name>\");\n\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>/?authMechanism=GSSAPI&authMechanismProperties=SERVICE_NAME:<service name>,SERVICE_REALM:<user's realm>\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreateGssapiCredential(\"<username>\", \"<password>\");\ncredential = credential.WithMechanismProperty(\"SERVICE_REALM\", \"<user's realm>\")\n    .WithMechanismProperty(\"SERVICE_NAME\", \"<service name>\");\n\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>/?authSource=<authenticationDb>&authMechanism=PLAIN\");"
                },
                {
                    "lang": "csharp",
                    "value": "var credential = MongoCredential.CreatePlainCredential(\"<authenticationDb>\", \"<username>\", \"<password>\");\nvar settings = MongoClientSettings.FromConnectionString(\"<connection string>\");\nsettings.Credential = credential;\nvar mongoClient = new MongoClient(settings);"
                }
            ],
            "preview": "In this guide, you can learn how to authenticate with MongoDB using the\nauthentication mechanisms available only in the MongoDB Enterprise Edition.\nAuthentication mechanisms are processes by which the driver and server confirm\nthe identity of a client to ensure security before connecting.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations",
            "title": "Write Operations",
            "headings": [],
            "paragraphs": "Modify Documents Delete Documents Insert Documents",
            "code": [],
            "preview": "Learn about the commands for running MongoDB write operations by using the MongoDB .NET/C# Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/encrypt-fields",
            "title": "In-Use Encryption",
            "headings": [
                "Overview",
                "Queryable Encryption",
                "Client-side Field Level Encryption"
            ],
            "paragraphs": "You can use the .NET/C# Driver to encrypt specific document fields by using a\nset of features called  in-use encryption . In-use encryption allows\nyour application to encrypt data  before  sending it to MongoDB\nand query documents with encrypted fields. In-use encryption prevents unauthorized users from viewing plaintext\ndata as it is sent to MongoDB or while it is in an encrypted database. To\nenable in-use encryption in an application and authorize it to decrypt\ndata, you must create encryption keys that only your application can\naccess. Only applications that have access to your encryption\nkeys can access the decrypted, plaintext data. If an attacker gains\naccess to the database, they can only see the encrypted ciphertext data\nbecause they lack access to the encryption keys. You might use in-use encryption to encrypt fields in your MongoDB\ndocuments that contain the following types of sensitive data: MongoDB offers the following features to enable in-use encryption: Credit card numbers Addresses Health information Financial information Any other sensitive or personally identifiable information (PII) Queryable Encryption Client-side Field Level Encryption Queryable Encryption is the next-generation in-use encryption feature,\nfirst introduced as a preview feature in MongoDB Server version 6.0 and\nas a generally available (GA) feature in MongoDB 7.0. Queryable\nEncryption supports searching encrypted fields for equality and encrypts\neach value uniquely. To learn more about Queryable Encryption, see  Queryable\nEncryption  in the Server manual. The implementation of Queryable Encryption in MongoDB 6.0 is incompatible with the GA version introduced in MongoDB 7.0. The Queryable Encryption preview feature is no longer supported. Client-side Field Level Encryption (CSFLE) was introduced in MongoDB\nServer version 4.2 and supports searching encrypted fields for equality.\nCSFLE differs from Queryable Encryption in that you can select either a\ndeterministic or random encryption algorithm to encrypt fields. You can only\nquery encrypted fields that use a deterministic encryption algorithm when\nusing CSFLE. When you use a random encryption algorithm to encrypt\nfields in CSFLE, they can be decrypted, but you cannot perform equality\nqueries on those fields. When you use Queryable Encryption, you cannot\nspecify the encryption algorithm, but you can query all encrypted\nfields. When you deterministically encrypt a value, the same input value\nproduces the same output value. While deterministic encryption allows\nyou to perform queries on those encrypted fields, encrypted data with\nlow cardinality is susceptible to code breaking by frequency analysis. To learn more about CSFLE, see  CSFLE  in the\nServer manual. To learn more about these concepts, see the following Wikipedia\nentries: Cardinality Frequency Analysis",
            "code": [],
            "preview": "You can use the .NET/C# Driver to encrypt specific document fields by using a\nset of features called in-use encryption. In-use encryption allows\nyour application to encrypt data before sending it to MongoDB\nand query documents with encrypted fields.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/count",
            "title": "Count Documents",
            "headings": [
                "Overview",
                "Sample Data",
                "Accurate Count",
                "Example",
                "Modify Behavior",
                "Estimated Count",
                "Modify Behavior",
                "Example",
                "Aggregation",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to get an  accurate  and  estimated  count of\nthe number of documents in your collection. The examples in this guide use the following documents in a collection called\n students : The following  Student  class models the documents in this\ncollection: The documents in the  students  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Student  class. To learn more about custom serialization, see\n Custom Serialization . To count the number of documents that match your  query filter , use the\n CountDocuments()  method. If you pass an empty query filter, this method\nreturns the total number of documents in the collection. The following example counts the number of documents where the\nvalue of  finalGrade  is less than  80 : You can modify the behavior of  CountDocuments()  by passing a  CountOptions  type as\na parameter. If you don't specify any options, the driver uses default values. You can set the following properties in a  CountOptions  object: Property Description Collation Hint Limit MaxTime Skip When you use  CountDocuments()  to return the total number of documents in a\ncollection, MongoDB performs a collection scan. You can avoid a collection scan and\nimprove the performance of this method by using a hint to take advantage of the built-in index on\nthe  _id  field. Use this technique only when calling  CountDocuments() \nwith an empty query parameter. To estimate the total number of documents in your collection, use the\n EstimatedDocumentCount()  method. The  EstimatedDocumentCount()  method is more efficient than the\n CountDocuments()  method because it uses the collection's\nmetadata rather than scanning the entire collection. You can modify the behavior of  EstimatedDocumentCount()  by passing a\n EstimatedDocumentCountOptions  type as a parameter. If you don't\nspecify any options, the driver uses default values. You can set the following properties in a  EstimatedDocumentCountOptions  object: Property Description MaxTime The following example estimates the number of documents in the\n students  collection: You can use the  Count()  builder method to count the number\nof documents in an aggregation pipeline. The following example performs the following actions: Specifies a match stage to find documents with a  FinalGrade  value\ngreater than  80 Counts the number of documents that match the criteria To learn more about the operations mentioned, see the following\nguides: Specify a Query BSON Operations GUIDs Operations with Builders POCOs To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: CountDocuments() CountOptions EstimatedDocumentCount() EstimatedDocumentCountOptions",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"name\": \"Jonathon Howard \", \"finalGrade\": 87.5 }\n{ \"_id\": 2, \"name\": \"Keisha Freeman\", \"finalGrade\": 12.3 }\n{ \"_id\": 3, \"name\": \"Wei Zhang\", \"finalGrade\": 99.0 }\n{ \"_id\": 4, \"name\": \"Juan Gonzalez\", \"finalGrade\": 85.5 }\n{ \"_id\": 5, \"name\": \"Erik Trout\", \"finalGrade\": 72.3 }\n{ \"_id\": 6, \"name\": \"Demarcus Smith\", \"finalGrade\": 88.8 }"
                },
                {
                    "lang": "csharp",
                    "value": "public class Student {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public double FinalGrade { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Student>.Filter.Lt(s => s.FinalGrade, 80.0);\nvar count = _myColl.CountDocuments(filter);\nConsole.WriteLine(\"Number of documents with a final grade less than 80: \" + count);"
                },
                {
                    "lang": "none",
                    "value": "Number of documents with a final grade less than 80: 2"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Student>.Filter.Empty;\nCountOptions opts = new CountOptions(){Hint = \"_id_\"};\nvar count = collection.CountDocuments(filter, opts);"
                },
                {
                    "lang": "csharp",
                    "value": "var count = _myColl.EstimatedDocumentCount();\nConsole.WriteLine(\"Estimated number of documents in the students collection: \" + count);"
                },
                {
                    "lang": "none",
                    "value": "Estimated number of documents in the students collection: 6"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Student>\n  .Filter.Gt(s => s.FinalGrade, 80);\nvar result = _myColl.Aggregate().Match(filter).Count();\nConsole.WriteLine(\"Number of documents with a final grade more than 80: \" + result.First().Count);"
                },
                {
                    "lang": "none",
                    "value": "Number of documents with a final grade more than 80: 2"
                }
            ],
            "preview": "In this guide, you can learn how to get an accurate and estimated count of\nthe number of documents in your collection.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/specify-query",
            "title": "Specify a Query",
            "headings": [
                "Overview",
                "Literal Values",
                "Comparison Operators",
                "Logical Operators",
                "Array Operators",
                "Element Operators",
                "Evaluation Operators",
                "Additional Information"
            ],
            "paragraphs": "In this guide, you can learn how to specify a query using the MongoDB .NET/C# Driver. You can narrow the set of matched documents returned by your query by creating a\n query filter . A query filter is an expression that specifies the documents you\nwant to match in a read, update, or delete operation. The examples in this guide use the following documents in a collection called\n guitars : The following  Guitar  class models the documents in this collection. To learn more about class mapping, see  Class Mapping . The following code instantiates the  _guitarsCollection  object using the\n Guitar  class as a type parameter. This type parameter causes the driver to\nautomatically serialize and deserialize the documents it sends to and receives\nfrom MongoDB to instances of the  Guitar  class: This guide shows how to specify queries using query filters. You can also\nspecify queries using LINQ. To learn more about using LINQ, see\n LINQ . The documents in the  guitars  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Guitar  class. To learn more about custom serialization, see  Custom Serialization . Literal value queries return documents with an exact match to your query filter. The following example specifies a query filter as a parameter to the  Find() \nmethod. The query matches all documents where the\n make  field equals \"Fender\". The following example uses builders to create a query filter that matches the\nsame documents as the preceding example: To learn more about using builders, see  Operations with Builders . Use an empty query filter to match all documents in the collection. Create\nan empty query filter with builders as follows: Comparison operators analyze the value in a document against the specified value\nin your query filter. Common comparison operators include: For a full list of comparison operators, see the  Comparison\nQuery Operators  page. The following example specifies a query filter as a parameter to the  Find() \nmethod. The query matches all documents where the  establishedYear  field is\ngreater than  1985 . The following example uses builders to create a query filter that matches the\nsame documents as the preceding example: To learn more about using builders, see  Operations with Builders . Operator Builder Description > Gt() Greater than <= Lte() Less than or equal to != Ne() Not equal to Logical operators match documents using logic applied to the results of two or more\nsets of expressions. The following is a list of some logical operators: For a full list of logical operators, see the  Logical\nQuery Operators  page. The following example specifies a query filter as a parameter to the  Find() \nmethod. The query matches all documents where the\n establishedYear  field is greater than or equal to  1985 , and the  make \nfield is not equal to \"Kiesel\". The following example uses builders to create a query filter that matches the\nsame documents as the preceding example: To learn more about using builders, see  Operations with Builders . Operator Builder Description && And() All expressions must evaluate to true. || Or() At least one expression must evaluate to true. Array operators match documents based on the value or quantity of elements in an array\nfield. The following is a list of builder methods that use array operators: For more information on the array operators, see the  Array\nQuery Operators  page. The following example uses builders to create a query filter that matches all\ndocuments that have 3 elements in the  models  field: To learn more about using builders, see  Operations with Builders . Operator Description All() Matches documents if the array field contains all elements specified in\nthe query. Any() Matches documents if any element in the array field matches the specified\nquery filter. Size() Matches documents if the array field is a specified size. The  Any()  builder uses the  $elemMatch  query operator. To learn more about the  $elemMatch  query selector, see\n $elemMatch . Element operators query data based on the presence or type of a field. For a full list of element operators, see the  Element\nQuery Operators  page. The following example uses builders to create a query filter that matches all\ndocuments that have a  rating  field: To learn more about using builders, see  Operations with Builders . Evaluation operators analyze data on individual fields, or on the entire collection's\ndocuments. Some builder methods that use evaluation operators include  Regex() \nand  Text() . For a full list of evaluation operators, see the  Evaluation\nQuery Operators  page. The following example uses builders to create a query filter that matches all\ndocuments that have a value in the  make  field that starts with the letter\n\"G\": To learn more about using builders, see  Operations with Builders . For more information about the operators mentioned in this guide, see the\nfollowing Server Manual Entries: To learn more about using Builders, see  Operations with Builders . To learn how to specify queries using LINQ, see  LINQ . Comparison Query Operators Logical Query Operators Array Query Operators Element Query Operators Evaluation Query Operators",
            "code": [
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"make\": \"Fender\", \"models\": [\"Stratocaster\", \"Telecaster\"], \"establishedYear\": 1946, \"rating\": 9 }\n{ \"_id\": 2, \"make\": \"Gibson\", \"models\": [\"Les Paul\", \"SG\", \"Explorer\"], \"establishedYear\": 1902, \"rating\": 8 }\n{ \"_id\": 3, \"make\": \"PRS\", \"models\": [\"Silver Sky\", \"SE\", \"Custom\"], \"establishedYear\": 1985, \"rating\": 9 }\n{ \"_id\": 4, \"make\": \"Kiesel\", \"models\": [\"Ares\", \"Vader\", \"Solo\"], \"establishedYear\": 2015 }\n{ \"_id\": 5, \"make\": \"Ibanez\", \"models\": [\"RG\", \"AZ\"], \"establishedYear\": 1957, \"rating\": 7 }\n{ \"_id\": 6, \"make\": \"Strandberg\", \"models\": [\"Boden\", \"Salen\"], \"establishedYear\": 1982 }"
                },
                {
                    "lang": "csharp",
                    "value": "private static IMongoCollection<Guitar> _guitarsCollection;"
                },
                {
                    "lang": "csharp",
                    "value": "public class Guitar\n{\n    public int Id { get; set; }\n\n    public string Make { get; set; }\n\n    public List<string> Models { get; set; }\n\n    public int EstablishedYear { get; set; }\n\n    public int? Rating { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var results = _guitarsCollection.Find(g => g.Make == \"Fender\").ToList();\n\nforeach (var doc in results)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"models\" : [\"Stratocaster\", \"Telecaster\"], \"establishedYear\" : 1946, \"rating\" : 9 }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Guitar>.Filter.Eq(g => g.Make, \"Fender\");\nvar result = _guitarsCollection.Find(filter).ToList();\n\nforeach (var doc in result)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"models\" : [\"Stratocaster\", \"Telecaster\"], \"establishedYear\" : 1946, \"rating\" : 9 }"
                },
                {
                    "lang": "csharp",
                    "value": "var result = _guitarsCollection.Find(Builders<Guitar>.Filter.Empty).ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var results = _guitarsCollection.Find(g => g.EstablishedYear > 1985).ToList();\n\nforeach (var doc in results)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 4, \"make\" : \"Kiesel\", \"models\" : [\"Ares\", \"Vader\", \"Solo\"], \"establishedYear\" : 2015, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Guitar>.Filter.Gt(g => g.EstablishedYear, 1985);\nvar result = _guitarsCollection.Find(filter).ToList();\n\nforeach (var doc in result)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 4, \"make\" : \"Kiesel\", \"models\" : [\"Ares\", \"Vader\", \"Solo\"], \"establishedYear\" : 2015, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var results = _guitarsCollection.Find(g => g.EstablishedYear >= 1985 && r.Make != \"Kiesel\").ToList();\n\nforeach (var doc in results)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 3, \"make\" : \"PRS\", \"models\" : [\"Silver Sky\", \"SE\", \"Custom\"], \"establishedYear\" : 1985, \"rating\" : 9 }"
                },
                {
                    "lang": "csharp",
                    "value": "var builder = Builders<Guitar>.Filter;\nvar filter = builder.And(builder.Gte(g => g.EstablishedYear, 1985), builder.Ne(r => r.Make, \"Kiesel\"));\nvar result = _guitarsCollection.Find(filter).ToList();\n\nforeach (var doc in result)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 3, \"make\" : \"PRS\", \"models\" : [\"Silver Sky\", \"SE\", \"Custom\"], \"establishedYear\" : 1985, \"rating\" : 9 }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Guitar>.Filter.Size(g => g.Models, 3);\nvar result = _guitarsCollection.Find(filter).ToList();\n\nforeach (var doc in result)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 2, \"make\" : \"Gibson\", \"models\" : [\"Les Paul\", \"SG\", \"Explorer\"], \"establishedYear\" : 1902, \"rating\" : 8 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"models\" : [\"Silver Sky\", \"SE\", \"Custom\"], \"establishedYear\" : 1985, \"rating\" : 9 }\n{ \"_id\" : 4, \"make\" : \"Kiesel\", \"models\" : [\"Ares\", \"Vader\", \"Solo\"], \"establishedYear\" : 2015, \"rating\" : null }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Guitar>.Filter.Exists(g => g.Rating);\nvar result = _guitarsCollection.Find(filter).ToList();\n\nforeach (var doc in result)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"make\" : \"Fender\", \"models\" : [\"Stratocaster\", \"Telecaster\"], \"establishedYear\" : 1946, \"rating\" : 9 }\n{ \"_id\" : 2, \"make\" : \"Gibson\", \"models\" : [\"Les Paul\", \"SG\", \"Explorer\"], \"establishedYear\" : 1902, \"rating\" : 8 }\n{ \"_id\" : 3, \"make\" : \"PRS\", \"models\" : [\"Silver Sky\", \"SE\", \"Custom\"], \"establishedYear\" : 1985, \"rating\" : 9 }\n{ \"_id\" : 5, \"make\" : \"Ibanez\", \"models\" : [\"RG\", \"AZ\"], \"establishedYear\" : 1957, \"rating\" : 7 }"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Guitar>.Filter.Regex(g => g.Make, \"^G\");\nvar result = _guitarsCollection.Find(filter).ToList();\n\nforeach (var doc in result)\n{\n    Console.WriteLine(doc.ToBsonDocument());\n}"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 2, \"make\" : \"Gibson\", \"models\" : [\"Les Paul\", \"SG\", \"Explorer\"], \"establishedYear\" : 1902, \"rating\" : 8 }"
                }
            ],
            "preview": "In this guide, you can learn how to specify a query using the MongoDB .NET/C# Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/delete",
            "title": "Delete Documents",
            "headings": [
                "Overview",
                "Sample Data",
                "Delete Operations",
                "Delete One Document",
                "Delete Multiple Documents",
                "Parameters",
                "Example",
                "Return Value",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to remove documents from your MongoDB\ncollections using delete operations. The examples in this guide use the  restaurants  collection\nfrom the  sample_restaurants  database. The documents in this\ncollection use the following  Restaurant ,  Address , and  GradeEntry \nclasses as models: This collection is from the  sample datasets  provided\nby Atlas. See the  Quick Start  to learn how to create a free MongoDB cluster\nand load this sample data. The documents in the  restaurants  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Restaurant  class. To learn more about custom serialization, see  Custom Serialization . Use delete operations to remove documents that match a  query filter .\nThe query filter determines which records are selected for deletion\nbased on the criteria in  the query filter\ndocument . You can perform\ndelete operations in MongoDB with the following methods: DeleteOne() , which deletes  the first document  that matches the query filter DeleteMany() , which deletes  all documents  that match the query filter The following code shows how to use the asynchronous\n DeleteOneAsync()  method or the synchronous  DeleteOne()  method to\ndelete one document. The following code shows how to use the asynchronous\n DeleteManyAsync()  method or the synchronous  DeleteMany()  method to\ndelete all matched documents. Find runnable examples using these methods under  additional\ninformation . The  DeleteOne()  and  DeleteMany()  methods require you to pass a\nquery filter specifying which documents to match. More information\non how to construct a query filter is available in  the Query Documents\ntutorial . Both methods optionally take a  DeleteOptions  type as an additional parameter,\nwhich represents options you can use to configure the delete operation.\nIf you don't specify any  DeleteOptions  properties, the driver does\nnot customize the delete operation. The  DeleteOptions  type allows you to configure options with the\nfollowing properties: Property Description Collation Comment Hint Let The following code uses the  DeleteMany()  method to search on the\n\"borough_1\" index and delete all documents where the  address.street \nfield value includes the phrase \"Pearl Street\": If the preceding example used the  DeleteOne()  method instead of\n DeleteMany() , the driver would delete the first of the 26\nmatched documents. The  DeleteOne()  and  DeleteMany()  methods return a\n DeleteResult  type. This type contains the  DeletedCount  property,\nwhich indicates the number of documents deleted, and the\n IsAcknowledged  property, which indicates if the result is\nacknowledged. If the query filter does not match any documents, no documents\nare deleted and  DeletedCount  is 0. For runnable examples of the delete operations, see the following usage\nexamples: Delete a Document Delete Many Documents To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: DeleteOne() DeleteOneAsync() DeleteMany() DeleteManyAsync() DeleteOptions DeleteResult",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Restaurant\n{\n    public ObjectId Id { get; set; }\n\n    public string Name { get; set; }\n\n    [BsonElement(\"restaurant_id\")]\n    public string RestaurantId { get; set; }\n\n    public string Cuisine { get; set; }\n\n    public Address Address { get; set; }\n\n    public string Borough { get; set; }\n\n    public List<GradeEntry> Grades { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Address\n{\n    public string Building { get; set; }\n\n    [BsonElement(\"coord\")]\n    public double[] Coordinates { get; set; }\n\n    public string Street { get; set; }\n\n    [BsonElement(\"zipcode\")]\n    public string ZipCode { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class GradeEntry\n{\n    public DateTime Date { get; set; }\n\n    public string Grade { get; set; }\n\n    public float? Score { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var result = await _restaurantsCollection.DeleteOneAsync(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = _restaurantsCollection.DeleteOne(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = await _restaurantsCollection.DeleteManyAsync(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = _restaurantsCollection.DeleteMany(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Regex(\"address.street\", \"Pearl Street\");\n\nDeleteOptions opts = new DeleteOptions { Hint = \"borough_1\" };\n\nConsole.WriteLine(\"Deleting documents...\");\nvar result = _restaurantsCollection.DeleteMany(filter, opts);\n\nConsole.WriteLine($\"Deleted documents: {result.DeletedCount}\");\nConsole.WriteLine($\"Result acknowledged? {result.IsAcknowledged}\");"
                },
                {
                    "lang": "none",
                    "value": "Deleting documents...\nDeleted documents: 26\nResult acknowledged? True"
                }
            ],
            "preview": "In this guide, you can learn how to remove documents from your MongoDB\ncollections using delete operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/tls",
            "title": "Enable TLS on a Connection",
            "headings": [
                "Overview",
                "Enable TLS",
                "Configure a Client Certificate",
                "Allow Insecure TLS",
                "Check Certificate Revocation",
                "Revocation Checking by Operating System",
                "Windows",
                "macOS",
                "Linux",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to connect to MongoDB instances with the\n TLS/SSL \nsecurity protocol using the underlying TLS/SSL support in the .NET framework. To\nconfigure your connection to use TLS/SSL, enable the TLS/SSL settings in either\nthe  connection string  or\n MongoClientSettings . You can enable TLS for the connection to your MongoDB instance\nin two different ways: using a property on a  MongoClientSettings  object or\nthrough a parameter in your connection string. To enable TLS with a  MongoClientSettings  object, set the  UseTls  property\nto  true : To enable TLS with a connection string, assign the\nparameter  tls  a value of  true  in the connection string passed to the\n MongoClient  constructor: You can configure your X.509 certificate using  MongoClientSettings . The following\ncode sample creates a new X.509 certificate object using the certificate file named\n client.p12 , which is protected by the password  mySuperSecretPassword . The code\nthen adds this certificate to the  SslSettings.ClientCertificates  array in\n MongoClientSettings . When loading a certificate with a password, the certificate object must contain a private\nkey. If it doesn't, your certificate will not be passed to the server. When TLS is enabled, the .NET/C# Driver automatically verifies the certificate that\nthe server presents. When testing your code, you can disable certificate verification.\nThis is known as  insecure TLS. When using insecure TLS, the only requirement is that the server present an X.509\ncertificate. The driver will accept a certificate even if any of the following are true: You can allow insecure TLS in two different ways: using a property on a\n MongoClientSettings  object or through a parameter in your connection string. The hostname of the server and the subject name (or subject alternative name)\non the certificate don't match. The certificate is expired or not yet valid. The certificate doesn't have a trusted root certificate in the chain. The certificate purpose isn't valid for server identification. To allow insecure TLS with a  MongoClientSettings \nobject, set the  AllowInsecureTls  property to  true : To allow insecure TLS using a connection string,\nassign the connection string parameter  tlsInsecure  a value of  true : Always set this option to  false  in production. For security reasons, it's\nimportant that the server certificate is properly validated. When an X.509 certificate should no longer be trusted--for example, if its private key\nhas been compromised--the certificate authority will revoke the certificate. By default, the .NET/C# Driver doesn't check whether a server's certificate has been\nrevoked before it connects. You can enable revocation checking using either\n MongoClientSettings  or the connection string. To enable revocation checking using  MongoClientSettings , set\n SslSettings.CheckCertificateRevocation  to  true : To enable revocation checking using a connection string,\nassign the connection string parameter  tlsDisableCertificateRevocationCheck \na value of  false : The .NET/C# Driver doesn't check revocation by default because this is the default\nbehavior of the  SslStream  class in both the\n .NET framework \nand the  .NET standard. The .NET/C# Driver supports the following revocation-checking mechanisms differently on\nWindows, macOS, and Linux: Online Certificate Status Protocol (OCSP) ,\na common mechanism for checking revocation OCSP stapling , a mechanism in which the server\nincludes a time-stamped OCSP response to the client along with the certificate Certificate revocation lists (CRLs), ,\nan alternative to OCSP On Windows, the .NET/C# Driver supports OCSP, OCSP stapling, and CRLs without OCSP,\nin both the .NET Framework and .NET Core. On Windows, the .NET/C# Driver will report a \"hard fail\" and cancel the TLS\nhandshake if the OCSP responder is unavailable. Other operating systems and drivers\nwill report a \"soft fail\" and continue connecting. On macOS, the .NET/C# Driver supports OCSP and OCSP stapling. Beginning with .NET Core 2.0, the driver does  not  support CRLs without OCSP. On Linux, the .NET/C# Driver supports OCSP, OCSP stapling, and CRLs without OCSP. To learn more about any of the connection options discussed in this\nguide, see the following API documentation: MongoClientSettings",
            "code": [
                {
                    "lang": "csharp",
                    "value": "var settings = new MongoClientSettings { UseTls = true };\nvar client = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>:<port>?tls=true\");"
                },
                {
                    "lang": "csharp",
                    "value": "var cert = new X509Certificate2(\"client.p12\", \"mySuperSecretPassword\");\n\nvar settings = new MongoClientSettings\n{\n   SslSettings = new SslSettings\n   {\n      ClientCertificates = new[] { cert }\n   },\n   UseTls = true\n};"
                },
                {
                    "lang": "csharp",
                    "value": "var settings = new MongoClientSettings\n{\n   UseTls = true,\n   AllowInsecureTls = true\n};\nvar client = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>:<port>?tls=true&tlsInsecure=true\");"
                },
                {
                    "lang": "csharp",
                    "value": "var settings = new MongoClientSettings\n{\n   SslSettings = new SslSettings\n   {\n      CheckCertificateRevocation = true\n   },\n   UseTls = true\n};"
                },
                {
                    "lang": "csharp",
                    "value": "var mongoClient = new MongoClient(\"mongodb://<username>:<password>@<hostname>:<port>?tls=true&tlsDisableCertificateRevocationCheck=false\");"
                }
            ],
            "preview": "In this guide, you can learn how to connect to MongoDB instances with the\nTLS/SSL\nsecurity protocol using the underlying TLS/SSL support in the .NET framework. To\nconfigure your connection to use TLS/SSL, enable the TLS/SSL settings in either\nthe connection string or\nMongoClientSettings.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/retrieve",
            "title": "Retrieve Data",
            "headings": [
                "Overview",
                "Sample Data",
                "Find Documents",
                "Find One Document",
                "Find Multiple Documents",
                "Modify Find Behavior",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to retrieve\ndata from a MongoDB collection by using read operations. You can call the\n Find()  method to retrieve documents that match a set of criteria. This page includes a short interactive lab that demonstrates how to\nretrieve data by using the  Find()  method. You can complete this lab\ndirectly in your browser window without installing MongoDB or a code editor. To start the lab, click the  Open Interactive Tutorial  button at the\ntop of the page. To expand the lab to a full-screen format, click the\nfull-screen button ( \u26f6 ) in the top-right corner of the lab pane. The examples in this guide use the  sample_restaurants.restaurants  collection\nfrom the  Atlas sample datasets . To learn how to create a\nfree MongoDB Atlas cluster and load the sample datasets, see the  Quick Start . The examples on this page use the following  Restaurant ,  Address , and  GradeEntry \nclasses as models: The documents in the  restaurants  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Restaurant  class. To learn more about custom serialization, see  Custom Serialization . Use the  Find()  method to retrieve documents from a collection.\nThe  Find()  method takes a  query filter  and returns all matching documents.\nA query filter is an object that specifies the documents you want to retrieve in\nyour query. To learn more about query filters, see  Specify a Query . To find a single document in a collection, pass a query filter that specifies the\ncriteria of the document you want to find, then chain the  FirstOrDefault()  or\n FirstOrDefaultAsync()  method. If more than one document matches the query\nfilter, these methods return the  first  matching document from the retrieved\nresults. If no documents match the query filter the methods return  null . To see a full example of using the  Find()  method to find a single document, see\n Additional Information . The  FirstOrDefault()  method returns the first document in\n natural order \non disk if no sort criteria is specified. To find multiple documents in a collection, pass a query filter to the  Find() \nmethod that specifies the criteria of the documents you want to retrieve. You can use a  cursor  to iterate over the documents returned by the  Find() \nmethod. A cursor is a mechanism that allows an application to iterate over database\nresults while holding only a subset of them in memory at a given time. Cursors\nare useful when your  Find()  method returns a large amount of documents. To use a cursor to iterate over the documents, pass a\nquery filter to the  Find()  method that specifies the criteria of the documents\nyou want to find, then chain the  ToCursor()  or  ToCursorAsync()  method.\nTo view a synchronous or asynchronous example, select the corresponding tab. If you are returning a small number of documents, or need your results returned\nas a  List  object, use the  ToList()  or  ToListAsync()  methods. To find multiple documents in a collection and hold them in memory as a list, pass a query filter\nto the  Find()  method that specifies the criteria of the documents you want\nto find, then chain the  ToList()  or  ToListAsync()  method. To view a\nsynchronous or asynchronous example, select the corresponding tab. To see a full example of using the  Find()  method to find multiple documents,\nsee  Additional Information . To find all documents in a collection, pass an empty filter\nto the  Find()  method. To see a fully runnable example of using the  Find()  method to find all documents, see\n Additional Information . You can modify the behavior of the  Find()  method by passing\na  FindOptions  object. You can configure the commonly used options with the following methods: To see a full list of available options, see\n FindOptions Properties . Method Description BatchSize Collation Comment Hint MaxTime This example performs the following actions: Finds all documents with \"Pizza\" in the  cuisine  field Sets the  BatchSize  to  3 Stores the results in a cursor Prints the documents referenced by the cursor Create a cursor with a  using statement  to\nautomatically invoke the\n Dispose() \nmethod once the cursor is no longer in use. To learn more about query filters, see  Specify a Query . To learn how to specify queries using LINQ, see  LINQ . To view runnable examples of the  Find()  method, see the\n Find a Document  page. To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Find() FirstOrDefault() FirstOrDefaultAsync() FindOptions ToList() ToListAsync() ToCursor() ToCursorAsync()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Restaurant\n{\n    public ObjectId Id { get; set; }\n\n    public string Name { get; set; }\n\n    [BsonElement(\"restaurant_id\")]\n    public string RestaurantId { get; set; }\n\n    public string Cuisine { get; set; }\n\n    public Address Address { get; set; }\n\n    public string Borough { get; set; }\n\n    public List<GradeEntry> Grades { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Address\n{\n    public string Building { get; set; }\n\n    [BsonElement(\"coord\")]\n    public double[] Coordinates { get; set; }\n\n    public string Street { get; set; }\n\n    [BsonElement(\"zipcode\")]\n    public string ZipCode { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class GradeEntry\n{\n    public DateTime Date { get; set; }\n\n    public string Grade { get; set; }\n\n    public float? Score { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurants = await _restaurantsCollection.Find(filter).FirstOrDefaultAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurants = _restaurantsCollection.Find(filter).FirstOrDefault();"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurants = await _restaurantsCollection.Find(filter).ToCursorAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurants = _restaurantsCollection.Find(filter).ToCursor();"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurants = await _restaurantsCollection.Find(filter).ToListAsync();"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurants = _restaurantsCollection.Find(filter).ToList();"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Empty;\nvar allRestaurants = _restaurantsCollection.Find(filter);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Eq(\"cuisine\", \"Pizza\");\nvar findOptions = new FindOptions { BatchSize = 3 };\n\nusing (var cursor = _restaurantsCollection.Find(filter, findOptions).ToCursor())\n{\n   foreach (var r in cursor.ToEnumerable())\n   {\n      WriteLine(r.Name);\n   }\n}"
                },
                {
                    "lang": null,
                    "value": "Pizza Town\nVictoria Pizza\n..."
                }
            ],
            "preview": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to retrieve\ndata from a MongoDB collection by using read operations. You can call the\nFind() method to retrieve documents that match a set of criteria.",
            "tags": "code examples, read, search, cursor",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/insert",
            "title": "Insert Documents",
            "headings": [
                "Overview",
                "Sample Data",
                "The _id Field",
                "Insert One Document",
                "Insert Multiple Documents",
                "Modify Insert Behavior",
                "Example",
                "Specify Ordered Behavior",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to add\ndocuments to a MongoDB collection by performing insert operations. An insert operation inserts one or more documents into a MongoDB collection.\nThe .NET/C# Driver provides the following methods to perform insert\noperations, each of which has an asynchronous and synchronous version: InsertOneAsync()  or  InsertOne() InsertManyAsync()  or  InsertMany() This page includes a short interactive lab that demonstrates how to\ninsert data by using the  InsertOneAsync()  method. You can complete this\nlab directly in your browser window without installing MongoDB or a code editor. To start the lab, click the  Open Interactive Tutorial  button at the\ntop of the page. To expand the lab to a full-screen format, click the\nfull-screen button ( \u26f6 ) in the top-right corner of the lab pane. The examples in this guide use the  restaurants  collection\nfrom the  sample_restaurants  database. The documents in this\ncollection use the following  Restaurant ,  Address , and  GradeEntry \nclasses as models: This collection is from the  sample datasets  provided\nby Atlas. See the  Quick Start  to learn how to create a free MongoDB cluster\nand load this sample data. The documents in the  restaurants  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Restaurant  class. To learn more about custom serialization, see  Custom Serialization . In a MongoDB collection, each document  must  contain an  _id  field\nwith a unique field value. MongoDB allows you to manage this field in two ways: Unless you can guarantee uniqueness, MongoDB recommends\nyou let the driver automatically generate  _id  values. To learn more about the  _id  field, see the Server Manual Entry on\n Unique Indexes . To learn more about document structure and rules, see the\nServer Manual Entry on  Documents . You can set this field for each document yourself, ensuring each\n _id  field value is unique. You can let the driver automatically generate unique  ObjectId \nvalues for each document  _id . If you do not manually set an\n _id  field value for a document, the driver will populate the field\nwith an  ObjectId . Duplicate  _id  values violate unique index constraints, which\ncauses the driver to return a  MongoWriteException  from\n InsertOne()  or a  MongoBulkWriteException  from\n InsertMany() . The following code shows how to use the asynchronous\n InsertOneAsync()  method or the synchronous  InsertOne()  method to\ninsert one document. The following code shows how to use the asynchronous\n InsertManyAsync()  method or the synchronous  InsertMany()  method to\ninsert multiple documents. Find runnable examples using these methods under  additional\ninformation . The  InsertOne()  method takes the document you seek to insert as a\nparameter. The  InsertMany()  method takes an  IEnumerable \ncollection of documents, such as a list or array, as a parameter. The  InsertOne()  method optionally takes a  InsertOneOptions  type as an additional parameter,\nwhich represents options you can use to configure the insert operation.\nIf you don't specify any  InsertOneOptions  properties, the driver does\nnot customize the insert. The  InsertOneOptions  type allows you to configure options with the\nfollowing properties: The  InsertMany()  method optionally takes a  InsertManyOptions \ntype as an additional parameter, which has the preceding\n BypassDocumentValidation  and  Comment  properties and the\nadditional  IsOrdered  property: Property Description BypassDocumentValidation Comment Property Description IsOrdered The following code uses the  InsertMany()  method to insert four new\n Restaurant  documents into a collection with\n BypassDocumentValidation  set to  true : The  InsertMany()  method has no return value. You can verify that\nyour documents were successfully inserted by executing a  Find() \noperation on the collection. For an example on how to find a document,\nsee  Find a Document . Assume you want to insert the following documents: If you attempt to insert these documents with default\n InsertManyOptions , the driver throws a  MongoBulkWriteException  at the third\ndocument because of the repeated  _id  value, but the documents before\nthe error-producing document are still inserted into your collection. If you look inside your collection, you should be able to see the following documents: If you set  IsOrdered  to  false  in your insert operation, the driver will\ncontinue to insert your documents even if some documents produce errors.\nWith this modified insert behavior, the driver throws an exception but inserts all documents\nthat do not produce errors. If you look inside your collection, you should be able to see the following documents: For runnable examples of the insert operations, see the following usage\nexamples: Insert a Document Insert Multiple Documents To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: InsertOne() InsertOneAsync() InsertMany() InsertManyAsync() InsertOneOptions InsertManyOptions",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Restaurant\n{\n    public ObjectId Id { get; set; }\n\n    public string Name { get; set; }\n\n    [BsonElement(\"restaurant_id\")]\n    public string RestaurantId { get; set; }\n\n    public string Cuisine { get; set; }\n\n    public Address Address { get; set; }\n\n    public string Borough { get; set; }\n\n    public List<GradeEntry> Grades { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Address\n{\n    public string Building { get; set; }\n\n    [BsonElement(\"coord\")]\n    public double[] Coordinates { get; set; }\n\n    public string Street { get; set; }\n\n    [BsonElement(\"zipcode\")]\n    public string ZipCode { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class GradeEntry\n{\n    public DateTime Date { get; set; }\n\n    public string Grade { get; set; }\n\n    public float? Score { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "await _restaurantsCollection.InsertOneAsync(document);"
                },
                {
                    "lang": "csharp",
                    "value": "_restaurantsCollection.InsertOne(document);"
                },
                {
                    "lang": "csharp",
                    "value": "await _restaurantsCollection.InsertManyAsync(docs);"
                },
                {
                    "lang": "csharp",
                    "value": "_restaurantsCollection.InsertMany(docs);"
                },
                {
                    "lang": "csharp",
                    "value": "var restaurantsList = new List<Restaurant>()\n{\n    new() { Name = \"\u00c9t\u00e9 Bleu\", Cuisine = \"French\" },\n    new() { Name = \"Lucky Bird\", Cuisine = \"Caf\u00e9/Coffee/Tea\" },\n    new() { Name = \"Wildflower Caf\u00e9\", Cuisine = \"Vegetarian\" },\n    new() { Name = \"Blue Moon Grill\", Cuisine = \"American\" },\n};\n\nvar options = new InsertManyOptions() { BypassDocumentValidation = true };\n\nConsole.WriteLine(\"Inserting documents...\");\n_restaurantsCollection.InsertMany(restaurantsList, options);"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"name\" : \"Restaurant A\" }\n{ \"_id\" : 2, \"name\" : \"Restaurant B\" }\n{ \"_id\" : 1, \"name\" : \"Restaurant C\" }\n{ \"_id\" : 3, \"name\" : \"Restaurant D\" }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"name\" : \"Restaurant A\" }\n{ \"_id\" : 2, \"name\" : \"Restaurant B\" }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\" : 1, \"name\" : \"Restaurant A\" }\n{ \"_id\" : 2, \"name\" : \"Restaurant B\" }\n{ \"_id\" : 3, \"name\" : \"Restaurant D\" }"
                }
            ],
            "preview": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to add\ndocuments to a MongoDB collection by performing insert operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/connect",
            "title": "Connection Guide",
            "headings": [
                "Connection URI",
                "MongoClientSettings",
                "Other Connection Targets",
                "Connect to Atlas",
                "Connect to a Replica Set"
            ],
            "paragraphs": "This guide shows you how to connect to a MongoDB instance or replica set\ndeployment using the .NET/C# Driver. A  connection URI , also known as a  connection string , tells the driver how to connect to a MongoDB deployment and how to behave while connected. A standard connection string includes the following pieces: To use a connection URI, pass it as a string to the  MongoClient  constructor. In the\nfollowing example, the driver uses a sample connection URI to connect to a MongoDB\ninstance on port  27017  of  localhost : See  the MongoDB Manual  for more information about creating a connection string. Piece Description mongodb:// Required. A prefix that identifies this as a string in the\nstandard connection format. username:password@ Optional. Authentication credentials. If you include these, the client will authenticate the user against the database specified in  authSource . host[:port] Required. The host and optional port number where MongoDB is running. If you don't include the port number, the driver will use the default port,  27017 . /defaultauthdb Optional. The authentication database to use if the\nconnection string includes  username:password@ \nauthentication credentials but not the  authSource  option. If you don't include\nthis piece, the client will authenticate the user against the  admin  database. ?<options> Optional. A query string that specifies connection-specific\noptions as  <name>=<value>  pairs. See\n Connection Options  for a full description of\nthese options. Because each  MongoClient  represents a pool of connections to the\ndatabase, most applications require only a single instance of\n MongoClient , even across multiple requests. To learn more about\nhow connection pools work in the driver, see the  FAQ page . You can use a  MongoClientSettings  object to configure the connection in code\nrather than in a connection URI. To use a  MongoClientSettings  object, create an\ninstance of the class and pass it as an argument to the  MongoClient  constructor. In the following example, the driver uses a  MongoClientSettings  object to connect to a\nMongoDB instance on port  27017  of  localhost : To connect to a MongoDB deployment on Atlas, create a client. You can\ncreate a client that uses your connection string and other\nclient options by passing a  MongoClientSettings  object to the  MongoClient \nconstructor. To specify your connection URI, pass it to the  FromConnectionString() \nmethod, which returns a new  MongoClientSettings  instance. To specify any other\nclient options, set the relevant fields of the  MongoClientSettings  object. You can set the Stable API version as a client option to avoid\nbreaking changes when you upgrade to a new server version. To\nlearn more about the Stable API feature, see the  Stable API page . The following code shows how you can specify the connection string and\nthe Stable API client option when connecting to a MongoDB\ndeployment and verify that the connection is successful: Follow the  Atlas driver connection guide \nto retrieve your connection string. To connect to a replica set deployment, specify the hostnames (or IP addresses) and\nport numbers of the members of the replica set. If you aren't able to provide a full list of hosts in the replica set, you can\nspecify one or more of the hosts in the replica set and instruct the driver to\nperform automatic discovery in one of the following ways: In the following example, the driver uses a sample connection URI to connect to the\nMongoDB replica set  sampleRS , which is running on port  27017  of three different\nhosts, including  sample.host1 : Specify the name of the replica set as the value of the  replicaSet  parameter. Specify  false  as the value of the  directConnection  parameter. Specify more than one host in the replica set.",
            "code": [
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\n\n// Connection URI\nconst string connectionUri = \"mongodb://localhost:27017\";\n\n// Create a new client and connect to the server\nvar client = new MongoClient(connectionUri);"
                },
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\n\n// Create a MongoClientSettings object\nvar settings = new MongoClientSettings()\n{\n    Scheme = ConnectionStringScheme.MongoDB,\n    Server = new MongoServerAddress(\"localhost\", 27017)\n};\n\n// Create a new client and connect to the server\nvar client = new MongoClient(settings);"
                },
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\nusing MongoDB.Bson;\n\n// Replace the placeholder with your Atlas connection string\nconst string connectionUri = \"<connection string>\";\n\nvar settings = MongoClientSettings.FromConnectionString(connectionUri);\n\n// Set the ServerApi field of the settings object to Stable API version 1\nsettings.ServerApi = new ServerApi(ServerApiVersion.V1);\n\n// Create a new client and connect to the server\nvar client = new MongoClient(settings);\n\n// Send a ping to confirm a successful connection\ntry {\n    var result = client.GetDatabase(\"admin\").RunCommand<BsonDocument>(new BsonDocument(\"ping\", 1));\n    Console.WriteLine(\"Pinged your deployment. You successfully connected to MongoDB!\");\n} catch (Exception ex) { Console.WriteLine(ex);}\n"
                },
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\n\n// Connection URI\nconst string connectionUri = \"mongodb://sample.host1:27017/?replicaSet=sampleRS\";\n\n// Create a new client and connect to the server\nvar client = new MongoClient(connectionUri);"
                }
            ],
            "preview": "This guide shows you how to connect to a MongoDB instance or replica set\ndeployment using the .NET/C# Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/network-compression",
            "title": "Network Compression",
            "headings": [
                "Specify Compression Algorithms"
            ],
            "paragraphs": "You can enable a driver option to compress messages, which reduces the amount\nof data passed over the network between MongoDB and your application. The .NET/C# Driver supports the following compression algorithms: If you specify multiple compression algorithms, the driver selects the\nfirst one in the list supported by your MongoDB instance. Snappy : available in MongoDB 3.6 and later. Zlib : available in MongoDB 3.6 and later. Zstandard : available in MongoDB 4.2 and later. To enable compression for the connection to your MongoDB instance,\nspecify the algorithms you want to use in one of the following ways: Add the algorithms to your connection string as a parameter Specify the algorithms in the  Compressors  property of your  MongoClientSettings \nobject To enable compression by using the connection string, add the\n compressors  parameter to the connection string. You can\nspecify one or more compression algorithms, separating them with\ncommas: To enable compression by using\n MongoClientSettings ,\nset the  Compressors  property of your  MongoClientSettings  object to a\n List  of one or more  CompressorConfiguration  objects. Each\n CompressorConfiguration  object in the  List  represents an algorithm you\nwant to use:",
            "code": [
                {
                    "lang": "csharp",
                    "value": "const string connectionUri =\n  \"mongodb+srv://<user>:<password>@<cluster-url>/?compressors=snappy,zlib,zstd\";\n\nvar client = new MongoClient(connectionUri);"
                },
                {
                    "lang": "csharp",
                    "value": "var settings = new MongoClientSettings()\n{\n   Scheme = ConnectionStringScheme.MongoDB,\n   Server = new MongoServerAddress(\"<cluster-url>\"),\n   Compressors = new List<CompressorConfiguration>()\n   {\n      new CompressorConfiguration(CompressorType.Snappy),\n      new CompressorConfiguration(CompressorType.Zlib),\n      new CompressorConfiguration(CompressorType.Zstandard)\n   }\n};\n\nvar client = new MongoClient(settings);"
                }
            ],
            "preview": "You can enable a driver option to compress messages, which reduces the amount\nof data passed over the network between MongoDB and your application.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/modify",
            "title": "Modify Documents",
            "headings": [
                "Overview",
                "Sample Data",
                "Update Operations",
                "Required Parameters",
                "Update One Document",
                "Update Many Documents",
                "Customize the Update Operation",
                "Return Value",
                "Example",
                "Replace Operation",
                "Required Parameters",
                "Customize the Replace Operation",
                "Return Value",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to modify\ndocuments in a MongoDB collection by performing the following operations: The .NET/C# Driver provides the following methods to modify documents,\neach of which has an asynchronous and synchronous version: Update Operations Replace Operations UpdateOneAsync()  or  UpdateOne() UpdateManyAsync()  or  UpdateMany() ReplaceOneAsync()  or  ReplaceOne() This page includes a short interactive lab that demonstrates how to\nmodify data by using the  UpdateManyAsync()  method. You can complete this\nlab directly in your browser window without installing MongoDB or a code editor. To start the lab, click the  Open Interactive Tutorial  button at the\ntop of the page. To expand the lab to a full-screen format, click the\nfull-screen button ( \u26f6 ) in the top-right corner of the lab pane. The examples in this guide use the  restaurants  collection\nfrom the  sample_restaurants  database. The documents in this\ncollection use the following  Restaurant ,  Address , and  GradeEntry \nclasses as models: This collection is from the  sample datasets  provided\nby Atlas. See the  Quick Start  to learn how to create a free MongoDB cluster\nand load this sample data. The documents in the  restaurants  collection use the camel-case naming\nconvention. The examples in this guide use a  ConventionPack \nto deserialize the fields in the collection into Pascal case and map them to\nthe properties in the  Restaurant  class. To learn more about custom serialization, see  Custom Serialization . You can perform update operations in MongoDB with the following methods: UpdateOne() , which updates  the first document  that matches the search criteria UpdateMany() , which updates  all documents  that match the search criteria Each update method requires the following parameters: The .NET/C# Driver provides a  Builders  class that simplifies the creation of both\nquery filters and update documents. The following code sample uses  Builders  to create\ntwo documents for use as parameters in an update operation: A  query filter  document, which determines which records to update. See the\n MongoDB server manual  for\nmore information about query filters. An  update  document, which specifies the  update operator  (the kind of update to\nperform) and the fields and values that should change. See the\n Field Update Operators Manual page  for a complete\nlist of update operators and their usage. A query filter that searches for restaurants with a  borough  field value of \"Manhattan\" An update document that sets the value of the  borough  field of these restaurants\nto \"Manhattan (north)\" If you are using MongoDB Version 4.2 or later, you can use aggregation\npipelines made up of a subset of aggregation stages in update operations. For\nmore information on the aggregation stages MongoDB supports in\naggregation pipelines used in update operations, see our tutorial on building\n updates with aggregation pipelines . The following code shows how to use the asynchronous  UpdateOneAsync()  method\nor the synchronous  UpdateOne()  method to update one document. The following code shows how to use the asynchronous\n UpdateManyAsync()  method or the synchronous  UpdateMany()  method to\nupdate all matched documents. Find runnable examples that use these methods under  Additional\nInformation . Both methods optionally accept an  UpdateOptions  object as an additional parameter,\nwhich represents options you can use to configure the update operation.\nIf you don't specify any  UpdateOptions  properties, the driver does\nnot customize the update operation. The  UpdateOptions  type allows you to configure options with the\nfollowing properties: Property Description ArrayFilters BypassDocumentValidation Collation Comment Hint IsUpsert Let The  UpdateOne()  and  UpdateMany()  methods each return an  UpdateResult \nobject. The  UpdateResult  type contains the following properties: Property Description IsAcknowledged IsModifiedCountAvailable MatchedCount ModifiedCount UpsertedId The following code uses the  UpdateMany()  method to find all documents where the\n borough  field has the value \"Manhattan\", then updates the  borough \nvalue in these documents to \"Manhattan (north)\". Because the  IsUpsert  option is\nset to  true , the driver inserts a new document if the query filter doesn't\nmatch any existing documents. If the preceding example used the  UpdateOne()  method instead of\n UpdateMany() , the driver would update only the first of the\nmatched documents. You can perform a replace operation in MongoDB with the  ReplaceOne()  method.\nThis method removes all fields (except the  _id  field) from the first document that\nmatches the search criteria, then inserts the fields and values you specify into the\ndocument. The  ReplaceOne()  method requires the following parameters: Like in an update operation, you can use the  Builders  class in the .NET/C# Driver\nto create a query filter.\nThe following code sample uses  Builders  to create a query filter that searches\nfor restaurants with a  name  field value of \"Pizza Town\". The code also creates a new\n Restaurant  object that will replace the first matched document. The following code shows how to use the asynchronous  ReplaceOneAsync()  method\nor the synchronous  ReplaceOne()  method to replace one document. A query filter document, which determines which record to replace. A  replacement  document, which specifies the fields and values to insert in the new\ndocument. If the documents in your collection are mapped to a C# class,\nthe replacement document can be an instance of this class. The values of  _id  fields are immutable. If your replacement document specifies\na value for the  _id  field, it must match the  _id  value of the existing document. Find runnable examples that use these methods under  Additional\nInformation . The  ReplaceOne()  method optionally accepts a  ReplaceOptions  object as an\nadditional parameter, which represents options you can use to configure the replace\noperation. If you don't specify any  ReplaceOptions  properties, the driver does\nnot customize the replace operation. The  ReplaceOptions  type allows you to configure options with the\nfollowing properties: Property Description BypassDocumentValidation Collation Comment Hint IsUpsert Let The  ReplaceOne()  method returns a  ReplaceOneResult \nobject. The  ReplaceOneResult  type contains the following properties: Property Description IsAcknowledged IsModifiedCountAvailable MatchedCount ModifiedCount UpsertedId The following code uses the  ReplaceOne()  method to find the first document where the\n name  field has the value \"Pizza Town\", then replaces this document\nwith a new  Restaurant  document named \"Food World\". Because the  IsUpsert  option is\nset to  true , the driver inserts a new document if the query filter doesn't\nmatch any existing documents. For runnable examples of the update and replace operations, see the following usage\nexamples: To learn more about creating query filters, see the  Specify a Query  guide. Update a Document Update Many Documents Replace a Document To learn more about any of the methods or types discussed in this\nguide, see the following API documentation: UpdateOne() UpdateOneAsync() UpdateMany() UpdateManyAsync() UpdateOptions UpdateResult ReplaceOne() ReplaceOneAsync() ReplaceOptions ReplaceOneResult",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Restaurant\n{\n    public ObjectId Id { get; set; }\n\n    public string Name { get; set; }\n\n    [BsonElement(\"restaurant_id\")]\n    public string RestaurantId { get; set; }\n\n    public string Cuisine { get; set; }\n\n    public Address Address { get; set; }\n\n    public string Borough { get; set; }\n\n    public List<GradeEntry> Grades { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Address\n{\n    public string Building { get; set; }\n\n    [BsonElement(\"coord\")]\n    public double[] Coordinates { get; set; }\n\n    public string Street { get; set; }\n\n    [BsonElement(\"zipcode\")]\n    public string ZipCode { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class GradeEntry\n{\n    public DateTime Date { get; set; }\n\n    public string Grade { get; set; }\n\n    public float? Score { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter\n    .Eq(restaurant => restaurant.Borough, \"Manhattan\");\n\nvar update = Builders<Restaurant>.Update\n    .Set(restaurant => restaurant.Borough, \"Manhattan (north)\");"
                },
                {
                    "lang": "csharp",
                    "value": "var result = await _restaurantsCollection.UpdateOneAsync(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = _restaurantsCollection.UpdateOne(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = await _restaurantsCollection.UpdateManyAsync(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = _restaurantsCollection.UpdateMany(filter, update);"
                },
                {
                    "lang": "csharp",
                    "value": "  var filter = Builders<Restaurant>.Filter\n      .Eq(restaurant => restaurant.Borough, \"Manhattan\");\n\n  var update = Builders<Restaurant>.Update\n      .Set(restaurant => restaurant.Borough, \"Manhattan (north)\");\n\n  UpdateOptions opts = new UpdateOptions()\n  {\n      Comment = new BsonString(\"Borough updated for C# Driver Fundamentals\"),\n      IsUpsert = true\n  };\n\n  Console.WriteLine(\"Updating documents...\");\n  var result = _restaurantsCollection.UpdateMany(filter, update, opts);\n\n  Console.WriteLine($\"Updated documents: {result.ModifiedCount}\");\n  Console.WriteLine($\"Result acknowledged? {result.IsAcknowledged}\");"
                },
                {
                    "lang": "none",
                    "value": "Updating documents...\nUpdated documents: 10259\nResult acknowledged? True"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Eq(restaurant => restaurant.Name, \"Pizza Town\");\n\nRestaurant newRestaurant = new()\n{\n    Name = \"Food World\",\n    Cuisine = \"American\",\n    Address = new BsonDocument\n    {\n        {\"street\", \"Food St\"},\n        {\"zipcode\", \"10003\"},\n    },\n    Borough = \"Manhattan\",\n};"
                },
                {
                    "lang": "csharp",
                    "value": "var result = await _restaurantsCollection.ReplaceOneAsync(filter, newRestaurant);"
                },
                {
                    "lang": "csharp",
                    "value": "var result = _restaurantsCollection.ReplaceOne(filter, newRestaurant);"
                },
                {
                    "lang": "csharp",
                    "value": "var filter = Builders<Restaurant>.Filter.Eq(restaurant => restaurant.Name, \"Pizza Town\");\n\nRestaurant newRestaurant = new()\n{\n    Name = \"Food World\",\n    Cuisine = \"American\",\n    Address = new BsonDocument\n    {\n        {\"street\", \"Food St\"},\n        {\"zipcode\", \"10003\"},\n    },\n    Borough = \"Manhattan\",\n};\n\nReplaceOptions opts = new ReplaceOptions()\n{\n    Comment = new BsonString(\"Restaurant replaced for .NET/C# Driver Fundamentals\"),\n    IsUpsert = true\n};\n\nConsole.WriteLine(\"Replacing document...\");\nvar result = _restaurantsCollection.ReplaceOne(filter, newRestaurant, opts);\n\nConsole.WriteLine($\"Replaced documents: {result.ModifiedCount}\");\nConsole.WriteLine($\"Result acknowledged? {result.IsAcknowledged}\");"
                },
                {
                    "lang": "none",
                    "value": "Replacing document...\nReplaced documents: 1\nResult acknowledged? True"
                }
            ],
            "preview": "In this guide, you can learn how to use the MongoDB .NET/C# Driver to modify\ndocuments in a MongoDB collection by performing the following operations:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/serialization/class-mapping",
            "title": "Class Mapping",
            "headings": [
                "Overview",
                "Automatic Class Mapping",
                "Manually Creating A Class Map",
                "Customize Class Serialization",
                "Ignore Extra Elements",
                "Mapping with Constructors",
                "Customize Property Serialization",
                "Support Extra Elements",
                "Dynamically Serialize Properties",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to customize the way the MongoDB .NET/C# Driver\nmaps BSON documents to and from C# classes. You should read this page\nto learn more about the default class mapping behavior, or if you need to\ncustomize the way the driver serializes or deserializes your data. When you use a class, rather than a  BsonDocument , to represent data in a\nMongoDB collection, the .NET/C# Driver automatically creates a  class map \nthat it uses to serialize or deserialize your data. It does this mapping by matching\nthe name of the field in the document to the name of the property in the class. The type of the property in your class should match the type of the field in\nthe document. The .NET/C# Driver instantiates a serializer based on the\ntype of the property in your class. If the types don't match when the driver\nattempts to deserialize the data, the serializer throws an exception. You can bypass the driver's automatic class mapping functionality, and manually\ndefine the class map by using the  RegisterClassMap()  method. The following example defines a  Person  class: The following code demonstrates how to register the class map for the  Person \nclass: You can also manually map a subset of class properties, while still\nallowing the driver to automatically map the remaining properties. To do this,\nregister a class map and call the  AutoMap()  method before manually\nspecifying your properties. In the following code example, the  AutoMap()  method maps all properties\nof the  Person  class, then manually adjusts the mapping for the  Hobbies \nfield: You must register a class map  before  it's needed in your code. We recommend\nregistering class maps prior to initializing a connection with MongoDB. You can customize how the driver serializes and deserializes documents at the class\nlevel by using attributes with the class or by calling methods while registering\na class map. When a BSON document is deserialized to a C# class, the .NET/C# Driver\nlooks at the name of each field in the document and tries to find a matching property\nname in the class. By default, if a field in the document doesn't have a match in the class,\nthe driver throws an exception. You can choose to ignore any elements that do\nnot have a matching class property by using the  BsonIgnoreExtraElements  attribute.\nThis prevents the driver from throwing an exception, and maps any other fields\nthat have matching class properties. The following example shows how to add a  BsonIgnoreExtraElements  attribute\nto a class. You can also ignore any extra elements when registering a class map: By default, the .NET/C# Driver can automatically map a class only if the class has\na constructor with no arguments. If you want the driver to use a constructor that accepts\none or more arguments, you can add the  BsonConstructor  attribute to the constructor.\nIn this case, the driver the driver examines the types to determine how to map the\nconstructor arguments to class properties or fields. When the driver creates a class map for the following  Person  class, it will use the\nconstructor marked with the  BsonConstructor  attribute. The  name  argument will\nmap to the  Name  property and the  age  argument will map to the  Age  property. You can also specify the constructor to use when registering your class map: If there is more than one constructor with the  BsonConstructor \nattribute, the driver uses the constructor that has the most\nparameters with matching fields in the document. You can customize how the driver serializes a class property by\nadding attributes to the property. For more information about custom\nproperty serialization, see  Custom Serialization . You can design your C# class to store any extra elements in your\ndocument that don't have matching class properties. To do this your class must\nhave a  BsonDocument  type property to hold the extra elements. The following code uses the  BsonExtraElements  attribute with the\n ExtraElements  property to direct the driver to store extra elements: You can also support extra elements when initializing a class map as follows: After the driver serializes a class with extra elements back to BSON, the\nextra elements may not be in the same order as they were in the original\ndocument. You can use a method to determine whether or not to serialize a property. For\nthe driver to automatically use the method when serializing, you must prefix the\nmethod name with  ShouldSerialize  followed by the name of the property that\nthe method applies to. When the driver sees a method with this naming\nconvention, it uses that method to determine whether or not to serialize\nproperties that have the provided property name. The following example creates a method that only serializes the  Age  property\nif its value is not equal to  0 . The driver does not serialize any properties\nwhose values don't meet this requirement: You can also specify the method while registering a class map: For more information on using C# classes, see  POCOs . BsonClassMap RegisterClassMap AutoMap",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public List<string> Hobbies {get; set;}\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Person>(classMap =>\n{\n    classMap.MapMember(p => p.Name);\n    classMap.MapMember(p => p.Age);\n    classMap.MapMember(p => p.Hobbies);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Person>(classMap =>\n{\n    classMap.AutoMap();\n    classMap.MapMember(p => p.Hobbies).SetElementName(\"favorite_hobbies\");\n});"
                },
                {
                    "lang": "csharp",
                    "value": "[BsonIgnoreExtraElements]\npublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public List<string> Hobbies {get; set;}\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Person>(classMap =>\n{\n     classMap.AutoMap();\n     classMap.SetIgnoreExtraElements(true);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public List<string> Hobbies {get; set;}\n\n    [BsonConstructor]\n    public Person(string name, string age)\n    {\n        Name = name;\n        Age = age;\n    }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public List<string> Hobbies {get; set;}\n\n    public Person(string name, string age)\n    {\n        Name = name;\n        Age = age;\n    }\n}\n\nBsonClassMap.RegisterClassMap<Person>(classMap =>\n{\n    classMap.AutoMap();\n    classMap.MapCreator(p => new Person(p.Name, p.Age));\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class Person\n{\n    public string Name { get; set;\n    public int Age { get; set; }\n    public List<string> Hobbies {get; set;}\n    [BsonExtraElements]\n    public BsonDocument ExtraElements {get; set;}\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Person>(classMap =>\n{\n    classMap.AutoMap();\n    classMap.MapExtraElementsMember(p => p.ExtraElements);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public List<string> Hobbies {get; set;}\n\n    public bool ShouldSerializeAge()\n    {\n       return Age != 0;\n    }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Employee>(classMap =>\n{\n    classMap.AutoMap();\n    classMap.MapMember(p => c.Age).SetShouldSerializeMethod(\n        obj => ((Person) obj).Age != 0\n    );\n});"
                }
            ],
            "preview": "In this guide, you can learn how to customize the way the MongoDB .NET/C# Driver\nmaps BSON documents to and from C# classes. You should read this page\nto learn more about the default class mapping behavior, or if you need to\ncustomize the way the driver serializes or deserializes your data.",
            "tags": ".NET, object, attribute, code example, register, configure",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/serialization/polymorphic-objects",
            "title": "Polymorphic Objects",
            "headings": [
                "Overview",
                "Deserialize Polymorphic Objects",
                "Use Discriminators",
                "ScalarDiscriminatorConvention",
                "HierarchicalDiscriminatorConvention",
                "Custom Discriminator Conventions"
            ],
            "paragraphs": "Polymorphic  objects inherit properties and methods from one or more parent classes.\nThese objects require special mapping to ensure that the .NET/C# Driver correctly\nserializes them to and from BSON documents. This guide explains the following: The examples on this page use the following inheritance hierarchy: How to deserialize polymorphic types The discriminator conventions included with the .NET/C# Driver How to create custom discriminator conventions Before the serializer can deserialize any polymorphic objects, you must document the\nrelationship of all classes in the inheritance hierarchy. If you're using the automapper to map your classes, apply the  [BsonKnownTypes] \nattribute to each base class in the hierarchy. Pass each class that directly inherits\nfrom the base class as an argument. The following example shows how to apply the  [BsonKnownTypes]  attribute to\nclasses in the example  Animal  hierarchy: If you're creating a class map manually, call the\n BsonClassMap.RegisterClassMap<T>()  method for every class in the hierarchy, as shown\nin the following example: Apply the  [BsonKnownTypes]  attribute only to parent classes. Pass as arguments\nonly the types that  directly  inherit from the class, not all child classes in\nthe hierarchy. To learn more about mapping classes, see the  Class Mapping  documentation. In MongoDB, a  discriminator  is a field added to a document to identify the class\nto which the document deserializes. When a collection contains more than one type from a\nsingle inheritance hierarchy, discriminators ensure that each\ndocument deserializes to the right class. The .NET/C# Driver stores the discriminator\nvalue in a field named  _t  in the BSON document. Generally,  _t  is the second\nfield in the BSON document after  _id . Discriminator conventions  define the value stored in the discriminator field.\nIn this section, you can learn about the discriminator conventions included\nwith the .NET/C# Driver and how to create custom discriminator conventions. By default, the .NET/C# Driver uses the  ScalarDiscriminatorConvention . According\nto this convention, the .NET/C# Driver sets the value of the  _t  field to the name of\nthe class from which the document was serialized. Suppose you create an instance of the example  Animal  class and each of its\nsubclasses. If you serialize these objects to a single collection, the\n.NET/C# Driver applies the  ScalarDiscriminatorConvention  and the corresponding\nBSON documents appear as follows: The  ScalarDiscriminatorConvention  uses concise discriminator values, but can be\ndifficult to run a query on. For example, to find all documents of type or subtype  Cat ,\nyou must explicitly list each class you're looking for: To simplify queries against your collection of polymorphic types, you can use the\n HierarchicalDiscriminatorConvention . According to this convention, the value of  _t \nis an array of all classes in the inheritance hierarchy of the document's type. To use the  HierarchicalDiscriminatorConvention , label the base class of your\ninheritance hierarchy as the root class. If you're using the automapper,\nlabel the root class by applying the\n [BsonDiscriminatorAttribute]  attribute to the class and passing  RootClass = true \nas an argument. The following code example labels the  Animal  class as the\nroot of the example inheritance hierarchy: If you're creating a class map manually, call the  SetIsRootClass()  method and pass\n true  as an argument when you register the class map for the root class. The following\ncode example registers class maps for all five example classes but labels only the\n Animal  class as the root of the inheritance hierarchy: Suppose you label the example  Animal  class as the root of the inheritance hierarchy,\nand then create an instance of the  Animal  class and each of its\nsubclasses. If you serialize these objects to a single collection, the .NET/C# Driver\napplies the  HierarchicalDiscriminatorConvention  and the corresponding\nBSON documents appear as follows: When using the  HierarchicalDiscriminatorConvention , you can search for all\ndocuments of type or subtype  Cat  by using a single boolean condition, as shown in\nthe following example: Any document mapped to the root class still uses a string value for the discriminator\nfield. If you're working with data that doesn't follow the conventions used by the\n.NET/C# Driver--for example, data inserted into MongoDB by another driver or object\nmapper--you might need to use a different value for your discriminator field to\nensure your classes align with those conventions. If you're using the automapper, you can specify a custom value for a class's discriminator\nfield by applying the  [BsonDiscriminator]  attribute to the class and passing\nthe custom discriminator value as a string argument. The following code example\nsets the value of the discriminator field for the  Animal  class to \"myAnimalClass\": If you're creating a class map manually, call the  SetDiscriminator()  method and pass\nthe custom discriminator value as an argument when\nyou register the class map. The following code example sets the value of the\ndiscriminator field for the  Animal  class to \"myAnimalClass\": An instance of the previous  Animal  class appears as follows after serialization:",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Animal\n{\n}\n\npublic class Cat : Animal\n{\n}\n\npublic class Dog : Animal\n{\n}\n\npublic class Lion : Cat\n{\n}\n\npublic class Tiger : Cat\n{\n}"
                },
                {
                    "lang": "csharp",
                    "value": "[BsonKnownTypes(typeof(Cat), typeof(Dog))]\npublic class Animal\n{\n}\n\n[BsonKnownTypes(typeof(Lion), typeof(Tiger))]\npublic class Cat : Animal\n{\n}\n\npublic class Dog : Animal\n{\n}\n\npublic class Lion : Cat\n{\n}\n\npublic class Tiger : Cat\n{\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Animal>();\nBsonClassMap.RegisterClassMap<Cat>();\nBsonClassMap.RegisterClassMap<Dog>();\nBsonClassMap.RegisterClassMap<Lion>();\nBsonClassMap.RegisterClassMap<Tiger>();"
                },
                {
                    "lang": "json",
                    "value": "{ _id: ..., _t: \"Animal\", ... }\n{ _id: ..., _t: \"Cat\", ... }\n{ _id: ..., _t: \"Dog\", ... }\n{ _id: ..., _t: \"Lion\", ... }\n{ _id: ..., _t: \"Tiger\", ... }"
                },
                {
                    "lang": "csharp",
                    "value": "var query = coll.Aggregate().Match(a => a is Cat || a is Lion || a is Tiger);"
                },
                {
                    "lang": "csharp",
                    "value": "[BsonDiscriminator(RootClass = true)]\n[BsonKnownTypes(typeof(Cat), typeof(Dog)]\npublic class Animal\n{\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Animal>(classMap => {\n    classMap.AutoMap();\n    classMap.SetIsRootClass(true);\n});\nBsonClassMap.RegisterClassMap<Cat>();\nBsonClassMap.RegisterClassMap<Dog>();\nBsonClassMap.RegisterClassMap<Lion>();\nBsonClassMap.RegisterClassMap<Tiger>();"
                },
                {
                    "lang": "javascript",
                    "value": "{ _id: ..., _t: \"Animal\", ... }\n{ _id: ..., _t: [\"Animal\", \"Cat\"], ... }\n{ _id: ..., _t: [\"Animal\", \"Dog\"], ... }\n{ _id: ..., _t: [\"Animal\", \"Cat\", \"Lion\"], ... }\n{ _id: ..., _t: [\"Animal\", \"Cat\", \"Tiger\"], ... }"
                },
                {
                    "lang": "csharp",
                    "value": "var query = coll.Aggregate().Match(a => a is Cat);"
                },
                {
                    "lang": "csharp",
                    "value": "[BsonDiscriminator(\"myAnimalClass\")]\npublic class Animal\n{\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Animal>(classMap =>\n{\n    classMap.AutoMap();\n    classMap.SetDiscriminator(\"myAnimalClass\");\n});"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": \"...\", \"_t\": \"myAnimalClass\"}"
                }
            ],
            "preview": "Polymorphic objects inherit properties and methods from one or more parent classes.\nThese objects require special mapping to ensure that the .NET/C# Driver correctly\nserializes them to and from BSON documents.",
            "tags": ".NET, object, attribute, inheritance, child, parent, hierarchy, derived, base, serialize, deserialize, root",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/serialization/guid-serialization",
            "title": "GUIDs",
            "headings": [
                "Overview",
                "GuidRepresentationMode",
                "V2",
                "V3",
                "Serializing GUIDs in V3",
                "Serializing Objects in V3",
                "Additional Information"
            ],
            "paragraphs": "In this guide, you can learn how to serialize  globally unique identifiers \n( GUIDs ),\nalso known as  universally unique identifiers  (UUIDs). A GUID is a 16-byte integer that you can use as a unique ID for a MongoDB document.\nOriginally, GUIDs in MongoDB were represented as  BsonBinaryData  values of subtype 3.\nSubtype 3 did not standardize the byte order during serialization, which led to\ninconsistent serialization across MongoDB drivers.\nTo standardize the byte order and ensure consistent serialization across drivers, we\ncreated  BsonBinaryData  subtype 4. In MongoDB applications,  ObjectId  can be used as a unique identifier for\na document. Consider using  ObjectId  in place of a GUID with MongoDB\napplications where possible. Use  BsonBinaryData  subtype 4 for all new GUIDs. In many MongoDB collections, all GUID fields use the same subtype of  BsonBinaryData .\nSome older collections, however, may contain some GUID fields that\nuse subtype 3 and others that use subtype 4.\nTo ensure that the driver serializes and deserializes all GUIDs correctly,\nyou should set the  BsonDefaults.GuidRepresentationMode  property to one of the\nfollowing  GuidRepresentationMode  values: GuidRepresentationMode.V2  assumes that all GUIDs in a document use the same\n BsonBinaryData  subtype. In this mode, GUID representation is\ncontrolled by the reader or writer, not the serializer. V2  is the default  GuidRepresentationMode . When version 3 of the .NET/C# Driver is released, support for  GuidRepresentationMode.V2 \nwill be removed from the driver and  V3  will become the default. GuidRepresentationMode.V3  allows fields in the same document to use different\nGUID formats.\nIn this mode, GUID representation is controlled at the property level by configuring the\nserializer for each property. To use  GuidRepresentationMode.V3 , run the following line of code. You should run this\ncode during the bootstrapping phase of your application, before creating\na  MongoClient  object. Running in  V3  mode changes the behavior of the driver in the following ways: The  BsonBinaryReader.ReadBinaryData()  method ignores  readerSettings.GuidRepresentation The  BsonBinaryWriter.WriteBinaryData()  method ignores  writerSettings.GuidRepresentation The  JsonReader.ReadBinaryData()  method ignores  readerSettings.GuidRepresentation JsonWriter  ignores  writerSettings.GuidRepresentation Calling the  BsonBinaryData.ToGuid()  method without the  GuidRepresentation \nparameter works only on GUIDs of subtype 4. You can't use both  GuidRepresentationMode.V2  and  GuidRepresentationMode.V3 \nin a single application. GuidRepresentationMode.V3  handles GUID serialization at the level of individual\nproperties. This mode is more flexible than  V2 , but it also means you must ensure that\neach GUID field is serialized and deserialized correctly. If you're using the .NET/C# Driver to  automap your C# classes to document schemas ,\nyou can use the  BsonGuidRepresentation  attribute on a GUID property\nto specify the representation: If you're writing your own serialization code, you can use the\n GuidSerializer  class to serialize and deserialize individual GUID values to and\nfrom BSON fields. To ensure that the driver handles GUIDs correctly, use the\n GuidRepresentation  parameter when you construct a  GuidSerializer . The following code sample creates an instance of  GuidSerializer \nfor serializing GUID representations of subtype 4: If most of your GUIDs use the same representation, you can register a  GuidSerializer \nglobally. To create and register a  GuidSerializer , run the following code early\nin your application, such as during the bootstrapping phase: GuidRepresentation.Standard  is equivalent to  BsonBinaryData  subtype 4.\nOther GUID representations in the .NET/C# Driver, such as  CSharpLegacy ,\n JavaLegacy , and  PythonLegacy , are equivalent to subtype 3 but use\ndifferent byte orders. When you're working with two subtypes, you can combine a global serializer with the\n BsonGuidRepresentation  property attribute. For example, you can register a global\nserializer for the most commonly used GUID subtype, then use the  BsonGuidRepresentation \nattribute to denote any GUID properties of another subtype. You can use an  ObjectSerializer  to serialize hierarchical objects to subdocuments.\nTo ensure that GUIDs in these objects are serialized and deserialized correctly when using\n V3 , you should select the correct GUID representation when constructing your\n ObjectSerializer . The following code sample shows how to\ncreate an  ObjectSerializer  for a GUID representation of subtype 4: If your application relies on an  ObjectSerializer  to serialize any GUIDs, you\nmust also register the serializer early in your application, such as during the\nbootstrapping phase. The serializer that you\nregister will be used globally whenever an object serializer is needed and has not\nbeen otherwise specified. To register your  ObjectSerializer , pass it to the  BsonSerializer.RegisterSerializer() \nmethod: To learn more about any of the methods or types discussed in this\nguide, see the following API documentation: BsonBinaryData GuidRepresentationMode BsonGuidRepresentation GuidSerializer ObjectSerializer",
            "code": [
                {
                    "lang": "csharp",
                    "value": "BsonDefaults.GuidRepresentationMode = GuidRepresentationMode.V3;"
                },
                {
                    "lang": "csharp",
                    "value": "public class Widget\n{\n    public int Id { get; set; }\n\n   [BsonGuidRepresentation(GuidRepresentation.Standard)]\n   public Guid G { get; set; }\n}"
                },
                {
                    "lang": null,
                    "value": "var guidSerializer = new GuidSerializer(GuidRepresentation.Standard);"
                },
                {
                    "lang": "csharp",
                    "value": "BsonSerializer.RegisterSerializer(new GuidSerializer(GuidRepresentation.Standard));"
                },
                {
                    "lang": "csharp",
                    "value": "var objectDiscriminatorConvention = BsonSerializer.LookupDiscriminatorConvention(typeof(object));\nvar objectSerializer = new ObjectSerializer(objectDiscriminatorConvention, GuidRepresentation.Standard);"
                },
                {
                    "lang": "csharp",
                    "value": "var objectDiscriminatorConvention = BsonSerializer.LookupDiscriminatorConvention(typeof(object));\nvar objectSerializer = new ObjectSerializer(objectDiscriminatorConvention, GuidRepresentation.Standard);\nBsonSerializer.RegisterSerializer(objectSerializer);"
                }
            ],
            "preview": "In this guide, you can learn how to serialize globally unique identifiers\n(GUIDs),\nalso known as universally unique identifiers (UUIDs).",
            "tags": ".NET, attribute, property, code example, class, map, bson",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/serialization/poco",
            "title": "POCOs",
            "headings": [
                "Overview",
                "Create a POCO",
                "Custom Serialization",
                "Serialize Read-Only Properties",
                "Set Field Names",
                "Select Type Representation",
                "Set Field Order",
                "Identify Id Property",
                "Omit Empty Fields",
                "Customize Default Values",
                "Specify an ID Generator",
                "Customize DateTime Serialization",
                "Customize Dictionary Serialization",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn about how you can use \" Plain Old CLR/Class\nObjects \", or  POCOs , with the .NET/C# Driver for your operations\nand queries. POCOs are simple class objects that do not inherit\nfeatures from any framework-specific base classes or interfaces. We recommend\nusing POCOs in your C# code to adhere to idiomatic driver usage and\nachieve the best performance. You should read this guide if you want to learn more about how to use\nPOCOs with the .NET/C# Driver or if you need to adjust the driver's default\nfield mapping behavior. You can create a POCO by defining a simple class that does not\nimplement interfaces or extend classes from a framework. When you\nexecute an operation such as a read or write using a POCO, the driver\ninternally  serializes , or converts, the POCO to BSON. Select the  POCO  or  BSON  tab to see how the\ndriver serializes a sample POCO to BSON: You can define a POCO with any object structure that suits your\nneeds, including nested objects, arrays, lists, and any data types. If the default field mapping behavior does not meet your needs, you can\nspecify custom behavior using serialization-related attributes. These\nattributes change the way that the driver serializes each property of\nyour POCO. This section describes some of the common\nserialization-related attributes. If a property is read-only, the automapper doesn't include it in the class map for\nserialization. To force the automapper to include a property in the class map, apply the\n [BsonElement]  attribute to the property. The following code example applies the  [BsonElement]  attribute to the  Upc  property\nof the  Clothing  class.  Upc  is a read-only property because it has a  get  method\nbut no  set  method. You can also add a read-only property when you register the class map, as shown in the\nfollowing example: When the .NET/C# Driver serializes a read-only property, the property and its value\nare stored in the database, but never deserialized again. The driver serializes POCO properties to BSON fields with the same field\nname and capitalization. To store a property under a different name, use\nthe  [BsonElement()]  attribute. The following code maps the\n YearBuilt  property of the  House  class to the  year_built \nfield in the serialized BSON document: Though it is common to use the Pascal case naming convention when\ndefining C# classes, using the  [BsonElement()]  attribute\nallows you to select a different or custom naming convention in your\nMongoDB collection. If you want to serialize every property with a custom field name, you\ncan define a  ConventionPack  instead of using the\n [BsonElement()]  attribute. For example, if you define your class\nusing the Pascal case naming convention, you can use the following\ncode to use camel case field names in the serialized document: To serialize a C# property to a specific BSON type, use the\n [BsonRepresentation()]  attribute. This works only if the\nC# primitive type is convertible to the BSON type you specify.\nIn the following code sample, the  YearBuilt  property, defined as a\n char  in C#, is serialized as a BSON  Int32  type: For more information on valid type conversions, see the  C#\nConversions Specification . The driver serializes properties to BSON fields in the order they\nare specified in the POCO. To store properties in a custom order to\nmatch an existing schema, you can specify the  Order  named\nparameter in the  [BsonElement()]  attribute. In the following code\nsample, the driver stores the  YearBuilt  property after the\n Style  property: If any properties don't have an explicit  Order , the driver will\nserialize them in the default order after those that do. By default, the driver maps any public property named  Id ,  id , or\n _id  to the BSON  _id  field. To explicitly select the\nproperty to map to the  _id  field, use the  [BsonId()]  attribute.\nThe following code sample maps the  Identifier  property to the\n _id  field: If you identify more than one property as the  _id  field using the\n [BsonId()]  attribute, the driver throws a\n DuplicateBsonMemberMapAttributeException . If you specify the same\ndatabase field more than once\n(for example, if your POCO includes properties named  Id  and  _id ),\nthe driver throws a  BsonSerializationException . By default, the driver serializes undefined properties to fields with  null \nvalues. To ignore undefined properties during serialization, use the  [BsonIgnore] \nattribute. The following code shows how you can prevent the driver from\nserializing the  YearBuilt  property if it is undefined: In C#, a property has a default value until you assign a value to it. The\ndefault value depends on the property's data type. For example, the default value for\na reference-type property is  null . To specify a different default value for a property, apply the\n [BsonDefaultValue()]  attribute to the property and pass the desired default value as\nan argument. The following code examples applies the  [BsonDefaultValue()]  attribute to the\n YearBuilt  property. Until this property is assigned a value, its value is  1900 . You can also specify a different default value for a property when\nyou register the class map, as shown in the following example: By default, the .NET/C# Driver serializes all properties, including those that\ncontain default values. To instruct the driver to ignore a property that has the\ndefault value, use the  [BsonIgnoreIfDefault]  attribute. The following code example applies the  [BsonIgnoreIfDefault]  attribute to the\n YearBuilt  property. If the value of this property is the default for its data type\n( 0  for  int  properties), the driver won't serialize it. You can also instruct the driver to ignore a property that contains the default value when\nyou register the class map, as shown in the following example: You can both specify a different default value for a property and instruct the driver to\nignore the property if it contains this default value. To do so, apply both the\n [BsonDefaultValue()]  and  [BsonIgnoreIfDefault]  attributes to the property,\nas shown in the following code example: The previous code example sets the following serialization behavior: If a value hasn't been assigned to the  YearBuilt  property, it has the specified\ndefault value of  1900 . Because  1900  is the default value for this property, the driver will ignore the\nproperty if it has this value. Every document in a MongoDB collection must have a unique ID. When you serialize an object\nto a collection, if the  Id  property contains the default\nvalue for its data type, the .NET/C# Driver doesn't serialize it. Instead, the driver\ngenerates a unique ID value for the property. If the  Id  property is of type  Guid ,  ObjectId , or  string , the driver can\ngenerate the ID value on its own. If the  Id  property is any other data type, you must\nspecify the  IIdGenerator  type that the driver uses to generate the value.\nTo specify the  IIdGenerator  type, apply the  [BsonId(IdGenerator)]  attribute\nto the property and pass the  IIdGenerator  type as an argument. The .NET/C# Driver includes the following  IIdGenerator  types: In the following code example, if the  Id  property of the  House  class contains\nthe default value ( null ), the driver uses the COMB algorithm to generate a\nunique value during serialization: You can also specify an  IIdGenerator  type while registering the class map, as shown in\nthe following example: The .NET/C# Driver also includes  IIdGenerator  types that validate the  Id \nproperty and throw an exception if the ID is invalid. The following table lists these\ntypes: In the following code example, if the  Id  property of the  House  class contains\nthe default value ( null ), the driver throws an exception: Id  Field Data Type IIdGenerator  Type Guid  value generated by the COMB algorithm CombGuidGenerator BsonObjectId BsonObjectIdGenerator In the previous code example, if the  Id  property didn't have the\n [BsonId(IdGenerator)]  attribute, the driver would generate a non-COMB GUID\nto assign to the  Id  field. You can use the  RegisterIdGenerator()  method to specify a single  IIdGenerator \nfor all  Id  properties of a certain data type. The following code example instructs\nthe driver to use the  CombGuidGenerator  type for all  Guid  IDs: ID Validation IIdGenerator  Type Not null NullIdChecker Not all zeroes ZeroIdChecker<T> To customize how the .NET/C# Driver serializes  DateTime  properties, use the\n [BsonDateTimeOptions()]  attribute and specify the desired setting as an argument. If a  DateTime  property represents only a date, you can apply the\n [BsonDateTimeOptions(DateOnly = true)]  attribute to it.\nIf you do, the driver won't perform any time-zone conversion on the value. In the following code example, the  PatientRecord  class uses a  DateTime  for the\n DateOfBirth  property. The  [BsonDateTimeOptions(DateOnly = true)] \nattribute indicates that the property contains only a date. You can also use the  [BsonDateTimeOptions()]  attribute to specify the  DateTimeKind \nof a  DateTime  property. In the following code example, the  PatientRecord  class\nhas an  AppointmentTime  property of type  DateTime .\nThe  [BsonDateTimeOptions(Kind = DateTimeKind.Local)]  attribute indicates\nthat the time component of the property's value is in local time. When the\ndriver serializes this property, it converts the time to UTC, the standard\nformat for times stored in MongoDB. You can also specify one or both of the previous  DateTime  options when\nregistering the class map: The  DateTimeKind  enum is part of the .NET framework. For more information on\nits members, see the  Microsoft documentation for the DateTimeKind enum. The  DictionaryRepresentation  enum defines the formats the .NET/C# Driver\ncan serialize a  Dictionary  instance to. This enum includes the following members: In the following code example, the  RoomSizes  property is a dictionary that contains\neach room in a house and its corresponding size. The  [BsonDictionaryOptions()] \nattribute instructs the .NET/C# Driver to serialize\nthis property to a  BsonArray  object, and each entry in the dictionary to a\n BsonDocument  of the form  { k : \"<room>\", v : <size> } . You can also specify the serialization format of a dictionary when\nyou register the class map, as shown in the following example: Document : (Default) The driver serializes the  Dictionary  to a  BsonDocument .\nEach entry in the dictionary is a  BsonElement  with a name equal to\nthe entry's key and a value equal to the entry's value. You can\nuse this representation only when all the keys in the dictionary are strings that\nare also valid  BsonElement  names. ArrayOfArrays : The driver serializes the dictionary to a  BsonArray . Each\nentry in the dictionary is a nested, two-element  BsonArray  that contains\nthe entry's key and the entry's value. ArrayOfDocuments : The driver serializes the dictionary to a  BsonArray . Each\nentry in the dictionary is a nested  BsonDocument  of the form\n { k : key, v : value } . Because the keys and values are\ntagged with element names, you can query this format more intuitively than\nan  ArrayOfArrays . The following example shows how to insert a  Clothing  document with custom field\nmapping specifications into MongoDB. The following code defines the  Clothing  class with these\nserialization-related attributes: The following code instantiates a  Clothing  object and inserts the document into a collection: The BSON representation of the inserted document looks like this: [BsonElement()] , which specifies custom field names in the camel case naming convention [BsonRepresentation()] , which specifies serialization of the  Price  field as a BSON  Double  type [BsonDefaultValue()] , which sets the  Name  property to\n \"Generic item\"  if no value has been assigned to it For a full list of serialization-related attributes, see the\n Serialization.Attributes API documentation . For additional read and write operation examples using POCOs, see the  Usage Examples  or the  CRUD Fundamentals Pages . To learn more about how the driver maps BSON documents to POCOs, see\n Class Mapping . To learn more about any of the methods or types discussed in this\nguide, see the following API documentation: [BsonElement()] [BsonRepresentation()] [BsonId()] [BsonIgnore()] [BsonDefaultValue()] [BsonIgnoreIfDefault] [BsonDateTimeOptions()] [BsonDictionaryOptions()] ConventionPack InsertOne()",
            "code": [
                {
                    "lang": "csharp",
                    "value": "public class Clothing\n{\n    public ObjectId Id { get; set; }\n    public string Name { get; set; }\n    public bool InStock { get; set; }\n    public double Price { get; set; }\n    public List<string> ColorSelection { get; set; }\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": ObjectId(\"...\"),\n  \"Name\": \"Long Sleeve Shirt\",\n  \"InStock\": true,\n  \"Price\": 17.99,\n  \"ColorSelection\": [ \"black\", \"navy\", \"red\" ]\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Clothing\n{\n    public ObjectId Id { get; set; }\n    public string Name { get; set; }\n    public bool InStock { get; set; }\n    public double Price { get; set; }\n    public List<string> ColorSelection { get; set; }\n\n    [BsonElement]\n    public int Upc { get; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<Clothing>(classMap =>\n{\n    classMap.AutoMap();\n    classMap.MapProperty(c => c.Upc);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonElement(\"year_built\")]\n    public int YearBuilt { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "var camelCaseConvention = new ConventionPack { new CamelCaseElementNameConvention() };\nConventionRegistry.Register(\"CamelCase\", camelCaseConvention, type => true);"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonRepresentation(BsonType.Int32)]\n    public char YearBuilt { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonElement(Order = 2)]\n    public int YearBuilt { get; set; }\n\n    [BsonElement(Order = 1)]\n    public string Style { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    [BsonId]\n    public string Identifier { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonIgnore]\n    public int YearBuilt { get; set; }\n    public string Style { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonDefaultValue(1900)]\n    public int YearBuilt { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<House>(classMap =>\n{\n   classMap.AutoMap();\n   classMap.MapMember(h => h.YearBuilt).SetDefaultValue(1900);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonIgnoreIfDefault]\n    public int YearBuilt { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<House>(classMap =>\n{\n   classMap.AutoMap();\n   classMap.MapMember(h => h.YearBuilt).SetIgnoreIfDefault(true);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonDefaultValue(1900)]\n    [BsonIgnoreIfDefault]\n    public int YearBuilt { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    [BsonId(IdGenerator = typeof(CombGuidGenerator))]\n    public Guid Id { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<House>(classMap =>\n{\n   classMap.AutoMap();\n   classMap.MapIdMember(h => h.Id).SetIdGenerator(CombGuidGenerator.Instance);\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    [BsonId(IdGenerator = typeof(NullIdChecker))]\n    public Guid Id { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonSerializer.RegisterIdGenerator(\n  typeof(Guid),\n  CombGuidGenerator.Instance\n);"
                },
                {
                    "lang": "csharp",
                    "value": "public class PatientRecord\n{\n    public Guid Id { get; set; }\n\n    [BsonDateTimeOptions(DateOnly = true)]\n    public DateTime DateOfBirth { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class PatientRecord\n{\n    public Guid Id { get; set; }\n\n    [BsonDateTimeOptions(Kind = DateTimeKind.Local)]\n    public DateTime AppointmentTime { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<House>(classMap =>\n{\n   classMap.AutoMap();\n   classMap.MapMember(p => p.DateOfBirth)\n      .SetSerializer(new DateTimeSerializer(dateOnly: true));\n   classMap.MapMember(p => p.AppointmentTime)\n      .SetSerializer(new DateTimeSerializer(DateTimeKind.Local));\n});"
                },
                {
                    "lang": "csharp",
                    "value": "public class House\n{\n    public Guid Id { get; set; }\n\n    [BsonDictionaryOptions(DictionaryRepresentation.ArrayOfDocuments)]\n    public Dictionary<string, float> RoomSizes { get; set; }\n}"
                },
                {
                    "lang": "csharp",
                    "value": "BsonClassMap.RegisterClassMap<House>(classMap =>\n{\n    classMap.AutoMap();\n    classMAp.MapMember(h => h.RoomSizes)\n      .SetSerializer(new DictionaryInterfaceImplementerSerializer<Dictionary<string, float>>\n      (DictionaryRepresentation.ArrayOfDocuments));\n});"
                },
                {
                    "lang": "csharp",
                    "value": "var doc = new Clothing\n{\n    Name = \"Denim Jacket\",\n    InStock = false,\n    Price = 32.99m,\n    ColorSelection = new List<string> { \"dark wash\", \"light wash\" }\n};\n\n_myColl.InsertOne(doc);"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": ObjectId(\"...\"),\n  \"name\": \"Denim Jacket\",\n  \"inStock\": false,\n  \"price\": 32.99,\n  \"colorSelection\": [ \"dark wash\", \"light wash\" ]\n}"
                },
                {
                    "lang": "csharp",
                    "value": "public class Clothing\n{\n    public ObjectId Id { get; set; }\n\n    [BsonElement(\"name\")]\n    [BsonDefaultValue(\"Generic item\")]\n    public string Name { get; set; }\n\n    [BsonElement(\"inStock\")]\n    public bool InStock { get; set; }\n\n    [BsonElement(\"price\")]\n    [BsonRepresentation(BsonType.Decimal128)]\n    public decimal Price { get; set; }\n\n    [BsonElement(\"colorSelection\")]\n    public List<string> ColorSelection { get; set; }\n}"
                }
            ],
            "preview": "In this guide, you can learn about how you can use \"Plain Old CLR/Class\nObjects\", or POCOs, with the .NET/C# Driver for your operations\nand queries. POCOs are simple class objects that do not inherit\nfeatures from any framework-specific base classes or interfaces. We recommend\nusing POCOs in your C# code to adhere to idiomatic driver usage and\nachieve the best performance.",
            "tags": ".NET, object, custom class, attributes, code example",
            "facets": {
                "genre": [
                    "reference"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        },
        {
            "slug": "fundamentals/connection/connection-options",
            "title": "Connection Options",
            "headings": [
                "Using the Connection URI",
                "Using MongoClientSettings",
                "Connection Options"
            ],
            "paragraphs": "This section describes the MongoDB connection and authentication options\navailable in the .NET/C# Driver. You can configure your connection using either\nthe connection URI or a  MongoClientSettings  object. If you pass a connection URI to the  MongoClient  constructor, you can include\nconnection options in the string as  <name>=<value>  pairs. In the following example,\nthe connection URI contains the  connectTimeoutMS  option with a value of  60000 \nand the  tls  option with a value of  true : You can use a  MongoClientSettings  object to configure connection settings in code\nrather than in a connection URI. Configuring the connection this way makes it easier to\nchange settings at runtime, helps you catch errors during compilation, and provides\nmore configuration options than the connection URI. To use a  MongoClientSettings  object, create an instance of the class, set\nits properties, and pass it as an argument to the  MongoClient  constructor: The following table lists each connection option available in the\n MongoClientSettings  class and, if possible, how to achieve the same result in\nthe connection string. If a  MongoClientSettings  property maps to more than one\noption in the connection string, the  Connection URI Example  shows all\nrelevant options. If you're using a query parameter for a time duration, the value must be in\nmilliseconds. For example, to specify 60 seconds, use the value  60000 . If you're\nusing a  MongoClientSettings  object for a time duration, use the appropriate\n TimeSpan  value. MongoClientSettings  Property Description AllowInsecureTls ApplicationName AutoEncryptionOptions ClusterConfigurator Compressors ConnectTimeout Credential DirectConnection HeartbeatInterval HeartbeatTimeout IPv6 IsFrozen LinqProvider LoadBalanced You specify just one host name. You're not connecting to a replica set. You're not using the  SrvMaxHosts  property. You're not using the  DirectConnection  property. LocalThreshold LoggingSettings MaxConnecting MaxConnectionIdleTime MaxConnectionLifeTime MaxConnectionPoolSize MinConnectionPoolSize ReadConcern ReadEncoding ReadPreference You can include the  readPreferenceTags  parameter in the connection URI more\nthan once. If you do, the client treats each instance as a separate tag set.\nThe order of the tags in the URI determines the order for read preference. You can\nuse this parameter only if the read-preference mode is not  primary . ReplicaSetName RetryReads RetryWrites Scheme Server ServerApi Servers ServerSelectionTimeout SocketTimeout SrvMaxHosts SslSettings UseTls WaitQueueTimeout WriteConcern WriteEncoding",
            "code": [
                {
                    "lang": "csharp",
                    "value": "using MongoDB.Driver;\n\n// Connection URI\nconst string connectionUri = \"mongodb+srv://sample.host:27017/?connectTimeoutMS=60000&tls=true\";\n\n// Create a new client and connect to the server\nvar client = new MongoClient(connectionUri);"
                },
                {
                    "lang": "csharp",
                    "value": "//const string connectionUri = \"mongodb+srv://sample.host:27017/?connectTimeoutMS=60000&tls=true\";\n\n// Create a MongoClientSettings object\nvar settings = new MongoClientSettings()\n{\n    Scheme = ConnectionStringScheme.MongoDBPlusSrv,\n    Server = new MongoServerAddress(\"sample.host\", 27017),\n    ConnectTimeout = new TimeSpan(0, 0, 60),\n    UseTls = true\n};\n\n// Create a new client and connect to the server\nvar client = new MongoClient(settings);"
                },
                {
                    "lang": "none",
                    "value": "mongodb://user1:password1&authMechanism=GSSAPI\n&authMechanismProperties=SERVICE_NAME:other,REALM:otherrealm\n&authSource=$external"
                },
                {
                    "lang": "none",
                    "value": "readPreference=primaryPreferred\n&maxStalenessSeconds=90\n&readPreferenceTags=dc:ny,rack:1"
                }
            ],
            "preview": "This section describes the MongoDB connection and authentication options\navailable in the .NET/C# Driver. You can configure your connection using either\nthe connection URI or a MongoClientSettings object.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "programming_language": [
                    "csharp"
                ],
                "target_product": [
                    "drivers"
                ]
            }
        }
    ]
}