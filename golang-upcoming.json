{
    "url": "http://mongodb.com/docs/drivers/go/upcoming",
    "includeInGlobalSearch": false,
    "documents": [
        {
            "slug": "quick-start",
            "title": "Quick Start",
            "headings": [
                "Set up Your Project",
                "Use Go Mod to Initialize a Project",
                "Add MongoDB as a Dependency",
                "Add Other Dependencies",
                "Create a MongoDB Cluster",
                "Set up a Free Tier Cluster in Atlas",
                "Connect to your Cluster",
                "Query Your MongoDB Cluster from Your Application",
                "Next steps"
            ],
            "paragraphs": "This guide shows you how to create an application that uses the  Go driver \nto connect to a  MongoDB Atlas cluster . If you prefer to connect to MongoDB\nusing a different driver or programming language, see our\n list of official MongoDB drivers . The Go driver lets you connect to and communicate with MongoDB clusters\nfrom a Go application. MongoDB Atlas is a fully-managed cloud database service that hosts your data\non MongoDB clusters. In this guide, we show you how to get started with your\nown free (no credit card required) cluster. Follow the steps below to connect your Go application with a MongoDB Atlas\ncluster. Create a new directory and initialize your project by using  go mod . Use  go get  to add the Go driver as a dependency. Use  go get  to add any additional dependencies. This Quick Start\nuses the  godotenv  package to read a MongoDB connection string\nfrom an environment variable to avoid embedding credentials within\nsource code. After setting up your Go project dependencies, create a MongoDB cluster\nwhere you can store and manage your data. Complete the\n Get Started with Atlas  guide to set up a new\nAtlas account, free tier MongoDB cluster, load datasets, and\ninteract with the data. After completing the steps in the Atlas guide, you should have a new MongoDB\ncluster deployed in Atlas, a new database user, and\n sample datasets loaded  into your cluster. In this step, you create and run an application that uses the Go\ndriver to connect to your MongoDB cluster and run a query on the sample\ndata. You pass instructions to the driver on where and how to connect to your\nMongoDB cluster in a string called the  connection string . This string\nincludes information on the hostname or IP address and port of your\ncluster, authentication mechanism, user credentials when applicable, and\nother connection options. To retrieve your connection string for the cluster and user you created in\nthe previous step, log into your Atlas account and navigate to the\n Database  section and click the  Connect  button for the cluster that you\nwant to connect to as shown below. Proceed to the  Connect Your Application  step and select the Go\ndriver. Then, click the  Copy  button to copy the  connection string \nto your clipboard as shown below. Save your Atlas connection string in a safe location that you can access\nfor the next step. To learn more about connecting to the Go driver through Atlas, see\nthe  Atlas driver connection guide \nand select  Go  from the  Select your language  dropdown. Next, create a file to contain your application called  main.go \nin the base directory of your project. Use the following sample\ncode to run a query on your sample dataset in MongoDB Atlas. Specify your MongoDB Atlas connection string as the value of the\n uri  variable, or create an environment variable called\n MONGODB_URI  and set your Atlas connection string as its value. Run the sample code with the following command from your command line: After completing this step, you should have a working application that uses\nthe Go driver to connect to your MongoDB cluster, run a query on the\nsample data, and print out the result. Make sure to replace the \"<password>\" section of the connection string with\nthe password you created for your user that has  atlasAdmin  permissions. When you run  main.go , it should output the details of the movie from\nthe sample dataset which looks something like the following: If you receive no output or an error, check whether you properly set up\nyour environment variable and whether you loaded the sample dataset in\nyour MongoDB Atlas cluster. If your output is empty, ensure you have loaded the\n sample datasets  into your cluster. Learn how to read and modify data using the Go driver in our Fundamentals\nCRUD guide or how to perform common operations from our\n Usage Examples .",
            "code": [
                {
                    "lang": "shell",
                    "value": "mkdir go-quickstart\ncd go-quickstart\ngo mod init go-quickstart"
                },
                {
                    "lang": "shell",
                    "value": "go get go.mongodb.org/mongo-driver/mongo"
                },
                {
                    "lang": "shell",
                    "value": "go get github.com/joho/godotenv"
                },
                {
                    "lang": "bash",
                    "value": "export MONGODB_URI='<your atlas connection string>'"
                },
                {
                    "lang": "bash",
                    "value": "go run main.go"
                },
                {
                    "lang": "go",
                    "value": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Println(\"No .env file found\")\n\t}\n\n\turi := os.Getenv(\"MONGODB_URI\")\n\tif uri == \"\" {\n\t\tlog.Fatal(\"You must set your 'MONGODB_URI' environment variable. See\\n\\t https://www.mongodb.com/docs/drivers/go/current/usage-examples/#environment-variable\")\n\t}\n\tclient, err := mongo.Connect(options.Client().ApplyURI(uri))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer func() {\n\t\tif err := client.Disconnect(context.TODO()); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tcoll := client.Database(\"sample_mflix\").Collection(\"movies\")\n\ttitle := \"Back to the Future\"\n\n\tvar result bson.M\n\terr = coll.FindOne(context.TODO(), bson.D{{\"title\", title}}).Decode(&result)\n\tif err == mongo.ErrNoDocuments {\n\t\tfmt.Printf(\"No document was found with the title %s\\n\", title)\n\t\treturn\n\t}\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tjsonData, err := json.MarshalIndent(result, \"\", \"    \")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%s\\n\", jsonData)\n}\n"
                },
                {
                    "lang": "json",
                    "value": "{\n    \"_id\": \"573a1398f29313caabce9682\",\n    ...\n    \"title\": \"Back to the Future\",\n    ...\n}"
                }
            ],
            "preview": "Create a new directory and initialize your project by using go mod.",
            "tags": null,
            "facets": {
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "issues-and-help",
            "title": "Issues & Help",
            "headings": [
                "Bugs / Feature Requests",
                "Pull Requests"
            ],
            "paragraphs": "We are lucky to have a vibrant MongoDB Go community that includes users\nwith varying levels of experience using the Go driver. We find the quickest\nway to get support for general questions is through the  MongoDB Community Forums . To learn more, refer to our  support channels . If you think you've found a bug or want to see a new feature in the Go\ndriver, please open a case in our issue management tool, JIRA: Bug reports in JIRA for the Go driver and the Core Server (i.e. SERVER) project are  public . If you've identified a security vulnerability in a driver or any other\nMongoDB project, please report it according to the instructions found in the\n Create a Vulnerability Report page . Create an account and log in . Navigate to  the GODRIVER project . Click  Create Issue . Please provide as much information as possible\nabout the issue and the steps to reproduce it. We are happy to accept contributions to help improve the driver. We will guide\nuser contributions to ensure they meet the standards of the codebase. Please\nensure that any pull requests include documentation, tests, and pass the\n gradle  checks. To get started, check out the source and work on a branch: Finally, follow the  Testing/Development guidelines  to\nensure your code passes any newly added and existing tests.",
            "code": [
                {
                    "lang": "bash",
                    "value": "$ git clone https://github.com/mongodb/mongo-go-driver.git\n$ cd mongo-go-driver\n$ git checkout -b myNewFeature"
                }
            ],
            "preview": "We are lucky to have a vibrant MongoDB Go community that includes users\nwith varying levels of experience using the Go driver. We find the quickest\nway to get support for general questions is through the MongoDB Community Forums.",
            "tags": "suggestion, github",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "faq",
            "title": "FAQ",
            "headings": [
                "Why Am I Getting Errors While Connecting to MongoDB?",
                "How Does Connection Pooling Work in the Go driver?",
                "How Can I Fix the \"WriteNull can only write while positioned on a Element or Value but is positioned on a TopLevel\" Error?",
                "How Do I Convert a BSON Document to JSON?"
            ],
            "paragraphs": "This page contains frequently asked questions and their corresponding answers. If you can't find an answer to your problem on this page,\nsee the  Issues & Help  page for next steps and more\nresources. If you have trouble connecting to a MongoDB deployment, see\nthe  Connection Troubleshooting Guide \nfor possible solutions. Every  Client  instance has a built-in connection pool for each server\nin your MongoDB topology. Connection pools open sockets on demand to support\nconcurrent MongoDB operations, or  goroutines , in your application. The maximum size of each connection pool is set by the  maxPoolSize  option, which\ndefaults to  100 . If the number of in-use connections to a server reaches\nthe value of  maxPoolSize , the next request to that server will wait\nuntil a connection becomes available. The  Client  instance opens two additional sockets per server in your\nMongoDB topology for monitoring the server's state. For example, a client connected to a 3-node replica set opens 6\nmonitoring sockets. It also opens the necessary sockets to support\nan application's concurrent operations on each server, up to\nthe value of  maxPoolSize . If  maxPoolSize  is  100  and the\napplication only uses the primary (the default), then only the primary\nconnection pool grows and there can be at most  106  total connections. If the\napplication uses a  read preference  to query the\nsecondary nodes, their pools also grow and there can be  306  total connections. Additionally, connection pools are rate-limited such that each connection pool\ncan only create, at maximum, the value of  maxConnecting  connections\nin parallel at any time. Any additional goroutine stops waiting in the\nfollowing cases: You can set the minimum number of concurrent connections to\neach server by using the  minPoolSize  option, which defaults to  0 .\nAfter setting  minPoolSize , the connection pool is initialized with\nthis number of sockets. If sockets close due to any network errors, causing\nthe total number of sockets (both in use and idle) to drop below the minimum, more sockets\nopen until the minimum is reached. You can set the maximum number of milliseconds that a connection can\nremain idle in the pool before being removed and replaced with\nthe  maxIdleTimeMS  option, which defaults to  None  (no limit). The following default configuration for a  Client  works for most applications: Create a client once for each process, and reuse it for all\noperations. It is a common mistake to create a new client for each\nrequest, which is very inefficient. To support high numbers of concurrent MongoDB operations\nwithin one process, you can increase  maxPoolSize . Once the pool\nreaches its maximum size, additional operations wait for sockets\nto become available. The driver does not limit the number of operations that\ncan wait for sockets to become available and it is the application's\nresponsibility to limit the size of its pool to bound queuing\nduring a load spike. Operations can wait for any length of time\nunless you define the  waitQueueTimeoutMS  option. An operation that waits more than the length of time defined by\n waitQueueTimeoutMS  for a socket raises a connection error. Use this\noption if it is more important to bound the duration of operations\nduring a load spike than it is to complete every operation. When  Client.Disconnect()  is called by any goroutine, the driver\ncloses all idle sockets and closes all sockets that are in\nuse as they are returned to the pool. One of the existing goroutines finishes creating a connection, or\nan existing connection is checked back into the pool. The driver's ability to reuse existing connections improves due to\nrate-limits on connection creation. The  bson.Marshal()  method requires a parameter that can be decoded\ninto a BSON document, such as the  bson.D  type. This error occurs\nwhen you pass something  other  than a BSON document to\n bson.Marshal() . The  WriteNull  error occurs when you pass a  null  to\n bson.Marshal() . Situations in which a similar error can occur\ninclude the following: You may encounter this error when you perform a CRUD operation that\ninternally uses the  bson.Marshal()  method or when you call\n bson.Marshal()  directly to encode data. The following code produces a  WriteNull  error because the driver\ncannot encode the  null  value of  sortOrder  to BSON during\nthe  FindOneAndUpdate()  operation: The following code shows how to correctly initialize the  sortOrder \nvariable as a  bson.D  type so that the driver can convert it to BSON: You pass a string to  bson.Marshal() , causing a  WriteString  error. You pass a boolean to  bson.Marshal() , causing a  WriteBoolean  error. You pass an integer to  bson.Marshal() , causing a  WriteInt32  error. The driver provides a variety of marshaler methods that can be used to\nconvert a BSON document to JSON, such as the  MarshalExtJSON() \nmethod. To view a readable form of the JSON encoding, you must use\nan unmarshaler method or string type-casting to parse the JSON byte\nformat. The following code converts a BSON document to JSON using the\n MarshalExtJSON()  method, then parses and prints the JSON byte array\nusing string type-casting: To learn more about conversions between BSON and Go types, see the\n Work with BSON  guide.",
            "code": [
                {
                    "lang": "go",
                    "value": "client, err := mongo.Connect(options.Client().ApplyURI(\"<connection string>\"))"
                },
                {
                    "lang": "go",
                    "value": "var sortOrder bson.D\nopts := options.FindOneAndUpdate().SetSort(sortOrder)\n\nupdateDocument := bson.D{{\"$inc\", bson.D{{\"counter\", 1}}}}\nresult := coll.FindOneAndUpdate(context.TODO(), bson.D{}, updateDocument, opts)\nif err := result.Err(); err != nil {\n    panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "sortOrder := bson.D{}"
                },
                {
                    "lang": "go",
                    "value": "bsonDocument := bson.D{{\"hello\", \"world\"}}\n\njsonBytes, err := bson.MarshalExtJSON(bsonDocument, true, false)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(string(jsonBytes))"
                },
                {
                    "lang": "none",
                    "value": "{\"hello\":\"world\"}"
                }
            ],
            "preview": "This page contains frequently asked questions and their corresponding answers.",
            "tags": "code example, connection error, question, help",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "",
            "title": "MongoDB Go Driver",
            "headings": [
                "Introduction",
                "Connect to a Compatible MongoDB Deployment",
                "Quick Start",
                "Quick Reference",
                "What's New",
                "Usage Examples",
                "Fundamentals",
                "API",
                "FAQ",
                "Connection Troubleshooting",
                "Issues & Help",
                "Compatibility",
                "Learn",
                "Developer Hub"
            ],
            "paragraphs": "Welcome to the documentation site for the official MongoDB Go Driver.\nYou can add the driver to your application to work with MongoDB in Go.\nDownload it using  go get \nor set up a runnable project by following our Quick Start guide. You can use the Go driver to connect to MongoDB\ndeployments running on one of the following hosted services or editions: MongoDB Atlas : the fully\nmanaged service for MongoDB deployments in the cloud MongoDB Enterprise : the\nsubscription-based, self-managed version of MongoDB MongoDB Community : the\nsource-available, free-to-use, and self-managed version of MongoDB Learn how to establish a connection to MongoDB Atlas and begin\nworking with data in the  Quick Start  section. See driver syntax examples for common MongoDB commands in the\n Quick Reference  section. For a list of new features and changes in each version, see the\n What's New  section. For fully runnable code snippets and explanations for common\nmethods, see  Usage Examples . Learn how to perform the following tasks using the Go driver in the\nFundamentals section: Connect to MongoDB Specify an API Version How the Driver Uses Context Authenticate with MongoDB Use Enterprise Authentication with MongoDB Work with BSON Read from and Write to MongoDB Perform Aggregations Construct Indexes Perform Transactions Record Log Messages Run A Database Command Specify Collations to Order Results Use Driver Events in Your Code Store and Retrieve Large Files Use a Time Series Collection Encrypt Fields Work with Geospatial Data For detailed information about types and methods in the MongoDB\nGo driver, see the  MongoDB Go Driver API documentation . For answers to commonly asked questions about the MongoDB\nGo Driver, see  FAQ \nsection. For solutions to some issues you might see when connecting to a MongoDB\ndeployment while using the MongoDB Go Driver, see\n Connection Troubleshooting . Learn how to report bugs, contribute to the driver, and find\nadditional resources for asking questions in the  Issues & Help  section. For the compatibility charts that show the recommended Go Driver version\nfor each MongoDB Server version, see  Compatibility . Visit the Developer Hub and MongoDB University to learn more about the\nMongoDB Go Driver. The Developer Hub provides tutorials and social engagement for\ndevelopers. To learn how to use MongoDB features with the Go driver, see the  How\nTo's and Articles page . To ask questions and engage in discussions with fellow developers using\nthe Go Driver, see the  forums page .",
            "code": [],
            "preview": "Welcome to the documentation site for the official MongoDB Go Driver.\nYou can add the driver to your application to work with MongoDB in Go.\nDownload it using go get\nor set up a runnable project by following our Quick Start guide.",
            "tags": null,
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "connection-troubleshooting",
            "title": "Connection Troubleshooting",
            "headings": [
                "Connection Error",
                "Check Connection String",
                "Configure Firewall",
                "Authentication Error",
                "Check Connection String",
                "Verify the Authentication Mechanism",
                "Verify User Is in Authentication Database",
                "Error Sending Message",
                "Check Connection String",
                "Verify the Authentication Mechanism",
                "Verify User Is in Authentication Database",
                "Configure Firewall",
                "Check the Number of Connections",
                "Timeout Error",
                "Set Timeout Option",
                "Check the Number of Connections"
            ],
            "paragraphs": "This page offers potential solutions to issues you might encounter when\nusing the MongoDB Go Driver to connect to a MongoDB deployment. This page addresses only connection issues. If you encounter any other issues\nwith MongoDB or the driver, visit the following resources: The  Frequently Asked Questions (FAQ)  for the\nGo driver The  Issues & Help  page, which has\ninformation about reporting bugs, contributing to the driver, and\nfinding additional resources The  MongoDB Community Forums  for\nquestions, discussions, or general technical support The following error message is a general message indicating that the driver\ncannot connect to a server on the specified hostname or port: The following sections describe methods that may help resolve the issue. Verify that the hostname and port number in the connection string are both\naccurate. In the sample error message, the hostname is  127.0.0.1  and the\nport is  27017 . The default port value for a MongoDB instance is\n 27017 , but you can configure MongoDB to communicate on another port. Assuming that your MongoDB deployment uses the default port, verify that port\n 27017  is open in your firewall. If your deployment uses a different port,\nverify the correct port is open in your firewall. Do not open a port in your firewall unless you are sure that it is the port\nused by your MongoDB instance. The Go driver can fail to connect to a MongoDB instance if\nthe authorization is not configured correctly. In these cases, the driver raises\nan error message similar to one of the following messages: The following sections describe methods that may help resolve the issue. An invalid connection string is the most common cause of authentication\nissues when attempting to connect to MongoDB. If your connection string contains a username and password, ensure that they\nare in the correct format. When connecting to a replica set, include all the replica set hosts\nin your connection string. Separate each of the hosts in the connection\nstring with a comma. This enables the driver to establish a connection\nif one of the hosts is unreachable. For more information about connection strings,\nsee  Connection URI  in the Connection Guide. If the username or password includes any of the following characters, they\nmust be  percent encoded : Ensure that your credentials and authentication mechanism are correct. You can\nstore your authentication credentials in environment variables or you can pass\nthem to the  SetAuth()  method. To learn more about authentication, see the\n Authentication Mechanisms  guide. To successfully authenticate a connection by using a username and password,\nthe username must be defined in the authentication database. The default\nauthentication database is the  admin  database. To use a different database\nfor authentication, specify the  authSource  in the connection string. The\nfollowing example instructs the driver to use  users  as the authentication\ndatabase: When the driver fails to send a command after you make a request,\nit often displays the following general error message: The following sections describe methods that may help resolve the issue. Verify that the connection string in your app is accurate. For more information\nabout verifying your connection string, see\n Connection Error \nand  Authentication Error . Make sure you are using the correct authentication mechanism and credentials.\nFor more information about authentication errors, see\n Authentication Error . Verify the user is in the correct authentication database. For more\ninformation about the authentication database, see\n Authentication Error . The firewall must have an open port for communicating with the MongoDB\ninstance. For more information about configuring the firewall, see\n Connection Error . Each  MongoClient  instance supports a maximum number of concurrent open\nconnections in its connection pool. The configuration parameter  maxPoolSize \ndefines this value and is set to  100  by default. If there are already a\nnumber of open connections equal to  maxPoolSize , the server waits until\na connection becomes available. If this wait time exceeds the  maxIdleTimeMS \nvalue, the driver responds with an error. For more information about how\nconnection pooling works, see\n How Does Connection Pooling Work in the Go Driver? \nin the FAQ. Sometimes when you send a request through the driver to the server, the request\ntimes out. When this happens, you might receive an error message\nsimilar to the following message: If you receive this error, try the following methods to resolve the\nissue. The  Client  supports a single  Timeout  option that controls the amount of\ntime a single operation can take to execute. You can set this value by using\nthe  SetTimeout()  method or by specifying the  timeoutMS  option in your\nconnection string. The following example sets the single timeout value to 5 seconds using the\nconnection string option: The number of connections to the server may exceed  maxPoolSize . For more\ninformation about checking the number of connections, see\n Error Sending Message .",
            "code": [
                {
                    "lang": "none",
                    "value": "Error: couldn't connect to server 127.0.0.1:27017"
                },
                {
                    "lang": "none",
                    "value": "Command failed with error 18 (AuthenticationFailed): 'Authentication\nfailed.' on server localhost:27017."
                },
                {
                    "lang": "none",
                    "value": "connection() error occurred during connection handshake: auth error:\nsasl conversation error: unable to authenticate using mechanism\n\"SCRAM-SHA-256\": (AuthenticationFailed) Authentication failed."
                },
                {
                    "lang": "none",
                    "value": ": / ? # [ ] @"
                },
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://<username>:<password>@<hostname>:<port>/?authSource=users\"\nclient, err := mongo.Connect(options.Client().ApplyURI(uri))"
                },
                {
                    "lang": "none",
                    "value": "com.mongodb.MongoSocketWriteException: Exception sending message"
                },
                {
                    "lang": "none",
                    "value": "timed out while checking out a connection from connection pool: context canceled"
                },
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://<username>:<password>@<hostname>:27017/?timeoutMS=5000\"\nclient, err := mongo.Connect(options.Client().ApplyURI(uri))"
                }
            ],
            "preview": "This page offers potential solutions to issues you might encounter when\nusing the MongoDB Go Driver to connect to a MongoDB deployment.",
            "tags": "code example, disconnected, deployment",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "compatibility",
            "title": "Compatibility",
            "headings": [
                "MongoDB Compatibility",
                "Compatibility Table Legend",
                "Language Compatibility"
            ],
            "paragraphs": "The following compatibility table specifies the recommended version of the\nMongoDB Go Driver for use with a specific version of MongoDB. The first column lists the driver version. MongoDB ensures compatibility between the MongoDB Server and the drivers\nfor three years after the server version's end of life (EOL) date. To learn\nmore about the MongoDB release and EOL dates, see\n MongoDB Software Lifecycle Schedules . Icon Explanation \u2713 All features are supported. \u229b The Driver version will work with the MongoDB version, but not all\nnew MongoDB features are supported. No mark The Driver version is not tested with the MongoDB version. Go Driver Version MongoDB 7.0 MongoDB 6.1 MongoDB 6.0 MongoDB 5.0 MongoDB 4.4 MongoDB 4.2 MongoDB 4.0 MongoDB 3.6 MongoDB 3.4 MongoDB 3.2 MongoDB 3.0 MongoDB 2.6 1.12 to 1.14 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.11 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.10 \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.9 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.8 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.7 \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.6 \u229b \u229b \u229b \u2713  \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.5 \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.4 \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.3 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.2 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.1 \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 1.0 \u229b \u229b \u229b \u229b \u229b \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 The 1.6 driver does not support snapshot reads on secondaries. For more\ninformation, see the  MongoDB Server version 5.0 release notes . For more information on how to read the compatibility tables, see our guide on\n MongoDB Compatibility Tables. The MongoDB Go Driver requires Go 1.18 or later.",
            "code": [],
            "preview": "The following compatibility table specifies the recommended version of the\nMongoDB Go Driver for use with a specific version of MongoDB.",
            "tags": null,
            "facets": {
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "whats-new",
            "title": "What's New",
            "headings": [
                "What's New in 2.0",
                "What's New in 1.14",
                "What's New in 1.13",
                "What's New in 1.12.1",
                "What's New in 1.12",
                "Queryable Encryption",
                "Logging Interface",
                "Additional BSON Marshalling Options",
                "Simplified Write Concern Specification",
                "Additional Changes",
                "What's New in 1.11",
                "What's New in 1.10",
                "What's New in 1.9",
                "What's New in 1.8",
                "What's New in 1.7",
                "What's New in 1.6",
                "What's New in 1.5",
                "What's New in 1.4",
                "What's New in 1.3",
                "What's New in 1.2",
                "What's New in 1.1",
                "What's New in 1.0"
            ],
            "paragraphs": "Learn what's new in: To learn more about changes and updates between versions, you can\nread the  release notes  published with the driver source code. Version 2.0 Version 1.14 Version 1.13 Version 1.12.1 Version 1.12 Version 1.11 Version 1.10 Version 1.9 Version 1.8 Version 1.7 Version 1.6 Version 1.5 Version 1.4 Version 1.3 Version 1.2 Version 1.1 Version 1.0 The 2.0 Go driver release includes the following improvements and fixes: Starting in version 2.0, the  mongo.Connect()  method does not\naccept a context parameter. This method accepts only an options\nobject. To view an example that uses this method, see the\n Connection Example Code  in the\nConnection Guide. You can access the GridFS API from the  mongo  package. In previous\nversions, you could access GridFS functions from the separate  gridfs \npackage, but this functionality is now merged with the main driver\n mongo  package. To learn more, see the  GridFS  guide. The  Comment  field in any options struct takes a value of type  any  instead of type\n string . To set this field, you can use the  SetComment()  method and pass a parameter\nof type  any . Updates to monitoring event documents: To view sample event documents, see the  Monitoring  guides. The  CommandStartedEvent  and  CommandFinishedEvent  structs\nhave a single  ServerConnectionID  field of type  int64  to\ncapture the connection ID. The  ConnectionID  field of the  PoolEvent \nstruct takes a value of type  int64  instead of  uint64 . The 1.14 Go driver release includes the following improvements and fixes: Go versions before 1.18 are no longer supported. In case of a heartbeat timeout, in-progress operations are preemptively canceled. Connection strings that include the  \"mongodb+srv://\"  prefix can contain capital\nletters in the SRV hostname. The 1.13 Go driver release includes the following improvements and fixes: Logging for server selection and SDAM. To learn more about logging, see the\n Logging  documentation. Methods on the  Collection  type that allow you to manage search indexes programmatically. The  event.CommandStartedEvent  and  event.CommandFinishedEvent  events return\nthe  DatabaseName  field. This field is also included in the command-logging analogs. In a sharded topology, when selecting a server to retry an unsuccessful query, the driver\nexcludes the server used for the initial attempt. Instead, if there's more than\none eligible  mongos  instance, the driver randomly selects one. Unhealthy instances\nare automatically excluded from selection. Streaming SDAM is disabled by default on AWS Lambda and similar function-as-a-service\n(FaaS) platforms. You can enable monitoring by using the\n serverMonitoringMode  URI option. The 1.12 Go driver release includes the following improvements and fixes: The driver unpins connections when ending a session. This prevents connections\nfrom leaking when a user runs a transaction while connected to a load balancer. The driver does not throw a runtime error when you unmarshal an empty\n bson.RawValue  type with an invalid type or marshal a  nil  pointer of a  ReadConcern  instance. Setting  options.LogComponentAll  as the log component correctly results in the publication of logs against all components. New features of the 1.12 Go driver release include: The  mongo.NewClient()  and  client.Connect()  methods are\ndeprecated. You can create a client and connect in one call\nby using the  mongo.Connect()  method. This driver version adds support for  Queryable Encryption  (QE). To learn\nmore about the requirements for using the QE feature, see the\n Queryable Encryption Driver Compatibility Table . The  ClientEncryption.CreateEncryptedCollection() \nmethod automatically creates data encryption keys when\nyou create a new encrypted collection. To learn how to use the QE\nfeature, see the  Quick Start  in the Server manual. You can now record connection management and command execution events by\nusing the  LogSink  logging interface. To learn more, see the  Logging  Fundamentals guide. This driver version adds features to the  options  package to specify\nhow the driver marshals and unmarshals BSON. The following example shows how to set BSON options on your\n Client . The options specify the following behaviors: For a full example of how to specify and implement the  BSONOptions \ntype, see the  API documentation . The driver falls back to  json   struct tags  if  bson  struct tags are absent. The driver marshals  nil  Go map types as empty BSON documents. The driver marshals  nil  Go slice types as empty BSON arrays. This driver version simplifies the  WriteConcern  API. To learn more about\nthe changes, see  Write Concern . Support for authentication with AWS IAM roles in EKS. Addition of the  Cursor.SetBatchSize()  method to allow\nspecification of the size of batches fetched when iterating through a\ncursor. Addition of the  UnmarshalValue()  method to allow ummarshalling of\nBSON values marshalled with the  MarshalValue()  method. New features of the 1.11 Go driver release include: Versions 1.11.0 through 1.11.2 of the driver have been retracted because\nof a bug that could cause undefined behavior when reading the  Raw  field\non database error types, such as  CommandError  and\n WriteException . Version 1.11.8 of the driver has been retracted because\nit incorrectly contains changes intended for 1.12.1. Upgrade to version 1.11.9 or later if you are using a retracted\nversion of the driver. Removal of support for MongoDB versions 3.5 and older. Removal of support for Go versions 1.12 and older. Improvements to  Timeout  API and behavior, including: Modified retry logic for greater application resiliency. Extended  mongo.IsTimeout  error helper to catch more timeout errors. New GridFS methods that take contexts instead of using  SetReadDeadline \nand  SetWriteDeadline . Reduced memory allocations during operation execution. Fix for SRV polling bug that prevented changes in SRV records when the\nassociated MongoDB connection string included a username and password. Support for  GCP (Google Cloud Platform)  service accounts when using\nGoogle Cloud Key Management Services. Improvements to server-side resource cleanup when using the  Cursor.All  and\n Session.WithTransaction  functions. SERVICE_HOST  Kerberos authentication parameter specification enabled with\nthe  authMechanismProperties  connection string option. Corrected output from the  bson.Raw.String()  method to Extended JSON\ntype for timestamps when the BSON document contains a UTC Timestamp\nfield. Resolution of conflicts when retrying reads with read concern\n \"available\"  or  \"linearizable\" . New features of the 1.10 Go driver release include: The 1.10.1 Go driver patches a bug that can cause data corruption when\nrotating  Data Encryption Keys  encrypted\nwith a  Customer Master Key  hosted on Google\nCloud Key Management Service or Azure Key Vault. Full compatibility with MongoDB 6.0. Support for new features related to  Queryable Encryption ,\nincluding new options for automatic and manual encryption. Support for the new Automatic Encryption Shared Library, which replaces the\n mongocryptd  process. The shared library requires MongoDB v6.0 Enterprise\nor later and  libmongocrypt  1.5.0 or later. clustered index  creation support. A new API and  ClientEncryption  entity operations for encryption key\nmanagement. A  Timeout  client option to set default context timeouts for\neach operation sent through that client. A patch to default data to either  primitive.M  or  primitive.D  when\ndecoding empty types. Support for encoding atypical map key types for data that can be unmarshalled\ninto a textual representation of itself. Performance optimizations, including: Improved full document requests for before and after updates in change\nstream events. Improved  PRN (pseudo-random number)  and  UUID (universally\nunique identifier)  generation. Reduced memory consumption when compressing wire messages. Troubleshooting support for  frequently encountered issues. New features of the 1.9 Go driver release include: Improved connection storm mitigation. Custom  options to change-stream and aggregate operations. Let  option on most CRUD commands that specifies parameters for use\nin an aggregate expression.  Let  must be a document that maps\nparameter names to values that are constant or closed expressions without\nreferences to document fields. MongoDB v5.0 or later is required. New constructor functions that create  Cursor  and  SingleResult \ninstances from marshallable and non-nil BSON documents. New features of the 1.8 Go driver release include: Full compatibility with MongoDB 5.1. Support for  KMIP (Key Management Interoperability Protocol)  as a KMS\nprovider for  CSFLE (Client-side Field Level Encryption) . Redesigned driver connection pool for low operation  Context  timeouts and\nto reduce connection churn. Behavior changes include: New connection creation times out at  connectTimeoutMS . At most, two new connections can be established at the same time. Removal of oppressive and unnecessarily gendered language in the Go driver\ndocumentation, code, tests, and spec tests. New features of the 1.7 Go driver release include: The 1.7.2 Go driver contains a bug fix for a data race that can occur between\ncreating and checking out connections when  minPoolSize > 0 . Full compatibility with MongoDB 5.0. Support for the  \"snapshot\"  read concern outside of\nmulti-document transactions for certain read operations. Improved  WriteException  and  BulkWriteException  error messages for\nschema validation via the  WriteError.Details  field. New features of the 1.6 Go driver release include: The 1.6.2 Go driver contains a bug fix for a data race that can occur between\ncreating and checking out connections when  minPoolSize > 0 . Support for the MongoDB Stable API. For more information, see the\n Stable API Guide . Support for connections to any MongoDB service that runs behind a load\nbalancer. Support for creating time series collections. For more information, see\nthe  Time Series Collections Guide . Let  option for aggregate expressions. New features of the 1.5 Go driver release include: Support for Azure and  GCP (Google Cloud Platform)  key-management\nservices with Client-side Field Level Encryption. New errors API to detect duplicate-key errors, timeouts, and network\nerrors. Server monitoring to monitor changes on a MongoDB deployment. Errors to prevent unexpected behavior on maps that contain multiple\nkeys being used as a hint option, as a sort option, or for index creation. New features of the 1.4 Go driver release include: Full compatibility with MongoDB 4.4. Support for stapled and non-stapled OCSP verification. New  tlsDisableOCSPEndpointCheck=true  URI option to disable sending HTTP\nrequests if the OCSP responder is not reachable from the driver and there is\nno stapled response. Additional context to errors encountered during BSON unmarshalling. Proper  Unwrap  functions for various driver error types. New features of the 1.3 Go driver release include: mgocompat  package that exports a BSON registry compatible with\n globalsign/mgo/bson , which can be used via the\n ClientOptions.SetRegistry  method. RegisterTypeEncoder  and  RegisterHookEncoder  methods, which\nreplace the deprecated  RegisterEncoder  method. A corresponding change has\nbeen made to replace  RegisterDecoder . New features of the 1.2 Go driver release include: Support for CSFLE. bson.MarshalValue  function, which marshals Go types to BSON. StringCodec , which allows non-string fields to be decoded into a\nString field in a struct. IntCodec ,  UIntCodec ,  BoolCodec , and  FloatCodec  added to\n mgocompat  to allow codecs to convert between numbers and booleans. New features of the 1.1 Go driver release include: Full compatibility with MongoDB 4.2. Redesigned lower-level driver implementation to improve maintainability and\nperformance. Connection Monitoring and Pooling specifications to monitor various connection\nand connection pool events with improved utilization. This release adds no new features.",
            "code": [
                {
                    "lang": "go",
                    "value": "bsonOpts := &options.BSONOptions{\n     UseJSONStructTags: true,\n     NilMapAsEmpty:     true,\n     NilSliceAsEmpty:   true,\n}\noptions.Client().SetBSONOptions(bsonOpts)"
                }
            ],
            "preview": "Learn what's new in:",
            "tags": "update, backward compatibility",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples",
            "title": "Usage Examples",
            "headings": [
                "Overview",
                "How to Use the Usage Examples",
                "Connection String",
                "Environment Variable"
            ],
            "paragraphs": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following: A full Go program that you can run in your own environment The expected result after running the program These examples use the  sample datasets  provided by\nAtlas. You can load them into your database on the free tier of MongoDB\nAtlas by following the  Get Started with Atlas Guide  or you can\n import the sample dataset into a local MongoDB instance . Once you import the dataset, you can copy and paste a usage\nexample into your development environment of choice. You can follow the\n Quick Start  to learn more about getting\nstarted with the MongoDB Go Driver. Follow the  \"Connect to your Cluster\" \nstep to find the\n connection string  to define your\n MONGODB_URI  environment variable to run the usage examples. If your\ninstance uses  SCRAM authentication ,\nyou can replace  <user>  with your username,  <password>  with your\npassword, and  <cluster-url>  with the URL or IP address of your instance. To learn more about connecting to your MongoDB instance, see  Connection Guide . To connect the example to your MongoDB instance, you must  define\nan environment variable  by using\nyour connection string. You can use  GoDotEnv  to define\nyour environment variable. Add the following application configuration in your  .env  file at the\nroot of your project. To learn more, see the\n GoDotEnv documentation . Replace the preceding connection string with  your MongoDB deployment's connection string .",
            "code": [
                {
                    "lang": "go",
                    "value": "uri := os.Getenv(\"MONGODB_URI\")"
                },
                {
                    "lang": null,
                    "value": "MONGODB_URI=mongodb+srv://<user>:<password>@<cluster-url>?retryWrites=true&w=majority"
                }
            ],
            "preview": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following:",
            "tags": null,
            "facets": {
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals",
            "title": "Fundamentals",
            "headings": [],
            "paragraphs": "Learn how to perform the following tasks using the Go driver in the\nFundamentals section: Connect to MongoDB Specify an API Version How the Driver Uses Context Authenticate with MongoDB Use Enterprise Authentication with MongoDB Work with BSON Read from and Write to MongoDB Perform Aggregations Construct Indexes Perform Transactions Record Log Messages Run A Database Command Specify Collations to Order Results Use Driver Events in Your Code Store and Retrieve Large Files Use a Time Series Collection Encrypt Fields Work with Geospatial Data",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/find-operations",
            "title": "Find Operations",
            "headings": [],
            "paragraphs": "Find a Document Find Multiple Documents",
            "code": [],
            "preview": "Learn by example: how to create queries and retrieve data by using the MongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/deleteOne",
            "title": "Delete a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can delete a document in a collection by using the  DeleteOne() \nmethod. The following example matches documents in the  movies  collection\nin which the  title  is \"Twilight\", deleting the first document\nmatched: View a  fully runnable example. Read the  Usage Examples  to learn how\nto run this example. After you run the full example, it removes the following document\nin the  movies  collection: For an example on how to find a document, see  Find a Document . To learn more about deleting documents, see  Delete Documents . DeleteOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nfilter := bson.D{{\"title\", \"Twilight\"}}\n\n// Deletes the first document that has a \"title\" value of \"Twilight\"\nresult, err := coll.DeleteOne(context.TODO(), filter)\n\n// Prints a message if any errors occur during the operation\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// result truncated\n{ \"_id\": ObjectId(\"...\"), ..., \"title\": \"Twilight\", ... }"
                }
            ],
            "preview": "You can delete a document in a collection by using the DeleteOne()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/insertMany",
            "title": "Insert Multiple Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can insert multiple documents into a collection by using the  InsertMany() \nmethod. This example uses the following  Restaurant  struct as a model for documents\nin the  restaurants  collection: The  omitempty   struct tag  omits the corresponding\nfield from the inserted document when left empty. The following example inserts two new documents to the  restaurants \ncollection: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. After you run the full example, you can find the following inserted\ndocuments in the  restaurants  collection: For an example on how to find multiple documents, see the\n Find Multiple Documents  usage example. To learn more about inserting documents, see\n inserting documents . InsertMany()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Restaurant struct {\n\tName         string\n\tRestaurantId string        `bson:\"restaurant_id,omitempty\"`\n\tCuisine      string        `bson:\"cuisine,omitempty\"`\n\tAddress      interface{}   `bson:\"address,omitempty\"`\n\tBorough      string        `bson:\"borough,omitempty\"`\n\tGrades       []interface{} `bson:\"grades,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\n\n// Creates two sample documents describing restaurants\nnewRestaurants := []interface{}{\n\tRestaurant{Name: \"Rule of Thirds\", Cuisine: \"Japanese\"},\n\tRestaurant{Name: \"Madame Vo\", Cuisine: \"Vietnamese\"},\n}\n\n// Inserts sample documents into the collection\nresult, err := coll.InsertMany(context.TODO(), newRestaurants)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "  { \"_id\": ObjectID(\"...\"), \"name\": \"Rule of Thirds\", \"cuisine\": \"Japanese\"},\n  { \"_id\": ObjectID(\"...\"), \"name\": \"Madame Vo\", \"cuisine\": \"Vietnamese\"}"
                }
            ],
            "preview": "You can insert multiple documents into a collection by using the InsertMany()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/updateOne",
            "title": "Update a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can update a document in a collection by using the  UpdateOne() \nmethod. The following example performs the following on the  restaurants \ncollection: View a  fully runnable example. Read the  Usage Examples  to learn how\nto run this example. Matches a document with a specific  _id Creates a new field in the matched document called  avg_rating  with a value of 4.4 After you run the full example, you can find the following updated\ndocument in the  restaurants  collection: For an example on how to find a document, see  Find a Document . To learn more about replacing documents, specifying query filters, and\nhandling potential errors, see  Modify Documents . To learn more about update operators,\nsee the  MongoDB update operator reference documentation . UpdateOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\nid, _ := primitive.ObjectIDFromHex(\"5eb3d668b31de5d588f42a7a\")\nfilter := bson.D{{\"_id\", id}}\n\n// Creates instructions to add the \"avg_rating\" field to documents\nupdate := bson.D{{\"$set\", bson.D{{\"avg_rating\", 4.4}}}}\n\n// Updates the first document that has the specified \"_id\" value\nresult, err := coll.UpdateOne(context.TODO(), filter, update)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// result truncated\n{\n   \"_id\" : ObjectId(\"5eb3d668b31de5d588f42a7a\"),\n   ...\n   \"name\" : \"Green House Cafe\",\n   \"restaurant_id\" : \"40372112\",\n   \"avg_rating\" : 4.4\n}"
                }
            ],
            "preview": "You can update a document in a collection by using the UpdateOne()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/findOne",
            "title": "Find a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can retrieve a single document from a collection by using the\n FindOne()  method. This example uses the following  Restaurant  struct as a model for documents\nin the  restaurants  collection: The following example matches documents in the  restaurants  collection\nin which the  name  is \"Bagels N Buns\", returning the first document\nmatched: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. Running the full example prints the following document, which is stored in the\n result  variable as a  Restaurant  struct: To learn more about specifying query filters and\nhandling potential errors, see\n Retrieve Data . To learn more about query operators,\nsee the  MongoDB query operator reference documentation . FindOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Restaurant struct {\n\tID           primitive.ObjectID `bson:\"_id\"`\n\tName         string\n\tRestaurantId string `bson:\"restaurant_id\"`\n\tCuisine      string\n\tAddress      interface{}\n\tBorough      string\n\tGrades       []interface{}\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\n\n// Creates a query filter to match documents in which the \"name\" is\n// \"Bagels N Buns\"\nfilter := bson.D{{\"name\", \"Bagels N Buns\"}}\n\n// Retrieves the first matching document\nvar result Restaurant\nerr = coll.FindOne(context.TODO(), filter).Decode(&result)\n\n// Prints a message if no documents are matched or if any\n// other errors occur during the operation\nif err != nil {\n\tif err == mongo.ErrNoDocuments {\n\t\treturn\n\t}\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// results truncated\n{\n   \"ID\": \"5eb3d668b31de5d588f42950\",\n   \"Name\": \"Bagels N Buns\",\n   \"RestaurantId\": \"40363427\"\n   \"Address\": [...],\n   \"Borough\": \"Staten Island\",\n   \"Cuisine\": \"Delicatessen\",\n   \"Grades\": [...]\n}"
                }
            ],
            "preview": "You can retrieve a single document from a collection by using the\nFindOne() method.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "quick-reference",
            "title": "Quick Reference",
            "headings": [],
            "paragraphs": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation. Command Syntax",
            "code": [
                {
                    "lang": "go",
                    "value": "err = coll.FindOne(context.TODO(), bson.D{{\"firstName\", Mike}}).Decode(&result)"
                },
                {
                    "lang": "go",
                    "value": "[{firstName Mike}, {lastName Smith} ...]"
                },
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(context.TODO(), bson.D{{\"age\", bson.D{{\"$gte\", 46}}}})"
                },
                {
                    "lang": "go",
                    "value": "[{firstName Kyle}, {age 51}, ... ]\n[{firstName Omar}, {age 47}, ... ]"
                },
                {
                    "lang": "go",
                    "value": "result, err := coll.InsertOne(\n    context.TODO(),\n    bson.D{\n        {\"animal\", \"Dog\"},\n        {\"breed\", \"Beagle\"}\n    }\n)"
                },
                {
                    "lang": "go",
                    "value": "docs := []interface{} {\n    bson.D{{\"firstName\", \"Erik\"}, {\"age\", 27}},\n    bson.D{{\"firstName\", \"Mohammad\"}, {\"lastName\", \"Ahmad\"}, {\"age\", 10}},\n    bson.D{{\"firstName\", \"Todd\"}},\n    bson.D{{\"firstName\", \"Juan\"}, {\"lastName\", \"Pablo\"}}\n }\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "result, err := coll.UpdateOne(\n    context.TODO(),\n    bson.D{{\"firstName\", \"Erik\"}},\n    bson.D{{\"$set\", bson.D{{\"age\", 28}}}}\n)\nfmt.Printf(\"The number of modified documents: %d\\n\", result.ModifiedCount)"
                },
                {
                    "lang": "go",
                    "value": "The number of modified documents: 1"
                },
                {
                    "lang": "go",
                    "value": "result, err := coll.UpdateMany(\n    context.TODO(),\n    bson.D{{\"age\", bson.D{{\"$gte\", 58}}}},\n    bson.D{{\"$set\", bson.D{{\"description\", \"Senior\"}}}}\n)\nfmt.Printf(\"The number of modified documents: %d\\n\", result.ModifiedCount)"
                },
                {
                    "lang": "go",
                    "value": "The number of modified documents: 4"
                },
                {
                    "lang": "go",
                    "value": "result, err := coll.UpdateMany(\n    context.TODO(),\n    bson.D{},\n    bson.D{{\"$push\", bson.D{{family, \"brother\"}}}}\n)"
                },
                {
                    "lang": "go",
                    "value": "[{firstName Xiao}, {family [\"brother\"]}, ... ]\n[{firstName Omar}, {family [\"brother\", \"mother\"]}, ... ]\n..."
                },
                {
                    "lang": "go",
                    "value": "result, err := coll.ReplaceOne(\n    context.TODO(),\n    bson.D{{\"firstName\", \"Mick\"}},\n    bson.D{{\"firstName\", \"Mike\"}, {\"lastName\", \"Doe\"}}\n)"
                },
                {
                    "lang": "go",
                    "value": "[{{firstName Mike}, {lastName Doe} }]"
                },
                {
                    "lang": "go",
                    "value": "result, err := coll.DeleteOne(\n    context.TODO(),\n    bson.D{{\"firstName\", \"Xiao\"}}\n)"
                },
                {
                    "lang": "go",
                    "value": "results, err := coll.DeleteMany(\n    context.TODO(),\n    bson.D{{\"age\", bson.D{{\"$lte\", 12}}}}\n)"
                },
                {
                    "lang": "go",
                    "value": "models := []mongo.WriteModel{\n    mongo.NewInsertOneModel().SetDocument(bson.D{{\"firstName\", \"John\"}, {\"age\", 5}}),\n    mongo.NewUpdateOneModel().SetFilter(bson.D{{\"firstName\", \"Juan\"}}).\n        SetUpdate(bson.D{{\"$set\", bson.D{{\"age\", 12}}}}),\n}\nopts := options.BulkWrite().SetOrdered(true)\n\nresults, err := coll.BulkWrite(context.TODO(), models, opts)"
                },
                {
                    "lang": "go",
                    "value": "[{firstName John}, {age 5} ... ]\n[{firstName Juan}, {age 12} ... ]"
                },
                {
                    "lang": "go",
                    "value": "pipeline := mongo.Pipeline{bson.D{{\"$match\", bson.D{{\"operationType\", \"insert\"}}}}}\ncs, err := coll.Watch(context.TODO(), pipeline)"
                },
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(context.TODO(), bson.D{})\n\nfor cursor.Next(context.TODO()) {\n    var result bson.D\n    if err := cursor.Decode(&result); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(result)\n}"
                },
                {
                    "lang": "go",
                    "value": "[{firstName Doug} ... ]\n[{firstName Erik} ...]\n[{lastName Chang} ...]\n..."
                },
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(context.TODO(), bson.D{})\n\nvar results []bson.D\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "[{name Mike} ... ]\n[{name Edgar} ...]\n[{name Freddie} ...]\n..."
                },
                {
                    "lang": "go",
                    "value": "count, err := coll.CountDocuments(context.TODO(), bson.D{})"
                },
                {
                    "lang": "go",
                    "value": "6"
                },
                {
                    "lang": "go",
                    "value": "results, err := coll.Distinct(context.TODO(), \"firstName\", bson.D{})"
                },
                {
                    "lang": "go",
                    "value": "Mike\nXiao\n..."
                },
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(context.TODO(), bson.D{}, options.Find().SetLimit(2))"
                },
                {
                    "lang": "go",
                    "value": "[{breed Beagle} ... ]\n[{breed German Shepard} ...]"
                },
                {
                    "lang": "go",
                    "value": "// the collection has 6 documents\ncursor, err := coll.Find(context.TODO(), bson.D{}, options.Find().SetSkip(4))"
                },
                {
                    "lang": "go",
                    "value": "[{item Pen} ... ]\n[{item Chair} ...]"
                },
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(context.TODO(), bson.D{}, options.Find().SetSort(bson.D{{\"age\", 1}}))"
                },
                {
                    "lang": "go",
                    "value": "[{firstName Dev} {age 5} ... ]\n[{firstName Jose} {age 7} ... ]\n[{firstName Om} {age 8} ... ]"
                },
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(\n    context.TODO(),\n    bson.D{},\n    options.Find().SetProjection(\n        bson.D{{\"age\", 0}, {\"_id\",0}}\n    )\n)"
                },
                {
                    "lang": "go",
                    "value": "[{firstName Lester}]\n[{firstName Wendall} {lastName Griffin}]\n..."
                },
                {
                    "lang": "go",
                    "value": "model := mongo.IndexModel{Keys: bson.D{{\"firstName\", 1}, {\"lastName\", -1}}}\nname, err := coll.Indexes().CreateOne(context.TODO(), model)"
                },
                {
                    "lang": "go",
                    "value": "// only searches fields with text indexes\ncursor, err := coll.Find(context.TODO(), bson.D{{\"$text\", bson.D{{\"$search\", \"beagle\"}}}})"
                },
                {
                    "lang": "go",
                    "value": "[{\"firstName\": \"Emily\" , \"Description\": \"I love to play sports and walk my beagle.\"} ... ]"
                }
            ],
            "preview": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation.",
            "tags": null,
            "facets": {
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/count",
            "title": "Count Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can get an approximation on the number of documents in a\ncollection by using the  EstimatedDocumentCount()  method and an exact\nnumber of documents in a collection by using the  CountDocuments() \nmethod. The following example performs the following on the  movies \ncollection: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. Approximates the number of documents in the collection Counts the number of documents in which the  countries  contains \"China\" After you run the full example, you should see the following: There are about  23541  documents in the  movies  collection There are  303  documents in the  movies  collection that contain \"China\" in the  countries  field The exact number of documents may vary depending on your data set. To learn more about counting documents, see\n Count Documents . CountDocuments() EstimatedDocumentCount()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\n\n// Specifies a filter to match documents where the \"countries\" array\n// includes a value of \"China\"\nfilter := bson.D{{\"countries\", \"China\"}}\n\n// Retrieves and prints the estimated number of documents in the collection\nestCount, estCountErr := coll.EstimatedDocumentCount(context.TODO())\nif estCountErr != nil {\n\tpanic(estCountErr)\n}\n\n// Retrieves and prints the number of documents in the collection\n// that match the filter\ncount, err := coll.CountDocuments(context.TODO(), filter)\nif err != nil {\n\tpanic(err)\n}"
                }
            ],
            "preview": "You can get an approximation on the number of documents in a\ncollection by using the EstimatedDocumentCount() method and an exact\nnumber of documents in a collection by using the CountDocuments()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/distinct",
            "title": "Retrieve Distinct Values of a Field",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can retrieve a list of distinct values for a field across a\ncollection by using the  Distinct()  method. The following example performs the following on the  movies \ncollection: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. Matches documents in which the  directors  contains \"Natalie Portman\" Returns distinct values of the  title  from the matched documents After you run the full example, it returns an empty slice of an\n interface  type that contains the following values: To learn more about retrieving distinct values, see  Retrieve Distinct Values . Distinct()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nfilter := bson.D{{\"directors\", \"Natalie Portman\"}}\n\n// Retrieves the distinct values of the \"title\" field in documents\n// that match the filter\nresults, err := coll.Distinct(context.TODO(), \"title\", filter)\n\n// Prints a message if any errors occur during the operation\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "none",
                    "value": " A Tale of Love and Darkness\n New York, I Love You"
                }
            ],
            "preview": "You can retrieve a list of distinct values for a field across a\ncollection by using the Distinct() method.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/struct-tagging",
            "title": "Use Struct Tags",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can specify the way that the Go Driver converts Go\nstructs to  BSON  by using struct tags. The following code declares a struct of type  BlogPost . This struct\ncontains a struct tag that maps the  WordCount  field to the BSON\nfield name  word_count . By default, the driver marshals the other\nfields as the lowercase of the struct field name: The following example creates a  BlogPost  instance and inserts it\ninto the  posts  collection. During the insert operation, the driver\ninterprets the struct tag to marshal the  WordCount \nstruct field as  word_count : View a  fully runnable example. Read the  Usage Examples  to learn how\nto run this example. Read the  Usage Examples  to learn how\nto run this example. After you run the full example, you can find the following document\nin the  posts  collection: For an example on how to find a document, see  Find a Document . To learn more about using struct tags, converting to/from BSON, and\nhandling potential errors, see  working with BSON . Structs and Struct Tags InsertOne() FindOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "type BlogPost struct {\n\tTitle       string\n\tAuthor      string\n\tWordCount   int `bson:\"word_count\"`\n\tLastUpdated time.Time\n\tTags        []string\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_training\").Collection(\"posts\")\n\npost := BlogPost{\n\tTitle:       \"Annuals vs. Perennials?\",\n\tAuthor:      \"Sam Lee\",\n\tWordCount:   682,\n\tLastUpdated: time.Now(),\n\tTags:        []string{\"seasons\", \"gardening\", \"flower\"},\n}\n\n// Inserts a document describing a blog post into the collection\n_, err = coll.InsertOne(context.TODO(), post)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n    \"_id\" : ObjectId(\"...\"),\n    \"title\" : \"Annuals vs. Perennials?\",\n    \"author\" : \"Sam Lee\",\n    \"word_count\" : 682,\n    \"lastupdated\": ...,\n    \"tags\" : [\"seasons\", \"gardening\", \"flower\"]\n}"
                }
            ],
            "preview": "You can specify the way that the Go Driver converts Go\nstructs to BSON by using struct tags.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/updateMany",
            "title": "Update Multiple Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can update multiple documents in a collection by using the  UpdateMany() \nmethod. The following example performs the following on the\n listingsAndReviews  collection: View a  fully runnable example. Read the  Usage Examples  to learn how\nto run this example. Matches documents in which the market field of the address subdocument,  address.market  is \"Sydney\" Updates the  price  in the matched documents by 1.15 times After you run the full example, you can find the following updated\ndocuments in the  listingsAndReviews  collection: For an example on how to find multiple documents, see  Find Multiple Documents . To learn more about replacing documents, specifying query filters, and\nhandling potential errors, see  Modify Documents . To learn more about update operators,\nsee the  MongoDB update operator reference documentation . UpdateMany()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_airbnb\").Collection(\"listingsAndReviews\")\nfilter := bson.D{{\"address.market\", \"Sydney\"}}\n\n// Creates instructions to update the values of the \"price\" field\nupdate := bson.D{{\"$mul\", bson.D{{\"price\", 1.15}}}}\n\n// Updates documents in which the value of the \"address.market\"\n// field is \"Sydney\"\nresult, err := coll.UpdateMany(context.TODO(), filter, update)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// results truncated\n...\n{ \"_id\" : \"10091713\", ... , \"name\" : \"Surry Hills Studio\", ... , \"price\" : 181.00, ... },\n{ \"_id\" : \"9908871\", ... , \"name\" : \"Family friendly beach house\", ... , \"price\" : 751.00, ... },\n{ \"_id\" : \"20989061\", ... , \"name\" : \"Big and sunny Narraben room\", ... , \"price\" : 60.00, ... },\n..."
                }
            ],
            "preview": "You can update multiple documents in a collection by using the UpdateMany()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/changestream",
            "title": "Monitor Data Changes",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can open a change stream on a  MongoCollection ,\n MongoDatabase , or  MongoClient  by using the  Watch()  method. The following example opens a change stream on the  restaurants  collection\nand prints inserted documents: View a  fully runnable example. Read the  Usage Examples  to learn how\nto run this example. After you run the full example, run the  Insert a\nDocument usage example  in a different\nshell. Once you run the insert operation, you should see the following\noutput: Make sure to shut down this usage example once you finish by closing\nyour terminal. To learn more about opening a change stream and handling\npotential errors, see: Fundamentals page on  change streams MongoDB Server Manual  Change Streams Documentation Watch()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\n\n// Creates instructions to watch for insert operations\npipeline := mongo.Pipeline{bson.D{{\"$match\", bson.D{{\"operationType\", \"insert\"}}}}}\n\n// Creates a change stream that receives change events\ncs, err := coll.Watch(context.TODO(), pipeline)\nif err != nil {\n\tpanic(err)\n}\ndefer cs.Close(context.TODO())\n\nfmt.Println(\"Waiting For Change Events. Insert something in MongoDB!\")\n\n// Prints a message each time the change stream receives an event\nfor cs.Next(context.TODO()) {\n\tvar event bson.M\n\tif err := cs.Decode(&event); err != nil {\n\t\tpanic(err)\n\t}\n\toutput, err := json.MarshalIndent(event[\"fullDocument\"], \"\", \"    \")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%s\\n\", output)\n}\nif err := cs.Err(); err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// results truncated\n{\n  \"_id\": ...,\n  \"name\": \"8282\",\n  \"cuisine\": \"Korean\"\n}"
                }
            ],
            "preview": "Learn by example: how to monitor data changes in MongoDB by using the MongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/write-operations",
            "title": "Write Operations",
            "headings": [],
            "paragraphs": "Insert a Document Insert Multiple Documents Update a Document Update Multiple Documents Replace a Document Delete a Document Delete Multiple Documents",
            "code": [],
            "preview": "Learn by example: how to insert, update, and delete data by using the MongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/find",
            "title": "Find Multiple Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can find multiple documents in a collection by using the  Find() \nmethod. This example uses the following  Restaurant  struct as a model for documents\nin the  restaurants  collection: The following example matches documents in the  restaurants  collection\nin which the  cuisine  is \"Italian\", returning all documents matched: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. Running the full example prints the following documents, which are stored in\nthe  results  variable as  Restaurant  structs: To learn more about specifying query filters and\nhandling potential errors, see\n Retrieve Data . To learn more about query operators,\nsee the  MongoDB query operator reference documentation . Find() Cursor",
            "code": [
                {
                    "lang": "go",
                    "value": "type Restaurant struct {\n\tID           primitive.ObjectID `bson:\"_id\"`\n\tName         string\n\tRestaurantId string `bson:\"restaurant_id\"`\n\tCuisine      string\n\tAddress      interface{}\n\tBorough      string\n\tGrades       interface{}\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\n\n// Creates a query filter to match documents in which the \"cuisine\"\n// is \"Italian\"\nfilter := bson.D{{\"cuisine\", \"Italian\"}}\n\n// Retrieves documents that match the query filer\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// results truncated\n...\n{ ... , \"Name\" : \"Epistrophy Cafe\", \"RestaurantId\": \"41117553\", \"Cuisine\" : \"Italian\", ... },\n{ ... , \"Name\" : \"Remi\", \"RestaurantId\": \"41118090\", \"Cuisine\" : \"Italian\", ... },\n{ ... , \"Name\" : \"Sant Ambroeus\", \"RestaurantId\": \"41120682\", \"Cuisine\" : \"Italian\", ... },\n..."
                }
            ],
            "preview": "You can find multiple documents in a collection by using the Find()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/replaceOne",
            "title": "Replace a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can replace a document in a collection by using the  ReplaceOne() \nmethod. This example uses the following  Restaurant  struct as a model for documents\nin the  restaurants  collection: The  omitempty   struct tag  omits the corresponding\nfield from the inserted document when left empty. This example performs the following actions on the  restaurants \ncollection: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. Matches a document in which the  name  is \"Madame Vo\" Replaces the matched document with a new document After you run the full example, you can find the following replaced\ndocument in the  restaurants  collection: For an example on how to find a document, see the  Find a Document  usage\nexample. To learn more about replacing documents, specifying query filters, and\nhandling potential errors, see  Modify Documents . ReplaceOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Restaurant struct {\n\tName         string\n\tRestaurantId string        `bson:\"restaurant_id,omitempty\"`\n\tCuisine      string        `bson:\"cuisine,omitempty\"`\n\tAddress      interface{}   `bson:\"address,omitempty\"`\n\tBorough      string        `bson:\"borough,omitempty\"`\n\tGrades       []interface{} `bson:\"grades,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\nfilter := bson.D{{\"name\", \"Madame Vo\"}}\n\n// Creates a new document containing \"Name\" and \"Cuisine\" fields\nreplacement := Restaurant{Name: \"Monsieur Vo\", Cuisine: \"Asian Fusion\"}\n\n// Replaces the first document that matches the filter with a new document\nresult, err := coll.ReplaceOne(context.TODO(), filter, replacement)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\" : ObjectId(\"...\"),\n   \"name\" : \"Monsieur Vo\",\n   \"cuisine\" : \"Asian Fusion\"\n}"
                }
            ],
            "preview": "You can replace a document in a collection by using the ReplaceOne()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/command",
            "title": "Run a Command",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can run commands directly on your MongoDB server by using the\n RunCommand()  method. The following example retrieves statistics about the\n sample_restaurants  database: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. After you run the full example, it returns a  SingleResult  type\nthat contains the following values: The  result  variable may vary depending on the contents of your\ncollection. RunCommand()",
            "code": [
                {
                    "lang": "go",
                    "value": "db := client.Database(\"sample_restaurants\")\n\n// Retrieves statistics about the specified database\ncommand := bson.D{{\"dbStats\", 1}}\n\nvar result bson.M\n// Runs the command and prints the database statistics\nerr := db.RunCommand(context.TODO(), command).Decode(&result)\n\n// Prints a message if any errors occur during the command execution\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// results truncated\n{\n    \"avgObjSize\": 548.4101901854896,\n    \"collections\": 2,\n    \"dataSize\": 14014074,\n    \"db\": \"sample_restaurants\",\n    \"indexSize\": 286720,\n    ...,\n}"
                }
            ],
            "preview": "You can run commands directly on your MongoDB server by using the\nRunCommand() method.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/bulkWrite",
            "title": "Perform Bulk Operations",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can perform bulk write operations on a collection by using the\n BulkWrite()  method. This example uses the following  Restaurant  struct as a model for documents\nin the  restaurants  collection: The  omitempty   struct tag  omits the corresponding\nfield from the inserted document when left empty. The following example performs the following in order on the  restaurants \ncollection: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. Matches a document in which the  name  is \"Cafe Tomato\" and replaces it with a new document Matches a document in which the  name  is \"Cafe Zucchini\" and updates\nthe value to \"Zucchini Land\" After you run the full example, you can find the following document\nin the  restaurants  collection: For an example on how to find a document, see  Find a Document . To learn more about performing bulk write operations on a collection\nand handling potential errors, see  Bulk Operations . BulkWrite() NewUpdateOneModel() NewReplaceOneModel()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Restaurant struct {\n\tName         string\n\tRestaurantId string        `bson:\"restaurant_id,omitempty\"`\n\tCuisine      string        `bson:\"cuisine,omitempty\"`\n\tAddress      interface{}   `bson:\"address,omitempty\"`\n\tBorough      string        `bson:\"borough,omitempty\"`\n\tGrades       []interface{} `bson:\"grades,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\n\n// Creates write models that specify replace and update operations\nmodels := []mongo.WriteModel{\n\tmongo.NewReplaceOneModel().SetFilter(bson.D{{\"name\", \"Cafe Tomato\"}}).\n\t\tSetReplacement(Restaurant{Name: \"Cafe Zucchini\", Cuisine: \"French\"}),\n\tmongo.NewUpdateOneModel().SetFilter(bson.D{{\"name\", \"Cafe Zucchini\"}}).\n\t\tSetUpdate(bson.D{{\"$set\", bson.D{{\"name\", \"Zucchini Land\"}}}}),\n}\n\n// Specifies that the bulk write is ordered\nopts := options.BulkWrite().SetOrdered(true)\n\n// Runs a bulk write operation for the specified write operations\nresults, err := coll.BulkWrite(context.TODO(), models, opts)"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": ObjectId(\"...\"),\n  \"name\": \"Zucchini Land\",\n  \"cuisine\": \"French\"\n}"
                }
            ],
            "preview": "You can perform bulk write operations on a collection by using the\nBulkWrite() method.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/deleteMany",
            "title": "Delete Multiple Documents",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can delete multiple documents in a collection by using the\n DeleteMany()  method. The following example matches documents in the  movies  collection\nin which the  runtime  is greater than 800 minutes, deleting all\ndocuments matched: View a  fully runnable example. Read the  Usage Examples  to learn how\nto run this example. After you run the full example, it removes the following documents\nin the  movies  collection: For an example on how to find multiple documents, see  Find Multiple Documents . To learn more about deleting documents, see  Delete Documents . DeleteMany()",
            "code": [
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nfilter := bson.D{{\"runtime\", bson.D{{\"$gt\", 800}}}}\n\n// Deletes all documents that have a \"runtime\" value greater than 800\nresults, err := coll.DeleteMany(context.TODO(), filter)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "// results truncated\n{ \"_id\": ObjectId(\"573a1397f29313caabce69db\"), ... , \"runtime\": 1256, ... },\n{ \"_id\": ObjectId(\"573a1397f29313caabce75fe\"), ... , \"runtime\": 910, ... },\n{ \"_id\": ObjectId(\"573a1399f29313caabcee1aa\"), ... , \"runtime\": 1140, ... },\n{ \"_id\": ObjectId(\"573a13a6f29313caabd18ae0\"), ... , \"runtime\": 877, ... }"
                }
            ],
            "preview": "You can delete multiple documents in a collection by using the\nDeleteMany() method.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/monitoring",
            "title": "Monitoring",
            "headings": [],
            "paragraphs": "Cluster Monitoring : monitor changes\nin your cluster configuration Command Monitoring : monitor command\nexecution Connection Pool Monitoring :\nmonitor changes in the connection pool",
            "code": [],
            "preview": null,
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "usage-examples/insertOne",
            "title": "Insert a Document",
            "headings": [
                "Example",
                "Expected Result",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "You can insert a document into a collection by using the  InsertOne() \nmethod. This example uses the following  Restaurant  struct as a model for documents\nin the  restaurants  collection: The  omitempty   struct tag  omits the corresponding\nfield from the inserted document when left empty. The following example inserts a new document to the  restaurants  collection: View a  fully runnable example Read the  Usage Examples  to learn how\nto run this example. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. After you run the full example, you can find the following inserted\ndocument in the  restaurants  collection: For an example on how to find a document, see the  Find a Document  usage\nexample. To learn more about inserting documents, see\n inserting documents . InsertOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Restaurant struct {\n\tName         string\n\tRestaurantId string        `bson:\"restaurant_id,omitempty\"`\n\tCuisine      string        `bson:\"cuisine,omitempty\"`\n\tAddress      interface{}   `bson:\"address,omitempty\"`\n\tBorough      string        `bson:\"borough,omitempty\"`\n\tGrades       []interface{} `bson:\"grades,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_restaurants\").Collection(\"restaurants\")\nnewRestaurant := Restaurant{Name: \"8282\", Cuisine: \"Korean\"}\n\nresult, err := coll.InsertOne(context.TODO(), newRestaurant)\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": ObjectId(\"...\"),\n  \"name\": \"8282\",\n  \"cuisine\": \"Korean\"\n}"
                }
            ],
            "preview": "You can insert a document into a collection by using the InsertOne()\nmethod.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud",
            "title": "CRUD Operations",
            "headings": [],
            "paragraphs": "CRUD (Create, Read, Update, Delete) operations enable you to work with\ndata stored in MongoDB. Some operations combine aspects of read and write operations. To learn\nmore about these hybrid methods, see  Compound Operations . To learn about how to modify the way your CRUD operations execute, see  Modify Execution of CRUD Operations . Read Operations  find and return\ndocuments stored in your database. Write Operations  insert, modify,\nor delete documents in your database.",
            "code": [],
            "preview": "CRUD (Create, Read, Update, Delete) operations enable you to work with\ndata stored in MongoDB.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/stable-api",
            "title": "Stable API",
            "headings": [
                "Overview",
                "Specify an API Version",
                "Example",
                "Modify Behavior",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "The Stable API feature requires MongoDB Server 5.0 or later. Only use the Stable API feature if all the MongoDB\nservers you are connecting to support this feature. In this guide, you can learn how to specify  Stable API \ncompatibility when connecting to a MongoDB instance or replica set. The Stable API feature forces the server to run operations with\nbehaviors compatible with the  API version  you specify. An API\nversion defines the expected behavior of the operations it covers and\nthe format of server responses. The operations and the server responses\nmay differ depending on the API version you specify. When you use the Stable API feature with an official MongoDB driver, you\ncan update your driver or server without worrying about backward\ncompatibility issues of the commands covered by the Stable API. To learn more about the commands the server covers, see\n Stable API . The  Client  optionally takes a  ServerAPIOptions  type through\nthe  ClientOptions . To specify an API version, append the  SetServerAPIOptions()  method\nwith your  server API options  to your\n ClientOptions . After you specify an API version, the  Client  runs\noperations that are compatible with the API version for the duration of\nyour connection. The MongoDB Go Driver currently only supports  ServerAPIVersion1 . The following example instantiates a  Client  that sets the\nStable API version and connects to a server. You can further modify the behavior of the stable API feature by\nappending to the  ServerAPIOptions  type. If you don't specify any\noptions, the driver uses the default values for each option. Method Description ServerAPI() SetStrict() SetDeprecationErrors() This example specifies for the server to perform the following actions: Use Version 1 of the API Return errors for features that aren't part of Version 1 Return errors for deprecated features To learn more about connecting to your MongoDB instance or replica set,\nsee  Connection Guide . For more information on the options in this section, see the following\nAPI Documentation: Client ClientOptions ServerAPI() ServerAPIOptions ServerApiVersion SetDeprecationErrors() SetStrict()",
            "code": [
                {
                    "lang": "go",
                    "value": "// Specify a server URI to connect to\nuri := \"mongodb://<hostname>:<port>\"\n\n// Specify the Stable API version in the ClientOptions object\nserverAPI := options.ServerAPI(options.ServerAPIVersion1)\n\n// Pass in the URI and the ClientOptions to the Client\nclient, err := mongo.Connect(options.Client().ApplyURI(uri).SetServerAPIOptions(serverAPI))\nif err != nil {\n    panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "// Specify a server URI to connect to\nuri := \"mongodb://<hostname>:<port>\"\n\n// Specify the Stable API version and append options in the ClientOptions object\nserverAPI := options.ServerAPI(options.ServerAPIVersion1).SetStrict(true).SetDeprecationErrors(true)\n\n// Pass in the URI and the ClientOptions to the Client\nclient, err := mongo.Connect(options.Client().ApplyURI(uri).SetServerAPIOptions(serverAPI))\nif err != nil {\n    panic(err)\n}"
                }
            ],
            "preview": "In this guide, you can learn how to specify Stable API\ncompatibility when connecting to a MongoDB instance or replica set.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/enterprise-auth",
            "title": "Enterprise Authentication Mechanisms",
            "headings": [
                "Overview",
                "Authenticate to GSSAPI/Kerberos",
                "Example",
                "Set Custom SERVICE_NAME and SERVICE_REALM Fields",
                "Authenticate to LDAP (PLAIN)",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to authenticate in MongoDB using the\n authentication mechanisms  available in the MongoDB Enterprise Edition.\nAuthentication mechanisms are processes by which the driver and server confirm\nthe identity of a client to ensure security before connecting. You can use the following authentication mechanisms with the latest version of\nthe MongoDB Enterprise Edition: To authenticate using another mechanism, see the\n Authentication Mechanisms  fundamentals page. To learn\nmore about establishing a connection to your MongoDB cluster, see the\n Connection Guide . You can specify your authentication mechanism and credentials when connecting to\nMongoDB through the following methods: GSSAPI/Kerberos LDAP (Plain) Using a  connection string URI . To learn more about using a\nconnection string URI for enterprise authentication, see the  Server manual\nentry on connection string URIs . Specifying credentials and an authentication mechanism in the\n Credential  type. The Generic Security Services API (GSSAPI) authentication mechanism allows the\nuser to authenticate to a Kerberos service using the user's principal. You must use the  gssapi   build tag \nand specify  cgo support  during\ncompilation to use Kerberos authentication.  cgo  support is enabled by\ndefault unless you previously set environment variables to\ncross-compile to a different platform. To use the  gssapi  build tag,\ncompile your code with the following command: This example specifies the authentication mechanism using the following\nplaceholders: The following code shows how you can define a  Credential  struct to\nauthenticate to Kerberos and create a client with your authentication\npreferences: You don't need to define a password or the  PasswordSet  field in\nyour  Credential  struct if you store authentication keys in\n keytab  files. You can initialize a credential cache for\nauthenticating the Kerberos principal using the  kinit  binary. To\nlearn more about the  kinit  binary, see the  Oracle documentation . The following command shows how you can invoke a credential cache for a\nsample username: You can alternatively authenticate using a connection string URI,\nspecifying your  URL-encoded  Kerberos\nprincipal, password, and  hostname , the network address of your\nMongoDB server: username : Your Kerberos principal. A sample username is  myuser@KERBEROS.EXAMPLE.COM . password : Your Kerberos user's password. You can also store your\npassword in a  keytab  file to avoid exposing your\npassword in your code. connection uri : Your connection string URI. You can specify additional properties with your authentication\nmechanism using the  AuthMechanismProperties  field in the\n Credential  struct. The default service name for Kerberos is\n\"mongodb\". The following code shows how you can set custom values\nfor the  SERVICE_NAME  and  SERVICE_REALM  fields when defining a\n Credential  struct: For additional properties, see the\n Server manual entry on authentication properties . You can authenticate to a Lightweight Directory Access Protocol (LDAP) server\nusing your directory server username and password. This authentication mechanism sends the password to the server in\nplaintext, so use this mechanism only with TLS connections. This example specifies the authentication mechanism using the following\nplaceholders: The following code shows how you can define a  Credential  struct to\nauthenticate to LDAP and create a client with your authentication\npreferences: You can alternatively authenticate using a connection string URI,\nspecifying your LDAP username, password, and  hostname , the network\naddress of your MongoDB server: username : Your LDAP username password : Your LDAP password connection uri : Your connection string URI The method refers to PLAIN instead of LDAP since it\nauthenticates using the PLAIN Simple Authentication and Security Layer\n(SASL) defined in  RFC-4616 . To learn more about the concepts in this guide, see the following documentation: MongoDB Server Support for Kerberos Authentication MongoDB Server Support for LDAP Proxy Authentication Credential  type SetAuth()  method",
            "code": [
                {
                    "lang": "sh",
                    "value": "go build -tags gssapi"
                },
                {
                    "lang": "go",
                    "value": "credential := options.Credential{\n        AuthMechanism: \"GSSAPI\",\n        Username:      \"<username>\",\n        Password:      \"<password>\",\n        PasswordSet:   true,\n}\n\nuri := \"<connection uri>\"\nclientOpts := options.Client().ApplyURI(uri).SetAuth(credential)\n\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "sh",
                    "value": "kinit myuser@KERBEROS.EXAMPLE.COM"
                },
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://<username>:<password>@<hostname>/?authMechanism=GSSAPI\""
                },
                {
                    "lang": "go",
                    "value": "credential := options.Credential{\n        AuthMechanism: \"GSSAPI\",\n        Username:      \"<username>\",\n        Password:      \"<password>\",\n        AuthMechanismProperties: map[string]string{\n                \"SERVICE_REALM\": \"<Kerberos service realm>\",\n                \"SERVICE_NAME\":  \"<service name>\",\n        },\n}"
                },
                {
                    "lang": "go",
                    "value": "credential := options.Credential{\n        AuthMechanism: \"PLAIN\",\n        Username:      \"<username>\",\n        Password:      \"<password>\",\n     }\n\nuri := \"<connection uri>\"\nclientOpts := options.Client().ApplyURI(uri).SetAuth(credential)\n\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://<username>:<password>@<hostname>/?authMechanism=PLAIN\""
                }
            ],
            "preview": "In this guide, you can learn how to authenticate in MongoDB using the\nauthentication mechanisms available in the MongoDB Enterprise Edition.\nAuthentication mechanisms are processes by which the driver and server confirm\nthe identity of a client to ensure security before connecting.",
            "tags": "security, code example, credentials",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/geo",
            "title": "Work with Geospatial Data",
            "headings": [
                "Overview",
                "Store Geospatial Data",
                "GeoJSON",
                "Positions",
                "Types",
                "Legacy Coordinate Pairs",
                "Geospatial Indexes",
                "2dsphere",
                "2d",
                "Geospatial Queries",
                "Query Operators",
                "Examples",
                "Query by Proximity",
                "Query Within a Range",
                "Additional Resources"
            ],
            "paragraphs": "In this guide, you can learn how to work with  geospatial data ; data formats,\nindexes, and queries. Geospatial\ndata represents a geographic location on the surface of the Earth, or data\non a Euclidean plane. Examples of geospatial data include: Locations of movie theaters Borders of countries Routes of bicycle rides Dog exercise areas in New York City Points on a graph All geospatial data in MongoDB is stored in one of the following formats: GeoJSON, a format that represents geospatial data on an earth-like\nsphere. Legacy Coordinate Pair, a format that represents geospatial data\non a Euclidean plane. Use GeoJSON to store data that represents geospatial information on\nan earth-like sphere. GeoJSON is composed of one or more  positions \nand a  type . A position represents a single place on Earth and exists in code as an array\ncontaining the following values: The following is the  position  of the MongoDB Headquarters in\nNew York City, NY. Longitude in the first position (required) Latitude in the second position (required) Elevation in the third position (optional) GeoJSON orders coordinates as  longitude  first and  latitude  second.\nThis may be surprising as geographic coordinate system conventions generally list\nlatitude first and longitude second. Make sure to check what format any other\ntools you are working with use. Popular tools such as OpenStreetMap and Google\nMaps list coordinates as latitude first and longitude second. Your GeoJSON object's type determines the geometric shape it represents. Geometric shapes are\nmade up of positions. Here are some common GeoJSON types and how you can specify them with positions: To learn more about the GeoJSON types you can use in MongoDB, see the\n GeoJSON manual entry . For definitive information on GeoJSON, see the\n official IETF specification . Point : a single position. The following  Point  represents the location of\nthe MongoDB Headquarters: LineString : an array of two or more positions that forms a series of line\nsegments. A  LineString  can represent a path, route, border, or any other linear\ngeospatial data. The following  LineString  represents a segment of\n the Great Wall of China : Polygon : an array of positions in which the first and last\nposition are the same and enclose some space. The following\n Polygon  represents  the land within Vatican City : Use legacy coordinate pairs to store data that represents geospatial information\non a two-dimensional Euclidean plane. Your field should contain an array of two values in which the first represents\nthe  x  axis value and the second represents the  y  axis value. For more information on legacy coordinate pairs, see the\n MongoDB server manual page on legacy coordinate pairs . To enable querying on geospatial data, you must create an index that\ncorresponds to the data format. The following index types enable geospatial\nqueries: 2dsphere  for GeoJSON data 2d  for legacy coordinate pairs To query data stored in the GeoJSON format, add the field containing\nboth the  type  and  coordinates  to a  2dsphere  index. The\nfollowing example creates a  2dsphere  index on the  location  field: To query data stored as legacy coordinate pairs, you must add the field containing\nlegacy coordinate pairs to  a  2d  index. The following example creates a\n 2d  index on the  coordinates  field: To perform a geospatial query, create a query filter with a field name and a geospatial\nquery operator. You can specify additional options for certain geospatial query operators\nto limit the documents returned. If you have not done so, you must  create a geospatial index \nto enable geospatial queries. Spherical ( 2dsphere ) and flat ( 2d ) indexes support some, but\nnot all, of the same query operators. For a full list of operators\nand their index compatibility, see the\n manual entry for geospatial queries . To query your geospatial data, use one of the following query operators: When using the  $near  operator, you can specify the following distance operators: When using the  $geoWithin  operator, you can specify the following shape operators: For more information on geospatial query operators, see the\n manual entry for geospatial queries . $near $geoWithin $nearSphere $geoIntersects   requires a 2dsphere index $minDistance $maxDistance $box $polygon $center $centerSphere The following examples use the MongoDB Atlas sample dataset. You can load sample datasets into\nyour database on the free tier of MongoDB Atlas by following the  Get Started with Atlas Guide  or you can  import the sample dataset into a local MongoDB instance . The examples use the  theaters  collection in the  sample_mflix  database\nfrom the sample dataset. The  theaters  collection contains a  2dsphere  index\non the  location.geo  field. The following example queries for documents with a  location.geo  field\nwithin 1000 meters of the MongoDB Headquarters in New York City, NY. It returns documents\nfrom nearest to farthest. The following example queries for documents with a  location.geo  field\nno closer than 2000 meters and no farther than 3000 meters of the MongoDB\nHeadquarters in New York City, NY. It returns documents from nearest to farthest. For more information about working with geospatial data, see the\n manual entry for geospatial data . For more information about supported GeoJSON types, see the the\n GeoJSON manual entry . For more information about geospatial query operators, see the\n manual entry for geospatial queries . For more information about working with indexes with the Go driver, see the\n index guide .",
            "code": [
                {
                    "lang": "go",
                    "value": "[]float64{-73.986805, 40.7620853}"
                },
                {
                    "lang": "go",
                    "value": "bson.D{\n    {\"name\", \"MongoDB HQ\"},\n    {\"location\", bson.D{\n        {\"type\", \"Point\"},\n        {\"coordinates\", []float64{-73.986805, 40.7620853}},\n    }},\n}"
                },
                {
                    "lang": "go",
                    "value": "bson.D{\n    {\"name\", \"Great Wall of China\"},\n    {\"location\", bson.D{\n        {\"type\", \"LineString\"},\n        {\"coordinates\", [][]float64{\n            {116.572, 40.430},\n            {116.570, 40.434},\n            {116.567, 40.436},\n            {116.566, 40.441},\n        }}},\n    },\n}"
                },
                {
                    "lang": "go",
                    "value": "bson.D{\n    {\"name\", \"Vatican City\"},\n    {\"location\", bson.D{\n        {\"type\", \"Polygon\"},\n        {\"coordinates\", [][][]float64{{\n            {116.572, 40.430},\n            {116.570, 40.434},\n            {116.567, 40.436},\n            {116.572, 40.430},\n        }}},\n    }},\n}"
                },
                {
                    "lang": "json",
                    "value": "bson.D{{\"center\", []int16{0, 0}}}"
                },
                {
                    "lang": "go",
                    "value": "indexModel := mongo.IndexModel{\n    Keys:    bson.D{{\"location\", \"2dsphere\"}},\n}\n\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "indexModel := mongo.IndexModel{\n    Keys:    bson.D{{\"location.coordinates\", \"2d\"}},\n}\n\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "mongoDBHQ := bson.D{{\"type\", \"Point\"}, {\"coordinates\", []float64{-73.986805, 40.7620853}}}\n\nfilter := bson.D{\n    {\"location.geo\", bson.D{\n        {\"$near\", bson.D{\n            {\"$geometry\", mongoDBHQ},\n            {\"$maxDistance\", 1000},\n        }},\n    }},\n}\nvar places []bson.D\noutput, err := coll.Find(context.TODO(), filter)\nif err = output.All(context.TODO(), &places); err != nil {\n    panic(err)\n}\n\nfor _, place := range places {\n            res, _ := bson.MarshalExtJSON(place, false, false)\n            fmt.Println(string(res))\n    }"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\":{...},\"theaterId\":1908,\"location\":{\"address\":{...},\"geo\":{\"type\":\"Point\",\"coordinates\":[-73.983487,40.76078]}}}\n{\"_id\":{...},\"theaterId\":1448,\"location\":{\"address\":{...},\"geo\":{\"type\":\"Point\",\"coordinates\":[-73.982094,40.769882]}}}"
                },
                {
                    "lang": "go",
                    "value": "mongoDBHQ := bson.D{{\"type\", \"Point\"}, {\"coordinates\", []float64{-73.986805, 40.7620853}}}\n\n    filter := bson.D{\n            {\"location.geo\",\n                    bson.D{\n                            {\"$nearSphere\", bson.D{\n                                    {\"$geometry\", mongoDBHQ},\n                                    {\"$minDistance\", 2000},\n                                    {\"$maxDistance\", 3000},\n                            }},\n                    }},\n    }\n    var places []bson.D\n    output, err := coll.Find(context.TODO(), filter)\n    if err = output.All(context.TODO(), &places); err != nil {\n            panic(err)\n    }\n\n    for _, place := range places {\n            res, _ := bson.MarshalExtJSON(place, false, false)\n            fmt.Println(string(res))\n    }"
                },
                {
                    "lang": "json",
                    "value": "{\"_id\":{...},\"theaterId\":482,\"location\":{...},\"geo\":{\"type\":\"Point\",\"coordinates\":[-73.99295,40.74194]}}}"
                }
            ],
            "preview": "In this guide, you can learn how to work with geospatial data; data formats,\nindexes, and queries. Geospatial\ndata represents a geographic location on the surface of the Earth, or data\non a Euclidean plane.",
            "tags": "code example, coordinates, location, geographic",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/auth",
            "title": "Authentication Mechanisms",
            "headings": [
                "Overview",
                "Supported Mechanisms",
                "Example Conventions",
                "Default",
                "SCRAM-SHA-256",
                "SCRAM-SHA-1",
                "MONGODB-CR",
                "MONGODB-AWS",
                "X.509"
            ],
            "paragraphs": "In this guide, you can learn how to use each  authentication\nmechanism  available in the MongoDB Community Edition. MongoDB uses\nauthentication mechanisms to confirm an identity and establish trust to\nensure security in the driver and server before connecting. To authenticate using  GSSAPI/Kerberos  or  LDAP , see the\n Enterprise Authentication Mechanisms  fundamentals page. To\nlearn more about establishing a connection to your MongoDB cluster, see\nthe  Connection Guide . The Go driver supports the following authentication mechanisms: The Go Driver establishes a connection with an authentication mechanism\nthrough a  Client \ntype. The  Client  type specifies the mechanism and credentials to use\nas connection options in a  Credential \ntype . To configure these options, pass a  Credential  type to the\n SetAuth() \nmethod of the  ClientOptions \ntype. The following sections demonstrate this process by using the five\nmechanisms the MongoDB Community Edition supports. SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-CR MongoDB-AWS X.509 Each authentication mechanism contains the following placeholders: username  - Your MongoDB username password  - Your MongoDB user's password hostname  - Your MongoDB servers network address, accessible by\nyour client port  - Your MongoDB servers port number authenticationDb  - Your MongoDB database that contains the user's\nauthentication data. If you omit this option, the driver uses the\ndefault value  admin . The default mechanism uses one of the following authentication\nmechanisms depending on what MongoDB versions your server supports: To specify the default authentication mechanism, omit the\n AuthMechanism  option: To learn more about the challenge-response (CR) and salted\nchallenge-response authentication mechanisms (SCRAM) that MongoDB supports,\nsee the  SCRAM  section of the server manual. Mechanism Versions SCRAM-SHA-256 MongoDB 4.0 and later SCRAM-SHA-1 MongoDB 3.0, 3.2, 3.4, and 3.6 MONGODB-CR MongoDB 2.6 and earlier SCRAM-SHA-256  is a salted challenge-response authentication mechanism\n(SCRAM) that uses your username and password, encrypted with the  SHA-256 \nalgorithm, to authenticate your user. To specify the  SCRAM-SHA-256  authentication mechanism, assign the\n AuthMechanism  option the value  \"SCRAM-SHA-256\" : SCRAM-SHA-256  is the default authentication method for MongoDB starting\nin MongoDB 4.0. SCRAM-SHA-1  is a salted challenge-response mechanism (SCRAM) that uses your\nusername and password, encrypted using the  SHA-1  algorithm, to authenticate\nyour user. To specify the  SCRAM-SHA-1  authentication mechanism, assign the\n AuthMechanism  option the value  \"SCRAM-SHA-1\" : SCRAM-SHA-1  is the default authentication method for MongoDB versions\n3.0, 3.2, 3.4, and 3.6. MONGODB-CR  is a challenge-response authentication mechanism that uses your\nusername and password to authenticate your user. This authentication mechanism was deprecated starting in MongoDB 3.6\nand is no longer supported as of MongoDB 4.0. The  MONGODB-AWS  authentication mechanism uses your Amazon Web Services\nIdentity and Access Management (AWS IAM) credentials to authenticate your\nuser. To connect to a MongoDB instance with  MONGODB-AWS  authentication enabled,\nspecify the  MONGODB-AWS  authentication mechanism. The driver checks for your credentials in the following sources in the order\nthey are listed: The MONGODB-AWS authentication mechanism is available only in MongoDB\nversions 4.4 and later. Connection string Environment variables Web identity token file AWS ECS endpoint specified in the  AWS_CONTAINER_CREDENTIALS_RELATIVE_URI \nenvironment variable AWS EC2 endpoint. For more information, see  IAM Roles for Tasks . The driver obtains the credentials only from the first source in which they are found.\nFor example, if you specify your AWS credentials in the connection string, the\ndriver ignores any credentials that you have specified in environment variables. To connect to your MongoDB instance using your AWS IAM credentials, perform the\nfollowing steps: If you must specify an AWS session token, use the temporary\ncredentials returned from an  assume role request . To use temporary credentials, assign the value of your  sessionToken  to\nthe  AuthMechanismProperties  option: The following examples set the appropriate credentials by using the  SetAuth() \nmethod. You can also specify these credentials by using the  ApplyURI() \nmethod. If you use the  ApplyURI()  method you must URL encode the username\nand password to ensure they are correctly parsed. Assign the  AuthMechanism  option the value  MONGODB-AWS Assign the  Username  option the value of your  accessKeyID Assign the  Password  option the value of your  secretAccessKey To authenticate to your MongoDB instance using AWS credentials stored in\nenvironment variables, use a shell to set the variables as follows: After you've set the preceding environment variables, specify the  MONGODB-AWS \nauthentication mechanism as shown in the following example: If you don't require an AWS session token for the role you're\nauthenticating with, omit the line containing  AWS_SESSION_TOKEN . You can use the OpenID Connect (OIDC) token obtained from a web identity provider to authenticate\nto Amazon Elastic Kubernetes Service (EKS) or other services.\nTo use an OIDC token, create a file that contains your token, then\nset the absolute path to this file in an environment variable by using\na shell as shown in the following example: After you've set the preceding environment variable, specify the  MONGODB-AWS \nauthentication mechanism as shown in the following example: The  X.509  authentication mechanism uses\n TLS  with X.509 certificates to\nauthenticate your user, identified by the relative distinguished names\n(RDNs) of your client certificate. When you specify the  X.509 \nauthentication mechanism, the server authenticates the connection using\nthe paths of the following files: To specify the  X.509  authentication mechanism, perform the\nfollowing: tlsCAFile  which contains either a single or a bundle of certificate authorities to trust when making a TLS connection tlsCertificateKeyFile  which references the path to the client certificate file or the client private key file Assign the  tlsCAFile  the path to its file in the connection string Assign the  tlsCertificateKeyFile  the path to its file in the connection string Assign the  AuthMechanism  option the value  \"MONGODB-X509\"",
            "code": [
                {
                    "lang": "go",
                    "value": "credential := options.Credential{\n   AuthSource: \"<authenticationDb>\",\n   Username: \"<username>\",\n   Password: \"<password>\",\n}\nclientOpts := options.Client().ApplyURI(\"mongodb://<hostname>:<port>\").\n   SetAuth(credential)\n\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "go",
                    "value": "credential := options.Credential{\n   AuthMechanism: \"SCRAM-SHA-256\",\n   AuthSource: \"<authenticationDb>\",\n   Username: \"<username>\",\n   Password: \"<password>\",\n}\nclientOpts := options.Client().ApplyURI(\"mongodb://<hostname>:<port>\").\n   SetAuth(credential)\n\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "go",
                    "value": "credential := options.Credential{\n   AuthMechanism: \"SCRAM-SHA-1\",\n   AuthSource: \"<authenticationDb>\",\n   Username: \"<username>\",\n   Password: \"<password>\",\n}\nclientOpts := options.Client().ApplyURI(\"mongodb://<hostname>:<port>\").\n   SetAuth(credential)\n\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "go",
                    "value": "var accessKeyID, secretAccessKey string\nawsCredential := options.Credential{\n\tAuthMechanism: \"MONGODB-AWS\",\n\tAuthSource:    \"<authenticationDb>\",\n\tUsername:      \"<accessKeyID>\",\n\tPassword:      \"<secretAccessKey>\",\n}\n\nawsIAMClient, err := mongo.Connect(options.Client().SetAuth(awsCredential))\nif err != nil {\n\tpanic(err)\n}\n_ = awsIAMClient"
                },
                {
                    "lang": "go",
                    "value": "var accessKeyID, secretAccessKey, sessionToken string\nassumeRoleCredential := options.Credential{\n\tAuthMechanism: \"MONGODB-AWS\",\n\tAuthSource:    \"<authenticationDb>\",\n\tUsername:      \"<accessKeyID>\",\n\tPassword:      \"<secretAccessKey>\",\n\tAuthMechanismProperties: map[string]string{\n\t\t\"AWS_SESSION_TOKEN\": \"<sessionToken>\",\n\t},\n}\n\nassumeRoleClient, err := mongo.Connect(options.Client().SetAuth(assumeRoleCredential))"
                },
                {
                    "lang": "bash",
                    "value": "export AWS_ACCESS_KEY_ID=<awsKeyId>\nexport AWS_SECRET_ACCESS_KEY=<awsSecretKey>\nexport AWS_SESSION_TOKEN=<awsSessionToken>"
                },
                {
                    "lang": "go",
                    "value": "envVariablesCredential := options.Credential{\n\tAuthMechanism: \"MONGODB-AWS\",\n}\n\nenvVariablesClient, err := mongo.Connect(options.Client().SetAuth(envVariablesCredential))\nif err != nil {\n\tpanic(err)\n}\n_ = envVariablesClient"
                },
                {
                    "lang": "bash",
                    "value": "export AWS_WEB_IDENTITY_TOKEN_FILE=<absolute path to file containing your OIDC token>"
                },
                {
                    "lang": "go",
                    "value": "envVariablesCredential := options.Credential{\n\tAuthMechanism: \"MONGODB-AWS\",\n}\n\nenvVariablesClient, err := mongo.Connect(options.Client().SetAuth(envVariablesCredential))\nif err != nil {\n\tpanic(err)\n}\n_ = envVariablesClient"
                },
                {
                    "lang": "go",
                    "value": "caFilePath := \"<cafile_path>\"\ncertificateKeyFilePath := \"<client_certificate_path>\"\n\nuri := \"mongodb://<hostname>:<port>/?tlsCAFile=%s&tlsCertificateKeyFile=%s\"\nuri = fmt.Sprintf(uri, caFilePath, certificateKeyFilePath)\ncredential := options.Credential{\n   AuthMechanism: \"MONGODB-X509\",\n}\n\nclientOpts := options.Client().ApplyURI(uri).SetAuth(credential)"
                }
            ],
            "preview": "In this guide, you can learn how to use each authentication\nmechanism available in the MongoDB Community Edition. MongoDB uses\nauthentication mechanisms to confirm an identity and establish trust to\nensure security in the driver and server before connecting.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/collations",
            "title": "Collations",
            "headings": [
                "Overview",
                "Collations in MongoDB",
                "Specify a Collation",
                "Set a Collation on a Collection or View",
                "Create a Collection Example",
                "Use the Default Collation Example",
                "Set a Collation on an Index",
                "Example",
                "Set a Collation on an Operation",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use  collations  to order your query\nor aggregation operation results by string values. A collation is a set of character\nordering conventions that apply to a specific language and locale. MongoDB sorts strings using  binary collation  by default. This collation\nmethod uses the  ASCII standard \ncharacter values to compare and order strings. Certain languages and locales\nhave specific character ordering conventions that differ from the ASCII\nstandard. For example, in Canadian French, the right-most accented character determines\nthe ordering for strings when the other characters are the same. Consider the\nfollowing Canadian French words: When using the default binary collation, MongoDB sorts them in the following order: When using the Canadian French collation, MongoDB sorts them in the following order: cote cot\u00e9 c\u00f4te c\u00f4t\u00e9 To specify a collation, create a  Collation  object. You must define the  Locale  field\nof the  Collation  object; all other fields are optional. For example, the following code\nexample specifies a  Collation  object with the  \"en_US\"  locale collation: For a complete list of  Collation  object fields, visit the  Collation API documentation . To see all the supported locales and the\ndefault values for the  Locale  fields, visit  Supported Languages and Locales . You can apply a collation when you create a new collection or view. This defines the default\ncollation for any operations called on that collection or view. Set a collation through a\n CreateCollectionOptions  or  CreateViewOptions  object. Then, call the\n CreateCollection()  or  CreateView()  method with your options object as an argument. The following example creates a new collection called  books  and specifies a default\ncollation with the  \"fr\"  locale. The  Strength  collation field has a value of  1 \nto ignore differences in letter accents. If you call an operation that uses a collation on the  books  collection, the operation\nuses the default collation specified in the  Create a Collection Example . Assume the  books  collection contains the following documents: The following example uses the  Find()  method to return all documents with a  name  value\nthat alphabetically precedes  \"Infinite Jest\" : Without specifying a default  books  collation, the  Find()  method would follow default\nbinary collation rules to determine the  name  values that precede  \"Infinite Jest\" . These\nrules place words beginning with \"\u00c7\" after those beginning with \"I\". The output would resemble\nthe following: To learn more about the  Find()  method, see  Retrieve Data . To learn how to insert documents, see  Insert a Document . You can apply a collation when you create a new index on a collection. The index stores\nan ordered representation of the documents in the collection, so your MongoDB instance\ndoesn't perform the ordering for sorting operations in-memory. To use the index in an operation, your operation must use the same collation as the one\nspecified in the index. Additionally, ensure that the operation is covered by the index that\ncontains the collation. Set a collation through an  IndexOptions  object and pass this object\nas an argument to the  CreateOne()  method. After creating the  books  collection and applying a default collation, as shown in the\n Create a Collection Example  section, you cannot change the collection's default collation.\nHowever, you can create an index for the collection with a different collation. The following example uses the  CreateOne()  method to create an ascending index on the\n name  field and specifies a new collation with an  \"en_US\"  locale: Operations that read, update, and delete documents from a collection can use collations.\nApplying a collation to an operation overrides any default collation previously defined\nfor a collection. If you apply a new collation to an operation that differs from an index's collation,\nyou cannot use that index. As a result, the operation may not perform as well as one\nthat is covered by an index. For more information on the disadvantages of sorting operations\nnot covered by an index, see  Using Indexes to Sort Query Results .\nSee the  MongoDB manual  for a list of\noperations that support collation. You can use operations that support collation to update and query documents in the\n books  collection. The following example uses the  Find()  method to return documents in which the  length \nvalue is greater than  \"1000\" . The  NumericOrdering  collation field has a value of\n true  to ensure that values are sorted in numerical order rather than alphabetical\norder: Without specifying a collation with a  NumericOrdering  field set to  true , the\nsame  Find()  operation compares  length  values as strings. In this case, the\noutput resembles the following: To learn more about the  Find()  method, see the  Retrieve Data  guide. To learn more about collations, visit the following manual pages: Collation Collation Locales and Default Parameters To learn more about the methods discussed in this guide, see the following\nAPI Documentation: Collation CreateCollectionOptions IndexModel CreateOne() IndexOptions UpdateOptions",
            "code": [
                {
                    "lang": "none",
                    "value": "cote\ncot\u00e9\nc\u00f4te\nc\u00f4t\u00e9"
                },
                {
                    "lang": "none",
                    "value": "cote\nc\u00f4te\ncot\u00e9\nc\u00f4t\u00e9"
                },
                {
                    "lang": "go",
                    "value": "myCollation := &options.Collation{Locale: \"en_US\"}"
                },
                {
                    "lang": "go",
                    "value": "myCollation := &options.Collation{Locale: \"fr\", Strength: 1}\nopts := options.CreateCollection().SetCollation(myCollation)\nerr := db.CreateCollection(context.TODO(), \"books\", opts)\n\nif err != nil {\n   panic(err)\n}"
                },
                {
                    "lang": "json",
                    "value": "{\"name\" : \"Emma\", \"length\" : \"474\"}\n{\"name\" : \"Les Mis\u00e9rables\", \"length\": \"1462\"}\n{\"name\" : \"Infinite Jest\", \"length\" : \"1104\"}\n{\"name\" : \"Cryptonomicon\", \"length\" : \"918\"}\n{\"name\" : \"\u00c7a\", \"length\" : \"1138\"}"
                },
                {
                    "lang": "json",
                    "value": "{\"name\":\"Emma\",\"length\":\"474\"}\n{\"name\":\"Cryptonomicon\",\"length\":\"918\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"name\", bson.D{{\"$lt\", \"Infinite Jest\"}}}}\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []bson.D\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\n\nfor _, result := range results {\n   res, _ := bson.MarshalExtJSON(result, false, false)\n   fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Emma\",\"length\":\"474\"}\n{\"name\":\"Cryptonomicon\",\"length\":\"918\"}\n{\"name\":\"\u00c7a\",\"length\":\"1138\"}"
                },
                {
                    "lang": "go",
                    "value": " myCollation := &options.Collation{Locale: \"en_US\"}\n opts := options.Index().SetCollation(myCollation)\n\n indexModel := mongo.IndexModel{\n   Keys:    bson.D{{\"name\", 1}},\n   Options: opts,\n }\n\n name, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\n if err != nil {\n   panic(err)\n }\n fmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": " Name of Index Created: name_1"
                },
                {
                    "lang": "json",
                    "value": "{\"name\":\"Emma\",\"length\":\"474\"}\n{\"name\":\"Les Mis\u00e9rables\",\"length\":\"1462\"}\n{\"\"name\":\"Infinite Jest\",\"length\":\"1104\"}\n{\"name\":\"Cryptonomicon\",\"length\":\"918\"}\n{\"name\":\"\u00c7a\",\"length\":\"1138\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"length\", bson.D{{\"$gt\", \"1000\"}}}}\nmyCollation := &options.Collation{Locale: \"en_US\", NumericOrdering: true}\nopts := options.Find().SetCollation(myCollation)\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\nif err != nil {\n   panic(err)\n}\n\nvar results []bson.D\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\n\nfor _, result := range results {\n   res, _ := bson.MarshalExtJSON(result, false, false)\n   fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Les Mis\u00e9rables\",\"length\":\"1462\"}\n{\"name\":\"Infinite Jest\",\"length\":\"1104\"}\n{\"name\":\"\u00c7a\",\"length\":\"1138\"}"
                }
            ],
            "preview": "In this guide, you can learn how to use collations to order your query\nor aggregation operation results by string values. A collation is a set of character\nordering conventions that apply to a specific language and locale.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/indexes",
            "title": "Indexes",
            "headings": [
                "Overview",
                "Query Coverage and Performance",
                "Operational Considerations",
                "Index Types",
                "Single Field Indexes",
                "Example",
                "Compound Indexes",
                "Example",
                "Multikey Indexes (Indexes on Array Fields)",
                "Example",
                "Clustered Indexes",
                "Example",
                "Text Indexes",
                "Example",
                "Geospatial Indexes",
                "Example",
                "Unique Indexes",
                "Example",
                "Remove an Index",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use  indexes  in the\nMongoDB Go Driver. Indexes support the efficient execution of queries in MongoDB. Without\nindexes, MongoDB scans  every  document in a collection (a  collection\nscan ) to find documents that match your query. Collection scans are\nslow and can negatively affect the performance of your application. With\nan appropriate index, MongoDB limits the number of documents it\ninspects. You can also use indexes in update operations, delete operations, and\n certain aggregation pipeline stages . A query in MongoDB can contain the following elements: When you specify these elements in the same index, MongoDB returns\nresults directly from the index, also called a  covered query . Element Necessity Purpose Query Required Specify the fields and values you're looking for. Options Optional Specify how the query executes. Projection Optional Specify the fields that MongoDB returns. Sort Optional Specify the order MongoDB returns documents. Your sort criteria must match or invert the order of the index. Consider an index on the field  name  in ascending order (A-Z) and  age  in descending order (9-0): MongoDB uses this index when you sort your data by either: Specifying a sort order of  name  and  age  ascending or  name  and  age \ndescending requires an in-memory sort. To learn how to ensure your index covers your query criteria and\nprojection, see  Query Coverage . name  ascending,  age  descending name  descending,  age  ascending To improve your query performance, create indexes on fields that appear\noften in your queries and operations that return sorted results. Track\nindex memory and disk usage for capacity planning since\neach index that you add consumes disk space and memory. In addition,\nwhen a write operation updates an indexed field, MongoDB\nalso must update the related index. Since MongoDB supports dynamic schemas, your application can query\nagainst fields with unknown or arbitrary names. MongoDB 4.2\nintroduced  wildcard indexes  to help\nsupport these queries. Wildcard indexes are not designed to replace\nworkload-based index planning. To learn more about designing your data model and choosing indexes\nappropriate for your application, see  Indexing Strategies  and  Data Modeling and Indexes . MongoDB supports several index types to support querying your data. The\nfollowing sections describe and show how to create the most common index\ntypes. To view a full list of index types, see  Indexes . Single field indexes holds a reference to a field within a\ncollection's documents. This index improves single field queries and sort performance, and\nsupports TTL indexes that automatically remove documents from a\ncollection after a certain amount of time. The  _id_  index is an example of a single field index. This index\nis automatically created on the  _id  field when you create a new\ncollection. The following example creates an index in ascending order on the\n title  field in the  sample_mflix.movies  collection: Compound indexes hold a reference to multiple fields within a\ncollection's documents. This index improves query and sort performance. The following example creates a compound index on the  fullplot  and\n title  fields in the  sample_mflix.movies  collection: Multikey indexes use the same syntax as a\n single field index  and a\n compound index . This index improves the\nperformance of queries that specify an array field as an index. The following example creates a multikey index on the  cast \nfield in the  sample_mflix.movies  collection: Clustered indexes improve the performance of insert, update, and delete\noperations on  clustered collections . Clustered collections store\ndocuments ordered by the clustered index key value. To create a clustered index, specify the clustered index option with the\n _id  field as the key and the unique field as  true  when you\ncreate your collection. The following example creates a clustered index on the  _id  field in\nthe  db.tea  collection: Text indexes support text search queries on string content. This index\nrequires a string field or an array of strings. MongoDB supports text\nsearch for several languages. You can specify the default language as an\noption when creating the index. A collection can only contain one text index. If you want to create a\ntext index for multiple text fields, you must create a  compound\nindex . The text search runs on all the text fields\nwithin the compound index. Text indexes differ from the more powerful\n Atlas full text search indexes .\nWe recommend Atlas search for Atlas users. The following example creates a text index on the  plot  field with\n italian  as the default language in the  sample_mflix.movies \ncollection: MongoDB supports queries containing geospatial coordinate data by using\n 2dsphere indexes . A  2dsphere  index must be in a GeoJSON objects\nfield. This index allows you to perform the following: Query geospatial data for inclusion, intersection, and proximity. Calculation of distances on a Euclidean plane and for working with the\n\"legacy coordinate pairs\" syntax used in MongoDB 2.2 and earlier. The  location.geo  field in a document from the\n sample_mflix.theaters  collection is a GeoJSON Point object that\ndescribes the coordinates of the theater: The following example creates a  2dsphere  index on the  location.geo  field: Attempting to create a geospatial index on a field that is covered by\na geospatial index results in an error. Unique indexes ensure that the indexed fields do not store duplicate\nvalues. By default, MongoDB creates a unique index on the  _id  field\nduring the creation of a collection. To create a unique index, specify the field or combination of fields\nthat you want to prevent duplication on and set the  unique  option to\n true . The following example creates a unique, descending index on the  theaterId  field: You can remove any unused index except the default unique index on the\n _id  field. To remove an index, pass the name of your index to the\n DropOne()  method. The following example removes an ascending index on the  title  field\nin the  sample_mflix.movies  collection: To learn more about the indexes mentioned, see the following\nguides: To learn more about the operations mentioned, see the following\nguides: Single Field Indexes TTL Indexes Compound Indexes Multikey Indexes Text Indexes Compound Text Index Restrictions Geospatial Queries GeoJSON Objects Unique Indexes Clustered Indexes Clustered Collections Specify a Query Modify Documents Delete Documents To learn more about any of the methods discussed in this\nguide, see the following API Documentation: IndexModel CreateOne() IndexOptions SetDefaultLanguage() DropOne() CreateCollection() CreateCollectionOptions",
            "code": [
                {
                    "lang": "none",
                    "value": "name_1_age_-1"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nindexModel := mongo.IndexModel{\n    Keys: bson.D{{\"title\", 1}},\n}\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}\nfmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": "Name of Index Created: title_1"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nindexModel := mongo.IndexModel{\n    Keys: bson.D{\n        {\"fullplot\", -1},\n        {\"title\", 1}\n    }\n}\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": "Name of Index Created: fullplot_-1_title_1"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nindexModel := mongo.IndexModel{\n    Keys: bson.D{{\"cast\", -1}}\n}\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": "Name of Index Created: cast_-1"
                },
                {
                    "lang": "go",
                    "value": "db := client.Database(\"db\")\ncio := bson.D{{\"key\", bson.D{{\"_id\", 1}}}, {\"unique\", true}}\nopts := options.CreateCollection().SetClusteredIndex(cio)\n\ndb.CreateCollection(context.TODO(), \"tea\", opts)"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nindexModel := mongo.IndexModel{Keys: bson.D{{\"plot\", \"text\"}, {\"default_language\", \"italian\"}}}\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n   panic(err)\n}\n\nfmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": "Name of Index Created: plot_text"
                },
                {
                    "lang": "javascript",
                    "value": "{\n   \"_id\" : ObjectId(\"59a47286cfa9a3a73e51e75c\"),\n   \"theaterId\" : 104,\n   \"location\" : {\n      \"address\" : {\n         \"street1\" : \"5000 W 147th St\",\n         \"city\" : \"Hawthorne\",\n         \"state\" : \"CA\",\n         \"zipcode\" : \"90250\"\n      },\n      \"geo\" : {\n         \"type\" : \"Point\",\n         \"coordinates\" : [\n            -118.36559,\n            33.897167\n         ]\n      }\n   }\n}"
                },
                {
                    "lang": "go",
                    "value": "indexModel := mongo.IndexModel{\n    Keys: bson.D{{\"location.geo\", \"2dsphere\"}}\n}\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": "location.geo_2dsphere"
                },
                {
                    "lang": "go",
                    "value": "indexModel := mongo.IndexModel{\n    Keys: bson.D{{\"theaterId\", -1}},\n    Options: options.Index().SetUnique(true),\n}\nname, err := coll.Indexes().CreateOne(context.TODO(), indexModel)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(\"Name of Index Created: \" + name)"
                },
                {
                    "lang": "none",
                    "value": "Name of Index Created: theaterId_-1"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"sample_mflix\").Collection(\"movies\")\nres, err := coll.Indexes().DropOne(context.TODO(), \"title_1\")\nif err != nil {\n    panic(err)\n}\nfmt.Println(res)"
                },
                {
                    "lang": "none",
                    "value": "{\"nIndexesWas\": {\"$numberInt\":\"2\"}}"
                }
            ],
            "preview": "In this guide, you can learn how to use indexes in the\nMongoDB Go Driver.",
            "tags": "code example",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/context",
            "title": "Context",
            "headings": [
                "Overview",
                "Expiration",
                "Server Selection",
                "Connection Checkout",
                "Connection Establishment",
                "Socket Read and Write"
            ],
            "paragraphs": "The MongoDB Go Driver uses the  context package  from Go's standard library to allow\napplications to signal timeouts and cancellations for any  blocking method \ncall. A blocking method relies on an external event, such as a network\ninput or output, to proceed with its task. An example of a blocking method in the Go Driver is the  Insert() \nmethod. If you want to perform an insert operation on a  Collection \nwithin 10 seconds, you can use a Context with a timeout. If the\noperation doesn't complete within the timeout, the method returns\nan error. If the Context passed into an operation does not have a deadline, you\ncan set a  Timeout  option on your  Client  and the operation will\nderive the timeout specification from this setting. To learn more\nabout using the single timeout setting, see the  Connection Guide . The driver considers a Context expired when an operation exceeds its\ntimeout or is canceled. The driver checks the Context expiration with\nthe  Done()  method. The following sections describe when and how the driver checks for\nexpiration. The driver might block a method call if it can't select a server for\nan operation. In this scenario, the driver loops until it finds a server to use for the\noperation. After each iteration, the driver returns a server selection\ntimeout error if the Context expired or the selection process took\nlonger than the  serverSelectionTimeoutMS  setting. To learn more about how the driver selects a server, see the\n Server Selection Algorithm . The driver might block a method call if there are no available\nconnections to check out. After selecting a server, the driver tries to check out a connection\nfrom the server's connection pool. If the Context expires while checking\nout a connection, the method returns a timeout error. The driver might block a method call if it must create a new\nconnection. When the driver creates a new connection to perform an operation, the\nContext sets a timeout for the establishment process. The driver sets the\ntimeout to either the Context expiration or connection timeout, whichever is\nshorter. The following example sets the connection timeout to  1  second and the\nContext deadline to  2  seconds. Because the connection timeout is\nshorter, the establishment process expires after  1  second. When the driver retrieves a connection for an operation, it sets the\nsocket\u2019s read or write deadline to either the Context deadline or socket\ntimeout, whichever is shorter. If you cancel the Context after the execution of the  Read()  or\n Write()  method but before its deadline, the behavior of the driver\ndiffers based on version. The driver generates a separate goroutine to listen for Context\ncancellation when the  Read()  or  Write()  method is in progress.\nIf the goroutine detects a cancellation, it closes the connection. The\npending  Read()  or  Write()  method returns an error which the\ndriver overwrites with the  context.Canceled  error. In versions prior to 1.5.0, the driver doesn't detect the Context\ncancellation and waits for the  Read()  or  Write()  method to\nreturn.",
            "code": [
                {
                    "lang": "go",
                    "value": " client, err := mongo.Connect(options.Client().ApplyURI(uri))\n\n ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n defer cancel()\n client.Database(\"<db>\").Collection(\"<collection>\").Insert(ctx, bson.D{{\"x\",1}})"
                },
                {
                    "lang": "go",
                    "value": " opts := options.Client()\n opts.SetConnectTimeout(1*time.Second)\n client, err := mongo.Connect(opts)\n\n ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n defer cancel()\n client.Database(\"<db>\").Collection(\"<collection>\").InsertOne(ctx, bson.D{{\"x\",1}})"
                }
            ],
            "preview": "The MongoDB Go Driver uses the context package from Go's standard library to allow\napplications to signal timeouts and cancellations for any blocking method\ncall. A blocking method relies on an external event, such as a network\ninput or output, to proceed with its task.",
            "tags": "code example, unblock",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/time-series",
            "title": "Time Series Collections",
            "headings": [
                "Overview",
                "Create a Time Series Collection",
                "Example",
                "Query a Time Series Collection",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn about  time series collections  in\nMongoDB, and how to interact with them in the MongoDB Go Driver. Time series collections efficiently store sequences of measurements over\na period of time. The collection consists of time series data with the\nfollowing information: Data collected over time Metadata that describes the measurement Date of the measurement Example Measurement Metadata Sales Data Revenue Company Infection Rates Amount of People Infected Location To create a time series collection, pass the following parameters to the\n CreateCollection()  method: Time series collections require MongoDB 5.0 or later. The name of the new collection to create The  TimeSeriesOptions  object specifying at least the time field The following example creates the  march2022  time series collection in the\n db  database with the  temperature  as the time field: To check if you created the collection, send the  \"listCollections\" \ncommand to the  RunCommand()  method: To query a time series collection, use the same conventions as you\nwould for  retrieving  and aggregating data. To learn more about the operations mentioned, see the following\nguides: Time Series Collections Time Series Collection Limitations Run a Command Retrieve Data To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: TimeSeriesOptions SetTimeField() CreateCollection() SetTimeSeriesOptions() RunCommand()",
            "code": [
                {
                    "lang": "go",
                    "value": "db := client.Database(\"db\")\n\n// Creates a time series collection that stores \"temperature\" values over time\ntso := options.TimeSeries().SetTimeField(\"temperature\")\nopts := options.CreateCollection().SetTimeSeriesOptions(tso)\n\ndb.CreateCollection(context.TODO(), \"march2022\", opts)"
                },
                {
                    "lang": "go",
                    "value": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n\tvar uri string\n\tif uri = os.Getenv(\"MONGODB_URI\"); uri == \"\" {\n\t\tlog.Fatal(\"You must set your 'MONGODB_URI' environment variable. See\\n\\t https://www.mongodb.com/docs/drivers/go/current/usage-examples/\")\n\t}\n\n\tclient, err := mongo.Connect(options.Client().ApplyURI(uri))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Disconnect(context.TODO())\n\n\tdb := client.Database(\"myDB\")\n\n\t// Creates a command to list collections\n\tcommand := bson.D{{\"listCollections\", 1}}\n\tvar result bson.M\n\n\t// Runs the command on the database\n\tcommandErr := db.RunCommand(context.TODO(), command).Decode(&result)\n\tif commandErr != nil {\n\t\tpanic(commandErr)\n\t}\n\n\t// Prints the command results\n\toutput, outputErr := json.MarshalIndent(result, \"\", \"    \")\n\tif outputErr != nil {\n\t\tpanic(outputErr)\n\t}\n\tfmt.Printf(\"%s\\n\", output)\n}\n"
                },
                {
                    "lang": "json",
                    "value": "{\n   ...\n   \"cursor\": {\n        \"firstBatch\": [\n            {\n                \"info\": {\n                    \"readOnly\": false\n                },\n                \"name\": \"march2022\",\n                \"options\": {\n                    \"timeseries\": {\n                        ...\n                    }\n                },\n                \"type\": \"timeseries\"\n            },\n    ...\n }"
                }
            ],
            "preview": "In this guide, you can learn about time series collections in\nMongoDB, and how to interact with them in the MongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/connections",
            "title": "Connections",
            "headings": [
                "Overview"
            ],
            "paragraphs": "Learn how to use the Go driver to configure your application's\nconnection to a MongoDB deployment in the following sections: To learn how to authenticate to MongoDB, see the following pages: Connection Guide Network Compression Enable and Configure TLS Connect to MongoDB Atlas from AWS Lambda Authentication Mechanisms Enterprise Authentication Mechanisms",
            "code": [],
            "preview": "Learn how to use the Go driver to configure your application's\nconnection to a MongoDB deployment in the following sections:",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/logging",
            "title": "Logging",
            "headings": [
                "Overview",
                "Enable Logging",
                "Configure a Logger",
                "Log Components and Severity Levels",
                "Example",
                "Use a Custom Logger",
                "Example",
                "Define the CustomLogger struct.",
                "Implement the Info() and Error() methods with custom log message formatting.",
                "Assign a Writer to your logger and set it as the Sink for your Client.",
                "Perform an operation.",
                "Integrate Third-Party Loggers",
                "Example",
                "Install the necessary packages.",
                "Define the logrus logger.",
                "Set the logger as the Sink for your Client.",
                "Perform operations.",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use the driver to configure  logging \nfor your application. The purpose of logging is to record driver events. A logger logs messages at a severity, or verbosity, level that you\ncan specify. By enabling a logger in your application, you can receive\ninformation about your application's activities at a high level, a\ndetailed level, or somewhere in between. To learn more about logging severity levels, see the Wikipedia entry on\nthe  Syslog standard for message logging . To configure a logger on your  Client  instance, call the\n SetLoggerOptions()  method when creating your  ClientOptions \nobject. The  SetLoggerOptions()  method takes a  LoggerOptions  type\nas a parameter. Set this  LoggerOptions  type to configure the\nlogger for your application. The following code shows how to create a client with logging enabled: To create a  LoggerOptions  object, call the  options.Logger() \nmethod. The following table describes how to set properties on\na  LoggerOptions  type to configure your logger. The first column lists\nthe  LoggerOptions  properties, the second column describes the\nproperties, and the third column lists the corresponding setter method and\nparameters for each property: Property Description Setter Method By default, the standard logger logs messages to your console ( stderr ). You can\nspecify a logging destination by setting the  MONGODB_LOG_PATH \nenvironment variable to  stdout  or a filepath. To specify the components that the driver logs against, set the\n LogComponent  type. The following table describes built-in\nspecifications for  LogComponent : You can specify the log component by using either the setting name\nor its enumeration value. The following code shows equivalent ways\nof enabling command monitoring: To specify the log severity level, set the  LogLevel \ntype. The following code shows how to enable logging at the\n LevelDebug  level: Setting Description Enumeration Value LogComponentAll Enables logging for all components 0 LogComponentCommand Enables command monitor logging 1 LogComponentTopology Enables topology logging 2 LogComponentServerSelection Enables server selection logging 3 LogComponentConnection Enables connection services logging 4 The Go driver currently emits only  LevelDebug  level\nmessages, but it supports other specifications for  LogLevel . To\nlearn more, see the  LogLevel  API\ndocumentation. This example shows how to configure the standard logger with the\nfollowing specifications: The following code performs an insert operation, which generates log\nmessages: The maximum document length is  25  bytes. The log component is  LogComponentCommand . The logging severity level is  LevelDebug . If the standard logging library does not meet your needs, you can\nimplement a custom logger. By customizing your logging configuration,\nyou have more control over the content, format, and frequency of log messages. To use a custom logger, define a logger struct and implement the\n Info()  and  Error()  methods for the struct. Next, set the logger as\nthe  LogSink  for your  Client  by calling the  SetSink()  method on\nyour  LoggerOptions  instance. This example demonstrates how to define and implement a custom logger. The preceding code example uses a  Mutex  type in the\n CustomLogger  struct to ensure atomic writes and prevent\nrace conditions. Setting a  Mutex  makes your logger safe for\nconcurrent use by multiple goroutines. In this example, the logger logs commands and connection\nevents at the  LevelDebug  level: The following code performs an insert operation, which generates log\nmessages: There are many third-party logging packages available in Go. To use\na third-party logger in your application, create a logger and assign it\nas the sink in your  LoggerOptions  instance. This example demonstrates how to integrate  logrus ,\na third-party logging package, into your application. Run the following  go get  commands in your terminal to download\nthe  logrus  packages required for this example: The following code creates a  logrus  logger with these\nspecifications: The logger logs messages to the console. The logger logs messages at the  DebugLevel  level. The logger formats messages using the  JSONFormatter \nformatter. In the following code example, the logger is configured to log\ncommands at the  LevelDebug  level. The following code performs some CRUD operations, which generate log\nmessages: You can find more information on third-party logging packages in their\nrespective GitHub repositories: To see full code examples that integrate these loggers, see the\n logging tests in the Go driver Github repository . logrus zap zerolog For more information about setting client options, see the\n Connection Guide . In addition to logging, you can enable server selection and\ntopology monitoring in your application. To learn more, see the\n Monitoring  Fundamentals guide. To learn more about any of the types or methods discussed in this\nguide, see the following API Documentation: SetLoggerOptions() LoggerOptions LogSink SetComponentLevel() SetMaxDocumentLength() SetSink() LogComponent LogLevel",
            "code": [
                {
                    "lang": "go",
                    "value": "loggerOptions := options.\n     Logger().\n     SetComponentLevel(options.LogComponentCommand, options.LogLevelDebug)\n\nclientOptions := options.\n     Client().\n     ApplyURI(uri).\n     SetLoggerOptions(loggerOptions)\n\nclient, err := mongo.Connect(clientOptions)"
                },
                {
                    "lang": "go",
                    "value": "// Using named value\ncomp := options.LogComponentCommand\n\n// Using enumeration\ncomp := options.LogComponent(1)"
                },
                {
                    "lang": "go",
                    "value": "lvl := options.LogLevelDebug"
                },
                {
                    "lang": "go",
                    "value": "loggerOptions := options.\n\tLogger().\n\tSetMaxDocumentLength(25).\n\tSetComponentLevel(options.LogComponentCommand, options.LogLevelDebug)\n\n// Creates options that include the logger specification\nclientOptions := options.\n\tClient().\n\tApplyURI(uri).\n\tSetLoggerOptions(loggerOptions)"
                },
                {
                    "lang": "go",
                    "value": "type Item struct {\n\tName string\n}\n\ncoll := client.Database(\"db\").Collection(\"testColl\")\n_, err = coll.InsertOne(context.TODO(), Item{Name: \"grapefruit\"})"
                },
                {
                    "lang": "console",
                    "value": "{\"command\":\"{\\\"insert\\\": \\\"testColl\\\",\\\"or...\",\"commandName\":\"insert\",\"databaseName\":\"db\",\"driverConnectionId\":1,\"message\":\"Command started\",\"operationId\":0,\"requestId\":13,\"serverConnectionId\":97377,\"serverHost\":\"...\",\"serverPort\":27017,\"timestamp\":...}\n{\"commandName\":\"insert\",\"driverConnectionId\":1,\"durationMS\":19,\"message\":\"Command succeeded\",\"operationId\":0,\"reply\":\"{\\\"n\\\": {\\\"$numberInt\\\":\\\"1\\\"},...\",\"requestId\":13,\"serverConnectionId\":97377,\"serverHost\":\"...\",\"serverPort\":27017,\"timestamp\":...}"
                },
                {
                    "lang": "go",
                    "value": "type CustomLogger struct {\n\tio.Writer\n\tmu sync.Mutex\n}\n"
                },
                {
                    "lang": "go",
                    "value": "func (logger *CustomLogger) Info(level int, msg string, _ ...interface{}) {\n\tlogger.mu.Lock()\n\tdefer logger.mu.Unlock()\n\tif options.LogLevel(level+1) == options.LogLevelDebug {\n\t\tfmt.Fprintf(logger, \"level: %d DEBUG, message: %s\\n\", level, msg)\n\t} else {\n\t\tfmt.Fprintf(logger, \"level: %d INFO, message: %s\\n\", level, msg)\n\t}\n}\n\nfunc (logger *CustomLogger) Error(err error, msg string, _ ...interface{}) {\n\tlogger.mu.Lock()\n\tdefer logger.mu.Unlock()\n\tfmt.Fprintf(logger, \"error: %v, message: %s\\n\", err, msg)\n}\n"
                },
                {
                    "lang": "go",
                    "value": "buf := bytes.NewBuffer(nil)\nsink := &CustomLogger{Writer: buf}\n\nloggerOptions := options.\n\tLogger().\n\tSetSink(sink).\n\tSetComponentLevel(options.LogComponentCommand, options.LogLevelDebug).\n\tSetComponentLevel(options.LogComponentConnection, options.LogLevelDebug)\n\n// Creates options that include the logger specification\nclientOptions := options.\n\tClient().\n\tApplyURI(uri).\n\tSetLoggerOptions(loggerOptions)"
                },
                {
                    "lang": "go",
                    "value": "type Item struct {\n\tName string\n}\n\ncoll := client.Database(\"db\").Collection(\"testColl\")\n_, err = coll.InsertOne(context.TODO(), Item{Name: \"grapefruit\"})"
                },
                {
                    "lang": "console",
                    "value": "level: 1 DEBUG, message: Connection pool created\nlevel: 1 DEBUG, message: Connection pool ready\nlevel: 1 DEBUG, message: Connection pool created\nlevel: 1 DEBUG, message: Connection pool ready\nlevel: 1 DEBUG, message: Connection pool created\nlevel: 1 DEBUG, message: Connection pool ready\nlevel: 1 DEBUG, message: Connection checkout started\nlevel: 1 DEBUG, message: Connection created\nlevel: 1 DEBUG, message: Connection ready\nlevel: 1 DEBUG, message: Connection checked out\nlevel: 1 DEBUG, message: Command started\nlevel: 1 DEBUG, message: Command succeeded\nlevel: 1 DEBUG, message: Connection checked in"
                },
                {
                    "lang": "bash",
                    "value": "go get github.com/bombsimon/logrusr/v4\ngo get github.com/sirupsen/logrus"
                },
                {
                    "lang": "go",
                    "value": "myLogger := &logrus.Logger{\n\tOut:   os.Stderr,\n\tLevel: logrus.DebugLevel,\n\tFormatter: &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t\tPrettyPrint:     true,\n\t},\n}"
                },
                {
                    "lang": "go",
                    "value": "sink := logrusr.New(myLogger).GetSink()\n\n// Sets options when configuring the logrus logger\nloggerOptions := options.\n\tLogger().\n\tSetSink(sink).\n\tSetComponentLevel(options.LogComponentCommand, options.LogLevelDebug)\n\n// Creates options that include the logger specification\nclientOptions := options.\n\tClient().\n\tApplyURI(uri).\n\tSetLoggerOptions(loggerOptions)"
                },
                {
                    "lang": "go",
                    "value": "type Item struct {\n\tName string\n}\n\ncoll := client.Database(\"db\").Collection(\"testColl\")\ndocs := []interface{}{\n\tItem{Name: \"starfruit\"},\n\tItem{Name: \"kiwi\"},\n\tItem{Name: \"cantaloupe\"},\n}\n_, err = coll.InsertMany(context.TODO(), docs)\nif err != nil {\n\tpanic(err)\n}\n_, err = coll.DeleteOne(context.TODO(), Item{Name: \"kiwi\"})\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "console",
                    "value": "{\n  \"command\": \"{\\\"insert\\\": \\\"testColl\\\", ...}\",\n  \"commandName\": \"insert\",\n  \"databaseName\": \"db\",\n  ...\n  \"level\": \"debug\",\n  \"message\": \"Command started\",\n  \"msg\": \"Command started\",\n  ...\n  \"time\": \"2023-07-06 10:23:42\"\n}\n{\n  \"commandName\": \"insert\",\n  ...\n  \"level\": \"debug\",\n  \"message\": \"Command succeeded\",\n  \"msg\": \"Command succeeded\",\n  ...\n  \"time\": \"2023-07-06 10:23:42\"\n}\n{\n  \"command\": \"{\\\"delete\\\": \\\"testColl\\\", ...}\",\n  \"commandName\": \"delete\",\n  \"databaseName\": \"db\",\n  ...\n  \"level\": \"debug\",\n  \"message\": \"Command started\",\n  \"msg\": \"Command started\",\n  ...\n  \"time\": \"2023-07-06 10:23:42\"\n}\n{\n  \"commandName\": \"delete\",\n  ...\n  \"level\": \"debug\",\n  \"message\": \"Command succeeded\",\n  \"msg\": \"Command succeeded\",\n  ...\n  \"time\": \"2023-07-06 10:23:42\"\n}"
                }
            ],
            "preview": "In this guide, you can learn how to use the driver to configure logging\nfor your application. The purpose of logging is to record driver events.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/bson",
            "title": "Work with BSON",
            "headings": [
                "Overview",
                "Data Types",
                "Struct Tags",
                "BSON Options",
                "Unmarshalling"
            ],
            "paragraphs": "In this guide, you can learn about how the Go driver handles conversions\nbetween BSON and Go types. The process of converting a Go type to\nBSON is called  marshalling , while the reverse process is called  unmarshalling . The following sections explain how the Go driver represents BSON data\nand how you can adjust default marshalling and unmarshalling behaviors. MongoDB stores documents in a binary representation called  BSON  that allows for easy and flexible data processing. The Go driver provides four main types for working with BSON data: The following example demonstrates how to construct a query filter by using the\n bson.D  type to match documents in which the  quantity  field value is greater\nthan 100: To learn more about how the Go driver handles BSON data, see the\n bson package API documentation . D : An ordered representation of a BSON document (slice) M : An unordered representation of a BSON document (map) A : An ordered representation of a BSON array E : A single element inside a D type In Go, a  struct  is a collection of data fields with declared data\ntypes. You can modify the default marshalling and unmarshalling behavior of\na struct field by using  struct tags , which are optional pieces of metadata\nattached to struct fields. The most common use of struct tags is for specifying\nthe field name in the BSON document that corresponds to the struct field.\nThe following table describes the additional struct tags that you can\nuse in the Go driver: If you don't specify struct tags, the Go driver marshals structs by using\nthe following rules: Struct Tag Description omitempty The field will not be marshalled if it is set to the zero value\ncorresponding to the field type. minsize If the field is type  int64 ,  uint ,  uint32 , or  uint64  and\nthe value of the field can fit in a signed  int32 , the field will be\nserialized as a BSON  int32  rather than a BSON  int64 . If the value\ncan't fit in a signed  int32 , this tag is ignored. truncate If the field type is a non-float numeric type, BSON doubles\nunmarshalled into that field will be truncated at the decimal point. inline If the field type is a struct or map field, the field will be\nflattened when marshalling and unflattened when unmarshalling. The driver only marshals and unmarshals exported fields. The driver generates a BSON key by using the lowercase of the\ncorresponding struct field. The driver marshals embedded struct fields as subdocuments. Each key\nis the lowercase of the field's type. The driver marshals a pointer field as the underlying type if the pointer\nis non-nil. If the pointer is nil, the driver marshals it as a BSON null\nvalue. When unmarshalling, the Go driver follows  these D/M type mappings \nfor fields of type  interface{} . The driver unmarshals BSON documents\nunmarshalled into an  interface{}  field as a  D  type. The following example demonstrates how the Go driver marshals a\nstruct with various struct tags: The corresponding BSON representation looks like this: In this example, struct tags make the driver: Set custom BSON field names such as  first_name Omit the empty  LastName  field Flatten the nested struct and bring all fields up to the top\nlevel The following example demonstrates how the Go driver marshals\na struct without any struct tags: The corresponding BSON representation looks like this: Without struct tags, the driver: Sets the lowercase of the struct fields as the BSON field names Includes an empty  lastname  field Stores the  Address  field as a nested value You can specify BSON options to adjust the marshalling and unmarshalling behavior of\nyour  Client  instance. To set BSON options on your  Client , create and configure\na  BSONOptions  instance. This example performs the following actions: Creates a  BSONOptions  instance by configuring the following settings: Sets the  UseJSONStructTags  field to  true , which instructs the driver\nto use the  \"json\"  struct tag if a  \"bson\"  struct tag is not specified Sets the  NilSliceAsEmpty  field to  true , which instructs the driver\nto marshal  nil  Go slices as empty BSON arrays Passes the  BSONOptions  instance to the  SetBSONOptions()  helper method to specify\na  ClientOptions  instance Creates a  Client  to apply the specified BSON marshalling and unmarshalling behavior To learn more about the  BSONOptions  type, see the\n BSONOptions API documentation .\nFor an example that specifies a  BSONOptions  instance and creates a client with\nthese options, see the  Connect() BSONOptions example . You can unmarshal BSON documents by using the  Decode()  method on the\nresult of the  FindOne  method or any  *mongo.Cursor  instance. The  Decode()  method returns an  error  type which\ncontains one of the following values: When used on the  SingleResult  type returned by the  FindOne() \nmethod,  Decode()  can also return the  ErrNoDocuments  error if no\ndocuments matched the query filter. The following example demonstrates how you can use the  Decode() \nmethod to unmarshal and read the result of a simple  FindOne() \noperation: The  Cursor  type also uses the  All()  method, which unmarshals all\ndocuments stored in the cursor into an array at the same time. The  bson  package includes a family of  Marshal()  and  Unmarshal() \nmethods that work with BSON-encoded data of  []byte  type. The following code demonstrates how you can unmarshal BSON back into a\nuser-defined struct by using methods from the  bson  package: To learn more about the marshalling and unmarshalling methods used with the\n Cursor  type, see the  Cursor API documentation To learn more about the marshalling and unmarshalling methods in the\n bson  package, see the  bson API documentation nil  if a document matched your query, and there were no errors\nretrieving and unmarshalling the document. If the driver retrieved your document but could not unmarshal your result, the\n Decode()  method returns the unmarshalling error. If there was an error retrieving your document during execution of the\n FindOne()  method, the error propagates to the  Decode()  method and\nthe  Decode()  method returns the error. You can use the  Raw  type to retrieve elements from a BSON\ndocument byte slice without unmarshalling it to a Go type. This type\nallows you to look up individual elements without unmarshalling\nthe entire BSON document.",
            "code": [
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"quantity\", bson.D{{\"$gt\", 100}}}}"
                },
                {
                    "lang": "go",
                    "value": "type Address struct {\n       Street string\n       City   string\n       State  string\n}\n\ntype Student struct {\n       FirstName string  `bson:\"first_name,omitempty\"`\n       LastName  string  `bson:\"last_name,omitempty\"`\n       Address   Address `bson:\"inline\"`\n       Age       int\n}\n\ncoll := client.Database(\"db\").Collection(\"students\")\naddress1 := Address{ \"1 Lakewood Way\", \"Elwood City\", \"PA\" }\nstudent1 := Student{ FirstName : \"Arthur\", Address : address1, Age : 8}\n_, err = coll.InsertOne(context.TODO(), student1)"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\" : ObjectId(\"...\"),\n  \"first_name\" : \"Arthur\",\n  \"street\" : \"1 Lakewood Way\",\n  \"city\" : \"Elwood City\",\n  \"state\" : \"PA\",\n  \"age\" : 8\n}"
                },
                {
                    "lang": "go",
                    "value": "type Address struct {\n       Street string\n       City   string\n       State  string\n}\n\ntype Student struct {\n       FirstName string\n       LastName  string\n       Address   Address\n       Age       int\n}\n\ncoll := client.Database(\"db\").Collection(\"students\")\naddress1 := Address{ \"1 Lakewood Way\", \"Elwood City\", \"PA\" }\nstudent1 := Student{ FirstName : \"Arthur\", Address : address1, Age : 8}\n_, err = coll.InsertOne(context.TODO(), student1)"
                },
                {
                    "lang": "json",
                    "value": "{\n  \"_id\" : ObjectId(\"...\"),\n  \"firstname\" : \"Arthur\",\n  \"lastname\" : \"\",\n  \"address\": {\n               \"street\" : \"1 Lakewood Way\",\n               \"city\" : \"Elwood City\",\n               \"state\" : \"PA\"\n             },\n  \"age\" : 8\n}"
                },
                {
                    "lang": "go",
                    "value": "bsonOpts := &options.BSONOptions {\n    UseJSONStructTags: true,\n    NilSliceAsEmpty: true,\n}\n\nclientOpts := options.Client().\n    ApplyURI(\"<connection string>\").\n    SetBSONOptions(bsonOpts)\n\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"students\")\nfilter := bson.D{{\"age\", 8}}\n\nvar result bson.D\nerr := coll.FindOne(context.TODO(), filter).Decode(&result)\n\nfmt.Println(result)"
                },
                {
                    "lang": "none",
                    "value": "[{_id ObjectID(\"...\")} {first_name Arthur} {street 1 Fern Way} {city Elwood City} {state PA} {age 8}]"
                },
                {
                    "lang": "go",
                    "value": "type Item struct {\n   Category string\n   Quantity int32\n}\n\ndoc, err := bson.Marshal(bson.D{{\"category\", \"plate\"}, {\"quantity\", 6}})\n\nvar test Item\nerr = bson.Unmarshal(doc, &test)\n\nfmt.Printf(\"Unmarshalled Struct:\\n%+v\\n\", test)"
                },
                {
                    "lang": "none",
                    "value": "Unmarshalled Struct:\n{Category:plate Quantity:6}"
                }
            ],
            "preview": "In this guide, you can learn about how the Go driver handles conversions\nbetween BSON and Go types. The process of converting a Go type to\nBSON is called marshalling, while the reverse process is called unmarshalling.",
            "tags": "code examples, serialization",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/transactions",
            "title": "Transactions",
            "headings": [
                "Overview",
                "Methods",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use the MongoDB Go Driver to perform\n transactions .  Transactions  allow\nyou to run a series of operations that do not change any data until the\ntransaction is committed. If any operation in the transaction returns an\nerror, the driver cancels the transaction and discards all data changes\nbefore they ever become visible. In MongoDB, transactions run within logical  sessions . A\n session  is a grouping of related\nread or write operations that you intend to run sequentially. Sessions\nenable  causal consistency  for a\ngroup of operations or allow you to execute operations in an\n ACID transaction . MongoDB\nguarantees that the data involved in your transaction operations remains\nconsistent, even if the operations encounter unexpected errors. When using the Go driver, you can create a new session from a\n Client  instance as a  Session  type. We recommend that you reuse\nyour client for multiple sessions and transactions instead of\ninstantiating a new client each time. Use a  Session  only with the  Client  (or associated\n Database  or  Collection ) that created it. Using a\n Session  with a different  Client  results in operation\nerrors. Implementations of  Session  are not safe for concurrent use by multiple  goroutines . After you start a session by using the  StartSession()  method, you can modify\nthe session state by using the method set provided by the  Session  interface. The\nfollowing table describes these methods: The  Session  interface also has methods to retrieve session\nproperties and modify mutable session properties. Find more information\nin the  API documentation . Method Description StartTransaction() AbortTransaction() CommitTransaction() The  CommitTransaction()  method is an idempotent function, which\nmeans that you can attempt to commit a transaction multiple times\nwithout changing data after the first successful commit. A transaction can succeed but return an error with the\n UnknownTransactionCommitResult  label. If you rerun the\n CommitTransaction()  method after receiving this error,\nyour data is not changed by the repeat attempts. WithTransaction() EndSession() The following example shows how you can create a session, create a\ntransaction, and commit a multi-document insert operation through the\nfollowing steps: If you require more control over your transactions, you can find an example\nshowing how to manually create, commit, and end transactions in the\n full code example . Create a session from the client using the  StartSession()  method. Use the  WithTransaction()  method to start a transaction. Insert multiple documents. The  WithTransaction()  method executes the\ninsert and commits the transaction. If any operation results in\nerrors,  WithTransaction()  handles canceling the transaction. Close the transaction and session using the  EndSession()  method. For more information about insert operations, see the\n Insert a Document  fundamentals page. For more information about specifying write concerns in the\nGo driver, see  Write Concern . For an additional example using sessions and transactions with the Go driver, see the\n developer blog post on Multi-Document ACID Transactions . To learn more about any of the types or methods discussed in this\nguide, see the following API Documentation: Session Client StartSession() TransactionOptions SetWriteConcern() InsertMany()",
            "code": [
                {
                    "lang": "go",
                    "value": "wc := writeconcern.Majority()\ntxnOptions := options.Transaction().SetWriteConcern(wc)\n\n// Starts a session on the client\nsession, err := client.StartSession()\nif err != nil {\n\tpanic(err)\n}\n// Defers ending the session after the transaction is committed or ended\ndefer session.EndSession(context.TODO())\n\n// Inserts multiple documents into a collection within a transaction,\n// then commits or ends the transaction\nresult, err := session.WithTransaction(context.TODO(), func(ctx mongo.SessionContext) (interface{}, error) {\n\tresult, err := coll.InsertMany(ctx, []interface{}{\n\t\tbson.D{{\"title\", \"The Bluest Eye\"}, {\"author\", \"Toni Morrison\"}},\n\t\tbson.D{{\"title\", \"Sula\"}, {\"author\", \"Toni Morrison\"}},\n\t\tbson.D{{\"title\", \"Song of Solomon\"}, {\"author\", \"Toni Morrison\"}},\n\t})\n\treturn result, err\n}, txnOptions)"
                }
            ],
            "preview": "In this guide, you can learn how to use the MongoDB Go Driver to perform\ntransactions. Transactions allow\nyou to run a series of operations that do not change any data until the\ntransaction is committed. If any operation in the transaction returns an\nerror, the driver cancels the transaction and discards all data changes\nbefore they ever become visible.",
            "tags": "code example, rollback, undo operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/run-command",
            "title": "Run a Command",
            "headings": [
                "Overview",
                "Execute a Command",
                "Response",
                "Example",
                "Output",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to run a database command with the\nGo driver. You can use database commands to perform a variety of\nadministrative and diagnostic tasks, such as fetching server statistics,\ninitializing a replica set, or running an aggregation pipeline. To run a database command, you must specify the command and any relevant\nparameters in a command document, then pass the command document to a\nwrapper method. The command document must be an order-preserving type\nsuch as  bson.D . The Go driver provides the following methods\nto run database commands: The following code shows how you can use the  RunCommand() \nmethod to run the  hello  command, which returns information about\nthe current member's role in the replica set, on a database: For a full list of database commands and corresponding parameters, see\nthe  Additional Information section . RunCommand() , which returns the command response as a\n SingleResult  type. You can use this method with any database command. RunCommandCursor() , which returns the command response as a\n Cursor  type. You can use this method if your database command\nreturns multiple result documents. RunCommand()  and  RunCommandCursor()  do not obey the read\npreference you may have set on your  Database  object elsewhere in\nyour code. You can set a read preference for command execution by\npassing a  RunCmdOptions  object to either method: For more information on\nread preference options, see the  Modify Execution of CRUD Operations \nfundamentals page. Each method returns a  SingleResult  object or a cursor that contains\nthe response from the database after the command has been executed. Each\ndatabase command performs a different function, so the response content\ncan vary across commands. However, every response contains documents\nwith the following fields: Field Description <command result> Provides fields specific to the database command. For example,\n count  returns the  n  field and  explain  returns the\n queryPlanner  field. ok Indicates whether the command has succeeded ( 1 )\nor failed ( 0 ). operationTime Indicates the logical time of the operation. MongoDB uses the\nlogical time to order operations. To learn more about logical time, see our  blog post about\nthe Global Logical Clock . $clusterTime Provides a document that returns the signed cluster time. Cluster time is a\nlogical time used for ordering of operations. The document contains the following fields: clusterTime , which is the timestamp of the highest known cluster time for the member. signature , which is a document that contains the hash of the cluster time and the ID\nof the key used to sign the cluster time. The following code shows how you can use the  RunCommand()  method to\nrun the  explain  command for a  count  operation on the  flowers  collection of the\n db  database. The  explain  command runs in the\n \"queryPlanner\"  verbosity mode: In the output, you should see fields explaining the\nexecution of the  count  operation, such as the winning plan, which is\nthe plan selected by the query optimizer, and any rejected\nplans. The output also contains information about the execution of the\n explain  command: For more information about the concepts in this guide, see the following documentation: To learn how to retrieve data from a cursor, see the\n Access Data From a Cursor  fundamentals page. db.runCommand() Database Commands hello Command explain Command RunCommand() RunCommandCursor() RunCmdOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "command := bson.D{{\"hello\", 1}}\n\nvar result bson.M\nerr = db.RunCommand(context.TODO(), command).Decode(&result)"
                },
                {
                    "lang": "go",
                    "value": "opts := options.RunCmd().SetReadPreference(readpref.Primary())\ncursor, err := db.RunCommandCursor(context.TODO(), command, opts)"
                },
                {
                    "lang": "go",
                    "value": "db := client.Database(\"db\")\n\n// Creates commands to count documents in a collection and explain\n// how the count command runs\ncountCommand := bson.D{{\"count\", \"flowers\"}}\nexplainCommand := bson.D{{\"explain\", countCommand}, {\"verbosity\", \"queryPlanner\"}}\n\n// Retrieves results of the explain command\nvar result bson.M\nerr = db.RunCommand(context.TODO(), explainCommand).Decode(&result)"
                },
                {
                    "lang": "json",
                    "value": "{\n    \"$clusterTime\": {\n        \"clusterTime\": {\n            \"T\": 1673969525,\n            \"I\": 24\n        },\n        \"signature\": {...}\n    },\n    \"command\": {\n        \"$db\": \"db\",\n        \"count\": \"flowers\"\n    },\n    \"explainVersion\": \"1\",\n    \"ok\": 1,\n    \"operationTime\": {\n        \"T\": 1673969525,\n        \"I\": 24\n    },\n    \"queryPlanner\": {\n        \"indexFilterSet\": false,\n        \"maxIndexedAndSolutionsReached\": false,\n        \"maxIndexedOrSolutionsReached\": false,\n        \"maxScansToExplodeReached\": false,\n        \"namespace\": \"db.flowers\",\n        \"rejectedPlans\": [],\n        \"winningPlan\": {\n            \"stage\": \"RECORD_STORE_FAST_COUNT\"\n        }\n    },\n    \"serverInfo\": {...},\n    \"serverParameters\": {\n        \"internalDocumentSourceGroupMaxMemoryBytes\": 104857600,\n        ...\n    }\n}"
                }
            ],
            "preview": "In this guide, you can learn how to run a database command with the\nGo driver. You can use database commands to perform a variety of\nadministrative and diagnostic tasks, such as fetching server statistics,\ninitializing a replica set, or running an aggregation pipeline.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/gridfs",
            "title": "GridFS",
            "headings": [
                "Overview",
                "How GridFS Works",
                "GridFS Operations",
                "Create a GridFS Bucket",
                "Upload Files",
                "Upload with an Input Stream",
                "Upload with an Output Stream",
                "Retrieve File Information",
                "Download Files",
                "Download a File to an Output Stream",
                "Download a File to an Input Stream",
                "Rename Files",
                "Delete Files",
                "Delete a GridFS Bucket",
                "Additional Resources",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to store and retrieve large files in\nMongoDB using the  GridFS  specification. GridFS splits large files\ninto chunks and stores each chunk as a separate document. When you query\nGridFS for a file, the driver assembles the chunks as necessary. The\ndriver implementation of GridFS is an abstraction that manages the operations\nand organization of the file storage. Use GridFS if the size of your files exceeds the BSON document size limit of\n16 MB. GridFS also helps you access files without loading the entire file\ninto memory. To learn more about whether GridFS is suitable for\nyour use case, see  GridFS  in the Server manual. GridFS organizes files in a  bucket , a group of MongoDB collections\nthat contain the chunks of files and information describing them. The\nbucket contains the following collections: When you create a new GridFS bucket, the driver creates the preceding\ncollections. The default bucket name  fs  prefixes the collection names,\nunless you specify a different bucket name. The driver creates the new GridFS\nbucket during the first write operation. The driver also creates an index on each collection to ensure efficient\nretrieval of the files and related metadata. The driver creates indexes\nif they do not already exist and when the bucket is empty. To learn more about\nGridFS indexes, see  GridFS Indexes  in the Server manual. When storing files with GridFS, the driver splits the files into smaller\nchunks, each represented by a separate document in the  chunks  collection.\nIt also creates a document in the  files  collection that contains\na file ID, file name, and other file metadata. The following diagram shows\nhow GridFS splits the uploaded files: When retrieving files, GridFS fetches the metadata from the  files \ncollection in the specified bucket then uses that information to reconstruct\nthe file from documents in the  chunks  collection. You can read the file\ninto memory or output it to a stream. chunks , which stores the binary file chunks files , which stores the file metadata The following sections describe how to perform GridFS operations: Create a GridFS Bucket Upload Files Retrieve File Information Download Files Rename Files Delete Files Delete a GridFS Bucket To store or retrieve files from GridFS, create a bucket or get a reference to\nan existing bucket on a MongoDB database. To create a  GridFSBucket  instance,\ncall the  GridFSBucket()  method on a  Database  instance, as shown\nin the following code: By default, the driver sets the name of the bucket to  fs . To\ncreate a bucket with a custom name, call the  SetName()  method\non a  BucketOptions  instance, as shown in the following code: If a GridFS bucket already exists, the  GridFSBucket()  method returns a\nreference to the bucket rather than instantiating a new one. You can upload a file into a GridFS bucket by using one of the following\nmethods: For either upload process, you can specify configuration information by creating\nan  UploadOptions  instance. To view a full list of options, see the\n UploadOptions API documentation . UploadFromStream() , which reads from an input stream OpenUploadStream() , which writes to an output stream To upload a file with an input stream, use the  UploadFromStream()  method\nand include the following parameters: The following code example reads from a file called  file.txt ,\ncreates an  opts  parameter to set file metadata, and uploads the\ncontent to a GridFS bucket: File name io.Reader  instance, including your opened file as a parameter opts  parameter to modify the behavior of  UploadFromStream() To upload a file with an output stream, use the  OpenUploadStream()  method\nand include the following parameters: The following code example opens an upload stream on a GridFS bucket and sets\nthe number of bytes in each chunk in the options parameter. Then, it calls\nthe  Write()  method on the content of  file.txt  to write its content to\nthe stream: File name opts  parameter to modify the behavior of  OpenUploadStream() You can retrieve file metadata stored in the  files  collection of the GridFS\nbucket. Each document in the  files  collection contains the following\npieces of information: To retrieve file data, call the  Find()  method on a  GridFSBucket \ninstance. You can pass a query filter as an argument to  Find()  to match\nonly certain file documents. The following example retrieves the file name and length of documents in\nwhich the  length  value is greater than  1500 : File ID File length Maximum chunk size Upload date and time File name metadata  document that stores any other information You must pass a query filter to the  Find()  method. To retrieve all\ndocuments in the  files  collection, pass an empty query filter to  Find() . You can download a GridFS file by using one of the following methods: DownloadToStream() , which downloads a file to an output stream OpenDownloadStream() , which opens an input stream You can download a file in a GridFS bucket directly to an output stream\nby using the  DownloadToStream()  method. The  DownloadToStream() \nmethod takes a file ID and an  io.Writer  instance as parameters. The\nmethod downloads the file with the specified file ID and writes it to the\n io.Writer  instance. The following example downloads a file and writes to a file buffer: You can download a file in a GridFS bucket to memory with an input\nstream by using the  OpenDownloadStream()  method. The\n OpenDownloadStream()  method takes a file ID as a parameter and\nreturns an input stream from which you can read the file. The following example downloads a file into memory and reads its contents: You can update the name of a GridFS file in your bucket by using the  Rename() \nmethod. Pass a file ID value and a new  filename  value as arguments to\n Rename() . The following example renames a file to  \"mongodbTutorial.zip\" : You can remove a file from your GridFS bucket by using the  Delete()  method.\nPass a file ID value as an argument to  Delete() . The following example deletes a file: You can delete a GridFS bucket by using the  Drop()  method. The following code example removes a GridFS bucket: To learn more about GridFS and storage, see the following pages in the Server\nmanual: GridFS FAQ: MongoDB Storage To learn more about the methods and types mentioned in this guide, see\nthe following API documentation: GridFSBucket() OpenUploadStream() UploadFromStream() Find() OpenDownloadStream() DownloadToStream() Rename() Delete() Drop()",
            "code": [
                {
                    "lang": "go",
                    "value": "db := client.Database(\"myDB\")\nbucket := db.GridFSBucket()"
                },
                {
                    "lang": "go",
                    "value": "db := client.Database(\"myDB\")\nbucketOpts := options.GridFSBucket().SetName(\"myCustomBucket\")\n\nbucket := db.GridFSBucket(bucketOpts)"
                },
                {
                    "lang": "go",
                    "value": "file, err := os.Open(\"home/documents/file.txt\")\nuploadOpts := options.GridFSUpload().SetMetadata(bson.D{{\"metadata tag\", \"first\"}})\n\nobjectID, err := bucket\n   .UploadFromStream(\n      \"file.txt\",\n      io.Reader(file),\n      uploadOpts\n   )\nif err != nil {\n   panic(err)\n}\n\nfmt.Printf(\"New file uploaded with ID %s\", objectID)"
                },
                {
                    "lang": "none",
                    "value": "New file uploaded with ID ..."
                },
                {
                    "lang": "go",
                    "value": "file, err := os.Open(\"home/documents/file.txt\")\nif err != nil {\n\tpanic(err)\n}\n\n// Defines options that specify configuration information for files\n// uploaded to the bucket\nuploadOpts := options.GridFSUpload().SetChunkSizeBytes(200000)\n\n// Writes a file to an output stream\nuploadStream, err := bucket.OpenUploadStream(\"file.txt\", uploadOpts)\nif err != nil {\n\tpanic(err)\n}\nfileContent, err := io.ReadAll(file)\nif err != nil {\n\tpanic(err)\n}\nvar bytes int\nif bytes, err = uploadStream.Write(fileContent); err != nil {\n\tpanic(err)\n}\nfmt.Printf(\"New file uploaded with %d bytes written\", bytes)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"length\", bson.D{{\"$gt\", 1500}}}}\ncursor, err := bucket.Find(filter)\nif err != nil {\n   panic(err)\n}\n\ntype gridFSFile struct {\n   Name   string `bson:\"filename\"`\n   Length int64  `bson:\"length\"`\n}\n\nvar foundFiles []gridFSFile\nif err = cursor.All(context.TODO(), &foundFiles); err != nil {\n   panic(err)\n}\n\nfor _, file := range foundFiles {\n   fmt.Printf(\"filename: %s, length: %d\\n\", file.Name, file.Length)\n}"
                },
                {
                    "lang": "go",
                    "value": "id, err := primitive.ObjectIDFromHex(\"62f7bd54a6e4452da13b3e88\")\nfileBuffer := bytes.NewBuffer(nil)\n\nif _, err := bucket.DownloadToStream(id, fileBuffer); err != nil {\n   panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "id, err := primitive.ObjectIDFromHex(\"62f7bd54a6e4452da13b3e88\")\ndownloadStream, err := bucket.OpenDownloadStream(id)\nif err != nil {\n   panic(err)\n}\n\nfileBytes := make([]byte, 1024)\nif _, err := downloadStream.Read(fileBytes); err != nil {\n   panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "id, err := primitive.ObjectIDFromHex(\"62f7bd54a6e4452da13b3e88\")\nif err := bucket.Rename(id, \"mongodbTutorial.zip\"); err != nil {\n    panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "id, err := primitive.ObjectIDFromHex(\"62f7bd54a6e4452da13b3e88\")\nif err := bucket.Delete(id); err != nil {\n   panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "if err := bucket.Drop(); err != nil {\n   panic(err)\n}"
                }
            ],
            "preview": "In this guide, you can learn how to store and retrieve large files in\nMongoDB using the GridFS specification. GridFS splits large files\ninto chunks and stores each chunk as a separate document. When you query\nGridFS for a file, the driver assembles the chunks as necessary. The\ndriver implementation of GridFS is an abstraction that manages the operations\nand organization of the file storage.",
            "tags": "code example, large files, storage, images",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/connections/connection-guide",
            "title": "Connection Guide",
            "headings": [
                "Overview",
                "Connection URI",
                "Parts of a Connection URI",
                "Connection Example",
                "Other Ways to Connect to MongoDB",
                "Connect to a MongoDB Server on Your Local Machine",
                "Connect to a Replica Set",
                "Direct Connection",
                "Connection Options",
                "Single Timeout Setting"
            ],
            "paragraphs": "In this guide, you can learn how to connect to a MongoDB instance or\nreplica set deployment by using the Go driver. You can use the Go driver to connect to deployments hosted in the\nfollowing environments: MongoDB Atlas : the fully\nmanaged service for MongoDB deployments in the cloud MongoDB Enterprise : the\nsubscription-based, self-managed version of MongoDB MongoDB Community : the\nsource-available, free-to-use, and self-managed version of MongoDB A  connection URI , also known as a connection string, tells the\ndriver how to connect to MongoDB and how to behave while connected. The following example explains each part of a sample connection URI: In this example, we use  mongodb  for the protocol, which specifies the\n Standard Connection String Format .\nYou can also use the  DNS Seed List Connection Format  if you\nwant more flexibility of deployment and the ability to change the\nservers in rotation without reconfiguring clients. The next part of the connection string contains your username and, if\nyou are using password-based authentication, your password. Replace the value of\n user  with your username and  pass  with your password. If you are using an\nauthentication mechanism that does not require a username and password, omit\nthis part of the connection URI. The next part of the connection string specifies the hostname or IP address and\nport of your MongoDB instance. In the preceding example, we use  sample.host \nas the hostname and  27017  as the port. Replace these values to point to\nyour MongoDB instance. The last part of the connection string specifies connection and authentication\noptions. In the example, we set two connection options:\n maxPoolSize=20  and  w=majority . To learn more about connection\noptions, read the  Connection Options  section of this guide. To connect to MongoDB, you must create a client. A client manages your\nconnections and runs database commands. You can create a client that uses your connection string and other\nclient options by passing a  ClientOptions  object to the  Connect() \nmethod. To specify your connection URI, pass it to the  ApplyURI() \nmethod, which returns a new  ClientOptions  instance. To set any other\noptions, call the relevant helper method from the  options  package. To learn more about connection options, see the\n Connection Options section . To learn\nmore about creating a client, see the API documentation for  Client  and  Connect() . You can set the Stable API version as an option to avoid\nbreaking changes when you upgrade to a new server version. To\nlearn more about the Stable API feature, see the  Stable API page . The following code shows how you can create a client that uses an Atlas\nconnection string and the Stable API version, connect to MongoDB, and\nverify that the connection is successful: We recommend that you reuse your client across sessions and operations.\nYou can use the same  Client  instance to perform multiple tasks, instead of\ncreating a new one each time. The  Client  type is safe for\nconcurrent use by multiple  goroutines . To learn more about\nhow connection pools work in the driver, see the  FAQ page . Follow the  Quick Start guide \nto retrieve your Atlas connection string. To learn about connecting to Atlas Serverless, see the\n Serverless Instance Limitations page  to identify the minimum driver version\nrequired. If you are connecting to a single MongoDB server instance or replica set\nthat is not hosted on Atlas, see the following sections to find out how to\nconnect. To test whether you can connect to your server, replace the connection\nstring with your localhost connection string in the preceding code example. If you must run a MongoDB server on your local machine for development\npurposes, complete the following steps: After you successfully start your MongoDB server, specify your connection\nstring in your driver connection code. If your MongoDB Server is running locally, you can use the connection string\n \"mongodb://localhost:<port>\"  where  <port>  is the port number you\nconfigured your server to listen for incoming connections. If you want to specify a different hostname or IP address, see our Server\nManual entry on  Connection Strings . Download the  Community \nor  Enterprise  version\nof MongoDB Server. Install and configure  MongoDB Server. Start the server. Always secure your MongoDB server from malicious attacks. See our\n Security Checklist  for a\nlist of security recommendations. A MongoDB replica set deployment is a group of connected instances that\nstore the same set of data. This configuration provides data\nredundancy and high data availability. To connect to a replica set deployment, specify the hostname and port numbers\nof each instance, separated by commas, and the replica set name as the value\nof the  replicaSet  parameter in the connection string. In the following\nexample, the hostnames are  host1 ,  host2 , and  host3 , and the\nport numbers are all  27017 . The replica set name is  myRS . When connecting to a replica set, the driver takes the following actions by default: Discovers all replica set members when given the address of any one member. Dispatches operations to the appropriate member, such as instructions\nto write against the  primary . You can specify just one host to connect to a replica set.\nHowever, to ensure connectivity when the specified host\nis unavailable, you should provide the full list of hosts. To force operations on the host designated in the connection URI, specify the  directConnection  option. Direct\nconnections: Don't support SRV strings. Fail on writes when the specified host is not the  primary . Require you to  specify a secondary read preference \nwhen the specified host isn't the  primary . This section explains several common MongoDB connection and authentication\noptions. You can pass the connection options as parameters of the connection\nURI to specify the behavior of the client. For a full list of connection options, see the  ClientOptions API\ndocumentation . Option Name Type Default Value Description timeoutMS integer null Specifies the number of milliseconds that a single operation run on the\n Client  can take before returning a timeout error. Operations honor\nthis setting only if there is no deadline on the operation Context. connectTimeoutMS integer 30000 Specifies the number of milliseconds to wait before timeout on a TCP\nconnection. maxPoolSize integer 100 Specifies the maximum number of connections that a connection pool may\nhave at a given time. replicaSet string null Specifies the replica set name for the cluster. All nodes in the\nreplica set must have the same replica set name, or the Client will not\nconsider them as part of the set. maxIdleTimeMS integer 0 Specifies the maximum amount of time a connection can remain idle\nin the connection pool before being removed and closed. The\ndefault is  0 , meaning a connection can remain unused\nindefinitely. minPoolSize integer 0 Specifies the minimum number of connections that the driver maintains\nin a single connection pool. socketTimeoutMS integer 0 Specifies the number of milliseconds to wait for a socket read or\nwrite to return before returning a network error. The  0 \ndefault value indicates that there is no timeout. serverSelectionTimeoutMS integer 30000 Specifies the number of milliseconds to wait to find an available,\nsuitable server to execute an operation. heartbeatFrequencyMS integer 10000 Specifies the number of milliseconds to wait between periodic\nbackground server checks. tls boolean false Specifies whether to establish a Transport Layer Security (TLS)\nconnection with the instance. This is automatically set to  true \nwhen using a DNS seedlist (SRV) in the connection string. You can\noverride this behavior by setting the value to  false . w string or integer null Specifies the write concern. To learn more about values, see the\nserver documentation on\n Write Concern options . directConnection boolean false Specifies whether to force dispatch  all  operations to the host\nspecified in the connection URI. You can set a single  Timeout  option on your  Client  to govern the\namount of time that a single operation can take to execute using the\n SetTimeout()  method or specifying the  timeoutMS  option in your\nconnection URI string.  Database ,  Collection ,\n Session ,  ChangeStream , and  Bucket  instances elsewhere in\nyour code inherit the  Timeout  option from  Client  if you do not set a\nContext for operations against the same entity. If you pass a Context into an operation with a deadline, the driver uses\nthat Context deadline for the operation. If the context does not have a\ndeadline, the driver derives a new Context from the given Context using\nthe  Timeout  option set on the  Client . The following code shows how to set the  Timeout  option on a  Client \nwith the  SetTimeout  option: The following example shows how you can set a single timeout with the\nURI option and execute an operation that inherits this setting: With default settings, if you set a  Timeout  option on your  Client \nand your operation requires a retry, the driver retries the operation\nas many times as possible before the timeout expires. Once the timeout\nexpires, the driver returns a timeout error. Versions 1.1 and later\nof the Go driver enable retryable reads and writes by default.\nSee the Server manual for more information about  retryable\nreads  and  retryable writes . SocketTimeout ,  wTimeout ,  MaxTime , and  MaxCommitTime \nwill be deprecated in an upcoming release. The driver ignores  MaxTime  and\n MaxCommitTime  if you set  Timeout . The driver still honors\n SocketTimeout  and  wTimeout , but these settings may result in\nundefined behavior. Consider using only the single timeout option instead.",
            "code": [
                {
                    "lang": "go",
                    "value": "// Connects to MongoDB and sets a Stable API version\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n\tvar uri string\n\tif uri = os.Getenv(\"MONGODB_URI\"); uri == \"\" {\n\t\tlog.Fatal(\"You must set your 'MONGODB_URI' environment variable. See\\n\\t https://docs.mongodb.com/drivers/go/current/usage-examples/\")\n\t}\n\n\t// Use the SetServerAPIOptions() method to set the Stable API version to 1\n\tserverAPI := options.ServerAPI(options.ServerAPIVersion1)\n\topts := options.Client().ApplyURI(uri).SetServerAPIOptions(serverAPI)\n\n\t// Create a new client and connect to the server\n\tclient, err := mongo.Connect(opts)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer func() {\n\t\tif err = client.Disconnect(context.TODO()); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t// Send a ping to confirm a successful connection\n\tvar result bson.M\n\tif err := client.Database(\"admin\").RunCommand(context.TODO(), bson.D{{\"ping\", 1}}).Decode(&result); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Pinged your deployment. You successfully connected to MongoDB!\")\n}\n"
                },
                {
                    "lang": "none",
                    "value": "mongodb://host1:27017,host2:27017,host3:27017/?replicaSet=myRS"
                },
                {
                    "lang": "go",
                    "value": "opts := options.Client().SetTimeout(5 * time.Second)"
                },
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://user:pass@sample.host:27017/?timeoutMS=5000\"\n\nclient, err := mongo.Connect(options.Client().ApplyURI(uri))\ncoll := client.Database(\"<db>\").Collection(\"<collection>\")\n\n...\ncoll.InsertOne(context.Background(), doc)"
                }
            ],
            "preview": "In this guide, you can learn how to connect to a MongoDB instance or\nreplica set deployment by using the Go driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/aggregation",
            "title": "Aggregation",
            "headings": [
                "Overview",
                "Analogy",
                "Compare Operations",
                "Limitations",
                "Examples",
                "Average Rating",
                "Omit Fields in Results",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use  aggregation operations  in the\nMongoDB Go Driver. Aggregation operations process data in your MongoDB collections based on\nyour specifications in the  aggregation pipeline . An aggregation\npipeline consists of one or more  stages . Each stage performs an\noperation based on its expression operators. After the driver executes\nthe aggregation pipeline, it returns an aggregated result. Aggregation operations operate similarly to a car factory. Car factories\nhave an assembly line. The assembly lines have assembly stations with\nspecialized tools to perform a specific task. To build a car, you send\nraw parts to the factory. Then, the assembly line transforms and\nassembles the parts into a car. The assembly line resembles the  aggregation pipeline , the assembly\nstations in the assembly line resemble the  aggregation stages , the\nspecialized tools represent the  expression operators , and the\nfinished product resembles the  aggregated result . The following table lists the tasks you can perform by using find and aggregation operations. Find Operations Aggregation Operations Aggregation operations have limitations. When performing aggregation\noperations, keep the following in mind: Returned documents must not violate the  BSON document size\nlimit  of 16 megabytes. Pipeline stages have a memory limit of 100 megabytes by default. If\nrequired, you may exceed this limit by using the  allowDiskUse \nmethod. The  $graphLookup  stage\nhas a strict memory limit of 100 megabytes and ignores\n allowDiskUse . The examples in this section use the following  Tea  struct as a model for documents\nin the  tea  collection: To run the examples in this section, load the sample data into the\n tea  collection in the  db  database by using the following snippet: Each document contains information about the tea type, the available toppings, and\nthe price. The following example calculates and displays the average rating and\nnumber of ratings for each tea category. The aggregation pipeline uses the  $group  stage to group the\ndocuments by the  category  field, calculates the average using the\n $avg  expression operator, and counts the number of documents using\nthe  $sum  expression operator. The following example matches documents where you can get milk foam as a\ntopping and lists the two cheapest options. The aggregation pipeline contains the following stages: $match  stage to match documents where the  toppings  field contains \"milk foam\" $unset  stage to omit the  _id  and  category  fields $sort  stage to sort the  price  and  toppings  in ascending order $limit  stage to show the first two documents To learn more about the terms mentioned, see the following\nguides: To view more aggregation examples, see the following guides: To learn more about the  Aggregate()  method and its behavior, see\n Retrieve Data . Expression Operators Aggregation Pipeline Aggregation Stages Operator Expressions Aggregation Pipeline Limits Count Limit Skip Text To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Aggregate() AggregateOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "type Tea struct {\n\tType     string\n\tCategory string\n\tToppings []string\n\tPrice    float32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"tea\")\ndocs := []interface{}{\n\tTea{Type: \"Masala\", Category: \"black\", Toppings: []string{\"ginger\", \"pumpkin spice\", \"cinnamon\"}, Price: 6.75},\n\tTea{Type: \"Gyokuro\", Category: \"green\", Toppings: []string{\"berries\", \"milk foam\"}, Price: 5.65},\n\tTea{Type: \"English Breakfast\", Category: \"black\", Toppings: []string{\"whipped cream\", \"honey\"}, Price: 5.75},\n\tTea{Type: \"Sencha\", Category: \"green\", Toppings: []string{\"lemon\", \"whipped cream\"}, Price: 5.15},\n\tTea{Type: \"Assam\", Category: \"black\", Toppings: []string{\"milk foam\", \"honey\", \"berries\"}, Price: 5.65},\n\tTea{Type: \"Matcha\", Category: \"green\", Toppings: []string{\"whipped cream\", \"honey\"}, Price: 6.45},\n\tTea{Type: \"Earl Grey\", Category: \"black\", Toppings: []string{\"milk foam\", \"pumpkin spice\"}, Price: 6.15},\n\tTea{Type: \"Hojicha\", Category: \"green\", Toppings: []string{\"lemon\", \"ginger\", \"milk foam\"}, Price: 5.55},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "groupStage := bson.D{\n\t{\"$group\", bson.D{\n\t\t{\"_id\", \"$category\"},\n\t\t{\"average_price\", bson.D{{\"$avg\", \"$price\"}}},\n\t\t{\"type_total\", bson.D{{\"$sum\", 1}}},\n\t}}}\n\n// Performs the aggregation and prints the results\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{groupStage})\nif err != nil {\n\tpanic(err)\n}\n\nvar results []bson.M\nif err = cursor.All(context.TODO(), &results); err != nil {\n\tpanic(err)\n}\nfor _, result := range results {\n\tfmt.Printf(\"Average price of %v tea options: $%v \\n\", result[\"_id\"], result[\"average_price\"])\n\tfmt.Printf(\"Number of %v tea options: %v \\n\\n\", result[\"_id\"], result[\"type_total\"])\n}"
                },
                {
                    "lang": "none",
                    "value": "Average price of black tea options: $6.075\nNumber of black tea options: 4\n\nAverage price of green tea options: $5.70\nNumber of green tea options: 4"
                },
                {
                    "lang": "go",
                    "value": "matchStage := bson.D{{\"$match\", bson.D{{\"toppings\", \"milk foam\"}}}}\nunsetStage := bson.D{{\"$unset\", bson.A{\"_id\", \"category\"}}}\nsortStage := bson.D{{\"$sort\", bson.D{{\"price\", 1}, {\"toppings\", 1}}}}\nlimitStage := bson.D{{\"$limit\", 2}}\n\n// Performs the aggregation and prints the results\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{matchStage, unsetStage, sortStage, limitStage})\nif err != nil {\n\tpanic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n\tpanic(err)\n}\nfor _, result := range results {\n\tfmt.Printf(\"Tea: %v \\nToppings: %v \\nPrice: $%v \\n\\n\", result.Type, strings.Join(result.Toppings, \", \"), result.Price)\n}"
                },
                {
                    "lang": "none",
                    "value": "Tea: Hojicha\nToppings: lemon, ginger, milk foam\nPrice: $5.55\n\nTea: Gyokuro\nToppings: berries, milk foam\nPrice: $5.65"
                }
            ],
            "preview": "In this guide, you can learn how to use aggregation operations in the\nMongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/connections/network-compression",
            "title": "Network Compression",
            "headings": [
                "Overview",
                "Specify Compression Algorithms",
                "Compression Algorithm Dependencies",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to enable  network compression  by using\nthe Go driver. You can specify a client option to compress messages,\nwhich reduces the amount of data passed over the network between MongoDB and\nyour application. The Go driver supports the following compression algorithms: If you specify multiple compression algorithms, the driver selects the\nfirst one in the list supported by your MongoDB deployment. You must add dependencies to use the Snappy or Zstandard compression algorithm.\nFor more information, see the  Compression Algorithm Dependencies  section of this\nguide. Snappy : available in MongoDB 3.4 and later. Zlib : available in MongoDB 3.6 and later. Zstandard : available in MongoDB 4.2 and later. You can enable compression for the connection to your MongoDB deployment\nby specifying the algorithms in one of two ways: Specify compression algorithms by using the following strings: Set the compression algorithm in your connection string. Set the compression algorithm in a  ClientOptions  instance. To enable compression by using the connection string, add the compression\nalgorithm as the value of the  compressors  parameter to your connection\nstring. You can specify one or more compression algorithms separated by\ncommas: To enable compression by specifying a  ClientOptions  instance, pass one or more\ncompression algorithms to the  SetCompressors()  method as a string\narray: \"snappy\"  for  Snappy  compression \"zlib\"  for  Zlib  compression \"zstd\"  for  Zstandard  compression To add the Snappy compression algorithm to your application, run the\nfollowing code: To add the Zstandard compression algorithm to your application, run the\nfollowing code: To add the Zlib compression algorithm to your application, import the built-in\n zlib  package. You must add the following import statement to application files\nthat instantiate a  Client  with Zlib compression: For more information about the concepts in this guide, see the following\ndocumentation: Connection URI  in the Connection Guide Connection String Compression Options \nin the Server manual The zlib package  Go documentation SetCompressors() ClientOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "opts := options.Client().ApplyURI(\"mongodb://localhost:27017/?compressors=snappy,zlib,zstd\")\nclient, _ := mongo.Connect(opts)"
                },
                {
                    "lang": "go",
                    "value": "opts := options.Client().SetCompressors([]string{\"snappy\", \"zlib\", \"zstd\"})\nclient, _ := mongo.Connect(opts)"
                },
                {
                    "lang": "bash",
                    "value": "go get github.com/golang/snappy"
                },
                {
                    "lang": "bash",
                    "value": "go get -u github.com/klauspost/compress"
                },
                {
                    "lang": "go",
                    "value": "import \"compress/zlib\""
                }
            ],
            "preview": "In this guide, you can learn how to enable network compression by using\nthe Go driver. You can specify a client option to compress messages,\nwhich reduces the amount of data passed over the network between MongoDB and\nyour application.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations",
            "title": "Read Operations",
            "headings": [],
            "paragraphs": "Specify a Query Count Documents Retrieve Data Access Data From a Cursor Retrieve Distinct Values Sort Results Skip Returned Results Limit the Number of Returned Results Specify Which Fields to Return Search Text Monitor Data Changes",
            "code": [],
            "preview": "Learn about the commands for running MongoDB read operations by using the MongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/connections/tls",
            "title": "Enable and Configure TLS",
            "headings": [
                "Overview",
                "Enable TLS",
                "Configure Certificates",
                "Reference Certificates in a Client",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use the TLS protocol to secure\nyour connection to a MongoDB deployment. To configure your connection to\nuse TLS, enable the TLS option and provide your certificates for\nvalidation when creating a client. This guide includes the following sections: Enable TLS  describes ways to enable TLS on\nyour connection Configure Certificates \ndescribes the certificates required to configure TLS Reference Certificates in a Client \nprovides an example of how to create a  Config  struct to configure your\nTLS options Additional Information \nprovides links to resources and API documentation for types\nand methods mentioned in this guide To learn more about TLS, see the Wikipedia entry on\n Transport Layer Security . You can enable TLS on a connection to your MongoDB instance\nin one of the following ways: Select from the following  Connection String  and\n ClientOptions  tabs to see a corresponding code sample: For a full list of client options, see  Connection Options . Setting the  tls  option to  true  in your connection string Passing an empty  Config  struct to the  SetTLSConfig() \nmethod when creating a  ClientOptions  instance If your connection string uses a DNS SRV record by including\nthe  mongodb+srv  prefix, TLS is enabled on your connection by\ndefault. To successfully initiate a TLS request, your application must present\ncryptographic certificates to prove its identity. Your application's\ncertificates must be stored as PEM files to enable TLS when connecting. The following list describes the components that your client must\npresent to establish a TLS-enabled connection: For production use, we recommend that your MongoDB deployment use valid\ncertificates generated and signed by the same certificate authority.\nFor testing, your deployment can use self-signed certificates. TLS Component Description Certificate Authority (CA) One or more certificate authorities to\ntrust when making a TLS connection. Client Certificate A digital certificate that allows the server to verify the identity\nof your application to establish an encrypted network connection. Certificate Key The client certificate private key file. This key is often\nincluded within the certificate file itself. Passphrase The password to decrypt the private client key if it is encrypted. You must reference your certificates in your  ClientOptions \nobject so that the server can validate them before the client connects.\nWe recommend that you set the  TLSConfig  field of your\n ClientOptions  instance to a  Config  struct to configure your\nTLS connection.  Config  structs are native to Go and allow you to keep\nall your TLS options in a single reusable object. To create a  Config  instance, import the  crypto/tls  and\n crypto/x509  packages. Next, create a  Config  struct instance and\nset the relevant struct fields for your configuration. Within your  Config  instance, you can set optional\nfields to configure TLS on your connection. For  testing purposes ,\nyou can set the  InsecureSkipVerify  field to  true . To learn more about the  Config  struct, see the  tls.Config API\ndocumentation . Setting the  InsecureSkipVerify  field to  true  disables\nboth certificate and hostname validation. Specifying this option in a production environment makes\nyour application insecure and potentially\nvulnerable to expired certificates and foreign processes posing\nas valid client instances. This example performs the following actions to create a  Config \ninstance and a  Client  instance with TLS enabled: Creates variables to reference the certificate filepaths Creates a CA file pool by using the  x509.NewCertPool()  method\nand appends the contents of the CA file Loads the client certificate files by using the\n tls.LoadX509KeyPair()  method Instantiates a  Config  struct and sets the  RootCAs  and\n Certificates  fields Passes the  Config  instance to the  SetTLSConfig()  method to\nset the  TLSConfig  field of the  ClientOptions To learn more about enabling TLS on a connection, see the\nfollowing Server manual documentation: TLS/SSL (Transport Encryption) TLS/SSL Configuration for Clients To learn more about the methods and types mentioned in this\nguide, see the following API documentation: ClientOptions SetTLSConfig() tls package x509 package",
            "code": [
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://<hostname>:<port>?tls=true\"\nopts := options.Client().ApplyURI(uri)\nclient, _ := mongo.Connect(opts)"
                },
                {
                    "lang": "go",
                    "value": "uri := \"<connection string>\"\nopts := options.Client().ApplyURI(uri).SetTLSConfig(&tls.Config{})\nclient, _ := mongo.Connect(opts)"
                },
                {
                    "lang": "go",
                    "value": "// Enable TLS on a connection by using the Go driver\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"os\"\n\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n\n\tcaFile := \"<path to CA certificate>\"\n\tcertFile := \"<path to public client certificate>\"\n\tkeyFile := \"<path to private client key>\"\n\n\t// Loads CA certificate file\n\tcaCert, err := os.ReadFile(caFile)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcaCertPool := x509.NewCertPool()\n\tif ok := caCertPool.AppendCertsFromPEM(caCert); !ok {\n\t\tpanic(\"Error: CA file must be in PEM format\")\n\t}\n\n\t// Loads client certificate files\n\tcert, err := tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Instantiates a Config instance\n\ttlsConfig := &tls.Config{\n\t\tRootCAs:      caCertPool,\n\t\tCertificates: []tls.Certificate{cert},\n\t}\n\n\turi := \"<connection string>\"\n\n\t// Sets TLS options in options instance\n\topts := options.Client().ApplyURI(uri).SetTLSConfig(tlsConfig)\n\n\t// Connects to MongoDB with TLS enabled\n\tclient, err := mongo.Connect(opts)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer func() {\n\t\tif err = client.Disconnect(context.TODO()); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n}\n"
                }
            ],
            "preview": "In this guide, you can learn how to use the TLS protocol to secure\nyour connection to a MongoDB deployment. To configure your connection to\nuse TLS, enable the TLS option and provide your certificates for\nvalidation when creating a client.",
            "tags": "code example, security, connection options",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations",
            "title": "Write Operations",
            "headings": [],
            "paragraphs": "Insert a Document Delete Documents Modify Documents Update Arrays in a Document Insert or Update in a Single Operation Bulk Operations",
            "code": [],
            "preview": "Learn about the commands for running MongoDB write operations by using the MongoDB Go Driver.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/encrypt-fields",
            "title": "In-Use Encryption",
            "headings": [
                "Overview",
                "Queryable Encryption",
                "Client-side Field Level Encryption"
            ],
            "paragraphs": "You can use the Go driver to encrypt specific document fields by using a\nset of features called  in-use encryption . In-use encryption allows\nyour application to encrypt data  before  sending it to MongoDB\nand query documents with encrypted fields. In-use encryption prevents unauthorized users from viewing plaintext\ndata as it is sent to MongoDB or while it is in an encrypted database. To\nenable in-use encryption in an application and authorize it to decrypt\ndata, you must create encryption keys that only your application can\naccess. Only applications that have access to your encryption\nkeys can access the decrypted, plaintext data. If an attacker gains\naccess to the database, they can only see the encrypted ciphertext data\nbecause they lack access to the encryption keys. You might use in-use encryption to encrypt fields in your MongoDB\ndocuments that contain the following types of sensitive data: MongoDB offers the following features to enable in-use encryption: Credit card numbers Addresses Health information Financial information Any other sensitive or personally identifiable information (PII) Queryable Encryption Client-side Field Level Encryption Queryable Encryption is the next-generation in-use encryption feature,\nfirst introduced as a preview feature in MongoDB Server version 6.0 and\nas a generally available (GA) feature in MongoDB 7.0. Queryable\nEncryption supports searching encrypted fields for equality and encrypts\neach value uniquely. To learn more about Queryable Encryption, see  Queryable\nEncryption  in the Server manual. The implementation of Queryable Encryption in MongoDB 6.0 is incompatible with the GA version introduced in MongoDB 7.0. The Queryable Encryption preview feature is no longer supported. Client-side Field Level Encryption (CSFLE) was introduced in MongoDB\nServer version 4.2 and supports searching encrypted fields for equality.\nCSFLE differs from Queryable Encryption in that you can select either a\ndeterministic or random encryption algorithm to encrypt fields. You can only\nquery encrypted fields that use a deterministic encryption algorithm when\nusing CSFLE. When you use a random encryption algorithm to encrypt\nfields in CSFLE, they can be decrypted, but you cannot perform equality\nqueries on those fields. When you use Queryable Encryption, you cannot\nspecify the encryption algorithm, but you can query all encrypted\nfields. When you deterministically encrypt a value, the same input value\nproduces the same output value. While deterministic encryption allows\nyou to perform queries on those encrypted fields, encrypted data with\nlow cardinality is susceptible to code breaking by frequency analysis. To learn more about CSFLE, see  CSFLE  in the\nServer manual. To learn more about these concepts, see the following Wikipedia\nentries: Cardinality Frequency Analysis",
            "code": [],
            "preview": "You can use the Go driver to encrypt specific document fields by using a\nset of features called in-use encryption. In-use encryption allows\nyour application to encrypt data before sending it to MongoDB\nand query documents with encrypted fields.",
            "tags": "privacy, security",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-read-pref",
            "title": "Modify Execution of CRUD Operations",
            "headings": [
                "Overview",
                "Write Concern",
                "Options",
                "Example",
                "Read Concern",
                "Options",
                "Example",
                "Read Preference",
                "Options",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to modify the way that the MongoDB Go Driver\nexecutes create, read, update, and delete (CRUD) operations using\n write concern ,  read concern , and  read preference  configurations\nfor replica sets. You can set write concern, read concern, and read preference options at\nthe following levels: In the following sections, you can learn how to customize the consistency and\navailability of the data in your replica sets. Client level, which sets the  default for all operation executions \nunless overridden Session level Transaction level Database level Collection level A write concern describes the number of data-bearing\nmembers in a replica set that must acknowledge a write operation, such\nas an insert or update, before the operation is returned as successful.\nBy default, the write concern requires only the primary\nreplica set member to acknowledge the write operation before the\noperation is deemed successful. The MongoDB Go Driver provides the  writeconcern  package, which lets\nyou specify the write concern for a replica set. Set the write\nconcern using the  SetWriteConcern()  method with a  WriteConcern \ntype. The  WriteConcern  type has the following methods to\nselect common write concern specifications: If you require a more specialized write concern, you can define a custom\n WriteConcern  struct literal. You can set the following fields in a\n WriteConcern  struct: Method Description Custom() Journaled() Majority() Unacknowledged() W1() Field Description W Journal WTimeout You can alternatively specify a write concern in your connection\nstring. See the  Server manual entry on Write Concern Options  for more information. The following code shows how you can specify different write concerns\nat the client and collection level. The  client-level  write concern\nrequests acknowledgement from two replica set members and sets journaling to\n false . The  collection-level  write concern requests\nacknowledgement from the majority of replica set members. The read concern option allows you to determine which data the client\nreturns from a query. The default read concern level is \"local\", meaning\nthat the client returns the instance\u2019s most recent data, with no guarantee that\nthe data has been written to a majority of the replica set members. The MongoDB Go Driver provides the  readconcern  package, which lets\nyou specify the read concern for a replica set. Set the read concern using the\n SetReadConcern()  method with a  ReadConcern  type. The  ReadConcern \ntype has the following methods to specify the read concern: Method Description Available() The query returns data from the instance\nwith no guarantee that the data has been written to a majority of\nthe replica set members. For more information, see the\n Read Concern specification . Linearizable() The query returns data that reflects all\nsuccessful writes issued with a write concern of  majority  and\nacknowledged prior to the start of the read operation. For more information, see the\n Read Concern specification . Local() The query returns the instance\u2019s most recent\ndata. For more information, see the\n Read Concern specification . Majority() The query returns the instance\u2019s most recent\ndata acknowledged as having been written to a majority of members\nin the replica set. For more information, see the\n Read Concern specification . Snapshot() The query returns a complete copy of the\ndata in a  mongod  instance at a specific point in time. Only\navailable for operations within multi-document transactions. For more information, see the\n Read Concern specification . The following code shows how you can specify a read concern of\n\"majority\". The code then selects a  Collection \nwith this option. The read preference option specifies how the MongoDB client routes read\noperations to the members of a replica set. By default, an application\ndirects its read operations to the primary member in a replica set. Read preference consists of the read preference mode and, optionally, a\n tag set list , the\n maxStalenessSeconds  option, and the\n hedged read  option. The MongoDB Go Driver provides the  readpref  package, which lets\nyou specify the read preference for a replica set. Set the read preference using the\n SetReadPreference()  method with a  ReadPref  type. The  ReadPref \ntype has the following methods to specify the read preference: Method Description Nearest() The client reads from a random eligible replica set member,\nprimary or secondary, based on a specified latency threshold. For more information, see the\n Read Preference Server manual entry . Primary() The client reads from the current replica set primary node. For more information, see the\n Read Preference Server manual entry . PrimaryPreferred() The client reads from the primary node in most situations. If the primary is\nunavailable, operations read from secondary members. For more\ninformation, see the  Read Preference Server manual entry . Secondary() The client reads from the secondary members of the replica set. For more information, see the\n Read Preference Server manual entry . SecondaryPreferred() The client reads from the secondary nodes in most situations. If the secondaries are\nunavailable, operations read from the primary member. For more information, see the\n Read Preference Server manual entry . You can alternatively specify a read preference in your connection\nstring. See the  Server manual entry on Read Preference\nOptions  for\nmore information. The following code shows how you can specify a read preference to read\nfrom secondary nodes. The code then selects a  Database \nwith this option. For more information about the concepts in this guide, see the following\nServer documentation: Connection Guide Write Concern for Replica Sets Read Concern Read Preference WriteConcern ReadConcern ReadPref",
            "code": [
                {
                    "lang": "go",
                    "value": "uri := \"mongodb://<hostname>:<port>\"\njournal := false\ncliWC := &writeconcern.WriteConcern{\n    W: 2,\n    Journal: &journal,\n}\nclOpts := options.Client().ApplyURI(uri).SetWriteConcern(cliWC)\nclient, err := mongo.Connect(clOpts)\n...\n\ncollWC := writeconcern.Majority()\ncollOpts := options.Collection().SetWriteConcern(collWC)\ncoll := client.Database(\"db\").Collection(\"myColl\", collOpts)"
                },
                {
                    "lang": "go",
                    "value": "rc := readconcern.Majority()\nopts := options.Collection().SetReadConcern(rc)\ndatabase := client.Database(\"db\")\ncoll := database.Collection(\"myCollection\", opts)"
                },
                {
                    "lang": "go",
                    "value": "rp := readpref.Secondary()\nopts := options.Database().SetReadPreference(rp)\ndatabase := client.Database(\"db\", opts)"
                }
            ],
            "preview": "In this guide, you can learn how to modify the way that the MongoDB Go Driver\nexecutes create, read, update, and delete (CRUD) operations using\nwrite concern, read concern, and read preference configurations\nfor replica sets.",
            "tags": "code example, replica set, consistency",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/cursor",
            "title": "Access Data From a Cursor",
            "headings": [
                "Overview",
                "Sample Cursor",
                "Retrieve Documents Individually",
                "Tailable Cursor",
                "Retrieve All Documents",
                "Close the Cursor",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to access data with a  cursor . A cursor is a mechanism that allows an application to iterate over\ndatabase results while holding only a subset of them in memory at a\ngiven time. Read operations that match multiple documents use a cursor\nto return those documents in batches rather than all at once. Each section uses the following  cursor  variable, which is a\n Cursor  struct that contains all the documents in a collection: In the examples in this guide, the driver unmarshals documents held in\nthe  cursor  variable to a sample  MyStruct  struct. A cursor is not  goroutine  safe. Do not use the same cursor in\nmultiple goroutines at the same time. To retrieve documents from your cursor individually while blocking the\ncurrent goroutine, use the  Next()  method. The method returns a document if all of the following conditions are met: A document is currently or will later be available. The driver didn't throw any errors. The context didn't expire. To attempt retrieving a document from a  tailable cursor , use the  TryNext()  method. The method returns a document if all of the following conditions are met: A document is currently available. The driver didn't throw any errors. The context didn't expire. To populate an array with all of your query results, use the  All() \nmethod: If the number and size of documents returned by your query exceeds\navailable application memory, your program will crash. If you except\na large result set, you should  consume your cursor iteratively . When your application no longer requires a cursor, close the cursor\nwith the  Close()  method. This method frees the resources your cursor\nconsumes in both the client application and the MongoDB server. Close the cursor when you  retrieve documents individually  because those methods make a cursor\n tailable . To learn more about the operations discussed in this guide, see the\nfollowing guides: Retrieve Data Specify a Query Work with BSON Tailable Cursors To learn more about cursors and how to access their elements, see\nthe following API Documentation: Cursor Cursor.All() Cursor.Next() Cursor.TryNext() Cursor.Decode() Cursor.RemainingBatchLength() Cursor.ID() Cursor.Err() Cursor.Close()",
            "code": [
                {
                    "lang": "go",
                    "value": "cursor, err := coll.Find(context.TODO(), bson.D{})\nif err != nil {\n\tpanic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "for cursor.Next(context.TODO()) {\n\tvar result MyStruct\n\tif err := cursor.Decode(&result); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%+v\\n\", result)\n}\nif err := cursor.Err(); err != nil {\n\tlog.Fatal(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "for {\n\tif cursor.TryNext(context.TODO()) {\n\t\tvar result MyStruct\n\t\tif err := cursor.Decode(&result); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"%+v\\n\", result)\n\t\tcontinue\n\t}\n\n\tif err := cursor.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif cursor.ID() == 0 {\n\t\tbreak\n\t}\n}"
                },
                {
                    "lang": "go",
                    "value": "var results []MyStruct\nif err = cursor.All(context.TODO(), &results); err != nil {\n\tpanic(err)\n}\nfor _, result := range results {\n\tfmt.Printf(\"%+v\\n\", result)\n}"
                },
                {
                    "lang": "go",
                    "value": "defer cursor.Close(context.TODO())"
                }
            ],
            "preview": "In this guide, you can learn how to access data with a cursor.",
            "tags": "code example, read operation, see results, iterate",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/project",
            "title": "Specify Which Fields to Return",
            "headings": [
                "Overview",
                "Sample Data",
                "Projection",
                "Exclude a Field",
                "Example",
                "Include a Field",
                "Example",
                "Aggregation",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to specify which fields to return in a\ndocument. The examples in this guide use the following  Course  struct as a model for documents\nin the  courses  collection: The  omitempty   struct tag  directs the\ndriver to exclude fields when unmarshalling based on your projection\nspecification. To run the examples in this guide, load the sample data into the\n db.courses  collection with the following snippet: Each document contains a description of a university course that\nincludes the course title, course ID, and maximum enrollment, corresponding to\nthe  title ,  course_id , and  enrollment  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. A projection specifies which fields to return in matched documents. The\nprojection document contains field names with a  1  to include the\ncorresponding field or  0  to exclude it. If you are using an aggregation framework,\nyou can also specify a projection to include newly computed fields. You can specify a projection by passing a projection document to the  SetProjection() \nmethod. The following operations take an options object as a parameter: Find() FindOne() FindOneAndDelete() FindOneAndReplace() FindOneAndUpdate() If you don't specify a projection, the operation returns all\nthe fields in matched documents. To exclude a field, pass the field you want to exclude with a  0  to\nthe  SetProjection()  method. The driver includes all fields that are\nnot explicitly excluded in the projection document, if you specify any\nfields to exclude. The following example excludes the  course_id  and  enrollment \nfields from the matched documents returned by the  Find()  method: To include a field, pass the field you want to include with a  1  to\nthe  SetProjection()  method. The driver excludes all fields that are\nnot explicitly included in the projection document, if you specify any\nfields to include. The following example includes only the  title  and  enrollment  fields\nfrom the matched documents returned by the  Find()  method: You can also create a  $project \nstage to specify a projection in an aggregation pipeline. The following example includes only the  title  and  course_id  fields\nfrom the matched documents returned by the  Aggregate()  method: To learn more about the operations mentioned, see the following\nguides: To learn about projecting text scores from your text search, see  Search Text . Specify a Query Retrieve Data Compound Operations Aggregation To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Find() FindOptions.SetProjection() FindOne() FindOneAndDelete() FindOneAndReplace() FindOneAndUpdate() Aggregate()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string `bson:\"title,omitempty\"`\n\tCourseId   string `bson:\"course_id,omitempty\"`\n\tEnrollment int32  `bson:\"enrollment,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"Primate Behavior\", CourseId: \"PSY2030\", Enrollment: 40},\n\tCourse{Title: \"Revolution and Reform\", CourseId: \"HIST3080\", Enrollment: 12},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{}\nopts := options.Find().SetProjection(bson.D{{\"course_id\", 0}, {\"enrollment\", 0}})\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\nif err != nil {\n    panic(err)\n}\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\n\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Primate Behavior\"}\n{\"title\":\"Revolution and Reform\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{}\nopts := options.Find().SetProjection(bson.D{{\"title\", 1}, {\"enrollment\", 1}})\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\nif err != nil {\n    panic(err)\n}\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Primate Behavior\",\"enrollment\":40}\n{\"title\":\"Revolution and Reform\",\"enrollment\":12}"
                },
                {
                    "lang": "go",
                    "value": "projectStage := bson.D{{\"$project\", bson.D{{\"title\", 1}, {\"course_id\", 1}}}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{projectStage})\nif err != nil {\n    panic(err)\n}\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Primate Behavior\",\"course_id\":\"PSY2030\"}\n{\"title\":\"Revolution and Reform\",\"course_id\":\"HIST3080\"}"
                }
            ],
            "preview": "In this guide, you can learn how to specify which fields to return in a\ndocument.",
            "tags": "read, code example, pipeline stage, customize output",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/compound-operations",
            "title": "Compound Operations",
            "headings": [
                "Overview",
                "Sample Data",
                "Find and Delete",
                "Modify Behavior",
                "Example",
                "Find and Update",
                "Modify Behavior",
                "Example",
                "Find and Replace",
                "Modify Behavior",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to perform  compound operations . Compound operations combine a read and write operation into\na single operation. If you perform a read and write operation\nseparately, there's a chance someone else may alter the document between\nboth operations. MongoDB prevents this by placing a write lock on the\ndocument you are modifying for the duration of your compound operation. MongoDB supports the following compound operations: Find and delete one document Find and update one document Find and replace one document To learn how to perform compound operations on more than one document\nat a time, see the  Transactions  guide. The examples in this guide use the following  Course  struct as a model for documents\nin the  courses  collection: To run the examples in this guide, load the sample data into the\n db.courses  collection with the following\nsnippet: Each document contains a description of a university course that\nincludes the course title and maximum enrollment, corresponding to\nthe  title  and  enrollment  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. The  FindOneAndDelete()  method finds the first document that matches\nthe specified query filter and deletes it. The method returns a\n SingleResult  containing the deleted document. The  FindOneAndDelete()  method is an atomic operation, which means it prevents\nany other write operations from changing the matching document until it\ncompletes. The  deleteOne()  method is also an atomic operation, but differs from\n FindOneAndDelete()  in that you cannot specify a sort order for the\nmatched documents. findOne()  method followed by the  deleteOne()  method. You can modify the behavior of the  FindOneAndDelete()  method by\npassing in a  FineOneAndDeleteOptions . If you don't specify a\n FineOneAndDeleteOptions , the driver uses the default values for each\noption. The  FineOneAndDeleteOptions  type allows you to configure options\nwith the following methods: Method Description SetCollation() SetMaxTime() SetProjection() SetSort() SetHint() The following example uses the  FindOneAndDelete()  method\nto match and delete the first document where the  enrollment \nfield value is less than 20: The  FindOneAndUpdate()  method finds the first document that matches\nthe specified query filter and updates it according to the update\ndocument. The method returns a  SingleResult  containing the matched\ndocument. The  FindOneAndUpdate()  method is an atomic operation, which means it prevents\nany other write operations from changing the matching document until it\ncompletes. The  updateOne()  method is also an atomic operation, but differs from\n FindOneAndUpdate()  in that you cannot specify a sort order for the\nmatched documents. To find a document and update it in separate operations, call\nthe  findOne()  method followed by the  updateOne()  method. You can modify the behavior of the  FindOneAndUpdate()  method by\npassing in a  FineOneAndUpdateOptions . If you don't specify a\n FineOneAndUpdateOptions , the driver uses the default values for each\noption. The  FineOneAndUpdateOptions  type allows you to configure options\nwith the following methods: Method Description SetArrayFilters() SetBypassDocumentValidation() SetCollation() SetMaxTime() SetProjection() SetReturnDocument() SetSort() SetUpsert() SetHint() The following example uses the  FindOneAndUpdate()  method to\nperform the following actions in order: Matches the first document where the  title  field value includes \"Modern\" Updates the matched document's  enrollment  field value to  32 Returns the updated document The  FindOneAndReplace()  method finds the first document that\nmatches the specified query filter and replaces it with the replacement\ndocument. The method returns a  SingleResult  containing the matched\ndocument. This method differs from the  ReplaceOne()  method.\n FindOneAndReplace()  performs a find and replace as a single\noperation, and eliminates the possibility of someone altering a\ndocument between both operations. You can modify the behavior of the  FindOneAndReplace()  method by\npassing in a  FineOneAndReplaceOptions . If you don't specify a\n FineOneAndReplaceOptions , the driver uses the default values for each\noption. The  FineOneAndReplaceOptions  type allows you to configure options\nwith the following methods: Method Description SetBypassDocumentValidation() SetCollation() SetMaxTime() SetProjection() SetReturnDocument() SetSort() SetUpsert() SetHint() The following example uses the  FindOneAndReplace()  method to\nperform the following actions in order: Matches the first document where the  title  is \"Representation Theory\" Replaces the matched document with a new document where the  title \nis \"Combinatorial Theory\" and the  enrollment  is  35 To learn more about performing the operations mentioned, see the\nfollowing guides: Specify a Query Retrieve Data Delete Documents Modify Documents Access Data in a SingleResult To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: FindOneAndDelete() FindOneAndDeleteOptions FindOneAndUpdate() FindOneAndUpdateOptions FindOneAndReplace() FindOneAndReplaceOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string\n\tEnrollment int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"Representation Theory\", Enrollment: 40},\n\tCourse{Title: \"Early Modern Philosophy\", Enrollment: 25},\n\tCourse{Title: \"Animal Communication\", Enrollment: 18},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"enrollment\", bson.D{{\"$lt\", 20}}}}\n\nvar deletedDoc Course\nerr := coll.FindOneAndDelete(context.TODO(), filter).Decode(&deletedDoc)\nif err != nil {\n   panic(err)\n}\n\nres, _ := bson.MarshalExtJSON(deletedDoc, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Animal Communication\",\"enrollment\":18}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"title\", bson.D{{\"$regex\", \"Modern\"}}}}\nupdate := bson.D{{\"$set\", bson.D{{\"enrollment\", 32}}}}\nopts := options.FindOneAndUpdate().SetReturnDocument(options.After)\n\nvar updatedDoc Course\nerr := coll.FindOneAndUpdate(context.TODO(), filter, update, opts).Decode(&updatedDoc)\nif err != nil {\n    panic(err)\n}\n\nres, _ := bson.MarshalExtJSON(updatedDoc, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Early Modern Philosophy\",\"enrollment\":32}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"title\", \"Representation Theory\"}}\nreplacement := Course{Title: \"Combinatorial Theory\", Enrollment: 35}\n\nvar outdatedDoc Course\nerr := coll.FindOneAndReplace(context.TODO(), filter, replacement).Decode(&previousDoc)\nif err != nil {\n    panic(err)\n}\n\nres, _ := bson.MarshalExtJSON(outdatedDoc, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Representation Theory\",\"enrollment\":40}"
                }
            ],
            "preview": "In this guide, you can learn how to perform compound operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/skip",
            "title": "Skip Returned Results",
            "headings": [
                "Overview",
                "Sample Data",
                "Skip",
                "Example",
                "Aggregation",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to skip a specified number of returned\nresults from read operations. The examples in this guide use the following  Course  struct as a model for documents\nin the  courses  collection: To run the examples in this guide, load these documents into the\n db.courses  collection with the following\nsnippet: Each document contains a description of a university course that\nincludes the course title and maximum enrollment, corresponding to\nthe  title  and  enrollment  fields. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To skip a specified number of returned results from a query, pass the\nnumber of documents you want to skip to the  SetSkip()  method of\nthe read operation's options. The following read operations take an options object as a parameter: If the number of documents exceeds the number of matched documents for a\nquery, that query returns no documents. Find operations return documents in a natural order that is not sorted\non any field. To avoid skipping random documents, use the  SetSort() \nmethod to sort documents on a field with unique values before setting a\nskip option. Find() FindOne() CountDocuments() GridFSBucket.Find() Passing in a negative number to the  SetSkip()  method results\nin a runtime error. The following example performs a  Find()  operation with the following\nbehavior: Sorts the results in ascending order on the  enrollment  field Skips the first two documents You can also include the  $skip \nstage in an aggregation pipeline to skip documents. The following example performs an  Aggregate()  operation with the following\nbehavior: Sorts the results in descending order on the  enrollment  field Skips the first document To learn more about the operations mentioned, see the following\nguides: Specify a Query Retrieve Data Sort Results Aggregation To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Find() FindOptions.SetSkip() Aggregate() CountDocuments() GridFSBucket.Find()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string\n\tEnrollment int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"World Fiction\", Enrollment: 35},\n\tCourse{Title: \"Abstract Algebra\", Enrollment: 60},\n\tCourse{Title: \"Modern Poetry\", Enrollment: 12},\n\tCourse{Title: \"Plate Tectonics\", Enrollment: 45},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "opts := options.Find().SetSort(bson.D{{\"enrollment\", 1}}).SetSkip(2)\n\ncursor, err := coll.Find(context.TODO(), bson.D{}, opts)\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Plate Tectonics\",\"enrollment\":45}\n{\"title\":\"Abstract Algebra\",\"enrollment\":60}"
                },
                {
                    "lang": "go",
                    "value": "sortStage := bson.D{{\"$sort\", bson.D{{\"enrollment\", -1}}}}\nskipStage := bson.D{{\"$skip\", 1}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{sortStage, skipStage})\nif err != nil {\n    panic(err)\n}\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Plate Tectonics\",\"enrollment\":45}\n{\"title\":\"World Fiction\",\"enrollment\":35}\n{\"title\":\"Modern Poetry\",\"enrollment\":12}"
                }
            ],
            "preview": "In this guide, you can learn how to skip a specified number of returned\nresults from read operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/query-document",
            "title": "Specify a Query",
            "headings": [
                "Overview",
                "Sample Data",
                "Literal Values",
                "Example",
                "Comparison",
                "Example",
                "Logical",
                "Example",
                "Element",
                "Example",
                "Evaluation",
                "Example",
                "Array",
                "Example",
                "Bitwise",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to specify a query to match a subset\nof documents. To match a subset of documents, specify a  query filter  containing\nyour  match criteria . Match criteria consist of the fields and\nvalues you want present in a document. A query filter contains at least\none set of match criteria to determine which documents to include in the\nresulting set. In a query filter, you can match fields with  literal values  or with  query operators . Query operators allow you to perform mathematical\nor logical operations to locate documents within a collection. Match criteria with literal values use the following format: Match criteria with a query operator use the following format: The following sections use  literal values \nand  query operators  with the  Find() \nmethod to match a subset of documents. The examples in this section use the following  Tea  struct as a model for documents\nin the  tea  collection: The  omitempty   struct tag  omits the corresponding\nfield from the inserted document when left empty. To run the examples in this guide, load the sample data into the  tea  collection in\nthe  db  database with the following snippet: Each document describes a tea type, its rating, and the vendors that\ncarry that variety. These items correspond to the  type ,  rating , and\n vendor  fields. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. Literal value query filters return documents with an exact match to your\nmatch criteria. If you specify an empty query filter, CRUD operations match all the\ndocuments in a collection. The following example matches documents where the  type  is \"Oolong\": Literal value queries return the same value as the  $eq \ncomparison operator. For example, the following query filters produce\nthe same result: Comparison operators analyze the value in a document against the specified\nvalue in your match criteria. Common comparison operators include\n $gt  for \"greater than\" comparisons,  $lte  for \"less than or equal\nto\" comparisons, and  $ne  for \"not equal to\" comparisons. The following example matches documents where the  rating  is less\nthan  7 : For a full list of comparison operators, see the  Comparison\nQuery Operators  page. Logical operators require at least two match criteria. They check if\ndocuments meet all, at lease one, or none of the specified criteria.\nCommon logical operators include  $and  where all match criteria must\nbe true, and  $or  where at least one of the match criteria must be\ntrue. The following example matches documents where the  rating  is greater\nthan  7  and less than or equal to  10 : For a full list of logical operators, see the  Logical\nQuery Operators  page. Multiple match criteria resembling an  $eq  comparison operator in\na literal query return the same value as the  $and  logical\noperator. For example, the following query filters produce the same result: Element operators check for the presence or type of the specified field. The following example matches documents where the  vendor  field does\nnot exist: For a full list of element operators, see the  Element\nQuery Operators  page. Evaluation operators analyze values in a document based on the\nspecified value in your match criteria. Common evaluation operators\ninclude  $regex  where a field's value must match the specified\nregular expression and  $text  where the field's value must contain\nthe specified string. The following example matches documents where the  type  begins with\nthe letter \"E\": For a full list of evaluation operators, see the  Evaluation\nQuery Operators  page. Array operators check the values or amount of elements in an array field. The following example matches documents where the  vendor  contains \"C\": For a full list of array operators, see the  Array\nQuery Operators  page. Bitwise operators convert a numeric field from a base-10 (decimal)\nnumber into the corresponding base-2 (binary) number. They check whether\nthe value in a document has the same bits set as the value in your match\ncriteria. The following example matches documents where the  rating  has the same\nbits set as  6  (which is \"00000110\"): For a full list of bitwise operators, see the  Bitwise\nQuery Operators  page. For information on specifying a geospatial query, see the guide on\n Geospatial Data . To learn more about any of the methods or types used in this\nguide, see the following API Documentation: Find() Cursor",
            "code": [
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"<field>\", \"<value>\"}}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"<field>\", bson.D{{\"<operator>\", \"<value>\"}}}}"
                },
                {
                    "lang": "go",
                    "value": "type Tea struct {\n\tType   string\n\tRating int32\n\tVendor []string `bson:\"vendor,omitempty\" json:\"vendor,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"tea\")\ndocs := []interface{}{\n\tTea{Type: \"Masala\", Rating: 10, Vendor: []string{\"A\", \"C\"}},\n\tTea{Type: \"English Breakfast\", Rating: 6},\n\tTea{Type: \"Oolong\", Rating: 7, Vendor: []string{\"C\"}},\n\tTea{Type: \"Assam\", Rating: 5},\n\tTea{Type: \"Earl Grey\", Rating: 8, Vendor: []string{\"A\", \"B\"}},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"type\", \"Oolong\"}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n    panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"Oolong\",\"rating\":7,\"vendor\":[\"C\"]}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"type\", \"Oolong\"}}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"type\", bson.D{{\"$eq\", \"Oolong\"}}}}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"rating\", bson.D{{\"$lt\", 7}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"English Breakfast\",\"rating\":6}\n{\"type\":\"Assam\",\"rating\":5}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{\n   {\"$and\",\n      bson.A{\n         bson.D{{\"rating\", bson.D{{\"$gt\", 7}}}},\n         bson.D{{\"rating\", bson.D{{\"$lte\", 10}}}},\n      },\n   },\n}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"Masala\",\"rating\":10,\"vendor\":[\"A\",\"C\"]}\n{\"type\":\"Earl Grey\",\"rating\":8,\"vendor\":[\"A\",\"B\"]}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"type\", \"Oolong\"}, {\"rating\", 7}}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{\n  {\"$and\",\n    bson.A{\n      bson.D{{\"type\", \"Oolong\"}},\n      bson.D{{\"rating\", 7}},\n    }},\n}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"vendor\", bson.D{{\"$exists\", false}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"English Breakfast\",\"rating\":6}\n{\"type\":\"Assam\",\"rating\":5}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"type\", bson.D{{\"$regex\", \"^E\"}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"English Breakfast\",\"rating\":6}\n{\"type\":\"Earl Grey\",\"rating\":8,\"vendor\":[\"A\",\"B\"]}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"vendor\", bson.D{{\"$all\", bson.A{\"C\"}}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"Masala\",\"rating\":10,\"vendor\":[\"A\",\"C\"]}\n{\"type\":\"Oolong\",\"rating\":7,\"vendor\":[\"C\"]}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"rating\", bson.D{{\"$bitsAllSet\", 6}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"type\":\"English Breakfast\",\"rating\":6}\n{\"type\":\"Oolong\",\"rating\":7,\"vendor\":[\"C\"]}"
                }
            ],
            "preview": "In this guide, you can learn how to specify a query to match a subset\nof documents.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/count",
            "title": "Count Documents",
            "headings": [
                "Overview",
                "Sample Data",
                "Accurate Count",
                "Modify Behavior",
                "Example",
                "Aggregation",
                "Example",
                "Estimated Count",
                "Modify Behavior",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to get an  accurate  and  estimated  count of\nthe number of documents in your collection. The examples in this section use the following  Tea  struct as a model for documents\nin the  tea  collection: To run the examples in this guide, load the sample data into the  tea  collection in the  db \ndatabase with the following snippet: Each document describes a tea type and its rating. These items\ncorrespond to the  type  and  rating  fields. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To count the number of documents that match your query filter, use the\n CountDocuments()  method. If you pass an empty query filter, this method\nreturns the total number of documents in the collection. When you use  CountDocuments()  to return the total number of documents in a\ncollection, MongoDB performs a collection scan. You can avoid a collection scan and\nimprove the performance of this method by using a  hint  to take advantage of the built-in index on\nthe  _id  field. Use this technique only when calling  CountDocuments() \nwith an empty query parameter. You can modify the behavior of  CountDocuments()  by passing in a\n CountOptions  type. If you don't specify any options, the driver uses\nits default values. The  CountOptions  type allows you to configure options with the\nfollowing methods: Method Description SetCollation() SetHint() SetLimit() SetMaxTime() SetSkip() The following example counts the number of documents where the\n rating  is less than  6 : You can also include the  $count \nstage to count the number of documents in an aggregation pipeline. The following example performs the following actions: Counts the number of documents in which the value of the  rating  field is greater\nthan  5 Assigns the count to the  counted_documents  field To estimate the number of documents in your collection, use the\n EstimatedDocumentCount()  method. The  EstimatedDocumentCount()  method is quicker than the\n CountDocuments()  method because it uses the collection's\nmetadata rather than scanning the entire collection. You can modify the behavior of  EstimatedDocumentCount()  by passing\nin an  EstimatedDocumentCountOptions  type. If you don't specify any\noptions, the driver uses its default values. The  EstimatedDocumentCountOptions  type allows you to configure\noptions with the following methods: Method Description SetMaxTime() The following example estimates the number of documents in the\n tea  collection: To learn more about the operations mentioned, see the following\nguides: Specify a Query Skip Returned Results Limit the Number of Returned Results Aggregation Collations To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: CountDocuments() CountOptions EstimatedDocumentCount() EstimatedDocumentCountOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "type Tea struct {\n\tType   string\n\tRating int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"tea\")\ndocs := []interface{}{\n\tTea{Type: \"Masala\", Rating: 10},\n\tTea{Type: \"Matcha\", Rating: 7},\n\tTea{Type: \"Assam\", Rating: 4},\n\tTea{Type: \"Oolong\", Rating: 9},\n\tTea{Type: \"Chrysanthemum\", Rating: 5},\n\tTea{Type: \"Earl Grey\", Rating: 8},\n\tTea{Type: \"Jasmine\", Rating: 3},\n\tTea{Type: \"English Breakfast\", Rating: 6},\n\tTea{Type: \"White Peony\", Rating: 4},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "opts := options.Count().SetHint(\"_id_\")\n\ncount, err := coll.CountDocuments(context.TODO(), bson.D{}, opts)\nif err != nil {\n     panic(err)\n}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"rating\", bson.D{{\"$lt\", 6}}}}\n\ncount, err := coll.CountDocuments(context.TODO(), filter)\nif err != nil {\n    panic(err)\n}\nfmt.Printf(\"Number of documents with a rating less than six: %d\\n\", count)"
                },
                {
                    "lang": "none",
                    "value": "Number of documents with a rating less than six: 4"
                },
                {
                    "lang": "go",
                    "value": "matchStage := bson.D{{\"$match\", bson.D{{\"rating\", bson.D{{\"$gt\", 5}}}}}}\ncountStage := bson.D{{\"$count\", \"counted_documents\"}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{matchStage, countStage})\nif err != nil {\n   panic(err)\n}\n\nvar results []bson.D\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\nfor _, result := range results {\n   fmt.Println(result)\n}"
                },
                {
                    "lang": "none",
                    "value": "[{counted_documents 5}]"
                },
                {
                    "lang": "go",
                    "value": "count, err := coll.EstimatedDocumentCount(context.TODO())\nif err != nil {\n   panic(err)\n}\nfmt.Printf(\"Estimated number of documents in the tea collection: %d\\n\", count)"
                },
                {
                    "lang": "none",
                    "value": "Estimated number of documents in the tea collection: 9"
                }
            ],
            "preview": "In this guide, you can learn how to get an accurate and estimated count of\nthe number of documents in your collection.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/distinct",
            "title": "Retrieve Distinct Values",
            "headings": [
                "Overview",
                "Sample Data",
                "Distinct",
                "Modify Behavior",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to retrieve distinct values for a\nspecified field across a single collection. The example in this guide uses the following  Course  struct as a model for documents\nin the  courses  collection: To run the example, load the sample data into the\n db.courses  collection with the following\nsnippet: Each document contains a description of a university course that\nincludes the course title, department, and enrollment. These items\ncorrespond to the  title ,  department , and  enrollment  fields\nin each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To retrieve distinct values for a specified field across a single\ncollection, pass the following parameters to the  Distinct() \nmethod: The field name you want distinct values for A  non-nil  query filter specifying which documents to match If you specify an empty query filter, the  Distinct()  method\nsearches for distinct values across all documents in a collection. You can modify the behavior of the  Distinct()  method by\npassing in a  DistinctOptions . If you don't specify a\n DistinctOptions , the driver uses the default values for each\noption. The  DistinctOptions  type allows you to configure options\nwith the following methods: Method Description SetCollation() SetMaxTime() The following example matches documents with an  enrollment  field\nvalue less than  50  and prints the distinct values\nof the  department  field using the  Distinct()  method: For a runnable example of retrieving distinct values, see  Retrieve Distinct Values of a Field . To learn about constructing a query filter, see  Specify a Query . To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Distinct() DistinctOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string\n\tDepartment string\n\tEnrollment int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"World Fiction\", Department: \"English\", Enrollment: 35},\n\tCourse{Title: \"Abstract Algebra\", Department: \"Mathematics\", Enrollment: 60},\n\tCourse{Title: \"Modern Poetry\", Department: \"English\", Enrollment: 12},\n\tCourse{Title: \"Plate Tectonics\", Department: \"Earth Science\", Enrollment: 30},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "results, err := coll.Distinct(context.TODO(), \"department\", bson.D{{\"enrollment\", bson.D{{\"$lt\", 50}}}})\nif err != nil {\n    panic(err)\n}\n\nfor _, result := range results {\n    fmt.Println(result)\n}"
                },
                {
                    "lang": "none",
                    "value": "Earth Science\nEnglish"
                }
            ],
            "preview": "In this guide, you can learn how to retrieve distinct values for a\nspecified field across a single collection.",
            "tags": "read operation, code example",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/changestream",
            "title": "Monitor Data Changes",
            "headings": [
                "Overview",
                "Sample Data",
                "Open a Change Stream",
                "Example",
                "Modify the Change Stream Output",
                "Example",
                "Modify the Behavior of Watch()",
                "Pre- and Post-Images",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to monitor document changes by using a  change stream . A change stream outputs new change events, providing access to real-time data changes.\nYou can open a change stream on a collection, database, or client object. The examples in this guide use the following  Course  struct as a model for documents\nin the  courses  collection: To run the examples in this guide, load these documents into the\n courses  collection in the  db  database by using the following snippet: Each document contains a description of a university course that\nincludes the course title and maximum enrollment, corresponding to\nthe  title  and  enrollment  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. Each example output shows truncated  _data ,  clusterTime , and\n ObjectID  values because the driver generates them uniquely. To open a change stream, use the  Watch()  method. The  Watch()  method requires a context\nparameter and a pipeline parameter. To return all changes, pass in an\nempty  Pipeline  object. The following example opens a change stream on the  courses  collection and\noutputs all changes: If you modify the  courses  collection in a separate program or shell, this code prints\nyour changes as they occur. Inserting a document with a  title  value\nof  \"Advanced Screenwriting\"  and an  enrollment  value of  20 \nresults in the following change event: Use the pipeline parameter to modify the change stream output. This parameter allows you to\nonly watch for certain change events. Format the pipeline parameter as an array of documents,\nwith each document representing an aggregation stage. You can use the following pipeline stages in this parameter: $addFields $match $project $replaceRoot $replaceWith $redact $set $unset The following example opens a change stream on the  db  database but only watches for\nnew delete operations: The  Watch()  method was called on the  db  database, so the code outputs\nnew delete operations on any collection within this database. Use the  options  parameter to modify the behavior of the  Watch()  method. You can specify the following options for the  Watch()  method: For more information on these options, visit the\n MongoDB Server manual . ResumeAfter StartAfter FullDocument FullDocumentBeforeChange BatchSize MaxAwaitTime Collation StartAtOperationTime Comment ShowExpandedEvents StartAtOperationTime Custom CustomPipeline When you perform any CRUD operation on a collection, by default, the\ncorresponding change event document contains only the delta of the fields modified\nby the operation. You can see the full document before and after a\nchange, in addition to the delta, by specifying settings in the  options \nparameter of the  Watch()  method. If you want to see a document's post-image, the full version of the\ndocument after a change, set the  FullDocument  field of the\n options  parameter to one of the following values: If you want to see a document's pre-image, the full version of the\ndocument before a change, set the  FullDocumentBeforeChange  field of the\n options  parameter to one of the following values: UpdateLookup : The change event document includes a copy of the\nentire changed document. WhenAvailable : The change event document includes a post-image of\nthe modified document for change events if the\npost-image is available. Required : The output is the same as for  WhenAvailable , but the\ndriver raises a server-side error if the post-image is not available. WhenAvailable : The change event document includes a pre-image of\nthe modified document for change events if the\npre-image is available. Required : The output is the same as for  WhenAvailable , but the\ndriver raises a server-side error if the pre-image is not available. To access document pre- and post-images, you must enable\n changeStreamPreAndPostImages  for the collection. See the\n MongoDB Server manual  for instructions and more\ninformation. There is no pre-image for an inserted document and no post-image for\na deleted document. The following example calls the  Watch()  method on the  courses  collection. It\nspecifies a value for the  FullDocument  field of the  options  parameter to\noutput a copy of the entire modified document, instead of only the changed fields: Updating the  enrollment  value of the document with the\n title  of  \"World Fiction\"  from  35  to  30  results in the\nfollowing change event: Without specifying the  FullDocument  option, the same update operation no longer\noutputs the  \"fullDocument\"  value in the change event document. For a runnable example of a change stream, see  Monitor Data Changes . For more information on change streams, see  Change Streams . To learn more about the  Watch()  method, visit the following API documentation links: Watch() for collections Watch() for databases Watch() for clients",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string\n\tEnrollment int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"World Fiction\", Enrollment: 35},\n\tCourse{Title: \"Abstract Algebra\", Enrollment: 60},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "none",
                    "value": "map[_id:map[_data:...] clusterTime: {...} documentKey:map[_id:ObjectID(\"...\")]\nfullDocument:map[_id:ObjectID(\"...\") enrollment:20 title:Advanced Screenwriting] ns:\nmap[coll:courses db:db] operationType:insert]"
                },
                {
                    "lang": "go",
                    "value": "changeStream, err := coll.Watch(context.TODO(), mongo.Pipeline{})\nif err != nil {\n\tpanic(err)\n}\ndefer changeStream.Close(context.TODO())\n\n// Iterates over the cursor to print the change stream events\nfor changeStream.Next(context.TODO()) {\n\tfmt.Println(changeStream.Current)\n}"
                },
                {
                    "lang": "go",
                    "value": "db := client.Database(\"db\")\npipeline := bson.D{{\"$match\", bson.D{{\"operationType\", \"delete\"}}}}\nchangeStream, err := db.Watch(context.TODO(), mongo.Pipeline{pipeline})\nif err != nil {\n\tpanic(err)\n}\ndefer changeStream.Close(context.TODO())\n\n// Iterates over the cursor to print the delete operation change events\nfor changeStream.Next(context.TODO()) {\n\tfmt.Println(changeStream.Current)\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"_id\": {\"_data\": \"...\"},\"operationType\": \"update\",\"clusterTime\": {\"$timestamp\":\n{\"t\":\"...\",\"i\":\"...\"}},\"fullDocument\": {\"_id\":\n{\"$oid\":\"...\"},\"title\": \"World Fiction\",\"enrollment\":\n{\"$numberInt\":\"30\"}}, \"ns\": {\"db\": \"db\",\"coll\": \"courses\"},\"documentKey\": {\"_id\":\n{\"$oid\":\"...\"}}, \"updateDescription\": {\"updatedFields\": {\"enrollment\": {\"$numberInt\":\"30\"}},\n\"removedFields\": [],\"truncatedArrays\": []}}"
                },
                {
                    "lang": "go",
                    "value": "opts := options.ChangeStream().SetFullDocument(options.UpdateLookup)\n\nchangeStream, err := coll.Watch(context.TODO(), mongo.Pipeline{}, opts)\nif err != nil {\n\tpanic(err)\n}\ndefer changeStream.Close(context.TODO())\n\nfor changeStream.Next(context.TODO()) {\n\tfmt.Println(changeStream.Current)\n}"
                }
            ],
            "preview": "In this guide, you can learn how to monitor document changes by using a change stream.",
            "tags": "code example, delta",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/sort",
            "title": "Sort Results",
            "headings": [
                "Overview",
                "Sample Data",
                "Sort Direction",
                "Ascending",
                "Example",
                "Descending",
                "Example",
                "Handling Ties",
                "Example",
                "Aggregation",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to specify the order of your results\nfrom an operation. The examples in this guide use the following  Course  struct as a model for documents\nin the  courses  collection: To run the examples in this guide, load the sample data into the\n db.courses  collection with the following snippet: Each document contains a description of a university course that\nincludes the course title and maximum enrollment, corresponding to\nthe  title  and  enrollment  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To specify the order of your results, pass an interface specifying the\nsort fields and direction to the  SetSort()  method of an operation's options. The following operations take options as a parameter: You can set an  ascending  or  descending  sort direction. Find() FindOne() FindOneAndDelete() FindOneAndUpdate() FindOneAndReplace() GridFSBucket.Find() An ascending sort orders your results from smallest to largest. To\nspecify this sort, pass the field you want to sort by and  1  to the\n SetSort()  method. With an ascending sort, the method orders values of type\n Boolean  from  false   to   true ,  String  type values\nfrom  a to z  and numeric type values from  negative infinity to\npositive infinity . The following example specifies an ascending sort on the  enrollment  field: A descending sort orders your results from largest to smallest. To\nspecify this sort, pass the field you want to sort by and  -1  to the\n SetSort()  method. With an descending sort, the method orders values of type\n Boolean  from  true   to   false ,  String  type values\nfrom  z to a  and numeric type values from  positive infinity to\nnegative infinity . The following example specifies a descending sort on the  enrollment  field: A tie occurs when two or more documents have identical values in the\nfield you are using to sort your results. MongoDB does not guarantee\norder if ties occur. For example, in the sample data, there is a tie for  enrollment  in\nthe following documents: You can sort on additional fields to resolve ties in the original sort.\nIf you want to guarantee a specific order for documents, select sort fields\nthat do not result in ties. The following example specifies a descending sort on the  enrollment  field,\nthen an ascending sort on the  title  field: You can also include the  $sort \nstage to specify a  sort in an aggregation pipeline. The following example specifies a descending sort on the  enrollment \nfield, then an ascending sort on the  title  field: To learn more about the operations mentioned, see the following\nguides: To learn about sorting text scores from your text search, see  Search Text . Specify a Query Retrieve Data Compound Operations Aggregation To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Find() FindOptions.SetSort() Aggregate() FindOne() FindOneAndDelete() FindOneAndUpdate() FindOneAndReplace() GridFSBucket.Find()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string\n\tEnrollment int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"World Fiction\", Enrollment: 35},\n\tCourse{Title: \"Abstract Algebra\", Enrollment: 60},\n\tCourse{Title: \"Modern Poetry\", Enrollment: 12},\n\tCourse{Title: \"Plate Tectonics\", Enrollment: 35},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{}\nopts := options.Find().SetSort(bson.D{{\"enrollment\", 1}})\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Modern Poetry\",\"enrollment\":12}\n{\"title\":\"World Fiction\",\"enrollment\":35}\n{\"title\":\"Plate Tectonics\",\"enrollment\":35}\n{\"title\":\"Abstract Algebra\",\"enrollment\":60}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{}\nopts := options.Find().SetSort(bson.D{{\"enrollment\", -1}})\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Abstract Algebra\",\"enrollment\":60}\n{\"title\":\"World Fiction\",\"enrollment\":35}\n{\"title\":\"Plate Tectonics\",\"enrollment\":35}\n{\"title\":\"Modern Poetry\",\"enrollment\":12}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"World Fiction\",\"enrollment\":35}\n{\"title\":\"Plate Tectonics\",\"enrollment\":35}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{}\nopts := options.Find().SetSort(bson.D{{\"enrollment\", -1}, {\"title\", 1}})\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Abstract Algebra\",\"enrollment\":60}\n{\"title\":\"Plate Tectonics\",\"enrollment\":35}\n{\"title\":\"World Fiction\",\"enrollment\":35}\n{\"title\":\"Modern Poetry\",\"enrollment\":12}"
                },
                {
                    "lang": "go",
                    "value": "sortStage := bson.D{{\"$sort\", bson.D{{\"enrollment\", -1}, {\"title\", 1}}}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{sortStage})\nif err != nil {\n    panic(err)\n}\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Abstract Algebra\",\"enrollment\":60}\n{\"title\":\"Plate Tectonics\",\"enrollment\":35}\n{\"title\":\"World Fiction\",\"enrollment\":35}\n{\"title\":\"Modern Poetry\",\"enrollment\":12}"
                }
            ],
            "preview": "In this guide, you can learn how to specify the order of your results\nfrom an operation.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/limit",
            "title": "Limit the Number of Returned Results",
            "headings": [
                "Overview",
                "Sample Data",
                "Limit",
                "Example",
                "Multiple Options",
                "Example",
                "Aggregation",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to limit the number of documents\nreturned from a read operation. The examples in this guide use the following  Course  struct as a model for documents\nin the  courses  collection: To run the examples in this guide, load the sample data into the\n db.courses  collection with the following snippet: Each document contains a description of a university course that\nincludes the course title and maximum enrollment, corresponding to\nthe  title  and  enrollment  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To limit the number of documents returned from a query, pass the\nnumber of documents you want returned to the  SetLimit()  method of\nthe read operation's options. The following read operations take an options object as a parameter: If the limit is  0  or exceeds the number of matched\ndocuments, the method returns all the documents. If the limit is a\nnegative number, the method uses the absolute value of the negative\nnumber as the limit and closes the cursor after retrieving\ndocuments. Find() CountDocuments() GridFSBucket.Find() The following example shows how to return two documents that have an\n enrollment  field value greater than 20: The driver performs the limit behavior last regardless of the order in which you set\nany other options. The following example performs a  Find()  operation with the following behavior: Sorts the results in descending order on the  enrollment  field Skips the first document Returns the first two of the remaining documents Using any of the following option configurations also produces the same result: You can also include the  $limit \nstage to specify a limit in an aggregation pipeline. The following example shows how to return three documents: To learn more about the operations mentioned, see the following\nguides: Specify a Query Retrieve Data Sort Results Skip Returned Results Aggregation To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: FindOptions.SetLimit() FindOptions.SetSort() FindOptions.SetSkip() Aggregate() CountDocuments() GridFSBucket.Find()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Course struct {\n\tTitle      string\n\tEnrollment int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"courses\")\ndocs := []interface{}{\n\tCourse{Title: \"Romantic Era Music\", Enrollment: 15},\n\tCourse{Title: \"Concepts in Topology\", Enrollment: 35},\n\tCourse{Title: \"Ancient Greece\", Enrollment: 100},\n\tCourse{Title: \"Physiology I\", Enrollment: 60},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"enrollment\", bson.D{{\"$gt\", 20}}}}\nopts := options.Find().SetLimit(2)\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Concepts in Topology\",\"enrollment\":35}\n{\"title\":\"Ancient Greece\",\"enrollment\":100}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{}\nopts := options.Find().SetSort(bson.D{{\"enrollment\", -1}}).SetLimit(2).SetSkip(1)\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Physiology I\",\"enrollment\":60}\n{\"title\":\"Concepts in Topology\",\"enrollment\":35}"
                },
                {
                    "lang": "go",
                    "value": "opts := options.Find().SetSort(bson.D{{\"enrollment\", -1}}).SetSkip(1).SetLimit(2)\nopts := options.Find().SetLimit(2).SetSort(bson.D{{\"enrollment\", -1}}).SetSkip(1)\nopts := options.Find().SetLimit(2).SetSkip(1).SetSort(bson.D{{\"enrollment\", -1}})\nopts := options.Find().SetSkip(1).SetSort(bson.D{{\"enrollment\", -1}}).SetLimit(2)\nopts := options.Find().SetSkip(1).SetLimit(2).SetSort(bson.D{{\"enrollment\", -1}})"
                },
                {
                    "lang": "go",
                    "value": "limitStage := bson.D{{\"$limit\", 3}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{limitStage})\nif err != nil {\n    panic(err)\n}\n\nvar results []Course\nif err = cursor.All(context.TODO(), &results); err != nil {\n    panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Romantic Era Music\",\"enrollment\":15}\n{\"title\":\"Concepts in Topology\",\"enrollment\":35}\n{\"title\":\"Ancient Greece\",\"enrollment\":100}"
                }
            ],
            "preview": "In this guide, you can learn how to limit the number of documents\nreturned from a read operation.",
            "tags": "read operation, code example, pipeline, customize output",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/retrieve",
            "title": "Retrieve Data",
            "headings": [
                "Overview",
                "Sample Data",
                "Find Operations",
                "Find All Documents",
                "Find One Document",
                "Modify Behavior",
                "Find Example",
                "Find One Example",
                "Find One by ObjectId Example",
                "Aggregation Operations",
                "Aggregation",
                "Modify Behavior",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to retrieve data from your MongoDB\ncollections using  read operations . Read operations allow you to do the following: Retrieve documents from your collections by using  find operations Perform transformations on documents in your collections by using  aggregation operations The examples in this guide use the following  Tea  struct as a model for documents\nin the  tea  collection: To run the examples in this guide, load these documents into the\n tea  collection in the  db  database by using the following snippet: Each document describes the tea variety a customer ordered, their\nrating, and the date of the order. These descriptions correspond to the\n item ,  rating , and  date_ordered  fields. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. Use  find operations  to retrieve data from MongoDB. Find operations\nconsist of the  Find()  and  FindOne()  methods. The  Find()  method expects you to pass a  Context  type and a\nquery filter. The method returns  all  documents that match the filter\nas a  Cursor  type. For an example that uses the  Find()  method, see the  Find Example \nsection of this page. To learn how to access data by using a cursor, see\nthe  Access Data From a Cursor  guide. The  FindOne()  method expects you to pass a  Context  type and a\nquery filter. The method returns  the first document  that matches the\nfilter as a  SingleResult  type. For an example that uses the  FindOne()  method, see the\n Find One Example  section of this page. For an example that\nuses  FindOne()  and queries by using a specific  ObjectId  value, see\nthe  Find One by ObjectId Example  section of this page. To learn how to access data from a  SingleResult  type, see\n Unmarshalling  in the BSON guide. You can modify the behavior of  Find()  and  FindOne()  by passing\nin a  FindOptions  and  FindOneOptions  type respectively. If you\ndon't specify any options, the driver uses the default values for each\noption. You can configure the commonly used options in both types with the\nfollowing methods: Method Description SetCollation() SetLimit() This option is not available for  FindOneOptions . The\n FindOne()  method internally uses  SetLimit(-1) . SetProjection() SetSkip() SetSort() The following example passes a context, filter, and  FindOptions  to\nthe  Find()  method, which performs the following actions: Matches documents where the  rating  value is between  5  and\n 9  (exclusive) Sorts the matched documents in ascending order by  date_ordered The following example passes a context, filter, and  FindOneOptions \nto the  FindOne()  method, which performs the following actions: Matches documents where the  date_ordered  value is on or before November\n30, 2009 Skips the first two matched documents This example defines an  id  variable with a value of type  ObjectId \nand uses  id  to specify a query filter. The filter matches a document\nwith an  _id  field value that corresponds to the  id  variable.\nThis example queries for the following document based on its  _id  value: The following code passes the filter and a  FindOneOptions  instance\nas parameters to the  FindOne()  method to perform the following actions: Match the document with the specified  ObjectId  value Project only the  Item  and  Rating  fields of the matched document The Go driver automatically generates a unique  ObjectId \nvalue for each document's  _id  field, so your  ObjectId  value\nmight differ from the preceding code example. For more information\nabout the  _id  field, see the  _id Field \nsection of the Insert a Document page. Use  aggregation operations  to retrieve and transform data from\nMongoDB. Perform aggregation operations using the  Aggregate() \nmethod. The  Aggregate()  method expects you to pass a  Context  type and\nan  aggregation pipeline . An aggregation pipeline defines how to\ntransform data through stages. Some of the stages are matching\ndocuments, renaming fields, and grouping values. The method returns the resulting documents in a  Cursor  type. If\nyou omit the  $match \nstage, the pipeline proceeds using all documents in the collection. To learn how to access data in a cursor, see  Access Data From a Cursor . The  Aggregate()  method optionally takes an  AggregateOptions \ntype, which represents options you can use to modify its behavior. If\nyou don't specify any options, the driver uses the default values for\neach option. The  AggregateOptions  type allows you to configure options with the\nfollowing methods: Method Description SetAllowDiskUse() SetBatchSize() SetBypassDocumentValidation() SetCollation() SetMaxTime() SetMaxAwaitTime() SetComment() SetHint() SetLet() The following example passes a context and an aggregation pipeline that\nperforms the following actions: To learn more about how to construct an aggregation pipeline, see\nthe MongoDB server manual page on  Aggregation . Groups reviews by item ordered Calculates the average rating for each item For runnable examples of the find operations, see the following usage\nexamples: To learn more about the operations mentioned, see the following\nguides: Find a Document Find Multiple Documents Specify a Query Access Data From a Cursor Skip Returned Results Sort Results Limit the Number of Returned Results Specify Which Fields to Return Aggregation Collations To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: FindOne() SingleResult Find() FindOptions FindOneOptions Cursor Aggregate() AggregateOptions",
            "code": [
                {
                    "lang": "go",
                    "value": "type Tea struct {\n\tItem        string    `bson:\"item,omitempty\"`\n\tRating      int32     `bson:\"rating,omitempty\"`\n\tDateOrdered time.Time `bson:\"date_ordered,omitempty\"`\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"tea\")\ndocs := []interface{}{\n\tTea{Item: \"Masala\", Rating: 10, DateOrdered: time.Date(2009, 11, 17, 0, 0, 0, 0, time.Local)},\n\tTea{Item: \"Sencha\", Rating: 7, DateOrdered: time.Date(2009, 11, 18, 0, 0, 0, 0, time.Local)},\n\tTea{Item: \"Masala\", Rating: 9, DateOrdered: time.Date(2009, 11, 12, 0, 0, 0, 0, time.Local)},\n\tTea{Item: \"Masala\", Rating: 8, DateOrdered: time.Date(2009, 12, 1, 0, 0, 0, 0, time.Local)},\n\tTea{Item: \"Sencha\", Rating: 10, DateOrdered: time.Date(2009, 12, 17, 0, 0, 0, 0, time.Local)},\n\tTea{Item: \"Hibiscus\", Rating: 4, DateOrdered: time.Date(2009, 12, 18, 0, 0, 0, 0, time.Local)},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{\n\t{\"$and\",\n\t\tbson.A{\n\t\t\tbson.D{{\"rating\", bson.D{{\"$gt\", 5}}}},\n\t\t\tbson.D{{\"rating\", bson.D{{\"$lt\", 9}}}},\n\t\t}},\n}\nsort := bson.D{{\"date_ordered\", 1}}\nopts := options.Find().SetSort(sort)\n\n// Retrieves documents that match the filter and prints them as structs\ncursor, err := coll.Find(context.TODO(), filter, opts)\nif err != nil {\n\tpanic(err)\n}\n\nvar results []Tea\nif err = cursor.All(context.TODO(), &results); err != nil {\n\tpanic(err)\n}\nfor _, result := range results {\n\tres, _ := bson.MarshalExtJSON(result, false, false)\n\tfmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"item\":\"Sencha\",\"rating\":7,\"date_ordered\":\"2009-11-18T05:00:00Z\"}\n{\"item\":\"Masala\",\"rating\":8,\"date_ordered\":\"2009-12-01T05:00:00Z\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"date_ordered\", bson.D{{\"$lte\", time.Date(2009, 11, 30, 0, 0, 0, 0, time.Local)}}}}\nopts := options.FindOne().SetSkip(2)\n\n// Retrieves a document that matches the filter and prints it as\n// a struct\nvar result Tea\nerr = coll.FindOne(context.TODO(), filter, opts).Decode(&result)\nif err != nil {\n\tif err == mongo.ErrNoDocuments {\n\t\tfmt.Println(\"No documents found\")\n\t} else {\n\t\tpanic(err)\n\t}\n}\n\nres, _ := bson.MarshalExtJSON(result, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"item\":\"Masala\",\"rating\":9,\"date_ordered\":\"2009-11-12T05:00:00Z\"}"
                },
                {
                    "lang": "json",
                    "value": " {\n     _id: ObjectId('65170b42b99efdd0b07d42de'),\n     item: \"Hibiscus\",\n     rating : 4,\n     date_ordered : 2009-12-18T05:00:00.000+00:00\n }"
                },
                {
                    "lang": "go",
                    "value": "id, err := primitive.ObjectIDFromHex(\"65170b42b99efdd0b07d42de\")\nif err != nil {\n\tpanic(err)\n}\n\n//  Creates a filter to match a document that has the specified\n//  \"_id\" value\nfilter := bson.D{{\"_id\", id}}\nopts := options.FindOne().SetProjection(bson.D{{\"item\", 1}, {\"rating\", 1}})\n\n// Retrieves a document that matches the filter and prints it as\n// a struct\nvar result Tea\nerr = coll.FindOne(context.TODO(), filter, opts).Decode(&result)\nif err != nil {\n\tif err == mongo.ErrNoDocuments {\n\t\tfmt.Println(\"No documents found\")\n\t} else {\n\t\tpanic(err)\n\t}\n}\n\nres, _ := bson.MarshalExtJSON(result, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"item\":\"Hibiscus\",\"rating\":4}"
                },
                {
                    "lang": "go",
                    "value": "groupStage := bson.D{\n\t{\"$group\", bson.D{\n\t\t{\"_id\", \"$item\"},\n\t\t{\"average\", bson.D{\n\t\t\t{\"$avg\", \"$rating\"},\n\t\t}},\n\t}}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{groupStage})\nif err != nil {\n\tpanic(err)\n}\n\n// Prints the average \"rating\" for each item\nvar results []bson.M\nif err = cursor.All(context.TODO(), &results); err != nil {\n\tpanic(err)\n}\nfor _, result := range results {\n\tfmt.Printf(\"%v had an average rating of %v \\n\", result[\"_id\"], result[\"average\"])\n}"
                },
                {
                    "lang": "none",
                    "value": "Sencha had an average rating of 8.5\nHibiscus had an average rating of 4\nMasala had an average rating of 9"
                }
            ],
            "preview": "In this guide, you can learn how to retrieve data from your MongoDB\ncollections using read operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/delete",
            "title": "Delete Documents",
            "headings": [
                "Overview",
                "Sample Data",
                "Delete Operations",
                "Parameters",
                "Return Value",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to remove documents from your MongoDB\ncollections using delete operations. The example in this guide uses the following  Book  struct as a model for documents\nin the  books  collection: To run the example in this guide, load the sample data into the\n db.books  collection with the following snippet: Each document contains a description of a book that\nincludes the title, author, and page length corresponding to\nthe  title ,  author , and  length  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. Use  delete operations  to remove data from MongoDB. Delete operations\nconsist of the following methods: DeleteOne() , which deletes  the first document  that matches the filter DeleteMany() , which deletes  all  documents that match the filter If one document matches your filter when running the  DeleteMany() \nmethod, it's equivalent to running the  DeleteOne()  method. The  DeleteOne()  and  DeleteMany()  methods expect you to pass a\n Context  type and a  non-nil  query filter specifying which\ndocuments to match. They both optionally take a  DeleteOptions  type as a third parameter,\nwhich represents options you can use to configure the delete operation.\nIf you don't specify a  DeleteOptions , the driver uses the default\nvalues for each option. The  DeleteOptions  type allows you to configure options with the\nfollowing methods: Method Description SetHint() SetCollation() The  DeleteOne()  and  DeleteMany()  methods return a\n DeleteResult  type. This type contains the  DeletedCount  property,\nwhich states the number of documents deleted. If there are no matches to\nyour filter, no document gets deleted and  DeletedCount  is  0 . The following example performs the following with the  DeleteMany() \nmethod: Matches and deletes documents where the  length  is greater than  300 Instructs the method to use the  _id  as the index If the preceding example used the  DeleteOne()  method instead of\n DeleteMany() , the driver would delete the first of the two\nmatched documents. For runnable examples of the delete operations, see the following usage\nexamples: To learn more about performing the operations mentioned, see the\nfollowing guides: To learn about how the driver uses Context, see  Context . To learn more about specifying hints, see  Indexes . To learn more about collations, see  Collations . Delete a Document Delete Multiple Documents Specify a Query To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: DeleteOne() DeleteMany() DeleteOptions DeleteResult",
            "code": [
                {
                    "lang": "go",
                    "value": "type Book struct {\n\tTitle  string\n\tAuthor string\n\tLength int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"books\")\ndocs := []interface{}{\n\tBook{Title: \"Atonement\", Author: \"Ian McEwan\", Length: 351},\n\tBook{Title: \"My Brilliant Friend\", Author: \"Elena Ferrante\", Length: 331},\n\tBook{Title: \"Lucy\", Author: \"Jamaica Kincaid\", Length: 103},\n\tBook{Title: \"Outline\", Author: \"Rachel Cusk\", Length: 258},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"length\", bson.D{{\"$gt\", 300}}}}\nopts := options.Delete().SetHint(bson.D{{\"_id\", 1}})\n\nresult, err := coll.DeleteMany(context.TODO(), filter, opts)\nif err != nil {\n   panic(err)\n}\n\nfmt.Printf(\"Number of documents deleted: %d\\n\", result.DeletedCount)"
                },
                {
                    "lang": "none",
                    "value": "Number of documents deleted: 2"
                }
            ],
            "preview": "In this guide, you can learn how to remove documents from your MongoDB\ncollections using delete operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/embedded-arrays",
            "title": "Update Arrays in a Document",
            "headings": [
                "Overview",
                "Sample Data",
                "Specify Array Elements",
                "First Array Element",
                "Example",
                "Multiple Array Elements",
                "Example",
                "All Array Elements",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to update array elements in one or more\ndocuments. To update elements in an array, perform the following actions: Provide an  update document  that specifies the update. Specify which array elements to update. Perform the update using an update operation with these specifications. The examples in this guide use the following  Drink  struct as a model for documents\nin the  drinks  collection: The  truncate   struct tag  allows the driver\nto truncate types such as  float64  to  int32  when unmarshalling. To run the examples in this guide, load the sample data into the\n db.drinks  collection with the following snippet: Each document contains a description of a drink that\nincludes the drink's description, available sizes in ounces, and available\npreparation styles, corresponding to the  description ,  sizes , and\n styles  fields in each document. The following examples use the  FindOneAndUpdate()  method to\nretrieve and update a document and to return the state of the document\nafter the update occurs. If you want to update multiple documents with\nan array field, use the  UpdateMany()  method. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To specify which array elements to update, use a  positional\noperator . Positional operators can specify the  first ,\n multiple , or  all \narray elements to update. To specify array elements with a positional operator, use  dot\nnotation . Dot notation is a property access syntax for navigating\narray elements and fields of an embedded document. To update the first array element that matches your query filter, use\nthe positional  $  operator. The query filter must be for the array\nfield. This example performs the following actions: Matches array elements in  sizes  where the value is less than or\nequal to  16 . Decrements the first array value matched by  2 . The query filter matches the values  12  and  16 . Since the\noperation matches  12  first, it is decremented. If you want to update\nboth matched values, see  Multiple Array Elements . To update multiple array elements that match your query filter, use the\nfiltered positional  $[<identifier>]  operator. You must include an\narray filter in your update operation to specify which array elements to\nupdate. The  <identifier>  is the name you use within your array filter. This\nvalue must begin with a lowercase letter and only contain alphanumeric\ncharacters. This example performs the following actions: Creates an array filter with an identifier called  hotOptions  to match\narray elements that contain \"hot\". Applies the array filter using the  SetArrayFilters()  method. Removes these array elements. To update all the array elements, use the all positional  $[]  operator. If you specify a query filter for the array field, the positional\n $[]  operator ignores the query filter and updates all the array\nelements. This example multiplies every array element in  sizes  by  29.57 \nto convert from ounces to milliliters: To learn more about the operations discussed in this guide, see the\nfollowing guides: Specify a Query Compound Operations Modify Documents Positional $ Operator Positional $[] Operator Positional $[<identifier>] Operator Dot Notation To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: FindOneAndUpdate() FindOneAndUpdateOptions.SetReturnDocument() FindOneAndUpdateOptions.SetArrayFilters() UpdateMany()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Drink struct {\n\tDescription string\n\tSizes       []int32 `bson:\"sizes,truncate\"`\n\tStyles      []string\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"drinks\")\ndocs := []interface{}{\n\tDrink{Description: \"Matcha Latte\", Sizes: []int32{12, 16, 20}, Styles: []string{\"iced\", \"hot\", \"extra hot\"}},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"sizes\", bson.D{{\"$lte\", 16}}}}\nupdate := bson.D{{\"$inc\", bson.D{{\"sizes.$\", -2}}}}\nopts := options.FindOneAndUpdate().\n    SetReturnDocument(options.After)\n\nvar updatedDoc Drink\nerr := coll.FindOneAndUpdate(context.TODO(), filter, update, opts).Decode(&updatedDoc)\nif err != nil {\n    panic(err)\n}\n\nres, _ := bson.MarshalExtJSON(updatedDoc, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"description\":\"Matcha Latte\",\"sizes\":[10,16,20],\"styles\":[\"iced\",\"hot\",\"extra hot\"]}"
                },
                {
                    "lang": "go",
                    "value": "identifier := []interface{}{bson.D{{\"hotOptions\", bson.D{{\"$regex\", \"hot\"}}}}}\nupdate := bson.D{{\"$unset\", bson.D{{\"styles.$[hotOptions]\", \"\"}}}}\nopts := options.FindOneAndUpdate().\n    SetArrayFilters(options.ArrayFilters{Filters: identifier}).\n    SetReturnDocument(options.After)\n\nvar updatedDoc Drink\nerr := coll.FindOneAndUpdate(context.TODO(), bson.D{}, update, opts).Decode(&updatedDoc)\nif err != nil {\n    panic(err)\n}\n\nres, _ := bson.MarshalExtJSON(updatedDoc, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"description\":\"Matcha Latte\",\"sizes\":[12,16,20],\"styles\":[\"iced\",\"\",\"\"]}"
                },
                {
                    "lang": "go",
                    "value": "update := bson.D{{\"$mul\", bson.D{{\"sizes.$[]\", 29.57}}}}\nopts := options.FindOneAndUpdate().\n    SetReturnDocument(options.After)\n\nvar updatedDoc Drink\nerr := coll.FindOneAndUpdate(context.TODO(), bson.D{}, update, opts).Decode(&updatedDoc)\nif err != nil {\n    panic(err)\n}\n\nres, _ := bson.MarshalExtJSON(updatedDoc, false, false)\nfmt.Println(string(res))"
                },
                {
                    "lang": "none",
                    "value": "{\"description\":\"Matcha Latte\",\"sizes\":[354,473,591],\"styles\":[\"iced\",\"hot\",\"extra hot\"]}"
                }
            ],
            "preview": "In this guide, you can learn how to update array elements in one or more\ndocuments.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/read-operations/text",
            "title": "Search Text",
            "headings": [
                "Overview",
                "Sample Data",
                "Text Index",
                "Text Search",
                "Search by a Term",
                "Example",
                "Search by a Phrase",
                "Example",
                "Search with Terms Excluded",
                "Example",
                "Sort by Relevance",
                "Example",
                "Aggregation",
                "Match a Search Term",
                "Sort by Relevance",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to run a  text search . MongoDB text search is different than  Atlas Search . The examples in this guide use the following  Dish  struct as a model for documents\nin the  menu  collection: To run the examples in this guide, load the sample data into the\n db.menu  collection with the following\nsnippet: Each document contains the  name  and  description  of a dish on a\nrestaurant's menu. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. You must create a  text index  before running a text search. A text\nindex specifies the string or string array field on which to run a text\nsearch. The examples in the following sections run text searches on the\n description  field of documents in the  menu  collection. To enable text searches on\nthe  description  field, create a text index with the following snippet: A text search retrieves documents that contain a  term  or a\n phrase  in the text indexed fields. A term is a sequence of\ncharacters that excludes whitespace characters. A phrase is a sequence\nof terms with any number of whitespace characters. To perform a text search, use the  $text  evaluation query operator,\nfollowed by the  $search  field in your query filter. The  $text  operator\nperforms a text search on the text indexed fields. The  $search  field\nspecifies the text to search in the text indexed fields. Query filters for text searches use the following format: To search for a term, specify the term as a string in your query filter.\nTo search for multiple terms, separate each term with spaces in the string. When searching for multiple terms, the  Find()  method returns\ndocuments with at least one of the terms in text indexed fields. The following example runs a text search for descriptions that contain the term \"herb\": Although the search term was \"herb\", the method also matches\ndescriptions containing \"herbs\" because a MongoDB text index uses suffix\nstemming to match similar words. To learn more about how\nMongoDB matches terms, see  Index Entries . To search for a phrase, specify the phrase with escaped quotes as a\nstring in your query filter. If you don't add escaped quotes around the\nphrase, the  Find()  method runs a  term search . Escaped quotes are a backslash character followed by a double quote\ncharacter. The following example runs a text search for descriptions that contain the\nphrase \"serves 2\": For each term or phrase you want to exclude from your text search,\nspecify the term or phrase prefixed with a minus sign as a string in\nyour query filter. You must search for at least one term if you want to exclude\nterms from your search. If you don't search for any terms, the\n Find()  method doesn't return any documents. The following example runs a text search for descriptions that contain the\nterm \"vegan\", but do not contain the term \"tofu\": A text search assigns a numerical text score to indicate how closely\neach result matches the string in your query filter. To reveal the text\nscore in your output, use a projection to retrieve the  textScore \nmetadata. You can sort the text score in descending order by specifying\na sort on the  textScore  metadata. The following example performs the following actions: Runs a text search for descriptions that contain the term \"vegetarian\" Sorts the results in descending order based on their text score Includes only the  name  and  score  fields in the final output document You can also include the  $text  evaluation query operator in the\n $match  stage to\nperform a text search in an aggregation pipeline. The following example runs a text search for descriptions that contain the term \"herb\": The following example performs the following actions: Runs a text search for descriptions that contain the term \"vegetarian\" Sorts the results in descending order based on their text score Includes only the  name  and  score  fields in the final output document To learn more about the operations mentioned, see the following\nguides: Specify a Query Sort Results Specify Which Fields to Return Text Indexes $text $meta Aggregation Indexes To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: Find() FindOptions.SetSort() FindOptions.SetProjection()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Dish struct {\n\tName        string\n\tDescription string\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"menu\")\ndocs := []interface{}{\n\tDish{Name: \"Shepherd\u2019s Pie\", Description: \"A vegetarian take on the classic dish that uses lentils as a base. Serves 2.\"},\n\tDish{Name: \"Green Curry\", Description: \"A flavorful Thai curry, made vegetarian with fried tofu. Vegetarian and vegan friendly.\"},\n\tDish{Name: \"Herbed Whole Branzino\", Description: \"Grilled whole fish stuffed with herbs and pomegranate seeds. Serves 3-4.\"},\n\tDish{Name: \"Kale Tabbouleh\", Description: \"A bright, herb-based salad. A perfect starter for vegetarians and vegans.\"},\n\tDish{Name: \"Garlic Butter Trout\", Description: \"Baked trout seasoned with garlic, lemon, dill, and, of course, butter. Serves 2.\"},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "model := mongo.IndexModel{Keys: bson.D{{\"description\", \"text\"}}}\nname, err := coll.Indexes().CreateOne(context.TODO(), model)\nif err != nil {\n\tpanic(err)\n}\n\nfmt.Println(\"Name of index created: \" + name)"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"$text\", bson.D{{\"$search\", \"<text to search>\"}}}}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"$text\", bson.D{{\"$search\", \"herb\"}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Dish\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\n\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Kale Tabbouleh\",\"description\":\"A bright, herb-based salad. A perfect starter for vegetarians and vegans.\"}\n{\"name\":\"Herbed Whole Branzino\",\"description\":\"Grilled whole fish stuffed with herbs and pomegranate seeds. Serves 3-4.\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"$text\", bson.D{{\"$search\", \"\\\"serves 2\\\"\"}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Dish\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\n\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Shepherd's Pie\",\"description\":\"A vegetarian take on the classic dish that uses lentils as a base. Serves 2.\"}\n{\"name\":\"Garlic Butter Trout\",\"description\":\"Baked trout seasoned with garlic, lemon, dill, and, of course, butter. Serves 2.\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"$text\", bson.D{{\"$search\", \"vegan -tofu\"}}}}\n\ncursor, err := coll.Find(context.TODO(), filter)\nif err != nil {\n   panic(err)\n}\n\nvar results []Dish\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\n\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Kale Tabbouleh\",\"description\":\"A bright, herb-based salad. A perfect starter for vegetarians and vegans.\"}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"$text\", bson.D{{\"$search\", \"vegetarian\"}}}}\nsort := bson.D{{\"score\", bson.D{{\"$meta\", \"textScore\"}}}}\nprojection := bson.D{{\"name\", 1}, {\"score\", bson.D{{\"$meta\", \"textScore\"}}}, {\"_id\", 0}}\nopts := options.Find().SetSort(sort).SetProjection(projection)\n\ncursor, err := coll.Find(context.TODO(), filter, opts)\nif err != nil {\n   panic(err)\n}\n\nvar results []bson.D\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\nfor _, result := range results {\n   res, _ := bson.MarshalExtJSON(result, false, false)\n   fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Green Curry\",\"score\":0.8999999999999999}\n{\"name\":\"Kale Tabbouleh\",\"score\":0.5625}\n{\"name\":\"Shepherd's Pie\",\"score\":0.5555555555555556}"
                },
                {
                    "lang": "go",
                    "value": "matchStage := bson.D{{\"$match\", bson.D{{\"$text\", bson.D{{\"$search\", \"herb\"}}}}}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{matchStage})\nif err != nil {\n   panic(err)\n}\n\nvar results []Dish\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\n\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Kale Tabbouleh\",\"description\":\"A bright, herb-based salad. A perfect starter for vegetarians and vegans.\"}\n{\"name\":\"Herbed Whole Branzino\",\"description\":\"Grilled whole fish stuffed with herbs and pomegranate seeds. Serves 3-4.\"}"
                },
                {
                    "lang": "go",
                    "value": "matchStage := bson.D{{\"$match\", bson.D{{\"$text\", bson.D{{\"$search\", \"vegetarian\"}}}}}}\nsortStage := bson.D{{\"$sort\", bson.D{{\"score\", bson.D{{ \"$meta\", \"textScore\" }}}}}}\nprojectStage := bson.D{{\"$project\", bson.D{{\"name\", 1}, {\"score\", bson.D{{ \"$meta\", \"textScore\" }}}, {\"_id\", 0}}}}\n\ncursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{matchStage, sortStage, projectStage})\nif err != nil {\n   panic(err)\n}\n\nvar results []bson.D\nif err = cursor.All(context.TODO(), &results); err != nil {\n   panic(err)\n}\nfor _, result := range results {\n    res, _ := bson.MarshalExtJSON(result, false, false)\n    fmt.Println(string(res))\n}"
                },
                {
                    "lang": "none",
                    "value": "{\"name\":\"Green Curry\",\"score\":0.8999999999999999}\n{\"name\":\"Kale Tabbouleh\",\"score\":0.5625}\n{\"name\":\"Shepherd's Pie\",\"score\":0.5555555555555556}"
                }
            ],
            "preview": "In this guide, you can learn how to run a text search.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/upsert",
            "title": "Insert or Update in a Single Operation",
            "headings": [
                "Overview",
                "Sample Data",
                "Upsert",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to perform an  upsert . The example in this guide uses the following  Plant  struct as a model for documents\nin the  plants  collection: To run the example in this guide, load the sample data into the\n db.plants  collection with the following snippet: Each document contains a description of an individual plant that\nincludes the species, plant ID, and height corresponding to\nthe  species ,  plant_id , and  height  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. Applications use insert and update operations to store and modify data.\nSometimes, you must choose between an insert and an update operation\ndepending on whether the document exists. MongoDB simplifies this\ndecision for us with an  upsert  option. An upsert performs one of the following actions: You can specify an upsert by passing  true  to the  SetUpsert() \nmethod in the options of the following write operation methods: Updates documents that match your query filter Inserts a new document if there are no matches to your query filter UpdateOne() UpdateByID() UpdateMany() ReplaceOne() FindOneAndUpdate() FindOneAndReplace() If you don't specify an upsert, no change occurs in the write\noperation when zero documents match your query filter. This is\nequivalent to passing  false  to the  SetUpsert()  method. The following example performs the following actions: If you query the  plants  collection to view all documents, you can\nsee that since the query filter did not match any documents, a new\ndocument was inserted with the specified fields: Matches documents where the  species  is \"Ledebouria socialis\" and\nthe  plant_id  is  3 Updates the  height  of the matched document to  8.3 Inserts this document if there are no matches to the query filter To learn more about the operations mentioned, see the following\nguides: Specify a Query Modify Documents Compound Operations To learn more about any of the methods or types mentioned in this\nguide, see the following API Documentation: UpdateOne() UpdateByID() UpdateMany() ReplaceOne() FindOneAndUpdate() FindOneAndReplace() UpdateOptions.SetUpsert() ReplaceOptions.SetUpsert() UpdateResult",
            "code": [
                {
                    "lang": "go",
                    "value": "type Plant struct {\n\tSpecies string\n\tPlantID int32 `bson:\"plant_id\"`\n\tHeight  float64\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"plants\")\ndocs := []interface{}{\n\tPlant{Species: \"Polyscias fruticosa\", PlantID: 1, Height: 27.6},\n\tPlant{Species: \"Polyscias fruticosa\", PlantID: 2, Height: 34.9},\n\tPlant{Species: \"Ledebouria socialis\", PlantID: 1, Height: 11.4},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "none",
                    "value": "{\"species\":\"Polyscias fruticosa\",\"plant_id\":1,\"height\":27.6}\n{\"species\":\"Polyscias fruticosa\",\"plant_id\":2,\"height\":34.9}\n{\"species\":\"Ledebouria socialis\",\"plant_id\":1,\"height\":11.4}\n{\"species\":\"Ledebouria socialis\",\"plant_id\":3,\"height\":8.3}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"species\", \"Ledebouria socialis\"}, {\"plant_id\", 3}}\nupdate := bson.D{{\"$set\", bson.D{{\"species\", \"Ledebouria socialis\"}, {\"plant_id\", 3}, {\"height\", 8.3}}}}\nopts := options.Update().SetUpsert(true)\n\nresult, err := coll.UpdateOne(context.TODO(), filter, update, opts)\nif err != nil {\n    panic(err)\n}\n\nfmt.Printf(\"Number of documents updated: %v\\n\", result.ModifiedCount)\nfmt.Printf(\"Number of documents upserted: %v\\n\", result.UpsertedCount)"
                },
                {
                    "lang": "none",
                    "value": "Number of documents updated: 0\nNumber of documents upserted: 1"
                }
            ],
            "preview": "In this guide, you can learn how to perform an upsert.",
            "tags": "code example, write, add data",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/modify",
            "title": "Modify Documents",
            "headings": [
                "Overview",
                "A Note About _id",
                "Update",
                "Parameters",
                "Return Values",
                "Example",
                "Replace",
                "Parameters",
                "Return Values",
                "Example",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to modify documents in MongoDB using\n update  and  replace  operations. Update operations change the fields that you specify while leaving other\nfields and values unchanged. Replace operations remove all existing fields\nexcept for  _id  in a document and substitute the deleted fields with\nthe new fields and values you specify. In MongoDB, all methods to modify documents follow the same pattern: The pattern expects you to: The driver provides the following methods to modify documents: changeX  is a placeholder and not a real method. Specify a query filter to match one or more documents to modify. Specify the field and value changes. Specify options, if you must modify the method behavior. UpdateByID() UpdateOne() UpdateMany() ReplaceOne() BulkWrite()   (not discussed in this guide) FindOneAndUpdate()   (not discussed in this guide) FindOneAndReplace()   (not discussed in this guide) Each document in a MongoDB collection has a unique and immutable  _id \nfield. You cannot use update and replace operations to change the\n _id  field. If you attempt to change this field, the update and\nreplace methods return a  WriteError . Use the  UpdateOne()  or  UpdateByID()  method to update a single\ndocument. Use the  UpdateMany()  method to update multiple documents. Each method takes an  update document  that includes at least one  update operator .\nThe update operator specifies the type of update to perform. The update\ndocument also includes the fields and values that describe the change.\nUpdate documents use the following format: See the MongoDB server manual for a  complete list of update operators\nand descriptions . If you are using MongoDB Server version 4.2 or later, you can use aggregation\npipelines made up of a subset of aggregation stages in update operations. To learn more about\nthe aggregation stages MongoDB supports in\naggregation pipelines, see our tutorial on performing\n updates with aggregation pipelines . UpdateOne() ,  UpdateByID() , and  UpdateMany()  return an\n UpdateResult  type that contains information about the update\noperation if the operation is successful. The  UpdateResult  type\ncontains the following properties: If multiple documents match the query filter passed to  UpdateOne() ,\nthe method selects and updates the first matched document. If no\ndocuments match the query filter, the update operation makes no\nchanges. See our  upsert guide \nto learn how to insert a new document if no documents match the query filter. Property Description MatchedCount The number of documents matched by the filter ModifiedCount The number of documents modified by the operation UpsertedCount The number of documents upserted by the operation UpsertedID The  _id  of the upserted document, or  nil  if there is none The following document describes an employee: The following example uses the  UpdateByID()  method to: The following shows the updated document resulting from the preceding update operation: Match the document where the  _id  value is 2158. Set the  name  field to \"Mary Wollstonecraft Shelley\" and the\n role  field to \"Marketing Director\". Increment the value of the  bonus  field by 2000. Use the  ReplaceOne()  method to replace a single document. ReplaceOne()  expects a  replacement document , which is the document\nthat you want to take the place of an existing document. Replacement\ndocuments use the following format: ReplaceOne()  returns an  UpdateResult  type that\ncontains information about the replace operation if the operation is\nsuccessful. The  UpdateResult  type contains the following properties: If multiple documents match the query filter passed to  ReplaceOne() ,\nthe method selects and replaces the first matched document. Your replace\noperation fails if no documents match the query filter. Property Description MatchedCount The number of documents matched by the filter ModifiedCount The number of documents modified by the operation UpsertedCount The number of documents upserted by the operation UpsertedID The  _id  of the upserted document, or  nil  if there is none The following document describes a kitchen item: The following example uses the  ReplaceOne()  method to substitute\nthis document with one that contains an  item  field with a\nvalue of \"Cup\" and a  quantity  field with a value of 107: The replaced document contains the contents of the replacement document\nand the immutable  _id  field as follows: For runnable examples of the update and replace operations, see the\nfollowing usage examples: To learn more about the operations mentioned, see the following\nguides: To learn more about updating array elements, see  Update Arrays in a Document . Update a Document Update Multiple Documents Replace a Document Specify a Query Overview Compound Operations Update Operators To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: WriteError UpdateOne() UpdateByID() UpdateMany() UpdateResult ReplaceOne()",
            "code": [
                {
                    "lang": "go",
                    "value": "bson.D{{\"<update operator>\", bson.D{{\"<field>\", <value>},\n                                    {\"<field>\", <value>}, ... }},\n       {\"<update operator>\", ... }, ... }"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\" : 2158,\n   \"name\" : \"Mary Shelley\",\n   \"department\" : \"Marketing\",\n   \"role\" : \"Marketing Analyst\",\n   \"bonus\" : 2500,\n   ...\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\" : 2158,\n   \"name\" : \"Mary Wollstonecraft Shelley\",\n   \"department\" : \"Marketing\",\n   \"role\" : \"Marketing Director\",\n   \"bonus\" : 4500,\n   ...\n}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"_id\", 2158}}\nupdate := bson.D{{\"$set\", bson.D{{\"name\", \"Mary Wollstonecraft Shelley\"},\n   {\"role\", \"Marketing Director\"}}}, {\"$inc\", bson.D{{\"bonus\", 2000}}}}\n\nresult, err := collection.UpdateOne(context.TODO(), filter, update)\nfmt.Printf(\"Documents matched: %v\\n\", result.MatchedCount)\nfmt.Printf(\"Documents updated: %v\\n\", result.ModifiedCount)"
                },
                {
                    "lang": "none",
                    "value": "Documents matched: 1\nDocuments updated: 1"
                },
                {
                    "lang": "go",
                    "value": "bson.D{{\"<field>\", \"<value>\"}, {\"<field>\", \"<value>\"}, ... }"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\" : 2056,\n   \"item\" : \"Mug\",\n   \"brand\" : \"Simply Ceramics\",\n   \"price\" : 2.99,\n   \"material\" : \"Glass\"\n}"
                },
                {
                    "lang": "json",
                    "value": "{\n   \"_id\" : 2056,\n   \"item\" : \"Cup\",\n   \"quantity\" : 107\n}"
                },
                {
                    "lang": "go",
                    "value": "filter := bson.D{{\"_id\", 2056}}\nreplacement := bson.D{{\"item\", \"Cup\"}, {\"quantity\", 107}}\n\nresult, err := collection.ReplaceOne(context.TODO(), filter, replacement)\nfmt.Printf(\"Documents matched: %v\\n\", result.MatchedCount)\nfmt.Printf(\"Documents replaced: %v\\n\", result.ModifiedCount)"
                },
                {
                    "lang": "none",
                    "value": "Documents matched: 1\nDocuments replaced: 1"
                }
            ],
            "preview": "In this guide, you can learn how to modify documents in MongoDB using\nupdate and replace operations.",
            "tags": "code example, write operation, change data",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/insert",
            "title": "Insert a Document",
            "headings": [
                "Overview",
                "The _id Field",
                "Insert a Document",
                "Example",
                "Modify InsertOne Behavior",
                "Insert Multiple Documents",
                "Example",
                "Modify InsertMany Behavior",
                "Ordered Behavior",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to  insert  documents into a MongoDB\ncollection. Before you can find, update, and delete documents in MongoDB, you must\ninsert those documents. You can insert one document by using the  InsertOne() \nmethod, or insert multiple documents by using either the  InsertMany() \nor  BulkWrite()  method. The following sections focus on  InsertOne()  and  InsertMany() .\nTo learn how to use the  BulkWrite()  method, see the\n Bulk Operations  guide. In MongoDB, each document  must  contain a unique  _id  field. The two options for managing this field are: Unless you provide strong guarantees for uniqueness, MongoDB recommends\nyou let the driver automatically generate  _id  values. To learn more about the  _id  field, see the Server Manual Entry on\n Unique Indexes . To learn more about document structure and rules, see the\nServer Manual Entry on  Documents . Managing this field yourself, ensuring that each value you use is unique. Letting the driver automatically generate unique  ObjectId  values. The\ndriver generates unique  ObjectId  values for documents that you do\nnot explicitly specify an  _id . Duplicate  _id  values violate unique index constraints, which\ncauses the driver to return a  WriteError . Use the  InsertOne()  method to insert a single document into a collection. Upon successful insertion, the method returns an\n InsertOneResult  instance that contains the  _id  of\nthe new document. This example uses the following  Book  struct as a model for documents\nin the  books  collection: The following example creates and inserts a document into the\n books  collection using the  InsertOne()  method: You can modify the behavior of  InsertOne()  by constructing and passing\nan optional  InsertOneOptions  struct.  The available options to set with\n InsertOneOptions  are: Construct an  InsertOneOptions  as follows: Option Description BypassDocumentValidation Use the  InsertMany()  method to insert multiple documents into a\ncollection. Upon successful insertion, the  InsertMany()  method returns an  InsertManyResult \ninstance that contains the  _id  fields of the inserted documents. The following example creates and inserts multiple documents into the\n books  collection using the  InsertMany()  method: After running the preceding code, your output resembles the following: You can modify the behavior of  InsertMany()  by constructing\nand passing an optional  InsertManyOptions  struct. The available options\nto set with  InsertManyOptions  are: Construct an  InsertManyOptions  as follows: Option Description BypassDocumentValidation Ordered Assume you want to insert the following documents: If you attempt to insert these documents with default  InsertManyOptions , a\n BulkWriteException  occurs at the third document because of the repeated\n _id  value, but the documents before the error-producing document still get\ninserted into your collection. You can get an acknowledgement of successful document insertion even\nif a BulkWriteException occurs: After running the preceding code, your collection contains the following documents: For runnable examples of the insert operations, see the following usage\nexamples: To learn more about performing the operations mentioned, see the\nfollowing guides: Insert a Document Insert Multiple Documents Specify a Query Bulk Operations To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: WriteError InsertOne() InsertOneResult InsertMany() InsertManyResult BulkWriteException",
            "code": [
                {
                    "lang": "go",
                    "value": "type Book struct {\n\tTitle  string\n\tAuthor string\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"books\")\ndoc := Book{Title: \"Atonement\", Author: \"Ian McEwan\"}\n\nresult, err := coll.InsertOne(context.TODO(), doc)\n\nfmt.Printf(\"Inserted document with _id: %v\\n\", result.InsertedID)"
                },
                {
                    "lang": "none",
                    "value": "Inserted document with _id: ObjectID(\"...\")"
                },
                {
                    "lang": "go",
                    "value": "opts := options.InsertOne().SetBypassDocumentValidation(true)"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"myDB\").Collection(\"favorite_books\")\ndocs := []interface{}{\n    Book{Title: \"Cat's Cradle\", Author: \"Kurt Vonnegut Jr.\"},\n    Book{Title: \"In Memory of Memory\", Author: \"Maria Stepanova\"},\n    Book{Title: \"Pride and Prejudice\", Author: \"Jane Austen\"},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)\nfmt.Printf(\"Documents inserted: %v\\n\", len(result.InsertedIDs))\n\nfor _, id := range result.InsertedIDs {\n    fmt.Printf(\"Inserted document with _id: %v\\n\", id)\n}"
                },
                {
                    "lang": "none",
                    "value": "Documents inserted: 3\nInserted document with _id: ObjectID(\"...\")\nInserted document with _id: ObjectID(\"...\")\nInserted document with _id: ObjectID(\"...\")"
                },
                {
                    "lang": "go",
                    "value": "opts := options.InsertMany().SetBypassDocumentValidation(true).SetOrdered(false)"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"title\": \"Where the Wild Things Are\" }\n{ \"_id\": 2, \"title\": \"The Very Hungry Caterpillar\" }\n{ \"_id\": 1, \"title\": \"Blueberries for Sal\" }\n{ \"_id\": 3, \"title\": \"Goodnight Moon\" }"
                },
                {
                    "lang": "json",
                    "value": "{ \"_id\": 1, \"title\": \"Where the Wild Things Are\" }\n{ \"_id\": 2, \"title\": \"The Very Hungry Caterpillar\" }"
                },
                {
                    "lang": "go",
                    "value": "type Book struct {\n    ID    int `bson:\"_id\"`\n    Title string\n}\n\n...\n\ndocs := []interface{}{\n    Book{ID: 1, Title: \"Where the Wild Things Are\"},\n    Book{ID: 2, Title: \"The Very Hungry Caterpillar\"},\n    Book{ID: 1, Title: \"Blueberries for Sal\"},\n    Book{ID: 3, Title: \"Goodnight Moon\"},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)\nif err != nil {\n    fmt.Printf(\"A bulk write error occurred, but %v documents were still inserted.\\n\", len(result.InsertedIDs))\n}\n\nfor _, id := range result.InsertedIDs {\n    fmt.Printf(\"Inserted document with _id: %v\\n\", id)\n}"
                },
                {
                    "lang": "none",
                    "value": "A bulk write error occurred, but 2 documents were still inserted.\nInserted document with _id: 1\nInserted document with _id: 2"
                }
            ],
            "preview": "In this guide, you can learn how to insert documents into a MongoDB\ncollection.",
            "tags": "code example, write operation, add data",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/monitoring/connection-monitoring",
            "title": "Connection Monitoring",
            "headings": [
                "Overview",
                "Subscribe to Events",
                "Event Descriptions",
                "Example Event Documents",
                "ConnectionPoolCreated",
                "ConnectionPoolReady",
                "ConnectionPoolCleared",
                "ConnectionPoolClosed",
                "ConnectionCreated",
                "ConnectionReady",
                "ConnectionClosed",
                "ConnectionCheckOutStarted",
                "ConnectionCheckOutFailed",
                "ConnectionCheckedOut",
                "ConnectionCheckedIn",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "This guide shows you how to use the Go driver to monitor the\ndriver's connection pool. A connection pool is a set of open\nTransmission Control Protocol (TCP) connections that your driver\nmaintains with a MongoDB instance. Connection pools help reduce the\nnumber of new connections your application needs to create,\nwhich might make your application run faster. You might use information about connection pool events in your\napplication to optimize performance or understand the client lifecycle. You can access details about connection pool events by subscribing to them\nin your application. The following example demonstrates how to subscribe\nto the  PoolEvent  event by instantiating a\n PoolMonitor  and connecting to a deployment: The following table describes the types of pool events that the driver\nemits: Pool Event Type Description ConnectionPoolCreated Created when a connection pool is created. ConnectionPoolReady Created when a connection pool is ready. ConnectionPoolCleared Created when all the connections in the pool are closed. ConnectionPoolClosed Created when a connection pool is closed, before the destruction of\nthe server instance. ConnectionCreated Created when a connection is created, but not necessarily\nwhen it is used for an operation. ConnectionReady Created after a connection completes a\nhandshake and is ready to be used for operations. ConnectionClosed Created when a connection is closed. ConnectionCheckOutStarted Created when an operation attempts to acquire a connection for\nexecution. ConnectionCheckOutFailed Created when an operation cannot acquire a connection for\nexecution. ConnectionCheckedOut Created when an operation successfully acquires a connection for\nexecution. ConnectionCheckedIn Created when a connection is checked back into the pool after an operation\nis executed. The following sections show sample output for each type of connection\npool monitoring event. To learn more about monitoring a MongoDB deployment, see the  How\nto Monitor MongoDB  article. To learn more about connecting to MongoDB, see the\n Connection Guide . To learn more about the methods and types mentioned in this\nguide, see the following API documentation: PoolMonitor  type PoolEvent  type SetPoolMonitor()  method",
            "code": [
                {
                    "lang": "go",
                    "value": "var eventArray []*event.PoolEvent\ncxnMonitor := &event.PoolMonitor{\n    Started: func(e *event.PoolEvent) {\n        eventArray = append(eventArray, e)\n    },\n}\nclientOpts := options.Client().ApplyURI(uri).SetPoolMonitor(cxnMonitor)\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionPoolCreated\",\n    \"address\": \"...\",\n    \"connectionId\": 0,\n    \"options\": {\n        \"maxPoolSize\": 100,\n        \"minPoolSize\": 0,\n        \"maxIdleTimeMS\": 0\n    },\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionPoolReady\",\n    \"address\": \"...\",\n    \"connectionId\": 0,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionPoolCleared\",\n    \"address\": \"...\",\n    \"connectionId\": 0,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionPoolClosed\",\n    \"address\": \"...\",\n    \"connectionId\": 0,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionCreated\",\n    \"address\": \"...\",\n    \"connectionId\": 1,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionReady\",\n    \"address\": \"...\",\n    \"connectionId\": 1,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionClosed\",\n    \"address\": \"...\",\n    \"connectionId\": 1,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionCheckOutStarted\",\n    \"address\": \"...\",\n    \"connectionId\": 0,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionCheckOutFailed\",\n    \"address\": \"...\",\n    \"connectionId\": 0,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionCheckedOut\",\n    \"address\": \"...\",\n    \"connectionId\": 1,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.PoolEvent\n{\n    \"type\": \"ConnectionCheckedIn\",\n    \"address\": \"...\",\n    \"connectionId\": 1,\n    \"options\": null,\n    \"reason\": \"\",\n    \"serviceId\": null,\n    \"error\": null\n}"
                }
            ],
            "preview": "This guide shows you how to use the Go driver to monitor the\ndriver's connection pool. A connection pool is a set of open\nTransmission Control Protocol (TCP) connections that your driver\nmaintains with a MongoDB instance. Connection pools help reduce the\nnumber of new connections your application needs to create,\nwhich might make your application run faster.",
            "tags": "code example, performance, monitor",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/monitoring/command-monitoring",
            "title": "Command Monitoring",
            "headings": [
                "Overview",
                "Subscribe to Events",
                "Event Descriptions",
                "Example Event Documents",
                "CommandStartedEvent",
                "CommandSucceededEvent",
                "CommandFailedEvent",
                "Additional Information",
                "API Documentation"
            ],
            "paragraphs": "This guide shows you how to use the Go driver to monitor the\noutcome of commands that the driver sends to your MongoDB deployment. You might use information about command events in your\napplication to understand changes in query performance or resolve bottlenecks. You can access details about command events by subscribing to them\nin your application. The following example demonstrates how to subscribe\nto the  CommandStartedEvent  event by instantiating a\n CommandMonitor  and connecting to a deployment: You can subscribe to one or more of the following command monitoring\nevents: Event Name Description CommandStartedEvent Created when a command starts. CommandSucceededEvent Created when a command succeeds. CommandFailedEvent Created when a command does not succeed. The following sections show sample output for each type of command monitoring event. To learn more about monitoring a MongoDB deployment, see the  How\nto Monitor MongoDB  article. To learn more about performing MongoDB operations, see the\n CRUD Operations  guides. To learn more about the methods and types mentioned in this\nguide, see the following API documentation: CommandMonitor  type SetMonitor()  method CommandStartedEvent  type CommandSucceededEvent  type CommandFailedEvent  type",
            "code": [
                {
                    "lang": "go",
                    "value": "var eventArray []*event.CommandStartedEvent\ncmdMonitor := &event.CommandMonitor{\n    Started: func(ctx context.Context, e *event.CommandStartedEvent) {\n        eventArray = append(eventArray, e)\n    },\n}\nclientOpts := options.Client().ApplyURI(uri).SetMonitor(cmdMonitor)\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "none",
                    "value": "*event.CommandStartedEvent\n{\n    \"Command\": \"...\",\n    \"DatabaseName\": \"...\",\n    \"CommandName\": \"...\",\n    \"RequestID\": ...,\n    \"ConnectionID\": \"...\",\n    \"ServerConnectionID\": ...,\n    \"ServiceID\": \"...\"\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.CommandSucceededEvent\n{\n    \"DurationNanos\": 38717583,\n    \"Duration\": 38717583,\n    \"CommandName\": \"insert\",\n    \"RequestID\": 13,\n    \"ConnectionID\": \"...\",\n    \"ServerConnectionID\": ...,\n    \"ServiceID\": null,\n    \"Reply\": \"...\"\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.CommandFailedEvent\n{\n    \"DurationNanos\": 38717583,\n    \"Duration\": 38717583,\n    \"CommandName\": \"insert\",\n    \"RequestID\": 13,\n    \"ConnectionID\": \"...\",\n    \"ServerConnectionID\": ...,\n    \"ServiceID\": null,\n    \"Failure\": \"...\"\n}"
                }
            ],
            "preview": "This guide shows you how to use the Go driver to monitor the\noutcome of commands that the driver sends to your MongoDB deployment.",
            "tags": "code example, operation",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/crud/write-operations/bulk",
            "title": "Bulk Operations",
            "headings": [
                "Overview",
                "Sample Data",
                "Bulk Write",
                "Modify Behavior",
                "Return Values",
                "Operations",
                "Insert",
                "Example",
                "Replace",
                "Example",
                "Update",
                "Example",
                "Delete",
                "Example",
                "Execution Order",
                "Ordered",
                "Unordered",
                "Example",
                "Additional Information",
                "Related Operations",
                "API Documentation"
            ],
            "paragraphs": "In this guide, you can learn how to use  bulk operations . Bulk operations perform a large number of write operations. Instead of\nmaking a call for each operation to the database, bulk operations\nperform multiple operations with one call to the database. The examples in this guide use the following  Book  struct as a model for documents\nin the  books  collection: To run the examples in this guide, load the sample data into the\n db.books  collection with the following snippet: Each document contains a description of a book that\nincludes the title, author, and page length corresponding to\nthe  title ,  author , and  length  fields in each document. If the necessary database and collection don't exist when\nyou perform a write operation, the server implicitly creates\nthem. To perform a bulk operation, pass an array of  WriteModel  documents to the  BulkWrite()  method. The  BulkWrite()  method optionally takes a  BulkWriteOptions \ntype, which represents options you can use to modify its behavior. If\nyou don't specify a  BulkWriteOptions , the driver uses the default\nvalues for each option. The  BulkWriteOptions  type allows you to configure options with the\nfollowing methods: Method Description SetBypassDocumentValidation() SetOrdered() The  BulkWrite()  method returns a  BulkWriteResult  type, which\ncontains information about the bulk operation if it's successful. The\n BulkWriteResult  type contains the following properties: Property Description InsertedCount The number of documents inserted. MatchedCount The number of documents matched by the  query filter  in update and replace operations. ModifiedCount The number of documents modified by update and replace operations. DeletedCount The number of documents deleted. UpsertedCount The number of documents  upserted  by update and replace operations. UpsertedIDs A map of an operation index to the  _id  of each  upserted  document. A  WriteModel  represents an insert, replace, update, or delete operation. To perform an insert operation, create an  InsertOneModel  specifying\nthe document you want to insert. To insert multiple documents, create an\n InsertOneModel  for each document you want to insert. The  InsertOneModel  allows you to specify its behavior with the\nfollowing method: Method Description SetDocument() This following example creates two  InsertOneModel  instances to\ninsert two documents: To perform a replace operation, create a  ReplaceOneModel  specifying\nthe document you want to replace and a  replacement document . To replace multiple documents, create a\n ReplaceOneModel  for each document you want to replace. The  ReplaceOneModel  allows you to specify its behavior with the\nfollowing methods: Method Description SetCollation() SetFilter() SetHint() SetReplacement() SetUpsert() The following example creates a  ReplaceOneModel  to replace a\ndocument where the  title  is \"Lucy\" with a new document: To perform an update operation, create an  UpdateOneModel  specifying\nthe document you want to update and an  update document . To update multiple documents, use the\n UpdateManyModel . The  UpdateOneModel  and  UpdateManyModel  allow you to specify\ntheir behavior with the following methods: Method Description SetArrayFilters() SetCollation() SetFilter() SetHint() SetUpdate() SetUpsert() The following example creates an  UpdateOneModel  to decrement a\ndocument's  length  by  15  if the  author  is \"Elena Ferrante\": To perform a delete operation, create a  DeleteOneModel  specifying\nthe document you want to delete. To delete multiple documents, use the\n DeleteManyModel . The  DeleteOneModel  and  DeleteManyModel  allow you to specify\ntheir behavior with the following methods: Method Description SetCollation() SetFilter() SetHint() The following example creates a  DeleteManyModel  to delete\ndocuments where the  length  is greater than  300 : The  BulkWrite()  method allows you to specify if you want to\nexecute the bulk operations as ordered or unordered in its\n BulkWriteOptions . By default, the  BulkWrite()  method executes bulk operations in\norder you added them and stops if an error occurs. This is equivalent to specifying  true  in the  SetOrdered() \nmethod: To execute bulk write operations in any order and continue if an error\noccurs, specify  false  to the  SetOrdered()  method. The method\nreports the errors afterward. The following example performs the following actions in any order: The following documents are present in the  books  collection after\nthe bulk operation: Inserts two documents. Replaces a document where the  title  is \"My Brilliant Friend\" with a new document. Increments every document's  length  by  10  if the current\n length  value is less than  200 . Deletes all documents where the  author  field value includes \"Jam\". For a runnable example on performing a bulk operation, see\n Perform Bulk Operations . To learn more about performing the operations mentioned, see the\nfollowing guides: Specify a Query Insert a Document Modify Documents Delete Documents Bulk Write Operations To learn more about any of the methods or types discussed in this\nguide, see the following API Documentation: BulkWrite() BulkWriteOptions BulkWriteResult NewInsertOneModel() NewReplaceOneModel() NewReplaceOneModel() NewUpdateOneModel() NewUpdateManyModel() NewDeleteOneModel() NewDeleteManyModel()",
            "code": [
                {
                    "lang": "go",
                    "value": "type Book struct {\n\tTitle  string\n\tAuthor string\n\tLength int32\n}\n"
                },
                {
                    "lang": "go",
                    "value": "coll := client.Database(\"db\").Collection(\"books\")\ndocs := []interface{}{\n\tBook{Title: \"My Brilliant Friend\", Author: \"Elena Ferrante\", Length: 331},\n\tBook{Title: \"Lucy\", Author: \"Jamaica Kincaid\", Length: 103},\n}\n\nresult, err := coll.InsertMany(context.TODO(), docs)"
                },
                {
                    "lang": "go",
                    "value": "models := []mongo.WriteModel{\n\tmongo.NewInsertOneModel().SetDocument(Book{Title: \"Beloved\", Author: \"Toni Morrison\", Length: 324}),\n\tmongo.NewInsertOneModel().SetDocument(Book{Title: \"Outline\", Author: \"Rachel Cusk\", Length: 258}),\n}"
                },
                {
                    "lang": "go",
                    "value": "models := []mongo.WriteModel{\n\tmongo.NewReplaceOneModel().SetFilter(bson.D{{\"title\", \"Lucy\"}}).\n\t\tSetReplacement(Book{Title: \"On Beauty\", Author: \"Zadie Smith\", Length: 473}),\n}"
                },
                {
                    "lang": "go",
                    "value": "models := []mongo.WriteModel{\n\tmongo.NewUpdateOneModel().SetFilter(bson.D{{\"author\", \"Elena Ferrante\"}}).\n\t\tSetUpdate(bson.D{{\"$inc\", bson.D{{\"length\", -15}}}}),\n}"
                },
                {
                    "lang": "go",
                    "value": "models := []mongo.WriteModel{\n\tmongo.NewDeleteManyModel().SetFilter(bson.D{{\"length\", bson.D{{\"$gt\", 300}}}}),\n}"
                },
                {
                    "lang": "go",
                    "value": "opts := options.BulkWrite().SetOrdered(true)"
                },
                {
                    "lang": "none",
                    "value": "{\"title\":\"Atonement\",\"author\":\"Ian McEwan\",\"length\":351}\n{\"title\":\"Middlemarch\",\"author\":\"George Eliot\",\"length\":904}\n{\"title\":\"Pale Fire\",\"author\":\"Vladimir Nabokov\",\"length\":246}"
                },
                {
                    "lang": "go",
                    "value": "models := []mongo.WriteModel{\n  mongo.NewInsertOneModel().SetDocument(Book{Title: \"Middlemarch\", Author: \"George Eliot\", Length: 904}),\n  mongo.NewInsertOneModel().SetDocument(Book{Title: \"Pale Fire\", Author: \"Vladimir Nabokov\", Length: 246}),\n  mongo.NewReplaceOneModel().SetFilter(bson.D{{\"title\", \"My Brilliant Friend\"}}).\n    SetReplacement(Book{Title: \"Atonement\", Author: \"Ian McEwan\", Length: 351}),\n  mongo.NewUpdateManyModel().SetFilter(bson.D{{\"length\", bson.D{{\"$lt\", 200}}}}).\n    SetUpdate(bson.D{{\"$inc\", bson.D{{\"length\", 10}}}}),\n  mongo.NewDeleteManyModel().SetFilter(bson.D{{\"author\", bson.D{{\"$regex\", \"Jam\"}}}}),\n}\nopts := options.BulkWrite().SetOrdered(false)\n\nresults, err := coll.BulkWrite(context.TODO(), models, opts)\nif err != nil {\n   panic(err)\n}\n\nfmt.Printf(\"Number of documents inserted: %d\\n\", results.InsertedCount)\nfmt.Printf(\"Number of documents replaced or updated: %d\\n\", results.ModifiedCount)\nfmt.Printf(\"Number of documents deleted: %d\\n\", results.DeletedCount)"
                },
                {
                    "lang": "none",
                    "value": "Number of documents inserted: 2\nNumber of documents replaced or updated: 2\nNumber of documents deleted: 1"
                }
            ],
            "preview": "In this guide, you can learn how to use bulk operations.",
            "tags": null,
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        },
        {
            "slug": "fundamentals/monitoring/cluster-monitoring",
            "title": "Cluster Monitoring",
            "headings": [
                "Overview",
                "Subscribe to Events",
                "Event Descriptions",
                "Example Event Documents",
                "ServerDescriptionChangedEvent",
                "Kind Field Value",
                "ServerOpeningEvent",
                "ServerClosedEvent",
                "TopologyDescriptionChangedEvent",
                "TopologyOpeningEvent",
                "TopologyClosedEvent",
                "ServerHeartbeatStartedEvent",
                "ServerHeartbeatSucceededEvent",
                "ServerHeartbeatFailedEvent",
                "API Documentation"
            ],
            "paragraphs": "This guide shows you how to use the Go driver to monitor topology\nevents in a MongoDB instance, replica set, or sharded cluster. The\ndriver creates topology events, also known as Server Discovery and\nMonitoring (SDAM) events, when there are any changes in the state of the\ninstance or cluster that you are connected to. You might use information about topology events in your\napplication to understand cluster changes, assess cluster health, or\nperform capacity planning. You can also configure logging in your application to learn more\nabout driver events. To learn more, see  Logging . You can access details about SDAM events by subscribing to them\nin your application. The following example demonstrates how to subscribe\nto the  ServerClosed  event by instantiating a\n ServerMonitor  and connecting to a deployment: You can subscribe to the following SDAM events by specifying properties\nof a  ServerMonitor  instance: Event Name Description ServerDescriptionChangedEvent Created when an instance state changes (such as from secondary to primary). ServerOpeningEvent Created when the server is initialized. ServerClosedEvent Created when the server is closed. TopologyDescriptionChangedEvent Created when the topology changes, such as an election of a new\nprimary or disconnection of a  mongos  proxy. TopologyOpeningEvent Created when the topology is initialized. TopologyClosedEvent Created when the topology is closed. ServerHeartbeatStartedEvent Created when the heartbeat is started. ServerHeartbeatSucceededEvent Created when the heartbeat succeeds. ServerHeartbeatFailedEvent Created when the heartbeat fails. The following sections show sample output for each type of SDAM event. The  Kind  field in an event document represents the type of a\nsingle server in a topology and can have the following values: Value Description 0 Unknown instance 1 Standalone instance 2 Replica set member 6 Primary instance 10 Secondary instance 18 Arbiter instance 34 Replica set ghost (a member that cannot be queried) 256 mongos  proxy instance 512 Load balancer instance To interpret the value of the  Kind  field, see the  Kind Field\nValue section . Because the driver calls  TopologyDescriptionChangedEvent  when the\ndeployment topology is locked, the callback (function argument) for this event\nmust not attempt any operation that requires server selection on\nthe same client. To interpret the value of the  Kind  field, see the  Kind Field\nValue section . ServerMonitor  type SetServerMonitor()  method ServerKind  type Server  type",
            "code": [
                {
                    "lang": "go",
                    "value": "var eventArray []*event.ServerClosedEvent\nsrvMonitor := &event.ServerMonitor{\n    ServerClosed: func(e *event.ServerClosedEvent) {\n        eventArray = append(eventArray, e)\n    },\n}\nclientOpts := options.Client().ApplyURI(uri).SetServerMonitor(srvMonitor)\nclient, err := mongo.Connect(clientOpts)"
                },
                {
                    "lang": "none",
                    "value": "*event.ServerDescriptionChangedEvent\n{\n    \"Address\": \"...\",\n    \"TopologyID\": \"...\",\n    \"PreviousDescription\": {\n        \"Addr\": \"...\",\n        \"Arbiters\": null,\n        \"AverageRTT\": 0,\n        \"AverageRTTSet\": false,\n        \"Compression\": null,\n        \"CanonicalAddr\": \"...\",\n        \"ElectionID\": \"...\",\n        \"HeartbeatInterval\": 0,\n        \"HelloOK\": false,\n        \"Hosts\": null,\n        \"LastError\": null,\n        \"LastUpdateTime\": \"...\",\n        \"LastWriteTime\": \"...\",\n        \"MaxBatchCount\": 0,\n        \"MaxDocumentSize\": 0,\n        \"MaxMessageSize\": 0,\n        \"Members\": null,\n        \"Passives\": null,\n        \"Passive\": false,\n        \"Primary\": \"...\",\n        \"ReadOnly\": false,\n        \"ServiceID\": null,\n        \"SessionTimeoutMinutes\": 0,\n        \"SetName\": \"...\",\n        \"SetVersion\": 0,\n        \"Tags\": null,\n        \"TopologyVersion\": null,\n        \"Kind\": 0,\n        \"WireVersion\": null\n    },\n    \"NewDescription\": {\n        \"Addr\": \"...\",\n        \"Arbiters\": null,\n        \"AverageRTT\": ...,\n        \"AverageRTTSet\": true,\n        \"Compression\": null,\n        \"CanonicalAddr\": \"...\",\n        \"ElectionID\": \"...\",\n        \"HeartbeatInterval\": ...,\n        \"HelloOK\": true,\n        \"Hosts\": [...],\n        \"LastError\": null,\n        \"LastUpdateTime\": \"...\",\n        \"LastWriteTime\": \"...\",\n        \"MaxBatchCount\": ...,\n        \"MaxDocumentSize\": ...,\n        \"MaxMessageSize\": ...,\n        \"Members\": [...],\n        \"Passives\": null,\n        \"Passive\": false,\n        \"Primary\": \"...\",\n        \"ReadOnly\": false,\n        \"ServiceID\": null,\n        \"SessionTimeoutMinutes\": 30,\n        \"SetName\": \"...\",\n        \"SetVersion\": 9,\n        \"Tags\": [...],\n        \"TopologyVersion\": {...},\n        \"Kind\": 10,\n        \"WireVersion\": {...}\n    }\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.ServerOpeningEvent\n{\n    \"Address\": \"...\",\n    \"TopologyID\": \"...\"\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.ServerClosedEvent\n{\n    \"Address\": \"...\",\n    \"TopologyID\": \"...\"\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.TopologyDescriptionChangedEvent\n{\n    \"TopologyID\": \"...\",\n    \"PreviousDescription\": {\n        \"Servers\": [\n            {\n                \"Addr\": \"...\",\n                \"Arbiters\": null,\n                \"AverageRTT\": 0,\n                \"AverageRTTSet\": false,\n                \"Compression\": null,\n                \"CanonicalAddr\": \"...\",\n                \"ElectionID\": \"...\",\n                \"HeartbeatInterval\": 0,\n                \"HelloOK\": false,\n                \"Hosts\": null,\n                \"LastError\": null,\n                \"LastUpdateTime\": \"...\",\n                \"LastWriteTime\": \"...\",\n                \"MaxBatchCount\": 0,\n                \"MaxDocumentSize\": 0,\n                \"MaxMessageSize\": 0,\n                \"Members\": null,\n                \"Passives\": null,\n                \"Passive\": false,\n                \"Primary\": \"...\",\n                \"ReadOnly\": false,\n                \"ServiceID\": null,\n                \"SessionTimeoutMinutes\": 0,\n                \"SetName\": \"...\",\n                \"SetVersion\": 0,\n                \"Tags\": null,\n                \"TopologyVersion\": null,\n                \"Kind\": 0,\n                \"WireVersion\": null\n            },\n            ...\n        ],\n        \"SetName\": \"...\",\n        \"Kind\": 10,\n        \"SessionTimeoutMinutes\": 30,\n        \"CompatibilityErr\": null\n    },\n    \"NewDescription\": {\n        \"Servers\": [...],\n        \"SetName\": \"...\",\n        \"Kind\": 10,\n        \"SessionTimeoutMinutes\": 30,\n        \"CompatibilityErr\": null\n    }\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.TopologyOpeningEvent\n{\n    \"TopologyID\": \"...\"\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.TopologyClosedEvent\n{\n    \"TopologyID\": \"...\"\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.ServerHeartbeatStartedEvent\n{\n    \"ConnectionID\": \"...\",\n    \"Awaited\": true\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.ServerHeartbeatSucceededEvent\n{\n \"DurationNanos\": ...,\n    \"Reply\": {\n        \"Addr\": \"...\",\n        \"Arbiters\": null,\n        \"AverageRTT\": 0,\n        \"AverageRTTSet\": false,\n        \"Compression\": null,\n        \"CanonicalAddr\": \"...\",\n        \"ElectionID\": \"...\",\n        \"HeartbeatInterval\": 0,\n        \"HelloOK\": true,\n        \"Hosts\": [...],\n        \"LastError\": null,\n        \"LastUpdateTime\": \"...\",\n        \"LastWriteTime\": \"...\",\n        \"MaxBatchCount\": ...,\n        \"MaxDocumentSize\": ...,\n        \"MaxMessageSize\": ...,\n        \"Members\": [...],\n        \"Passives\": null,\n        \"Passive\": false,\n        \"Primary\": \"...\",\n        \"ReadOnly\": false,\n        \"ServiceID\": null,\n        \"SessionTimeoutMinutes\": 30,\n        \"SetName\": \"...\",\n        \"SetVersion\": 9,\n        \"Tags\": [...],\n        \"TopologyVersion\": {...},\n        \"Kind\": 6,\n        \"WireVersion\": {...}\n    },\n    \"ConnectionID\": \"...\",\n    \"Awaited\": true\n}"
                },
                {
                    "lang": "none",
                    "value": "*event.ServerHeartbeatFailedEvent\n{\n    \"DurationNanos\": ...,\n    \"Failure\": \"<error message>\"\n    \"ConnectionID\": \"...\",\n    \"Awaited\": true\n}"
                }
            ],
            "preview": "This guide shows you how to use the Go driver to monitor topology\nevents in a MongoDB instance, replica set, or sharded cluster. The\ndriver creates topology events, also known as Server Discovery and\nMonitoring (SDAM) events, when there are any changes in the state of the\ninstance or cluster that you are connected to.",
            "tags": "code example, server, topology",
            "facets": {
                "genre": [
                    "reference"
                ],
                "target_product": [
                    "drivers"
                ],
                "programming_language": [
                    "go"
                ]
            }
        }
    ]
}