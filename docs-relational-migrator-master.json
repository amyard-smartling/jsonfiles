{
    "url": "http://mongodb.com/docs/relational-migrator",
    "includeInGlobalSearch": true,
    "documents": [
        {
            "slug": "installation",
            "title": "Installation",
            "headings": [],
            "paragraphs": "Relational Migrator supports local deployment and unattended server deployment models.\nFor instructions on installing Relational Migrator, see the following pages: Deployment Model Description Reference Local Suitable for evaluation and proof of concept jobs. Install on a Single Machine Unattended server Suitable for smaller production jobs. Install on an Unattended Server Kafka Suitable for larger production jobs. Integrates with your own Kafka\ninfrastructure to provide enhanced resiliency. The Kafka deployment model is not yet generally available, but you can\nreach out to your MongoDB account team to discuss private preview\nopportunities.",
            "code": [],
            "preview": "Relational Migrator supports local deployment and unattended server deployment models.\nFor instructions on installing Relational Migrator, see the following pages:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "getting-started",
            "title": "Get Started with Relational Migrator",
            "headings": [
                "Steps",
                "Install",
                "Create a project",
                "Create mapping rules with suggested mappings",
                "Customize your mapping rules",
                "Create a sync job"
            ],
            "paragraphs": "Relational Migrator is a tool to help you migrate your relational\ndata to MongoDB. This page guides you through installing the tool\nand running your first sync job. To get familiar with Relational Migrator capabilities,\nfeatures, and use cases, review the following resources: Supported Databases and Versions Migration Scenarios and Use Cases Relational Migrator Learning Byte You can install Relational Migrator with a\n single machine install  suitable\nfor testing or a  unattended server install \nfor production workloads. To start using Relational Migrator,\n create a project . Projects hold the\nsettings, schema conversion logic, and table mappings for a\nmigration. You can connect your\nsource and destination databases with the appropriate\n connection strings . Use  suggested mappings  to\ncreate initial mapping rules based on your\nrelational schema. Mapping rules specify how data from each\nrelational table migrates to MongoDB and how columns map to\nfields in MongoDB documents. Add or update  mapping rules  to create\nthe destination data model that best matches your\napplication needs. Sync jobs  move the data from relational\ntables to MongoDB collections. Sync jobs have two types: To start your migration to MongoDB,\n create a sync job . Snapshot  for point in time migrations. Continuous  for ongoing change data capture zero-downtime migrations.",
            "code": [],
            "preview": "MongoDB Relational Migrator is a tool to help you migrate your relational workloads to MongoDB.",
            "tags": "database migration, database conversion",
            "facets": {
                "genre": [
                    "tutorial"
                ],
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation",
            "title": "Code Generation",
            "headings": [
                "Use Cases",
                "Get Started"
            ],
            "paragraphs": "Relational Migrator can help you convert your SQL and application code\nto MongoDB. Use Relational Migrator's code generation features to\nstreamline the migration process. You can use the following features in the  Code Generation \ntab to convert your relational database SQL and generate new\napplication code: Feature Description Supports Query Converter Converts SQL based relational database code to function with\nMongoDB. The converted code takes into consideration the mapping\nrules and schema transformations defined in your project. SQL queries SQL views Stored procedures Generate App Code Automatically generates new application code based on your\nproject's mapping rules and schema transformations. C# ,  Java ,  JavaScript , and  JSON  application code Convert your application code Convert your SQL code",
            "code": [],
            "preview": "Relational Migrator can help you convert your SQL and application code\nto MongoDB. Use Relational Migrator's code generation features to\nstreamline the migration process.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/view-rules",
            "title": "View Rules",
            "headings": [
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can view mapping rules in the Schema model pane. Select a table name under\nthe  Relational  heading or a collection name under the  MongoDB  heading. Open a project. In the  Schema model  pane, click a table name under the\n Relational  header or a collection name under the  MongoDB  header. You can view mapping rules in the  Mappings  pane on the right of the screen.\nIf you applied a table filter, it is also visible under the  Table filter \nheader. Edit Rules Delete Rules",
            "code": [],
            "preview": "You can view mapping rules in the Schema model pane. Select a table name under\nthe Relational heading or a collection name under the MongoDB heading.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "",
            "title": "What is Relational Migrator",
            "headings": [
                "Bring Your Relational Workloads to MongoDB With Confidence",
                "Visualize Source and Destination Schemas",
                "Customize While Migrating",
                "Get Suggested Schema Recommendations",
                "Apply your Mapping Rules",
                "Replicate From Supported Relational Systems",
                "Transform Data as Its Replicated",
                "Pick a Language and Template",
                "Automatically Generate Application Code",
                "Go Further with MongoDB"
            ],
            "paragraphs": "MongoDB Relational Migrator is a tool to help you migrate relational workloads to MongoDB.\nRelational Migrator allows you to: Design an effective MongoDB schema derived from an existing relational schema. Migrate data from Oracle, SQL Server, MySQL, PostgreSQL, or Sybase ASE\nto MongoDB, while transforming to the target schema. Generate code artifacts to reduce the time required to update application code. Use the entity-relationship style  diagramming interface \nto visualize your schema and make schema mapping decisions. Split or merge tables across collections.\nEmbed a table as a  nested document \nor  array  in an existing collection.\nDefine  custom JavaScript expressions \nto create additional fields. Accelerate your schema mapping by asking Relational\nMigrator to  suggest a MongoDB schema \nfor your workload, or start with a blank slate. Quickly apply recommended table mappings\nto a specific collection in your model. Replicate data from Oracle, MySQL, SQL Server, PostgreSQL,\nor Sybase ASE to MongoDB Atlas or on-premises. Use the saved  mapping definitions \nto transform data to the MongoDB schema as it's replicated.\nReplication can be one time or continuous. Support for popular enterprise languages including C#, Java,\nJavaScript, JSON, and  multiple template frameworks . Use information about the new schema to accelerate\n new code development .\nIncludes code generation of entity classes, persistence layers, and APIs. Explore libraries and tools for MongoDB. Use MongoDB in your application\u2019s language Visually explore your data with MongoDB Compass Manage and monitor your deployments",
            "code": [],
            "preview": "Explore libraries and tools for MongoDB.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/delete-rules",
            "title": "Delete Rules",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Deleting a mapping rule removes the mapping rule from your project.\nDeleting a mapping rule does not remove existing collections from your\nMongoDB cluster. To remove a collection from your cluster: Delete the mapping rule in Relational Migrator. This avoids the collection\nbeing recreated by the next sync job. Manually delete the MongoDB collection. This removes the collection from your\ncluster. Deleting a parent mapping rule also deletes any child mapping rules. For example, if you delete a  New Documents  rule that defines a\ncollection and a  Array in Parent  rule for the same collection, the\n Array in Parent  rule is also deleted. Open a project. In the left  Schema model  pane, click the table or collection\nfor the mapping you want to delete. This prompts the  Mappings  pane to open on the right of the screen. On the  Mappings  pane, click the  Trash Can  icon. Click  Delete  to confirm. Create Rules From Relational Create Rules To MongoDB View mapping rules Edit mapping rules",
            "code": [],
            "preview": "Deleting a mapping rule removes the mapping rule from your project.\nDeleting a mapping rule does not remove existing collections from your\nMongoDB cluster.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "release-notes",
            "title": "Release Notes",
            "headings": [
                "1.5.0 Changelog",
                "1.4.6 Changelog",
                "1.4.4 Changelog",
                "1.4.3 Changelog",
                "1.3.3 Changelog",
                "1.3.2 Changelog",
                "1.3.1 Changelog",
                "1.3.0 Changelog",
                "1.2.0 Changelog",
                "1.1.3 Changelog",
                "1.1.2 Changelog"
            ],
            "paragraphs": "Released March 6, 2024 New features: Improvements: Bug fixes: Query converter is now in public preview. For details,\nsee  Enable Query Converter . Query converter now requires you to sign into a MongoDB Atlas\naccount. When you sign into Atlas, the process for\nselecting Atlas clusters in a sync job is dynamically populated. Query converter now supports conversion of relational database DML\ntriggers to  Atlas Triggers . Query converter now allows you to convert SQL queries and views\nto C#, Java, or JavaScript. Minor improvements to job recoverability and metrics. Released February 12, 2024 Improvements: Bug fixes: Added support for Oracle 11g as a source database. New status indicator on the project page that shows if a\nmigration is running. Improved permissions checks against MongoDB database when starting\na new migration. Improvements to  Query Converter private preview . Fixed an issue where completed migrations could not mark themselves\nas complete in web interface. Released January 29, 2024 Improvements: Improved synthetic foreign keys to be preserved after schema refresh. Fix for fully-offline deployments in airgapped environments. Fix for certain combinations of mappings, specifically two different\nmappings at the same level of embedding. Various minor fixes and improvements to Sybase database support, CDC\nstage metrics, verification stage, database exports, and logging. Released December 11, 2023 New features: Improvements: Sybase ASE database \nsupport is now available for one-time snapshot sync jobs and\nstored procedure conversion. Confluent-hosted Kafka support \nfor participants in the Kafka early access program. This release\nadds prebuilt support for connecting to a Kafka cluster managed by\nthe Confluent hosting provider. Kafka is an open-source platform for distributed,\nhigh-availability workloads. To gain access to Relational Migrator\nwith Kafka support, contact your MongoDB account team to sign up\nfor the Kafka Early Access Program. Integration supported with  Hackolade . Hackolade is a visual data modeling tool. You can explore\nschemas in Hackolade by importing a Relational Migrator\n.relmig file. For details, see  the Hackolade help article . Improved SQL query conversion quality for the Query Converter\n(private preview). For details on how to join the Query Converter\nearly access program, see  Query Converter . Improved application performance through expanded use of available\nmemory in suitable server environments. Released November 7, 2023 Improvements: Performance improvements for sync jobs that create large arrays. Fixed an issue where schema discovery failed on schema names\nthat contain the dash character. Released October 25, 2023 Improvements: New features: Improved performance when Relational Migrator analyzes large\nrelational schemas. Relational Migrator now integrates with the Windows certificate store\nfor SSL connections. New installer and binaries for Mac M1 architectures. Mapping rules now show the original column and type used to generate\nan  _id  field. Improved error messages in query converter (private preview). Released October 10, 2023 New features: Bug fixes: Ability to select  C# ,  Java , and  JavaScript  target languages\nfor stored procedure conversions in the query converter (private preview). Query conversions are now included when you export/import projects. Fixed an issue where update events could return errors in CDC jobs. Fixed an issue where Relational Migrator could hang while trying to\ndetect if a new version was available. Fixed an issue where all tables could be unexpectedly unchecked\nwhen selecting tables for a project. Improvements to execution of sync jobs under the Kafka deployment\nmodel (private preview). Released September 26, 2023 New features: Bug fixes: The Query Converter feature is now in private preview. To\nrequest private preview access, use the sign-up form within the\nRelational Migrator application: In the  Code Generation  tab, click the\n Query Converter  pane. Click the  Register interest  button. Fill out the form details and click the  Submit  button. SQL Server connections now require a database name, which\nresolves some issues caused by inferring the database name. Improvements to the Mac and Windows installers. Released September 4, 2023 New features: Bug fixes: Ability to change the data type for migrated fields. Ability to control how null values are represented in the migrated data. Ability to use calculated fields for a collection's  _id  value. Diagnostic dump includes configuration files to help streamline support. Improves to validation and error handling in mapping rules. Improves ability to parse a wider range of Oracle DDL files. Fixes an issue where tables were lost when refreshing a schema using SQL Server and Windows authentication. Fixes an issue where CDC updates may target the wrong document when tables do not have a primary key. Fixes an issue where database passwords can be incorrectly saved to the browser's password library. Released July 26, 2023 New features: Bug fixes: Support for connecting to a SQL Server named instance. Collection names now show for JSON schema files created from the  Code Generation  screen. Fixes a post-sync job issue where data verification sometimes stops\nor displays as not started. Fixes an issue where JSON columns containing top-level arrays cannot be migrated. Fixes an issue where excluded fields can overwrite calculated fields\nwith the same name. Fixes an issue where calculated fields based on decimal column values\nreturn  NaN . Fixes an issue where some diagram view fields are cut off after you\nchange the project level key handling option. Released Jun 22, 2023 Relational Migrator 1.1.2 is now generally available.\nRelational Migrator assists in migrating your relational workloads to MongoDB.",
            "code": [],
            "preview": "Released March 6, 2024",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/new-rules-from-relational",
            "title": "Create Rules From Relational",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Creating mapping rules is how you translate your relational tables into\nMongoDB collections. You can create mapping rules from either the\n Relational  or  MongoDB  headers of the schema model pane. Options available on the  Add mapping  pane depend on the type of\nmapping rule you are adding. For a full overview of each mapping rule\noption see: You can also create mapping rules based on a destination MongoDB model. For more\ninformation, see  Create Rules to MongoDB . New Documents Embedded Array Embedded documents Open a project. In the left  Schema model  pane, click on a collection under\nthe  Relational  header. This prompts the  Mappings  pane to open on the right of the screen. On the  Mappings  pane, click  + Add  to create a new mapping rule. Define the name of the target MongoDB collection. Define the options for the new mapping rule. When defining the\nmapping rule, you can: Change the collection name. Change field names. Include or exclude a field from your sync job by clicking the\n  icon next to the field name. Optionally, if you want to select a BSON type or set null handling\nrules for your mapping rule: You can view a field's  Original name  and\n Original type  in the expanded customized field menu. Click the   icon next to the field\nyou want to customize. Select a  BSON type . Select a  Null handling  option. Insert as null : preserves null values, and nulls\nare inserted into your destination collection. Omit : skips any null values, and nulls are not\ninserted into the destination collection. For additional details on field customization and data type conversions,\nsee  field customizations . Click  Save and close . To learn more about managing mapping rules, see: Edit mapping rules Delete mapping rules View mapping rules",
            "code": [],
            "preview": "Creating mapping rules is how you translate your relational tables into\nMongoDB collections. You can create mapping rules from either the\nRelational or MongoDB headers of the schema model pane.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/edit-rules",
            "title": "Edit Rules",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can update a mapping rule after it is created. Edited mapping rules take\neffect the next time a sync job is run. Options available on the  edit  pane depend on the type of\nmapping rule you are editing. For an overview of each mapping rule\noption, see: New Documents Embedded Array Embedded Documents From the  Mapping  screen, click a table or collection name\non the  Schema model  pane or  Diagram  view. From the  Mappings  pane,\nclick the   icon. Define the options for the mapping rule. When defining the\nmapping rule, you can: Change the collection name. Change field names. Include or exclude a field from your sync job by clicking the\n  icon next to the field name. Optionally, if you want to select a BSON type or set null handling\nrules for your mapping rule: You can view a field's  Original name  and\n Original type  in the expanded customized field menu. Click the   icon next to the field\nyou want to customize. Select a  BSON type . Select a  Null handling  option. Insert as null : preserves null values, and nulls\nare inserted into your destination collection. Omit : skips any null values, and nulls are not\ninserted into the destination collection. For additional details on field customization and data type conversions,\nsee  field customizations . Click  Save and close  to save your edits. To learn more about managing mapping rules, see: Create Rules From Relational Create Rules To MongoDB Delete mapping rules View mapping rules",
            "code": [],
            "preview": "You can update a mapping rule after it is created. Edited mapping rules take\neffect the next time a sync job is run.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/new-rules-suggested-mappings",
            "title": "Create Rules From Suggested Mappings",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "Relational Migrator can automatically suggest mapping rules based upon\nyour relational schema. Using suggested mappings can help you develop\nyour MongoDB data model faster. In the  Mappings  pane, you have the option to either apply all the suggested\nmapping rules, choose specific suggestions individually, or ignore all of the\nsuggested mapping rules. The  Suggested mappings  button remains visible,\nallowing you to modify your selection at a later point. You need to enable  Suggested mappings  from the  Project Settings .\nIf you created a project with a recommended schema, the suggested mappings\nfeature is disabled by default. In order for Relational Migrator to generate suggested mappings for a specific\ntable, you need to create a  New Documents \nmapping rule that maps the table to a collection. You can then select that\ncollection to see the suggested mapping rules. On the  Mapping  screen, click one of the following: A MongoDB collection on the  Schema model  pane. A collection on the MongoDB side of the project diagram. On the  Mappings  pane on the right-hand side of the screen, click\nthe  Suggested mappings  button. The suggested mapping rules are generated from your relational schema. The suggested mapping rules display with a blue rectangle in the MongoDB diagram.\nThese mapping rules are not added to your project until you click the\n Apply  button. Deselect the suggested mapping rules you do not want applied to your MongoDB schema. Click the green  Apply  button at the bottom of the  Mappings \npane. The suggested mapping rules are added to your project. Create a Sync job You can also manually create your mapping rules: Create Rules From Relational Create Rules To MongoDB",
            "code": [],
            "preview": "Relational Migrator can automatically suggest mapping rules based upon\nyour relational schema. Using suggested mappings can help you develop\nyour MongoDB data model faster.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/mapping-rules",
            "title": "Mapping Rules",
            "headings": [
                "MongoDB Schema Design Patterns",
                "Mapping Direction Preference",
                "Relationships",
                "Default Rules",
                "Data Type Detection",
                "Preview Mapping Rules",
                "Migrate as Options"
            ],
            "paragraphs": "A mapping rule specifies where data from each relational table should be\nmigrated to and how the columns should be mapped to fields in\nMongoDB documents. Mapping rules are created inside a project after you have provided a\nvalid  relational database connection string and credentials . Schema design patterns in MongoDB shape how your data is organized.\nGood schema design practices ensure efficient storage, retrieval, and\nmanipulation of your data. These design decisions can improve the\nperformance and scalability of your MongoDB deployment. Relational\nMigrator allows you to make key schema design decisions such as\ncombining multiple tables into a single collection or embedding data\nin your documents. For an overview of schema design best practices, review the following\ndocumentation: Data Model Examples and Patterns . Building with Patterns . Summary of Schema Design Anti-Patterns and How to Spot Them . The source relational model is static and unchanging while the target MongoDB model\nis dynamic and customizable. You can create a mapping rule based on a source  relational model \nor based on a destination  MongoDB model . Mapping rules help define a  one-to-one ,  one-to-many , or  many-to-many \nrelationship between your tables and collections. You can define mapping rules for the following configurations: A single table that maps to a single MongoDB collection. A single table that maps to multiple MongoDB collections. Multiple tables that map into a single collection. Relational Migrator automatically creates a  New Documents mapping rule \nfor each source table. This initial rule produces a MongoDB schema that\nis identical to the relational database. You can edit the initial rule\nbefore running any data migration jobs. Relational Migrator automatically selects the best MongoDB data type for each\nsource column. For example, SQL Server source data of types  text ,  varchar ,\n nvarchar  or  char   will become the MongoDB  string  data type. You can preview how mapping rules affect your data model by viewing the\nblue dotted box in the MongoDB diagram pane. This allows you to preview\nthe mapping rule before you apply it. If the collection entity doesn't exist, it is added to the\ndiagram with a preview state around the entire card. If the collection entity already exists, the embedded mappings are\nadded to the card with a preview state around the new fields. Mapping rules can be defined with the following  Migrate as  options: Option Behavior Migrate rows as New Documents Translates each relational database row to a new document. Migrate rows as Embedded array Translates each row into an array element within a parent document identified by a foreign key\nrelationship. Migrate rows as Embedded documents Translates each row as a set of fields or an embedded object in a child document identified by a foreign key relationship.",
            "code": [],
            "preview": "A mapping rule specifies where data from each relational table should be\nmigrated to and how the columns should be mapped to fields in\nMongoDB documents. Mapping rules are created inside a project after you have provided a\nvalid relational database connection string and credentials.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/new-rules-to-mongodb",
            "title": "Create Rules to MongoDB",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Creating mapping rules is how you translate your relational tables into\nMongoDB collections. You can create mapping rules from either the\n Relational  or  MongoDB  headers of the schema model pane. Options available on the  Add mapping  pane depend on the type of\nmapping rule you are adding. For a full overview of each mapping rule\noption see: You can also create mapping rules based on a destination MongoDB model. For more\ninformation, see  Create Rule from Relational . New Documents Embedded Array Embedded documents Open a project. In the left  Schema model  pane, click on a collection under the\n MongoDB  header. This prompts the  Mappings  pane to open on the right of the screen. On the  Mappings  pane, click  + Add  to create a new mapping rule. Select the name of the source table from the drop-down. Define the options for the new mapping rule. When defining the\nmapping rule, you can: Change the collection name. Change field names. Include or exclude a field from your sync job by clicking the\n  icon next to the field name. Optionally, if you want to select a BSON type or set null handling\nrules for your mapping rule: You can view a field's  Original name  and\n Original type  in the expanded customized field menu. Click the   icon next to the field\nyou want to customize. Select a  BSON type . Select a  Null handling  option. Insert as null : preserves null values, and nulls\nare inserted into your destination collection. Omit : skips any null values, and nulls are not\ninserted into the destination collection. For additional details on field customization and data type conversions,\nsee  field customizations . Click  Save and close . To learn more about managing mapping rules, see: Edit mapping rules Delete mapping rules View mapping rules",
            "code": [],
            "preview": "Creating mapping rules is how you translate your relational tables into\nMongoDB collections. You can create mapping rules from either the\nRelational or MongoDB headers of the schema model pane.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/schema-mapping",
            "title": "Schema Mapping",
            "headings": [
                "Mapping Rules",
                "Example",
                "Use-Case Denormalizing Table Structure",
                "Mapping Rule Results",
                "Mapping Rule Implementation"
            ],
            "paragraphs": "Schema mapping is the process by which you decide how your source relational schema\nshould be represented in your target MongoDB database. Facilitate the schema\nmapping process in Relational Migrator through customized mappings rules. During the schema mapping design process, Relational Migrator automatically derives\nthe source data model from the schema of your relational database. The destination data\nmodel can be influenced by customizing: Mapping Rule options Project ID field options This section provides a scenario and example implementation for the schema mapping\nprocess. This example converts a relational data model to a MongoDB data\nmodel. Using the  MongoEnterprises  relational database, the goal is to flatten\nall of the database's tables, so that all the order and customer data is\navailable in a single MongoDB collection. The following image shows the relational data model to be denormalized using the\nRelational Migrator. When using Relational Migrator, the goal is to achieve the following MongoDB data model.\nThe  Order  collection contains all the child elements from the  Customer ,\n Order ,  Product  and  Order Line  tables. The collection has nested\nobjects for the migrated tables. The results look like this: To accomplish the target data model results with Relational Migrator, configure\nthe  Order  table with the following mapping rule options: Relational Table Mapping Rule Type Root Path Order New Documents N/A OrderLine Embedded array OrderLines Customer Embedded documents Customer OrderStatus Embedded documents OrderStatus Product Embedded documents OrderLInes.Product",
            "code": [
                {
                    "lang": "json",
                    "value": "{\n  \"_id\": {\n    \"OrderID\": 1\n  },\n  \"CustomerID\": 1,\n  \"OrderStatusID\": 1,\n  \"TotalAmount\": 550,\n  \"Customer\": {\n    \"CustomerID\": 1,\n    \"Name\": \"Joelynn Fawthrop\",\n    \"Address1\": \"86 Dwight Pass\",\n    \"Address2\": \"Carregal\",\n    \"Address3\": \"3800-854\"\n  },\n  \"OrderLines\": [\n    {\n      \"OrderLineID\": 1,\n      \"OrderID\": 1,\n      \"ProductID\": 1,\n      \"Quantity\": 1,\n      \"Product\": {\n        \"ProductID\": 1,\n        \"Name\": \"MongoDB 5.0 Action Figure\",\n        \"Price\": 50\n      }\n    },\n    {\n      \"OrderLineID\": 4,\n      \"OrderID\": 1,\n      \"ProductID\": 3,\n      \"Quantity\": 1,\n      \"Product\": {\n        \"ProductID\": 3,\n        \"Name\": \"Gold Plated MongoDB Compass\",\n        \"Price\": 500\n      }\n    }\n  ],\n  \"OrderStatus\": {\n    \"OrderStatusID\": 1,\n    \"Name\": \"Order Placed\"\n  }\n}"
                }
            ],
            "preview": "Schema mapping is the process by which you decide how your source relational schema\nshould be represented in your target MongoDB database. Facilitate the schema\nmapping process in Relational Migrator through customized mappings rules.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/mapping-rule-options/embedded-array",
            "title": "Embedded Array",
            "headings": [
                "About this Task",
                "Behavior",
                "Example",
                "Embedded array"
            ],
            "paragraphs": "The  Embedded array  mapping rule is an advanced mapping rule option.\nIt must be explicitly added to a mapping model. The  Embedded array  mapping rule is available if the relational\ntable it is mapping from is on the many side of the foreign key relationship. The table containing the primary key must also be mapped to a\ncollection in the MongoDB model. Use the  Embedded array  mapping rule to insert the\nvalues of the child table as array elements under documents in\nthe collection mapped to the parent table. This section demonstrates the relational input and\nthe MongoDB output of the  Embedded array  mapping rule. In this example: Click the tabs below to see the input and output for this example: An  Embedded Array  mapping rule is applied to the  Customer  table. The  Source table  is set to  Order . The  Prefix  is set to  (root) . The  Field Name  is set to  orders . Customer  table: Orders  table: Id Name Address1 Address2 Address3 1 Joelynn Fawthrop 86 Dwight Pass Carregal 3800-854 OrderID CustomerID TotalAmount OrderStatusID 1 1 50.00 1 4 1 500.00 3 The document in the  Customer  collection now has the  Order  details\nembedded as an array of objects field called  Orders . All of the customers orders are now visible in the  Customer  collection\nas an array of nested documents.",
            "code": [
                {
                    "lang": "javascript",
                    "value": "{\n\"_id\": {    \"CustomerID\": 1  },\n\"Name\": \"Joelynn Fawthrop\",\n\"Address1\": \"86 Dwight Pass\",\n\"Address2\": \"Carregal\",\n\"Address3\": \"3800-854\",\n\"Orders\":\n   [\n      {  \"OrderID\": 1,\n         \"CustomerID\": 1,\n         \"TotalAmount\": 50,\n         \"OrderStatusID\": 1\n      },\n      {  \"OrderID\": 4,\n         \"CustomerID\": 1,\n         \"TotalAmount\": 500,\n         \"OrderStatusID\": 1\n      }\n   ]\n}"
                }
            ],
            "preview": "The Embedded array mapping rule is an advanced mapping rule option.\nIt must be explicitly added to a mapping model.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/mapping-rule-options/mapping-rule-options",
            "title": "Mapping Rule Options",
            "headings": [
                "Mapping Rule Concepts",
                "Get Started",
                "Details"
            ],
            "paragraphs": "Mapping rule options are important options that help define the state\nof your MongoDB collection after a migration. These options are defined when creating or editing a\n mapping rule . Every mapping rule joins a source table to a destination collection.\nYou can create mapping rules from either a table or an entity.\nWhen creating a mapping rule you must select the other entity. For example: For  Embedded array  and  Embedded document  mapping rules,\nyou must also configure where you want the embedded data inserted into your document. The table below provides a summary of the concepts associated with\nmapping rule options and the mapping rules they apply to. If you select a table and choose to create a mapping rule you must choose the destination collection. If you select a collection and choose to create a mapping rule, you must select the source table. Concept Description Applies To Collection Name The destination collection where the relational rows of data are migrated. New documents Parent collection The destination collection where the relational rows of data are migrated. Embedded documents   Embedded array Prefix A drop-down where you can specify your rule hierarchy. Embedded documents   Embedded array Field name Indicates the field containing the array or document. Embedded documents   Embedded array Create an array of primitive values Creates a single field array in the parent collection. Embedded array Merge fields into the parent Merges the table rows as fields at the parent collection level. Embedded documents Relational Migratory primary key id field migration is defined at\nthe project level. For details on how these project setting affect your migration,\nsee  Key Handling Options . New Documents Embedded Array Embedded documents To conceptualize the examples of each mapping rule, the following\n Mongo Enterprise  relational schema is used to help explain each\nmapping rule option.",
            "code": [],
            "preview": "Mapping rule options are important options that help define the state\nof your MongoDB collection after a migration.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/mapping-rule-options/new-documents",
            "title": "New Documents",
            "headings": [
                "About this Task",
                "Behavior",
                "Example",
                "New Documents"
            ],
            "paragraphs": "The  New Documents  mapping rule is the most basic mapping rule option.\nIt creates a document for each row of data in your relational database. Any database table can use a  New Documents  mapping rule. Use this mapping rule when you want data from a table to be\nstored in a dedicated collection. You can have multiple  New Documents  mapping rules from\ndifferent tables into the same collection. Relational Migrator treats\nthese tables as isolated data and the destination documents are not\nmerged together in any way. This section demonstrates the relational input and\nthe MongoDB output of the  New Documents  mapping rule. In this example a  New Documents  mapping rule is applied to a single row\nfrom the  Customer  table. Click the tabs below to see the input and output for this example: Customer  table: Id Name Address1 Address2 Address3 1 Joelynn Fawthrop 86 Dwight Pass Carregal 3800-854 The document in the  Customer  collection now has all the relation\ntable fields.",
            "code": [
                {
                    "lang": "javascript",
                    "value": "{\n   \"_id\": {    \"CustomerID\": 1  },\n   \"Name\": \"Joelynn Fawthrop\",\n   \"Address1\": \"86 Dwight Pass\",\n   \"Address2\": \"Carregal\",\n   \"Address3\": \"3800-854\"\n}"
                }
            ],
            "preview": "The New Documents mapping rule is the most basic mapping rule option.\nIt creates a document for each row of data in your relational database.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/field-customizations",
            "title": "Fields",
            "headings": [
                "Use Cases",
                "Behavior",
                "Get Started",
                "Learn More"
            ],
            "paragraphs": "You can customize fields when adding or editing your mapping rules.\nRelational Migrator allows you to define custom fields using\n Calculated Fields , define custom IDs using\n Customize ID Fields , or convert your source\nrelational column data types into  a supported BSON data type . You can use field customization to: Include or exclude fields in your mapping rules. Change field names. Embed child fields in parent documents with dotted paths. For details, see\n embedding fields . Customize  _id  fields using JavaScript expressions. Customize a field using JavaScript expressions. Configure null handling behavior. The fields section contains a list of fields derived from columns\nin the relational table. Mapping rules include each column by default.\nTo exclude a field from your sync job, uncheck the box.\nThe field name initially matches the column name (with the\n global casing  applied). To modify the name,\nedit the text box. You can click the  \nicon next to each field to reveal additional options. Relational Migrator assigns a default data type to your MongoDB fields\nthat most closely matches the source column data type. You can use the  BSON Type  drop-down menu to change the MongoDB\nfield data type to a different data type to fine-tune your schema.\nIf the chosen type is not compatible with the source values, each\nfield converted results in an error during the sync job. Sync jobs\ncontinue until the user-defined maximum error threshold is reached. To embed child fields in a parent document, rename the field in the\nform  parent.child . For example, renaming the field  productName \nto  product.name  results in a child document,  name , embedded\nwithin the parent document,  product . Any\nadditional fields with the same  product.  prefix are also\nembedded as children. Change a source relational datatype to a specific MongoDB BSON datatype. Supported data types for converted fields include: For details, see  conversion examples . Boolean Date Decimal Double Integer Long String Use  Null Handling  to specify the behavior\nof  Null  values. You can omit these values or include\nthem in your destination collections. You can view a field's  Original name  and\n Original type . These values correspond to the relational\ncolumns from which the field originates. For calculated fields, the BSON type is initially shown as\n Default , which means the field type is automatically\nselected at runtime. You can choose an explicit BSON type\nfor a calculated field and your sync job converts the type as\npart of the process. Edit Rules Calculated Fields Customize ID Fields Data Type Conversion Reference",
            "code": [],
            "preview": "You can customize fields when adding or editing your mapping rules.\nRelational Migrator allows you to define custom fields using\nCalculated Fields, define custom IDs using\nCustomize ID Fields, or convert your source\nrelational column data types into a supported BSON data type.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/mapping-rule-options/embedded-documents",
            "title": "Embedded Documents",
            "headings": [
                "About this Task",
                "Behavior",
                "Examples",
                "Embedded Documents",
                "Merge fields into the parent"
            ],
            "paragraphs": "The  Embedded Documents  mapping rule is an advanced mapping\nrule option. It must be explicitly added to a mapping model. The  Embedded Documents  mapping rule is available if the relational\ntable it is mapping from is on the one side of the foreign key relationship. The table containing the foreign key must also be mapped to a\ncollection in the MongoDB model. Use the  Embedded Documents  mapping rule to denormalize\na foreign key relationship. With  Embedded Documents  you can\nnest child foreign key fields in a parent collection. You have two main options when denormalizing your relational data\nwith the  Embedded Documents  option: You can embed the child documents into the parent and designate a\n Prefix  and  Field name  to embed fields as sub documents. You can merge into the parent, which represents the rows as\nfields at the parent level. This section demonstrates the relational input and\nthe MongoDB output of the  Embedded Documents  mapping rule. In this example: Click the tabs below to see the input and output for this example: A  Embedded Documents  mapping rule is applied to the  Order  table. The  OrderLine  table has two rows and the  Order  table has one row. The parent collection is set to  OrderLine . Merge fields into the parent  is not selected. The  Field name  is set to  order . OrderLine  table: Order  table: OrderLineID OrderID ProductID Quantity 1 1 1 1 4 1 3 1 OrderID CustomerID TotalAmount OrderStatusID 1 1 550.00 1 The documents in the  OrderLine  collection now has the  Order  details\nembedded as an embedded document called  Orders . In this example: Click the tabs below to see the input and output for this example: The  OrderLine  table has four rows and the Order table has three rows. A  Embedded Documents  mapping rule is applied to the  Order  table. The parent collection is set to  OrderLine . Merge fields into the parent  is selected. The  Prefix  is set to  (root) . OrderLine  table: Order  table: OrderLineID OrderID ProductID Quantity 1 1 1 1 2 2 2 1 3 3 3 1 4 1 3 1 OrderID CustomerID TotalAmount OrderStatusID 1 1 550.00 1 2 2 100.00 2 3 3 500.00 3 The documents in the  OrderLine  collection have the  Order  details\nmerged into the parent document as fields.",
            "code": [
                {
                    "lang": "javascript",
                    "value": "{\nObjectID: {\n   OrderLineID: 1,\n},\nOrderID: 1,\nProductID: 1,\nQuantity: 1,\nOrders: {\n   OrderID: 1,\n   CustomerID: 1,\n   TotalAmount: 550,\n   OrderStatusID: 1,\n},\n},\n{\nObjectID: {\n   OrderLineID: 4,\n},\nOrderID: 1,\nProductID: 3,\nQuantity: 1,\nOrders: {\n   OrderID: 1,\n   CustomerID: 1,\n   TotalAmount: 550,\n   OrderStatusID: 1,\n},\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{\n_id: {\n   orderLineId: 1,\n},\norderId: 1,\nproductId: 1,\nquantity: 1,\ncustomerId: 1,\norderStatusId: 1,\ntotalAmount: 550,\n},\n{\n_id: {\n   orderLineId: 2,\n},\norderId: 2,\nproductId: 2,\nquantity: 1,\ncustomerId: 2,\norderStatusId: 2,\ntotalAmount: 100,\n},\n{\n_id: {\n   orderLineId: 3,\n},\norderId: 3,\nproductId: 3,\nquantity: 1,\ncustomerId: 3,\norderStatusId: 3,\ntotalAmount: 500,\n},\n{\n_id: {\n   orderLineId: 4,\n},\norderId: 1,\nproductId: 3,\nquantity: 1,\ncustomerId: 1,\norderStatusId: 1,\ntotalAmount: 550,\n}"
                }
            ],
            "preview": "The Embedded Documents mapping rule is an advanced mapping\nrule option. It must be explicitly added to a mapping model.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/calculated-fields/edit-calculated-fields",
            "title": "Edit Calculated Fields",
            "headings": [
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can update the JavaScript expression used in existing calcualted\nfields. Newly edited calculated fields are updated in MongoDB after your\nnext sync job runs. The edited field is updated after your next sync job runs. From the  Mapping  screen, click a table or collection name\non the  Schema Model  pane or diagram view. Click the pencil icon next to the mapping rule that contains the\ncalculated field you want to edit. Click the vertical  ...  icon next to the calculated field\nyou want to edit. Click  Edit calculated field  and update the JavaScript\nexpression. Click  Done . Click  Save and close . Add Calculated Fields Delete Calculated Fields View Calculated Fields",
            "code": [],
            "preview": "You can update the JavaScript expression used in existing calcualted\nfields. Newly edited calculated fields are updated in MongoDB after your\nnext sync job runs.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/calculated-fields/delete-calculated-fields",
            "title": "Delete Calculated Fields",
            "headings": [
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can delete an existing calculated field and remove the field from\nyour mapping rule. Deleted calculated fields do not update in future\nsync job runs. The next time that you run a sync job, the deleted field is not updated\nin the MongoDB collection. From the  Mapping  screen, click a table or collection name\non the  Schema Model  pane or diagram view. Click the pencil icon next to the mapping rule that contains the\ncalculated field you want to delete. Click the vertical  ...  icon next to the calculated field you want\nto delete. Click  Delete calculated field . Click  Delete  to confirm you want to delete the field. Click  Save and close . Add Calculated Fields Edit Calculated Fields View Calculated Fields",
            "code": [],
            "preview": "You can delete an existing calculated field and remove the field from\nyour mapping rule. Deleted calculated fields do not update in future\nsync job runs.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/calculated-fields/view-calculated-fields",
            "title": "View Calculated Fields",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can view an existing calculated field the see the JavaScript\nexpression that generates calculated values. When you view a calculated field in a mapping rule: The field name is shown in  italics . The field does not have an include/exclude checkbox. The field does not state its data type. From the  Mapping  screen, click a table or collection name on the\n Schema model  pane or diagram view. Click the pencil icon next to the mapping rule you want to view. Hover over the  i  icon next to the calculated field you\nwant to view. The JavaScript expression displays in a tooltip window. Add Calculated Fields Delete Calculated Fields Edit Calculated Fields",
            "code": [],
            "preview": "You can view an existing calculated field the see the JavaScript\nexpression that generates calculated values.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/calculated-fields/calculated-fields",
            "title": "Calculated Fields",
            "headings": [
                "Use Cases",
                "Behavior",
                "Get Started"
            ],
            "paragraphs": "Calculated fields are JavaScript expressions that let you create new\nfields based on relational source columns. You can use calculated fields\nto transform your relational database source columns into customized\nMongoDB fields. You can use calculated fields to perform the following actions: Modify string values Split or concatenate fields Perform arithmetic operations such as addition and subtraction You can use JavaScript code in a calculated field. You cannot use third-party JavaScript libraries in calculated fields. Calculated fields have the following characteristics: They are optionally added to the list of fields belonging to a mapping\nrule. They only access data from a table row's column values. They serve as a transformation layer as you migrate your data to\nMongoDB. To create calculated fields, see  Add Calculated Fields . To create mapping rules, see the following pages: Create Rules From Suggested Mappings Create Rules to MongoDB Create Rules From Relational",
            "code": [],
            "preview": "Calculated fields are JavaScript expressions that let you create new\nfields based on relational source columns. You can use calculated fields\nto transform your relational database source columns into customized\nMongoDB fields.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/data-type-conversion-guide",
            "title": "Data Type Conversion Reference",
            "headings": [
                "Behavior",
                "Integer",
                "Boolean",
                "Long",
                "Decimal",
                "String"
            ],
            "paragraphs": "This page outlines examples that show the result of converting the\nsource value and data type to a specific BSON data type using customized\nfields. Sync job errors result in  BsonNull  values for the impacted fields.\nYour field's null handling strategy does not affect this\nbehavior. Your sync job continues with errors unless it reaches the threshold\nthat you defined when you created the sync job. When defining  Calculated Fields  and  Customize ID Fields ,\nRelational Migrator shows an initial data type of  default .\nWhen you run a sync job, Relational Migrator updates this data type. The following example shows results from applying data type\ncustomization for the value  100  with an  Integer  data type. Conversion Type Conversion Value Boolean false Date Thu Jan 01 10:00:00 AEST 1970 Decimal 100.0 Double 100.0 Integer 100 Long 100 String 100 The following example shows results from applying data type\ncustomization for the value  true  with a  Boolean  data type. Conversion Type Conversion Value Boolean true Date Thu Jan 01 10:00:00 AEST 1970 Decimal 1.0 Double 1.0 Integer 1 Long 1 String \"true\" The following example shows results from applying data type\ncustomization for the value  1233140483647  with a  Long  data type. Conversion Type Conversion Value Boolean false Date Wed Jan 28 22:01:23 AEDT 2009 Decimal 1233140483647.0 Double 1233140483647.0 Integer Error (Too big) Long 1233140483647 String \"1233140483647\" The following example shows results from applying data type\ncustomization for the value  26.55  with a  Decimal  data type. Conversion Type Conversion Value Boolean false Date Error Decimal 26.55 Double 26.55 Integer 26 Long 26 String \"26.55\" The following example shows results from applying data type\ncustomization for the value  \"Hello\"  with a  String  data type. The following example shows results from applying data type\ncustomization for the value  \"true\"  with a  String  data type. Conversion Type Conversion Value Boolean false Date Error Decimal Error Double Error Integer Error Long Error String \"Hello\" Conversion Type Conversion Value Boolean true Date Error Decimal Error Double Error Integer Error Long Error String \"true\"",
            "code": [],
            "preview": "This page outlines examples that show the result of converting the\nsource value and data type to a specific BSON data type using customized\nfields.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/calculated-fields/customized-id-fields",
            "title": "Customize ID Fields",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can customize an  _id  field as part of your sync job.\nCustomized  _id  fields allow you to change a field's BSON data type\nand write custom JavaScript expressions instead of using a project's\n Key Handling Option .\nCustomized  _id  fields  must  evaluate to a unique value. You may want to use customized  _id  fields to make your  _id  field\nmore expressive. For example, you can concatenate multiple fields to form\na unique  _id . You can revert the custom ID changes at any time. The  _id  field\nreturns to the project's  Key Handling Option . From the  Mapping  screen, click a table or collection name\non the  Schema model  pane or diagram view. From the  Schema model  pane,\nclick the   icon next to a mapping rule. Click the   icon next to the  _id  field\nand select  Transform to calculated field . (Optional) Select a  BSON type . (Optional) Select a  Null handling  option. Omit : Null values are not inserted into your\ndestination collection. Insert as null : Null values are inserted into the destination\ncollection. Enter a valid JavaScript expression. For examples, see\n valid JavaScript expressions . Click  Done  and then click  Save and close . Add Calculated Fields Edit Calculated Fields View Calculated Fields",
            "code": [],
            "preview": "You can customize an _id field as part of your sync job.\nCustomized _id fields allow you to change a field's BSON data type\nand write custom JavaScript expressions instead of using a project's\nKey Handling Option.\nCustomized _id fields must evaluate to a unique value.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/synthetic-foreign-key/synthetic-foreign-keys",
            "title": "Synthetic Foreign Keys",
            "headings": [
                "Use Cases",
                "Behavior",
                "Get Started",
                "Learn More"
            ],
            "paragraphs": "Relational Migrator allows you to create synthetic foreign keys. Foreign keys\ndefine and display a relationship between two tables through shared values.\nA synthetic foreign key also represents a relationship between two tables, but\nunlike a regular foreign key, it does not exist in the source database and can\nbe defined directly using Relational Migrator. Synthetic foreign keys represent\nrelationships between tables that allow you to then create mapping rules based\non those relationships. Use synthetic foreign keys when foreign keys aren't defined in your source\ndatabase but a logical relationship exists between two tables.\nCreate synthetic foreign keys before you create mapping rules to define\nrelationships between your tables before defining relationships between your\ntables and collections. You can add synthetic foreign keys using the diagramming toolbar in the\n Relational  model. You cannot use the  MongoDB  model to\nadd synthetic foreign keys. You can only build synthetic foreign keys on a single field from each table. You can only have one synthetic foreign key defined on a single foreign key\nfield. You can create a synthetic foreign key between any columns and tables, but if\nthe table rows do not share common values in the selected columns, embedded\ndocuments and arrays are not populated during the sync job. Add a Synthetic Foreign Key Mapping Rules Understand Diagrams",
            "code": [],
            "preview": "Relational Migrator allows you to create synthetic foreign keys. Foreign keys\ndefine and display a relationship between two tables through shared values.\nA synthetic foreign key also represents a relationship between two tables, but\nunlike a regular foreign key, it does not exist in the source database and can\nbe defined directly using Relational Migrator. Synthetic foreign keys represent\nrelationships between tables that allow you to then create mapping rules based\non those relationships.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/fields/calculated-fields/add-calculated-fields",
            "title": "Add Calculated Fields",
            "headings": [
                "Before you Begin",
                "About this Task",
                "Steps",
                "Examples",
                "Concatenate Strings",
                "Split Strings",
                "Replace Strings",
                "Check for String Values",
                "Perform Mathematic Operations",
                "Assign Values Based on Logical Conditions",
                "Extract JSON Values",
                "Access Array Elements",
                "Parse Dates",
                "Learn More"
            ],
            "paragraphs": "Calculated fields let you create new fields in your documents by\ncombining values from existing database columns using JavaScript\nexpressions. Calculated fields are evaluated each time a row is\nprocessed during a sync job. To create a calculated field, you must define a mapping rule. To create mapping rules, see the following pages: Create Rules From Suggested Mappings Create Rules to MongoDB Create Rules From Relational Calculated field expressions access values from the current source\ndatabase row using the syntax  columns[\"<COLUMN_NAME>\"] . When defining  Calculated Fields  and  Customize ID Fields ,\nRelational Migrator shows an initial data type of  default .\nWhen you run a sync job, Relational Migrator updates this data type. The new field is visible in MongoDB after your next sync job runs. From the  Mapping  screen, click a table or collection name\non the  Schema model  pane or diagram view. Add a new mapping rule or edit an existing mapping rule. Click the  +  icon to the right of the  All\nfields  label. Define a name for the new field in the  Field Name  text\nbox. Define a valid JavaScript expression for the new field in the  Value\nexpression  text box. Click  Done . Click  Save and close . The following examples show JavaScript expressions that you can use in\ncalculated fields: Combine two columns into a single field. The following example concatenates string values from the  firstName \nand  lastName  columns. Expression: Input: Output: Column Value firstName John lastName Smith Split column values into an array based on a specified character. The following example splits the  fullName  column into an array using\na space character as a delimiter, and returns the first element of the\narray. Expression: Input: Output: Column Value fullName John Doe Apply regex patterns to replace string values in a column. The following example performs a case-insensitive regex search on the\n fullName  column for the string  smith . If a match is found, the\nexpression replaces the matching string with  Doe . Expression: Input: Output: Column Value fullName John Smith Return true or false based on whether a column contains a string value. The following example returns  true  if the value in the  fullName \ncolumn includes the string  Smith . If the  fullName  column does\nnot include the string  Smith , the expression returns  false . Expression: Input: Output: Column Value fullName John Smith Perform mathematic operations on column values. The following example multiplies values from the columns  col1  and\n col2 . Expression: Input: Output: Column Value coll1 3 coll2 2 Assign column values based on logical conditions. The following example returns  yes  if the value of  col1  is\n 3 , and  no  if  col1  is a value other than  3 . Expression: Input: Output: Column Value coll1 3 Access data stored as JSON data type with calculated field expressions.\nRequires JSON data type columns (Postgres). The following example returns the value of the embedded  state  field\nfrom values in the  Employee  column. Expression: Input: Output: Access data stored as array data type with calculated fields\nexpressions. Requires array data type columns (Postgres or MySQL). The following example returns the second element of the values in the\n myArray  column. Expression: Input: Output: Column Value myArray [ \"a\", \"b\", \"c\" ] Parse an ISO8601-formatted date string into a date. The following example converts string values from the  dateAsString \ncolumn into dates. Expression: Input: Output: Column Value dateAsString \"2009-02-11\" Delete Calculated Fields Edit Calculated Fields View Calculated Fields",
            "code": [
                {
                    "lang": "none",
                    "value": "columns[\"firstName\"] + ' ' + columns[\"lastName\"]"
                },
                {
                    "lang": "none",
                    "value": "\"John Smith\""
                },
                {
                    "lang": "none",
                    "value": "columns[\"fullName\"].split(' ')[0]"
                },
                {
                    "lang": "none",
                    "value": "\"John\""
                },
                {
                    "lang": "none",
                    "value": "columns[\"fullName\"].replace(/smith/i, \"Doe\")"
                },
                {
                    "lang": "none",
                    "value": "\"John Doe\""
                },
                {
                    "lang": "none",
                    "value": "columns[\"fullName\"].includes(\"Smith\")"
                },
                {
                    "lang": "none",
                    "value": "true"
                },
                {
                    "lang": "none",
                    "value": "columns[\"col1\"] * columns[\"col2\"]"
                },
                {
                    "lang": "none",
                    "value": "6"
                },
                {
                    "lang": "none",
                    "value": "columns[\"col1\"] === 3 ? \"yes\" : \"no\""
                },
                {
                    "lang": "none",
                    "value": "yes"
                },
                {
                    "lang": "none",
                    "value": "columns[\"Employee\"].Address.state"
                },
                {
                    "lang": "json",
                    "value": "{\n   Employee: {\n      name: \"Mark\",\n      Address: {\n         state: \"California\"\n      }\n   }\n}"
                },
                {
                    "lang": "none",
                    "value": "\"California\""
                },
                {
                    "lang": "none",
                    "value": "columns[\"myArray\"][1]"
                },
                {
                    "lang": "none",
                    "value": "\"b\""
                },
                {
                    "lang": "none",
                    "value": "new Date(columns[\"dateAsString\"])"
                },
                {
                    "lang": "none",
                    "value": "2009-02-11T0:00:00Z"
                }
            ],
            "preview": "Calculated fields let you create new fields in your documents by\ncombining values from existing database columns using JavaScript\nexpressions. Calculated fields are evaluated each time a row is\nprocessed during a sync job.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "mapping-rules/synthetic-foreign-key/add-foreign-key",
            "title": "Add a Synthetic Foreign Key",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "Use synthetic foreign keys to establish relationships between your tables before\ncreating mapping rules. A synthetic foreign key represents a relationship between\ntwo tables, but unlike a regular foreign key, it does not exist in the source\ndatabase and can be defined directly using Relational Migrator. On the diagram toolbar, click  Add a synthetic foreign key . Select the parent table. You can select a parent table in two ways: Click on a single table or, Click and drag between your choice of parent and child table. If you select\nyour parent and child table in this manner, step 5 is completed. On the  Add relationship pane , select the cardinality. When you select  One to one , each row in the parent table must\nrelate to at most one row in the child table. When you select  One to many , each row in the parent table can\nrelate to zero or more rows in the child table. Click the  Parent field  drop-down and select a parent field. Click the  Child table  drop-down and select a child table. To represent the potential relationship, a blue line appears between the\nparent table and child table on the relational model. Click the  Child field  drop-down and select a child field. Select a child field whose values correspond to those in the parent field. Click  Save and close . To edit or delete a synthetic foreign key, click on the line in the relational\nmodel between two tables. On the  Relationships  pane, you can click\nthe  Edit relationship  or  Delete relationship  button. Create Rules From Relational Create Rules To MongoDB Create Rules From Suggested Mappings Mapping Rules",
            "code": [],
            "preview": "Use synthetic foreign keys to establish relationships between your tables before\ncreating mapping rules. A synthetic foreign key represents a relationship between\ntwo tables, but unlike a regular foreign key, it does not exist in the source\ndatabase and can be defined directly using Relational Migrator.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/creating-jobs",
            "title": "Create a Sync Job",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "Sync jobs are the worker processes responsible for transferring your\ndata and schemas from a relational database to MongoDB. Create a new\nsync job from the  Data Migration  tab. The URI credentials you provide when creating a sync job do not\nneed to be the same as the credentials used when creating your project. Create one or more mapping rules  in your\nRelational Migrator project. Prepare a  MongoDB URI  and\ncredentials that have read/write permissions on your destination database. On the  Data Migration  tab, click  Create Sync Job .\nRelational Migrator only runs one sync job at a time. If a sync job is in progress, this button is disabled. On the  Connect Source DB  form, enter the connection details\nto create the JDBC URI for your relational database. 2a. Select a database type from the  Database type  drop-down. 2b. Enter a host IP or DNS name in the  Host  text box. 2c. Enter a port number in the  Port  text box. 2d. Enter a database name in the  Database  text field. Depending on your relational database, this behavior varies: 2e. Enter a username in the  Username  text box. 2f. Enter a password in the  Password  text box. 2g. (Optional) Click the  Save a password for this session  checkbox. 2h. Click the  SSL  toggle switch to enable or disable SSL and select an SSL mode. 2i. Click  Connect . If you want to specify the JDBC URI manually, click the\n Enter URI manually  toggle switch on the  Connect SourceDB \nform. For details, see  Relational Database Connection Strings \n. Database Type Behavior Oracle You must enter a database name and a  Service ID  or  SID . SQL Server Enter a database name, or leave blank to load all databases. MySQL Enter a database name, or leave blank to load all databases. Postgres Leaving database name blank loads schemas from the default database. Connection and SSL details depend on the database type you are connecting to.\nIn addition to the generic connection properties listed above, you may also need\nto select a  Identifier  for Oracle and  Authentication \nfor SQL Server. Click  Connect . On the  Connect Destination DB  form, input your\n MongoDB connection string (URI) . If you leave any of the form fields for  Database ,  Username ,\nor  Password  blank, the values specified in the URI are used. Click  Connect . On the  Migration Options  form, select your\n Migration Options : Once you have established the database connection and specified the\njob type on the  Migration Options  form, Relational Migrator\nconducts various checks to ensure that the database is configured\ncorrectly. If any configuration is missing, a banner appears indicating\nthat the database is not properly configured, with a\n GENERATE SCRIPT  button to download a SQL script. This script includes the required configuration statements\nand additional instructions in the form of comments. Migration Option Description Mode Defines the type of sync job. Drop destination collections before migration Boolean. Indicates whether Relational Migrator drops a\ndestination collection before transferring data. Stop after errors Integer. Indicates the number of errors after which Relational\nMigrator stops the sync job. Verify migrated data Boolean. If true, the sync engine checks the migrated data\nagainst the source database. Only supported for snapshot mode. Before proceeding with starting a sync job: Download the script. Carefully review its contents. Execute the statements. Follow any commented manual steps. Click  Start . Monitor a Sync Job Data Verification For detailed information regarding the configuration requirements for each database,\nsee the follow Debezium reference links, which are internally utilized by Relational Migrator: MySQL Oracle PostgreSQL SQL Server",
            "code": [],
            "preview": "Sync jobs are the worker processes responsible for transferring your\ndata and schemas from a relational database to MongoDB. Create a new\nsync job from the Data Migration tab.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/sync-jobs",
            "title": "Sync Jobs",
            "headings": [
                "Types of Sync Jobs",
                "Get Started"
            ],
            "paragraphs": "Sync jobs transfer data from your relational database to MongoDB. Sync\njobs use project-level  Mapping Rules  to distribute data to\nyour MongoDB database. Relational Migrator offers two different sync job types: Snapshot : Snapshot sync jobs run once, typically for a point in time\nmigration strategy. Continuous : Continuous sync jobs cover new incoming data for a zero-downtime\nChange Data Capture (CDC) migration strategy. Continuous jobs run a snapshot stage first,\nfollowed by a CDC stage that captures database updates in near-real time.\nWhen you run a continuous sync job, your source and destination database\ndata remain in sync. The Kafka deployment model of Relational Migrator allows you to run\nlonger-running snapshot or continuous sync jobs with improved resiliency.\nThis model is currently available in private preview. If you are interested\nin learning about or testing this model, please contact your MongoDB account team. You can perform the following tasks from the  Data Migration  tab. Task Description Create a Sync Job Create a sync job which uses the defined mapping rules and migration options. Monitor a Sync Job View metadata, execution status, and issues for a sync job. Stop a Sync Job Cancels the execution of a sync job.",
            "code": [],
            "preview": "Sync jobs transfer data from your relational database to MongoDB. Sync\njobs use project-level Mapping Rules to distribute data to\nyour MongoDB database.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/stopping-jobs",
            "title": "Stop a Sync Job",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can stop a sync job from the  Job Overview  pane on the\n Data Migration  tab. The effects of stopping a sync job on your destination database depend on\nthe type and stage of the sync job: Once initiated, the process of canceling or completing a sync job may\ntake up to one minute. If you stop a snapshot sync job during the snapshot stage, any\npartially migrated data remains in the MongoDB database. If you stop a continuous sync job during the CDC stage, the process\nends gracefully, and Relational Migrator cleans up any temporary data. After a sync job is stopped, you cannot resume it. To migrate data from\na stopped sync job, you can create a new job and select the option\n Drop destination collections before migration . To stop your sync job, follow the instructions below based on the current stage of execution: Open the  Data Migration  tab. Click on the sync job in the  History  pane. Click the red  Terminate  button in the upper-right corner of the screen. Click the red  Terminate  button on the pop-up modal.\nOnce a sync job cancels, an  x  icon displays\nin the  History  pane, and the status of the sync\njob updates to  Snapshot cancelled . Open the  Data Migration  tab. Click on the sync job in the  History  pane. Click the  Complete CDC   button in the upper-right corner of the screen. Click the green  Complete CDC  button on the pop-up modal.\nOnce the sync job completes, a checkmark icon displays in the  History  pane, all stages display a status of  COMPLETED , and the status of the sync job updates to  CDC completed . Create a Sync Job Monitor a Sync Job",
            "code": [],
            "preview": "You can stop a sync job from the Job Overview pane on the\nData Migration tab.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/monitoring-jobs",
            "title": "Monitor a Sync Job",
            "headings": [
                "About this Task",
                "Job Overview",
                "Snapshot Stage",
                "CDC Stage",
                "Issues",
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can monitor a sync job from the  History  pane on the\n Data Migration  tab. The  History  pane contains\ninformation about in progress, completed, and failed sync jobs. Sync jobs execute in a number of distinct stages, which are visible on\nthe  Job overview  pane. For example: A snapshot sync job includes a snapshot stage and, optionally, a verification stage. A continuous sync job includes a snapshot stage, followed by a CDC stage. High-level sync job information displays in the top section of the  Job overview  pane. Metric Description Source URI The JDBC connection string used to connect to the source relational database. Destination URI The MongoDB connection string used to connect to the destination MongoDB database. Job Mode Indicates if the sync job is snapshot or continuous. Status Indicates the current or end status of the sync job. Snapshot stage information displays in the  Snapshot stage  section of the  Job overview  pane. Metric Description Snapshot stage status Indicates the status of the snapshot stage. Started Date and time that the snapshot stage started. Duration Time taken for the snapshot stage to complete. Tables migrated Total number of tables migrated from the source database. Rows migrated Total number of rows migrated from all tables. The CDC stage information is displayed in the  CDC stage  section\nof the  Job overview  pane. The CDC stage begins after the initial\nsnapshot stage has completed and remains in the  RUNNING  status\nuntil it is explicitly completed, or the sync job encounters an unrecoverable error. Metric Description CDC stage status Indicates the status of the CDC stage. When a CDC stage is actively replicating\ndata changes, this status is  RUNNING . Started Date and time that Relational Migrator started listening for data change events. Last event time Latest date and time that Relational Migrator detected a data change event. Total events seen Number of data change events Relational Migrator has detected since the CDC stage started. Events in the last hour Number of data change events Relational Migrator has detected in the last hour. If your sync job has errors during execution, you can find the details\nin the  Issues  pane on the  Data Migration  screen. Metric Description Date & Time The date and time that the issue occurred. Table / Collection The table or collection that caused the error. This is blank if the error is global. Count Total number of errors encountered. Error detail Detailed error message from the target deployment. Click on a previous sync job in the  History  pane to load the  Overview  and  Issue  information. Snapshot stage  and  CDC stage  logging information display next to each respective section of the  Job overview  pane. Click the  >  icon under the  Issues  section to view sync job errors. Review the debugging information in the  Error detail  column. Code Generation Add Calculated Fields Stop a Sync Job Data Verification",
            "code": [],
            "preview": "You can monitor a sync job from the History pane on the\nData Migration tab. The History pane contains\ninformation about in progress, completed, and failed sync jobs.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/data-verification/data-verification",
            "title": "Data Verification",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "Data verification is a process that is built into the sync engine.\nThe data verification process uses the source and destination\nconnection strings to validate that a sync job was successful. When data verification is successful, source and destination states match. When data verification is unsuccessful, source and destination states\ndo not match. Data verification does not consider the following when verifying\ndestination databases: Data verification is supported for one-time sync jobs. By default, data verification is not performed when running a sync job.\nYou must explicitly opt-in to verification in  Migration Options \nbefore the job is started. Enabling data verification can add significant compute time to a sync\njob. The source relational database row count equals the target collection\ndocument count. The source relational rows are equivalent to the collection documents. The destination collection contained unrelated data before the sync\njob started. The data in the relational database tables has changed since the sync\njob was started. Use Data Verification",
            "code": [],
            "preview": "Data verification is a process that is built into the sync engine.\nThe data verification process uses the source and destination\nconnection strings to validate that a sync job was successful.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/prerequisites",
            "title": "Prerequisites",
            "headings": [],
            "paragraphs": "The following pages outline the details and specifics of prepping your\ndatabase for use with Relational Migrator. The instructions for these\npages reiterate the steps and procedures of the SQL scripts that are\nautomatically generated by Relational Migrator when you create your\nfirst sync job: Database Snapshot Sync Job Support Continuous Sync Job Support MySQL Oracle PostGreSQL SQL Server Sybase",
            "code": [],
            "preview": "The following pages outline the details and specifics of prepping your\ndatabase for use with Relational Migrator. The instructions for these\npages reiterate the steps and procedures of the SQL scripts that are\nautomatically generated by Relational Migrator when you create your\nfirst sync job:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/data-verification/use-data-verification",
            "title": "Use Data Verification",
            "headings": [
                "Enable Data Verification",
                "Data Verification Overview",
                "Data Verification Statuses",
                "Successful Data Verification",
                "Data Verification Issues"
            ],
            "paragraphs": "Data verification runs as a separate process that is tightly\ncoupled to a sync job. Data verification can be enabled for one-time\nsync jobs. This page details how to enable and debug the\ndata verification process. You can enable data verification when  creating a sync job \non the  Data Migration  tab. On the  Migration Options  module, click the\n Verify migrated data  check box for your sync job. To view status and metadata information about the data verification process\nfor a sync job, click the  SYNC JOB / DATA VERIFICATION  slider. The Data Verification process can take as long or longer than the data sync job.\nYou can click  Terminate  to cancel a Data Verification process. On the  Data Verification  pane, you can view the metadata\nabout a sync jobs verification process. Syntax Description Verification Status The state of the verification process. Started The date time stamp that data verification process started. Duration The total elapsed time of the data verification process. Collections verified The total number of collections verified by the data verification process. Documents verified The total number of documents verified by the data verification process. Verification progress A real time percentage indicator of total work completed by the data verification process. A data verification process can be any of the following statuses: Status Description ABORTED A running data validation was unable to complete due to an error. CANCELLED The data validation process was cancelled by clicking  TERMINATE . CANCELLING The data validation process is being canceled. FAILED The source and destination databases do not match. The corresponding errors are listed on the  Issues  pane. VERIFIED Data validation is successful, the source and destination databases match. VERIFYING The data validation is in progress. Backend SQL and MongoDB query API commands are running to validate the migration. When a sync job is successful the status updates to  VERIFIED \nand a double checkmark is displayed in the  History  pane. If the data verification process detects any differences between the\nsource database and destination collections, the errors are\nreported in the Data Verification  Issues  pane. In this example, the data verification process is detecting that the\nnumber of documents in the target collection do not match the source\ndatabase. The Verification status is  FAILED . The specific issue and error detail is displayed in the  Issues  pane.",
            "code": [],
            "preview": "Data verification runs as a separate process that is tightly\ncoupled to a sync job. Data verification can be enabled for one-time\nsync jobs. This page details how to enable and debug the\ndata verification process.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/prerequisites/oracle",
            "title": "Configure Migration Prerequisites for Oracle",
            "headings": [
                "About this Task",
                "Steps",
                "Set up user permissions",
                "Set up user permissions",
                "Turn on LogMiner at the database level",
                "Enable supplemental logging",
                "Learn More"
            ],
            "paragraphs": "To run sync jobs from an Oracle source database, the database may require\nsome configuration changes. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. The\nOracle configurations depend on the type of sync job: For details on supported versions of Oracle, see\n Supported Databases and Versions . Snapshot sync jobs migrate all the data and then stops. Continuous sync job run a snapshot and then enter a CDC stage to\ncontinuously replicate data changes. If you're migrating from an Oracle 12c instance, you must run commands as\nthe SYSDBA role. In Oracle 12c the concept of a pluggable database was introduced. Some\nof these commands can be run on PDB(plugable database) while commands\nsuch as enabling  ARCHIVELOG  must be run on the\nCDB(container/master database). For details on each architecture,\nsee  Overview of Container Databases and Pluggable Databases . Supplemental logging is not allowed in Oracle Express editions. The following code creates a new Oracle service account\nfor Relational Migrator to connect to the Oracle\ninstance. Alternatively, you can use an existing Oracle\nservice account to connect to Relational Migrator with\nthe appropriate permissions. Create a service account: Grant select permissions to the service account: The required permission for the service account depend on whether\nthe tables are owned by the service account used to run the sync job.\nTo check table ownership run the following query: If the service account  is  the table owner: If the service account  is not  the table owner: The following code creates a new Oracle service account\nfor Relational Migrator to connect to the Oracle\ninstance. Alternatively, you can use an existing Oracle\nservice account to connect to Relational Migrator with\nthe appropriate permissions. Create a service account: Grant select permissions to the service account: The required permission for the service account depend on whether\nthe tables are owned by the service account used to run the sync job.\nTo check table ownership run the following query: If the service account  is  the table owner: If the service account  is not  the table owner: Grant additional permissions to the service account\nto run continuous sync jobs: To run continous jobs against Oracle, you must enable\n LogMiner  at the database level. The following code-block\nis an example of automatically-generated code, which you\ncan run manually by substituting your database name: To check if  LogMiner  is already enabled, run the\nfollowing query: To run continuous sync jobs against Oracle, you must\nenable supplemental logging at the database level: You must also enable supplemental logging for every\ntable in the migration: Relational Migrator relies on the open-source Debezium connector to\ncapture row-level changes. For more details, see  Debezium Oracle For details on enabling archive logging, see  Managing Archived Redo Logs . For additional troubleshooting and debugging information, see the\n Debezium Oracle help blog post .",
            "code": [
                {
                    "lang": "sql",
                    "value": "CREATE USER '<user>'@'localhost' IDENTIFIED BY '<password>';"
                },
                {
                    "lang": "sql",
                    "value": "SELECT TABLE_NAME, OWNER\nFROM ALL_TABLES\nWHERE TABLE_NAME ='<table_name>'\nORDER BY OWNER, TABLE_NAME;"
                },
                {
                    "lang": "sql",
                    "value": "GRANT CREATE SESSION TO <user>;\nGRANT SELECT ON V_$DATABASE TO <user>;"
                },
                {
                    "lang": "sql",
                    "value": "GRANT CREATE SESSION TO <user>;\nGRANT SELECT_CATALOG_ROLE TO <user>;\nGRANT SELECT <table> TO <user>;\nGRANT SELECT ON V_$DATABASE TO <user>;\nGRANT FLASHBACK ON <table> TO user;"
                },
                {
                    "lang": "sql",
                    "value": "CREATE USER '<user>'@'localhost' IDENTIFIED BY '<password>';"
                },
                {
                    "lang": "sql",
                    "value": "SELECT TABLE_NAME, OWNER\nFROM ALL_TABLES\nWHERE TABLE_NAME ='<table_name>'\nORDER BY OWNER, TABLE_NAME;"
                },
                {
                    "lang": "sql",
                    "value": "GRANT CREATE SESSION TO <user>;\nGRANT SELECT ON V_$DATABASE TO <user>;"
                },
                {
                    "lang": "sql",
                    "value": "GRANT CREATE SESSION TO <user>;\nGRANT SELECT_CATALOG_ROLE TO <user>;\nGRANT SELECT <table> TO <user>;\nGRANT SELECT ON V_$DATABASE TO <user>;\nGRANT FLASHBACK ON <table> TO user;"
                },
                {
                    "lang": "sql",
                    "value": "GRANT SET CONTAINER TO <user>;\nGRANT EXECUTE_CATALOG_ROLE TO <user>;\nGRANT SELECT ANY TRANSACTION TO <user>;\nGRANT LOGMINING TO <user>;\nGRANT CREATE TABLE TO <user>;\nGRANT LOCK <table> TO <user>;\nGRANT CREATE SEQUENCE TO <user>;\nGRANT SELECT ON DBA_TABLESPACES TO <user>;\nGRANT EXECUTE ON DBMS_LOGMNR TO <user>;\nGRANT EXECUTE ON DBMS_LOGMNR_D TO <user>;\nGRANT SELECT ON V_$LOG TO <user>;\nGRANT SELECT ON V_$LOG_HISTORY TO <user>;\nGRANT SELECT ON V_$LOGMNR_LOGS TO <user>;\nGRANT SELECT ON V_$LOGMNR_CONTENTS TO <user>;\nGRANT SELECT ON V_$LOGMNR_PARAMETERS TO <user>;\nGRANT SELECT ON V_$LOGFILE TO <user>;\nGRANT SELECT ON V_$ARCHIVED_LOG TO <user>;\nGRANT SELECT ON V_$ARCHIVE_DEST_STATUS TO <user>;\nGRANT SELECT ON V_$TRANSACTION TO <user>;"
                },
                {
                    "lang": "sql",
                    "value": "ALTER SYSTEM SET db_recovery_file_dest_size = 10G;\nALTER SYSTEM SET db_recovery_file_dest = '/opt/oracle/oradata/recovery_area' SCOPE=spfile;\nSHUTDOWN IMMEDIATE;\nSTARTUP MOUNT\nALTER DATABASE ARCHIVELOG;\nALTER DATABASE OPEN;"
                },
                {
                    "lang": "sql",
                    "value": " SELECT LOG_MODE FROM V_$DATABASE;"
                },
                {
                    "lang": "sql",
                    "value": "ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;"
                },
                {
                    "lang": "sql",
                    "value": "ALTER TABLE schemaName.tableName ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;\n/* Additional ALTER TABLE STATEMENTS... */"
                }
            ],
            "preview": "To run sync jobs from an Oracle source database, the database may require\nsome configuration changes. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. The\nOracle configurations depend on the type of sync job:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/prerequisites/sybase",
            "title": "Configure Migration Prerequisites for Sybase",
            "headings": [],
            "paragraphs": "There are no prerequisite requirements to use Relational Migrator with\nSybase ASE. Sybase only supports snapshot sync jobs.",
            "code": [],
            "preview": "There are no prerequisite requirements to use Relational Migrator with\nSybase ASE. Sybase only supports snapshot sync jobs.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/prerequisites/sql-server",
            "title": "Configure Migration Prerequisites for SQL Server",
            "headings": [
                "About this Task",
                "Steps",
                "Configure CDC at the Database Level",
                "Configure CDC at the database level",
                "Enable the SQL Server agent and check database permissions",
                "Configure CDC at the table level",
                "Learn More"
            ],
            "paragraphs": "To run sync jobs from a SQL Server source database,\nthe database may require some configuration changes. Before you start a\nsync job, Relational Migrator checks if the\ndatabase is configured correctly. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. This topic\nprovides more details on the required configuration steps. SQL Server\nconfiguration depends on the type of sync job: Snapshot sync jobs migrate all the data and then stops. Continuous sync job run a snapshot and then enter a CDC stage to\ncontinuously replicate data changes. This page covers the details of the SQL scripts automatically\ngenerated by Relational Migrator. Relational Migrator automatically detects configuration settings when\nconnecting to your database and generates the appropriate SQL\nstatements to enable CDC if required. Relational Migrator does not create any indexes on SQL Server to\nfacilitate sync jobs. The create index creation permission is not\nrequired. The easiest way to set up your database is to run the automatically\ngenerated script that Relational Migrator prompts you to download when\nyou  create a sync job . To  understand the\npermissions or run the SQL manually, read the procedures below. Configure your SQL Server instance based on the sync job type.\nRefer to the tab below for details on snapshot and continuous sync\njob configurations. For snapshot jobs against SQL Server, you must enable\nCDC at the database level. Enabling CDC at the database-level CDC generates a small\nnumber of system tables in the database, leaving user tables\nunchanged, and does not add any performance overhead. Enabling\nCDC alone does not result in changes being captured. To enable CDC at the database level\nuse the  sys.sp_cdc_enable_db  stored procedure. The code blocks below are a sample of the code\nautomatically-generated by Relational Migrator.\nYou can run the code manually by replacing the\ndatabase name for  MyDB : For SQL Server instances hosted on AWS RDS: For continuous jobs against SQL Server, you must enable\nCDC at both the database level and at the table level for\neach table. To enable CDC at the database level\nuse the  sys.sp_cdc_enable_db  stored procedure. The code blocks below are a sample of the code\nautomatically-generated by Relational Migrator.\nYou can run the code manually by replacing the\ndatabase name for  MyDB : For SQL Server instances hosted on AWS RDS: To enable the CDC option at the table level: You must have the server level  sysadmin  role. You must have the database level  db_owner  role. The  SQL Server agent \nmust be running. The service account used to connect to SQL Server\nmust have Select permission against all required tables. To enable CDC at the table level\nuse the  sys.sp_cdc_enable_table  stored procedure. You can check the SQL Server CDC settings by examining the  is_tracked_by_cdc \ncolumn in the  sys.tables catalog view .\nA value of  1  for  is_tracked_by_cdc  indicates the table\nis enabled for change data capture. The code block below is a sample of the\nautomatically generated code.You can run the code manually\nto enable table CDC: Relational Migrator relies on the open-source Debezium connector to\ncapture row-level changes. For more details, see\n Debezium SQL Server .",
            "code": [
                {
                    "lang": "sql",
                    "value": "USE MyDB\nGO\nEXEC sys.sp_cdc_enable_db\nGO"
                },
                {
                    "lang": "sql",
                    "value": "USE MyDB\nGO\nEXEC msdb.dbo.rds_cdc_enable_db 'MyDB';\nGO"
                },
                {
                    "lang": "sql",
                    "value": "USE MyDB\nGO\nEXEC sys.sp_cdc_enable_db\nGO"
                },
                {
                    "lang": "sql",
                    "value": "USE MyDB\nGO\nEXEC msdb.dbo.rds_cdc_enable_db 'MyDB';\nGO"
                },
                {
                    "lang": "sql",
                    "value": "USE MyDB\nGO\nEXEC sys.sp_cdc_enable_table\n@source_schema = N'dbo',\n@source_name   = N'MyTable',\n@role_name     = N'MyRole',\n@filegroup_name = N'MyDB_CT',\n@supports_net_changes = 1\nGO"
                }
            ],
            "preview": "To run sync jobs from a SQL Server source database,\nthe database may require some configuration changes. Before you start a\nsync job, Relational Migrator checks if the\ndatabase is configured correctly. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. This topic\nprovides more details on the required configuration steps. SQL Server\nconfiguration depends on the type of sync job:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter",
            "title": "Query Converter",
            "headings": [],
            "paragraphs": "Use Query Converter to convert SQL statements, views, and stored\nprocedures to MongoDB syntax. Relational Migrator considers the mapping\nrules and schema transformations defined in your project when converting\nyour SQL code.",
            "code": [],
            "preview": "Use Query Converter to convert SQL statements, views, and stored\nprocedures to MongoDB syntax. Relational Migrator considers the mapping\nrules and schema transformations defined in your project when converting\nyour SQL code.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/generate-app-code",
            "title": "Generate App Code",
            "headings": [
                "Code Generation Options",
                "Code Generation Templates",
                "Get Started"
            ],
            "paragraphs": "In a migration project, in addition to migrating data, you frequently\nupdate or rewrite parts of your application code. Relational Migrator's\nCode Generation feature reduces the time and effort involved in this process. Relational Migration Code Generation analyzes MongoDB collections and\ngenerates application code from your MongoDB schema. Code Generation: For each collection in your destination MongoDB connection, Code Generation generates code files. These files contain language specific model classes and appropriate library imports to run your application on MongoDB. You can then download or copy these automatically generated files into your application. You may need to make manual updates to the generated code in order to integrate it with your existing application code. Uses connections defined in your project to connect to MongoDB and generate application code files. Provides language support for C#, Java, JavaScript and JSON. Code Generation has the following options: Option Description Language The programming language that Relational Migrator generates code files for. Template Describes the types of artifacts that are generated in the chosen language. Code Generation supports the following application templates: Language Template Name Description C# Persistence Layer Includes the POCOs as well as repository classes that use the C# MongoDB Driver. C# POCO (Plain Old CLR Object) Generates your code as framework independent C# entity classes. Java POJO (Plain Old Java Object) Generates your code as framework independent Java entity classes. Java Spring Data Includes the POJOs as well as repository classes built using the Spring Data framework. JavaScript Mongoose Schemas Generates your code as Mongoose JavaScript schema classes. JavaScript Node Generates CRUD repository classes for use in a Node.js application. JSON JSON Schema (MongoDB) Generates JSON Schema files that are able to be used for  MongoDB schema validation . JSON JSON Schema (Standard) Generates JSON Schema files that can be used with third party tools. JSON Sample documents Generates sample JSON documents that align to each collection's schema. Download All Code Files Download Single Code Files",
            "code": [],
            "preview": "In a migration project, in addition to migrating data, you frequently\nupdate or rewrite parts of your application code. Relational Migrator's\nCode Generation feature reduces the time and effort involved in this process.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/prerequisites/my-sql",
            "title": "Configure Migration Prerequisites for MySQL",
            "headings": [
                "Steps",
                "(Optional) Set up user permissions",
                "(Optional) Set up user permissions",
                "(Optional) Manually verify Binlog is enabled",
                "Locate and update the MySQL configuration file",
                "Learn More"
            ],
            "paragraphs": "To run sync jobs from a MySQL source database, the database may require\nsome configuration changes. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. The\nMySQL Server configurations depend on the type of sync job: For details on supported versions of MySQL, see\n Supported Databases and Versions . Snapshot sync jobs migrate all the data and then stops. Continuous sync job run a snapshot and then enter a CDC stage to\ncontinuously replicate data changes. The following code creates a new MySQL service account\nfor Relational Migrator to connect to the MySQL\ninstance. Alternatively, you can use an existing MySQL service\naccount to connect to Relational Migrator with the appropriate\npermissions. Create a service account: Grant the required permissions to the service account: Apply the user privilege changes: Running continuous jobs on Relational Migrator\nrequires the  binary log \nto be enabled on your MySQL instance. The binary log (Binlog)\nrecords all operations in the order they are committed to the\ndatabase. The following code creates a new MySQL service account\nfor Relational Migrator to connect to the MySQL\ninstance. Alternatively, you can use an existing MySQL service\naccount to connect to Relational Migrator with the appropriate\npermissions. Create a service account: Grant the required permissions to the service account: Apply the user privilege changes: Relational Migrator automatically checks this setting for\nyou. To manually check the if the  Binlog  option is\nenabled, use the queries below for your version of MySQL: Binlog  is automatically enabled by default\non MySQL  8.x  versions. Run the following SQL query to get the  server_id \nvalue for your MySQL instance: Locate the config file for your MySQL instance by running\nthe following  mysqld  command in your terminal: Under the  [mysqld]  section of your MySQL\nconfiguration file add the following lines. Replace\nthe  XXXXX  value with the  server_id  from the\nprevious query: If you're running MySQL on AWS RDS and  automated backups \nare not enabled,  Binlog  will be disabled, even if\nthe values are set in the configuration file. Relational Migrator relies on the open-source Debezium connector to\ncapture row-level changes. For more details, see\n Debezium MySQL .",
            "code": [
                {
                    "lang": "sql",
                    "value": "CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';"
                },
                {
                    "lang": "sql",
                    "value": "GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT\nON *.*\nTO 'user'@'%';"
                },
                {
                    "lang": "sql",
                    "value": "FLUSH PRIVILEGES;"
                },
                {
                    "lang": "sql",
                    "value": "CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';"
                },
                {
                    "lang": "sql",
                    "value": "GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT\nON *.*\nTO 'user'@'%';"
                },
                {
                    "lang": "sql",
                    "value": "FLUSH PRIVILEGES;"
                },
                {
                    "lang": "sql",
                    "value": "SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n\nFROM performance_schema.global_variables WHERE variable_name='log_bin';"
                },
                {
                    "lang": "sql",
                    "value": "SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n\nFROM information_schema.global_variables WHERE variable_name='log_bin';"
                },
                {
                    "lang": "sql",
                    "value": "SELECT variable_value\nFROM\nperformance_schema.global_variables\nWHERE variable_name='server_id';"
                },
                {
                    "lang": "sql",
                    "value": "SELECT variable_value\nFROM\ninformation_schema.global_variables\nWHERE variable_name='server_id';"
                },
                {
                    "lang": null,
                    "value": "mysql --help | findstr cnf"
                },
                {
                    "lang": null,
                    "value": "mysql --help | grep cnf"
                },
                {
                    "lang": null,
                    "value": "server-id = XXXXX\nlog_bin = mysql-bin\nbinlog_format = ROW\nbinlog_row_image = FULL\nbinlog_expire_logs_seconds = 864000"
                },
                {
                    "lang": null,
                    "value": "server-id = XXXXX\nlog_bin = mysql-bin\nbinlog_format = ROW\nbinlog_row_image = FULL\nexpire_log_days = 10"
                }
            ],
            "preview": "To run sync jobs from a MySQL source database, the database may require\nsome configuration changes. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. The\nMySQL Server configurations depend on the type of sync job:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/ai-and-data-usage-information",
            "title": "AI and Data Usage Information",
            "headings": [
                "Third Party Providers",
                "How Your Data is Used",
                "Disable Query Converter"
            ],
            "paragraphs": "The Query Converter feature is powered by Generative AI\n(Gen AI), and may give inaccurate responses. Please see our  Generative AI FAQ \nfor more information about Gen AI in MongoDB products. Query Converter currently uses the  Azure OpenAI Service \nhosted by Microsoft. This is subject to change in the future. When you use Query Converter, the following information is sent to\nMongoDB's backend and/or the third party AI provider: The information that is sent is not shared with any other third\nparties or stored by the AI provider. Relational Migrator does not send\ndatabase connection strings, credentials, or any raw data from your\ndatabases. By default, your original query text and the AI-converted query\ntelemetry data is stored by MongoDB for up to one year to help us\nprovide support and improve the service. If you do not want\nyour data to be stored, you have the option to opt out: The full text of your query or stored procedure. The definition of any relational database tables used in the query.\nThese definitions include the table names, column names, data types,\nand any primary or foreign key relationships. The definition of your MongoDB collections and mapping rules.\nThese definitions include the relationships between the collections\nand tables used in the query and the collection names, field names\nand data types. You can disable the  Allow queries to be stored temporarily \ntoggle switch in the global project settings. You can uncheck the  Allow MongoDB to temporarily store the\nsource and converted queries to import the product feature  setting\nwhen you enable the query converter. Query Converter is available in the Relational Migrator UI once you have\n enabled the query converter feature .\nIf you no longer want to use the feature, you can ignore it and no data\nwill be sent to generative AI models. If needed, you can hide the\nfeature by clearing all browser data for the Relational Migrator host.",
            "code": [],
            "preview": "The Query Converter feature is powered by Generative AI\n(Gen AI), and may give inaccurate responses. Please see our Generative AI FAQ\nfor more information about Gen AI in MongoDB products.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/refresh-database-objects",
            "title": "Refresh Database Objects",
            "headings": [
                "Steps",
                "Navigate to the query converter pane",
                "Connect to your relational database",
                "Select database objects",
                "Select the new database objects",
                "Next Steps"
            ],
            "paragraphs": "You can refresh relational database objects from the\n Query Converter  pane. Refreshing database objects imports\nnew views and stored procedures into your project or updates the SQL\nsyntax if object definitions have changed. From the  Code Generation  tab, click the\n Query Converter  pane. Click the  Manage Database Objects . On the  Manage Database Objects  modal, click\nthe  Refresh Objects  button. Specify the connection details to your source database. For details, see  Relational Database Connection Strings . The credentials used to refresh your database objects do\nnot need to be the same credentials used when creating your\nproject. Click  Connect . On the  Manage Database Objects  modal, click\nthe   icon next to your database. Click the   icon next to your schema. Click the   icon next to\n Stored Procedures ,  Triggers , or\n Views . Click the   icon next to the\nviews or stored procedures you want to import or refresh. Click  Save . Newly imported views and stored procedures are visible under\nthe appropriate header on the  Query Converter \npane. To see a view or stored procedures SQL definition you can\nclick the object's name on the left-hand\n Query Converter  pane. Convert Views Convert Stored Procedures",
            "code": [],
            "preview": "You can refresh relational database objects from the\nQuery Converter pane. Refreshing database objects imports\nnew views and stored procedures into your project or updates the SQL\nsyntax if object definitions have changed.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "jobs/prerequisites/postgres",
            "title": "Configure Migration Prerequisites for PostgreSQL",
            "headings": [
                "Before you Begin",
                "Steps",
                "Enable logical replication",
                "Create a SQL replication role",
                "Grant ownership of each table to the role",
                "Create a publication",
                "Set replica identity to full",
                "Learn More"
            ],
            "paragraphs": "To run sync jobs from an PostgreSQL source database, the database may\nrequire some configuration changes. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. These instructions\nconfiguration PostgreSQL for both types of sync jobs: Snapshot sync jobs migrate all the data and then stops. Continuous sync job run a snapshot and then enter a CDC stage to\ncontinuously replicate data changes. If PostgreSQL is configured as a cluster, Relational Migrator must\nconnect to the master server. For snapshot jobs against PostgreSQL, the service account requires\nschema  USAGE  and table  SELECT  permissions. For continuous jobs against PostgreSQL, you must enable\nlogical replication, grant role permissions to the service\naccount, and create a publication. Logical replication may not be enabled by default. To enable logical\nreplication, change the  wal_level \nconfiguration in the\n postgresql.conf configuration file .\nYou  must restart the database instance  after changing the configuration file. If you are using PostgreSQL hosted on AWS RDS, you must\nset the  rds.logical_replication  parameter to  1 .\nFor details, see  Enable Logical Replication on AWS .\nYou  must restart the database instance  after setting the\nparameter. You can use the following query to check if your\nAWS RDS instance has logical\nreplication enabled: Create a role with  REPLICATION  and  LOGIN \ndatabase permissions: Grant the table  SELECT  and schema  USAGE \npermissions to the role. Each table in\nthe migration requires a  GRANT SELECT  statement: Grant the role to the service account Replace  <original_owner>  with the owner of the\nparticipating tables. Each table in the migration requires a  ALTER TABLE \nstatement: Create a  publication \neach table in the migration must be specified\nin the  FOR  statement separated by commas: Each table in the migration requires a  ALTER TABLE \nstatement: Relational Migrator relies on the open-source Debezium connector to\ncapture row-level changes. For more details, see\n Debezium PostgreSQL .",
            "code": [
                {
                    "lang": "sql",
                    "value": "GRANT USAGE ON SCHEMA <schema_name> TO <database_user_name>;\nGRANT SELECT ON TABLE <schema_name>.<table_name> TO <database_user_name>;"
                },
                {
                    "lang": "none",
                    "value": "wal_level = logical"
                },
                {
                    "lang": "sql",
                    "value": "SELECT name,setting\nFROM pg_settings\nWHERE name IN ('wal_level','rds.logical_replication');"
                },
                {
                    "lang": "sql",
                    "value": "CREATE ROLE <role> REPLICATION LOGIN;"
                },
                {
                    "lang": "sql",
                    "value": "GRANT USAGE ON SCHEMA <schema> TO <role>;\nGRANT SELECT ON <schema>.<table> TO <role>;\n-- ADDITIONAL GRANT SELECT STATEMENTS..."
                },
                {
                    "lang": "sql",
                    "value": "GRANT <role> TO <original_owner>;\nGRANT <role> TO <database_user_name>;"
                },
                {
                    "lang": "sql",
                    "value": "ALTER TABLE <schema>.<table> OWNER TO <role>;\n-- ADDITIONAL ALTER TABLE STATEMENTS..."
                },
                {
                    "lang": "sql",
                    "value": "CREATE PUBLICATION \"MIGRATOR_<name>_PUBLICATION\"\nFOR TABLE \"<schema>\".\"<table1>\",\"<schema>\".\"<table2>\";"
                },
                {
                    "lang": "sql",
                    "value": "ALTER TABLE <schema>.<table> REPLICA IDENTITY FULL;\n-- ADDITIONAL ALTER TABLE STATEMENTS..."
                }
            ],
            "preview": "To run sync jobs from an PostgreSQL source database, the database may\nrequire some configuration changes. If Relational Migrator determines the\ndatabase needs configuration changes, it automatically generates a\nSQL script with the required changes. It is recommended to have a\nDatabase Administrator (DBA) review the commands in this script and\nperform their execution on the database server. These instructions\nconfiguration PostgreSQL for both types of sync jobs:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/convert-triggers",
            "title": "Convert Triggers",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Navigate to the query converter pane",
                "Open the query converter view",
                "Select triggers",
                "Convert the SQL trigger",
                "Create the Trigger in Atlas",
                "Example",
                "Convert a MySQL Trigger",
                "Learn More"
            ],
            "paragraphs": "You can import and convert your SQL triggers to\n MongoDB Atlas Triggers  with the query converter.\nThe query converter considers the SQL code and relational schema defined\nin your project when converting your triggers. The query converter uses  AI (Artificial Intelligence) \ntechnology which may not be able to convert long or complex queries,\ntriggers, or stored procedures. Some queries may not be converted\ncorrectly while others may not be converted at all. The query converter uses the relational schema, the MongoDB schema,\nand the mapping rules in your current project to determine how the\nqueries should be converted. Conversions may fail or be incorrect if\nthe queries reference tables that are not in your relational schema\nor if they are not mapped to MongoDB collections. Converted queries, triggers, views, and stored procedures are saved in\nyour project and persist through project import and exports. SQL queries are limited to 10,000 text characters. Your relational database must have at least one trigger to convert. Always review and test the code generated by query\nconverter before deploying it in a production environment. From the  Code Generation  tab, click the\n Query Converter  pane. If it is your first time accessing Query Converter or your session\nhas expired, click  Log In To Use Query Converter \nand provide your Atlas credentials. If it is your first time using the query converter in your\nproject, click  Import From Database . If your project already has converted SQL code, click the\n Manage Database Objects  button on the left\npane. On the  Import Database Objects  modal, click\nthe   icon next to  Database . Click the   icon next to your schema. Click the   icon next to\n Triggers . You can toggle triggers for conversion by clicking\nthe   icon next to a trigger's\nname. All triggers are selected by default. Click  Save . The code for each trigger in your database\nschema is imported into your project and is visible in the\nleft  Query Converter  pane under\n Triggers . Click a trigger's name from the left pane under\n Triggers . The SQL trigger code displays in the\n Imported Trigger  pane. You can use the  Filter  text box to filter queries,\nstored procedures, triggers, and views based on object name and SQL\nsyntax. Click the  Convert  button. Wait for the query\nconverter to convert your code. The converted MongoDB code displays\non the  Converted MongoDB Query  pane. Click the   icon on the\n Converted MongoDB Query  pane to copy the MongoDB\ncode to your clipboard. Login to your  Atlas account . From the  Overview  screen, click  Triggers . Click  Add Trigger . The converted MongoDB code contains commented lines for\nall the variables you must select in Atlas to create\nyour trigger. For example: Enter a name for the trigger in the  Name  text\nfield. Select the  Cluster Name , the\n Database Name  and the\n Collection Name . Select the  Operation Type  as\n Insert Document . Toggle the  Document Preimage  and\n Full Document  switches to on. Enter converted MongoDB code in the  Function \ntext field. Update the  clusterName  and  databaseName  in\nthe generated Atlas code to match your cluster and\ndatabase name. Click  Save  to save the Atlas trigger. The following example shows a MySQL trigger converter to Atlas: Convert Views Convert Queries Convert Stored Procedures",
            "code": [
                {
                    "lang": "javascript",
                    "value": "// Collection Name: products\n// Operation Type: Insert"
                },
                {
                    "lang": "sql",
                    "value": "CREATE TRIGGER TRIGGER_UPPER_PRODUCTS\nBEFORE INSERT\nON MYDATABASE.PRODUCTS\nFOR EACH ROW\nSET NEW.FULL_NAME = UPPER(new.FULL_NAME)"
                },
                {
                    "lang": "javascript",
                    "value": "// The relational database trigger has been converted to MongoDB Atlas Triggers format.\n// To create a trigger, open your Atlas project (https://cloud.mongodb.com) and choose Triggers\n// For more on Atlas triggers see the docs: https://www.mongodb.com/docs/atlas/triggers/\n// Create your trigger using the following settings and paste the code into the Function section:\n// Watch Against: Collection\n// Cluster Name: Ensure clusterName matches selection in Atlas Trigger configuration\n// Database Name: Ensure databaseName matches selection in Atlas Trigger configuration\n// Collection Name: products\n// Operation Type: Insert\n// Full Document: On\n// Document Preimage: Off\n\nexports = async function(changeEvent) {\n   const clusterName = \"clusterName\";\n   const databaseName = \"databaseName\";\n\n   const { fullDocument } = changeEvent;\n   const db = context.services.get(clusterName).db(databaseName);\n   const collection = db.collection('products');\n\n   if (fullDocument && fullDocument.fullName) {\n      fullDocument.fullName = fullDocument.fullName.toUpperCase();\n      await collection.updateOne({ _id: fullDocument._id }, { $set: { fullName: fullDocument.fullName } });\n   }\n};"
                }
            ],
            "preview": "You can import and convert your SQL triggers to\nMongoDB Atlas Triggers with the query converter.\nThe query converter considers the SQL code and relational schema defined\nin your project when converting your triggers.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/enable-query-converter",
            "title": "Enable Query Converter",
            "headings": [
                "Before You Begin",
                "Steps",
                "Navigate to the query converter pane",
                "Read the user agreement",
                "(Optional) Review telemetry preferences",
                "Enable the query converter feature",
                "Next Steps"
            ],
            "paragraphs": "You can use the query converter to convert SQL statements, views, and\nstored procedures to MongoDB syntax. The query converter considers the\nmapping rules and schema transformations defined in your project when\nconverting your SQL code. Before you can use the query converter, you must sign in to your Atlas\naccount in Relational Migrator. For details, see  Log In with Atlas . From the  Code Generation  tab, click the\n Query Converter  pane. Telemetry data about the source and converted queries are\ntemporarily stored by MongoDB to improve the query converter\nfeature. If you do not want your data to be stored, you have\nthe option to opt out: You can disable the  Allow queries to be stored temporarily \ntoggle switch in the global project settings. You can uncheck the  Allow MongoDB to temporarily store the\nsource and converted queries to import the product feature  setting\nwhen you enable the query converter. Click  Start Using Query Converter .\nThe  Query Converter  pane is displayed. Convert Queries Convert Views Convert Stored Procedures",
            "code": [],
            "preview": "You can use the query converter to convert SQL statements, views, and\nstored procedures to MongoDB syntax. The query converter considers the\nmapping rules and schema transformations defined in your project when\nconverting your SQL code.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/convert-queries",
            "title": "Convert Queries",
            "headings": [
                "About this Task",
                "Steps",
                "Navigate to the query converter pane",
                "Open the SQL query converter view",
                "Enter your SQL query",
                "Convert and test syntax",
                "Examples",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can convert embedded application and reporting SQL queries to MongoDB\nsyntax using the query converter. Copy and paste your queries into the\nquery converter to update them to work with MongoDB and your migrated\nschema. The query converter uses  AI (Artificial Intelligence) \ntechnology which may not be able to convert long or complex queries,\ntriggers, or stored procedures. Some queries may not be converted\ncorrectly while others may not be converted at all. The query converter uses the relational schema, the MongoDB schema,\nand the mapping rules in your current project to determine how the\nqueries should be converted. Conversions may fail or be incorrect if\nthe queries reference tables that are not in your relational schema\nor if they are not mapped to MongoDB collections. Converted queries, triggers, views, and stored procedures are saved in\nyour project and persist through project import and exports. SQL queries are limited to 10,000 text characters. Always review and test the code generated by query\nconverter before deploying it in a production environment. From the  Code Generation  tab, click the\n Query Converter  pane. If it is your first time using the query converter in your\nproject, click  Paste SQL Query . If you have previously converted SQL code in your project, click the\n + ADD  button on the left-hand pane next to\n Queries . Copy your SQL query to your clipboard. Queries copied into the  SQL Query  text field\nmust be a SELECT query. For example:\n SELECT ID,ITEMNAME,PRICE FROM inventory . Under the  SQL Query  header, paste your SQL query\ninto the text box. Click the  Convert  button. Wait for your SQL code to\nconverted. The converted MongoDB syntax code displays\nin the  Converted MongoDB Query  text box. You can rename or delete queries from your project\nby clicking the  \nbutton on the  SQL Query  pane and clicking the\n  or   icon. Click the   icon to copy the MongoDB syntax\nto your clipboard. Test and validate the generated MongoDB syntax. You can use the  Filter  text box to filter queries,\nstored procedures, triggers, and views based on object name and SQL\nsyntax. The following table shows examples of SQL queries converted to MongoDB\nsyntax using query converter. The syntax and structure of the converted\nqueries vary depending on the mapping rules used in the project: SQL Syntax MongoDB Syntax Convert Views Convert Stored Procedures SQL to MongoDB Mapping Chart SQL to Aggregation Mapping Chart",
            "code": [
                {
                    "lang": "sql",
                    "value": "SELECT *\nFROM CUSTOMERS"
                },
                {
                    "lang": null,
                    "value": "async function query(db) {\n  return await db.collection('Customers').find({\n  }).toArray();\n}"
                },
                {
                    "lang": "sql",
                    "value": "SELECT CONTACTNAME, CITY\nFROM CUSTOMERS\nWHERE CONTACTNAME LIKE '%SMITH%'"
                },
                {
                    "lang": "node",
                    "value": "async function query(db) {\nreturn await db.collection('Customers').find({\n      ContactName: { $regex: '.*SMITH.*' }\n   }, {\n      projection: { ContactName: 1, City: 1, _id: 0 }\n   }).toArray();\n}"
                },
                {
                    "lang": "sql",
                    "value": "SELECT CUSTOMERID, CITY\nFROM CUSTOMERS AS C\nJOIN ORDERS AS O\n   ON C.CUSTOMERID = O.CUSTOMERID\nWHERE CONTACTNAME IN('ABI','JIM')"
                },
                {
                    "lang": "node",
                    "value": "const query = async (db) => {\nreturn await db.collection('Customers').aggregate([\n   {\n      $lookup: {\n         from: 'Orders',\n         localField: 'CustomerId',\n         foreignField: 'CustomerId',\n         as: 'customer_orders'\n      }\n   },\n   {\n      $match: {\n      CONTACTNAME: { $in: ['ABI', 'JIM'] }\n      }\n   },\n   {\n      $project: {\n      CustomerId: 1,\n      City: 1\n      }\n   }\n   ]).toArray();\n};"
                }
            ],
            "preview": "You can convert embedded application and reporting SQL queries to MongoDB\nsyntax using the query converter. Copy and paste your queries into the\nquery converter to update them to work with MongoDB and your migrated\nschema.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/convert-stored-procedures",
            "title": "Convert Stored Procedures",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Navigate to the query converter pane",
                "Open the query converter view",
                "Connect to your relational database",
                "Select stored procedures",
                "Convert and test code",
                "Examples",
                "JavaScript",
                "C#",
                "Java",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can import and convert your SQL stored procedures to MongoDB code\nwith the query converter. The query converter considers the mapping\nrules and schema transformations defined in your project when converting\nyour SQL code. The query converter uses  AI (Artificial Intelligence) \ntechnology which may not be able to convert long or complex queries,\ntriggers, or stored procedures. Some queries may not be converted\ncorrectly while others may not be converted at all. The query converter uses the relational schema, the MongoDB schema,\nand the mapping rules in your current project to determine how the\nqueries should be converted. Conversions may fail or be incorrect if\nthe queries reference tables that are not in your relational schema\nor if they are not mapped to MongoDB collections. Converted queries, triggers, views, and stored procedures are saved in\nyour project and persist through project import and exports. SQL queries are limited to 10,000 text characters. MongoDB does not have an official synonym object type for the SQL\nstored procedure. Instead, MongoDB supports custom JavaScript and\ndriver code that hosts the database logic. Part of your application\nmodernization journey is to choose the programming language and hosting\noption that best serves your application needs. You can host your\nconverted stored procedure code in your application or with\n MongoDB App Services Functions . Always review and test the code generated by query\nconverter before deploying it in a production environment. From the  Code Generation  tab, click the  Query Converter  pane. If it is your first time using the query converter in your\nproject, click  Import From Database . If your project already has converted SQL code, click the\n Manage Database Objects  button on the left-hand\npane. Specify the connection details to your source database. For details, see  Relational Database Connection Strings . Click  Connect . On the  Import Database Objects  modal, click\nthe   icon next to  Database . Click the   icon next to your schema. Click the   icon next to\n Stored Procedures . You can toggle stored procedures for conversion by clicking\nthe   icon next to a stored procedure's\nname. All stored procedures are selected by default. Click  Save . The code for each stored procedure in your database\nschema is imported into your project and is visible in the\n Query Converter  pane under\n Stored Procedures . Click a stored procedure's name from the left-hand pane under\n Stored Procedures . The code displays in the\n Imported Stored Procedure  pane. Select a  Target Language  from the drop-down. Query converter supports stored procedure conversions to\nJavascript, C#, and Java. Click the  Convert  button. Wait for the query\nconverter to convert your code. The converted MongoDB code displays\non the  Converted MongoDB Query  pane. Click the   icon on the\n Converted MongoDB Query  pane to copy the MongoDB\ncode to your clipboard. Test and validate the generated MongoDB code. You can use the  Filter  text box to filter queries,\nstored procedures, triggers, and views based on object name and SQL\nsyntax. The query converter can convert your stored procedures\nto Javascript, C#, or Java code. The examples below\nshow conversions to each language. The following example shows a MySQL stored procedure\nconverted to JavaScript: The following example shows a MySQL stored procedure\nconverted to C#: The following example shows a MySQL stored procedure\nconverted to Java: Convert Queries Convert Views SQL to MongoDB Mapping Chart SQL to Aggregation Mapping Chart",
            "code": [
                {
                    "lang": "sql",
                    "value": "BEGIN\n   DECLARE v_rentals INT;\n   DECLARE v_out       INT;\n   SELECT COUNT(*) INTO v_rentals\n   FROM rental\n   WHERE inventory_id = p_inventory_id;\n   IF v_rentals = 0 THEN\n      RETURN TRUE;\n   END IF;\n   SELECT COUNT(rental_id) INTO v_out\n   FROM inventory LEFT JOIN rental USING(inventory_id)\n   WHERE inventory.inventory_id = p_inventory_id\n   AND rental.return_date IS NULL;\n   IF v_out > 0 THEN\n      RETURN FALSE;\n   ELSE\n      RETURN TRUE;\n   END IF;\nEND"
                },
                {
                    "lang": "javascript",
                    "value": "async function query(db, p_inventory_id) {\nconst v_rentals = await db.collection('rental').countDocuments(\n   { inventoryId: p_inventory_id }\n);\nif (v_rentals === 0) {\n   return true;\n}\nconst v_out = await db.collection('inventory').aggregate([\n   {\n      $lookup: {\n      from: 'rental',\n      localField: 'inventoryId',\n      foreignField: 'inventoryId',\n      as: 'rentalData'\n      }\n   },\n   {\n      $match: {\n      inventoryId: p_inventory_id,\n      'rentalData.returnDate': { $exists: false }\n      }\n   },\n   {\n      $count: 'rentalId'\n   }\n   ]).toArray();\n   if (v_out.length > 0 && v_out[0].rentalId > 0) {\n      return false;\n   } else {\n      return true;\n   }\n   }"
                },
                {
                    "lang": "sql",
                    "value": "BEGIN\n      DECLARE v_customer_id INT;\n      DECLARE EXIT HANDLER FOR NOT FOUND RETURN NULL;\n      SELECT customer_id INTO v_customer_id\n      FROM rental\n      WHERE return_date IS NULL\n      AND inventory_id = p_inventory_id;\n      RETURN v_customer_id;\n   END"
                },
                {
                    "lang": "csharp",
                    "value": "async Task<int?> Query(IMongoDatabase db)\n{\n   var rentalCollection = db.GetCollection<BsonDocument>(\"rental\");\n   var filter = Builders<BsonDocument>.Filter.Eq(\"inventoryId\", p_inventory_id) & Builders<BsonDocument>.Filter.Eq(\"returnDate\", null);\n   var result = await rentalCollection.Find(filter).FirstOrDefaultAsync();\n   return result != null ? result[\"customerId\"].AsInt32 : (int?)null;\n}"
                },
                {
                    "lang": "sql",
                    "value": "BEGIN\n   SELECT inventory_id\n   FROM inventory\n   WHERE film_id = p_film_id\n   AND store_id = p_store_id\n   AND NOT inventory_in_stock(inventory_id);\n   SELECT COUNT(*)\n   FROM inventory\n   WHERE film_id = p_film_id\n   AND store_id = p_store_id\n   AND NOT inventory_in_stock(inventory_id)\n   INTO p_film_count;\nEND"
                },
                {
                    "lang": "java",
                    "value": "void query(MongoDatabase db) {\n   int p_film_id = 0;\n   int p_store_id = 0;\n   int p_film_count = 0;\n\n   MongoCollection<Document> inventoryCollection = db.getCollection(\"inventory\");\n\n   Bson filter = Filters.and(Filters.eq(\"filmId\", p_film_id), Filters.eq(\"storeId\", p_store_id), Filters.not(inventory_in_stock(\"inventoryId\")));\n   FindIterable<Document> result = inventoryCollection.find(filter);\n\n   for (Document doc : result) {\n      System.out.println(doc.getInteger(\"inventoryId\"));\n   }\n\n   p_film_count = (int) inventoryCollection.countDocuments(filter);\n}"
                }
            ],
            "preview": "You can import and convert your SQL stored procedures to MongoDB code\nwith the query converter. The query converter considers the mapping\nrules and schema transformations defined in your project when converting\nyour SQL code.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/generate-app-code/download-all-code-files",
            "title": "Download All Code Files",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Code Generation is a feature built into Relational Migrator that helps\nautomatically generate code files for your applications connected\nto MongoDB. This page details how to generate and download all code files into a zip file. Some templates also generate additional files which are not specific to\na MongoDB collection. These files are called  Support files .\nClick the  Support files  check box to indicate if you would like\nthese files included in your downloads. Navigate to the  Code Generation  screen, in the left  Generate code  pane. Select a  Language . Select a  Template . (Optional) Enter a keyword in the  Filter  text box to\nfilter the MongoDB collections. Select the MongoDB collections by clicking check box next to the collection name. Click the  Download selected files  button. The selected files download into a zip file\nto your  Downloads folder . The zip file has a naming convention of  PROJECTNAME-LANGUAGE-TEMPLATE . Download Single Code Files",
            "code": [],
            "preview": "Code Generation is a feature built into Relational Migrator that helps\nautomatically generate code files for your applications connected\nto MongoDB. This page details how to generate and download all code files into a zip file.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/generate-app-code/download-single-code-files",
            "title": "Download Single Code Files",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Code Generation is a feature built into Relational Migrator that helps\nautomatically generate code files for your applications connected\nto MongoDB. This page details how to generate and download individual code files. Some templates also generate additional files which are not specific to\na MongoDB collection. These files are called  Support files . Click\nthe  Support files  check box to indicate if you would like these\nfiles included in your downloads. You can view, download, or copy a single collections code file. Navigate to the  Code Generation  screen, in the left  Generate code  pane. Select a  Language . Select a  Template . (Optional) Enter a keyword in the  Filter  text box to\nfilter the MongoDB collections. Click the MongoDB collection name. A tab displays for each code file. More than one code file per collection may be generated depending on the template. Click the  Copy  or  Download  buttons in the target code file to download or copy that files contents. Download All Code Files",
            "code": [],
            "preview": "Code Generation is a feature built into Relational Migrator that helps\nautomatically generate code files for your applications connected\nto MongoDB. This page details how to generate and download individual code files.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "table-filters/delete-table-filters",
            "title": "Delete Table Filters",
            "headings": [
                "Before you Begin",
                "Steps",
                "Select a table filter",
                "Confirm deletion of your table filter",
                "Learn More"
            ],
            "paragraphs": "You can delete existing table filters. Deleting table filters removes\nSQL where statement and row limits when pulling data from your table. At least one table filter must be applied to your table.\nFor details on how to apply a table filter, see\n Apply Table Filters . From the  Schema model  pane, click the table\nthat has the table filter you want to delete. On the  Mappings  pane in the  Table Filter \nsection, click the   icon next to the table\nfilter. Click the red  Delete  button to confirm deletion of\nthe table filter. It can take a few seconds for the table filter to be removed\nfrom your project. Mapping Rules",
            "code": [],
            "preview": "You can delete existing table filters. Deleting table filters removes\nSQL where statement and row limits when pulling data from your table.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "table-filters/apply-table-filters",
            "title": "Apply Table Filters",
            "headings": [
                "Before you Begin",
                "Steps",
                "Apply a table filter",
                "(Optional) Add a row limit",
                "Save your table filter",
                "Learn More"
            ],
            "paragraphs": "You can use table filters to migrate specific subsets of your table data.\nTable filters allow you to apply SQL where and row limit clauses\nwhen pulling data from your table. Table filters are applied while you are creating mapping rules. See\n Create Rules From Relational  for more details. You can apply one filter per table. Each filter can have a SQL where\nclause, a row limit clause, or both. From the  Schema model  pane, click the table\nthat you want to apply a filter to. On the  Filter on  section in the edit\n mapping rule  pane, click  + Add . Under the  SQL query  header, enter a SQL where\ncriteria. The\nSQL you specify must be ANSI SQL compliant with your relational\ndatabase.The following are examples of SQL where clauses used\nto apply  SQL query  table filters: LASTNAME LIKE '%SMITH%' LASTNAME = 'SMITH' LASTNAME IN('SMITH') LASTNAME IN(SELECT LASTNAME FROM ASIA_CUSTOMERS\nWHERE ID < 100000) Under the  Row limit  header, click the\n Limit number of rows  radio button and enter a value.\nThis applies a limit clause at the end of your SQL query. Click  Save and close . After you save your filter, the  Schema model  pane\ndisplays a   icon for any tables containing a\nfilter under the  Relational  header. Mapping Rules",
            "code": [],
            "preview": "You can use table filters to migrate specific subsets of your table data.\nTable filters allow you to apply SQL where and row limit clauses\nwhen pulling data from your table.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "table-filters/table-filters",
            "title": "Table Filters",
            "headings": [
                "Table Filter Types",
                "Get Started"
            ],
            "paragraphs": "In a migration project, you can apply table filters to control the\nvolume of data migrated from each table. You can apply table filters\nwhen you configure the mapping rules from the relational schema model. Table filters allow you to: Migrate your data in logical batches. Limit the read operations on your source database. Create test environments before migrating your entire database. You can apply one filter per table. Each filter can have a SQL where\nclause, a row limit clause, or both. Filter Component Description Example SQL Syntax SQL Apply a SQL where clause to the tables database query. Only the customers who have a last name of Smith. WHERE LASTNAME = 'SMITH' Row limit Apply a SQL limit clause to the tables database query. Only migrate the top 100 rows. ... LIMIT 100 Both Apply a SQL where clause and a limit clause to the tables database query. Only 100 rows for customers who have a last name of Smith. WHERE LASTNAME = 'SMITH' LIMIT 100 Apply Table Filters",
            "code": [],
            "preview": "In a migration project, you can apply table filters to control the\nvolume of data migrated from each table. You can apply table filters\nwhen you configure the mapping rules from the relational schema model.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "table-filters/edit-table-filters",
            "title": "Edit Table Filters",
            "headings": [
                "Before you Begin",
                "Steps",
                "Select a table filter",
                "Edit your table filter",
                "Save the updated table filter",
                "Learn More"
            ],
            "paragraphs": "You can edit existing table filters. Editing table filters allows you to\nchange the SQL where statement and row limits when pulling data from\nyour table. At least one table filter must be applied to your table.\nFor details on how to apply a table filter, see\n Apply Table Filters . From the  Schema model  pane, click the table\nthat has the table filter you want to edit. On the  Mappings  pane in the  Table Filter \nsection, click the   icon. On the  Edit Filter  pane, under the  SQL Query \nheader, enter the updated SQL where statement for your table filter. (Optional) You can also add or remove row limits when editing a\ntable filter: To add a row limit, click the  Limit Number Of Rows \nand providing a value in the row limit text field. To remove a row limit, click the  No Limit \nradio button Click the green  Save and Close  button to save the\nupdated table filter. Mapping Rules",
            "code": [],
            "preview": "You can edit existing table filters. Editing table filters allows you to\nchange the SQL where statement and row limits when pulling data from\nyour table.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "code-generation/query-converter/convert-views",
            "title": "Convert Views",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Navigate to the query converter pane",
                "Open the query converter view",
                "Connect to your relational database",
                "Select views",
                "Convert and test code",
                "Examples",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "The query converter takes the  SQL (Structured Query Language) \nto create the view and converts it to the equivalent\n MQL (MongoDB Query Language) . The query converter considers\nthe mapping rules and schema transformations defined in your project\nwhen converting your SQL code. For details on the conversion process,\nsee  convert view examples . The query converter uses  AI (Artificial Intelligence) \ntechnology which may not be able to convert long or complex queries,\ntriggers, or stored procedures. Some queries may not be converted\ncorrectly while others may not be converted at all. The query converter uses the relational schema, the MongoDB schema,\nand the mapping rules in your current project to determine how the\nqueries should be converted. Conversions may fail or be incorrect if\nthe queries reference tables that are not in your relational schema\nor if they are not mapped to MongoDB collections. Converted queries, triggers, views, and stored procedures are saved in\nyour project and persist through project import and exports. SQL queries are limited to 10,000 text characters. Always review and test the code generated by query\nconverter before deploying it in a production environment. From the  Code Generation  tab, click the\n Query Converter  pane. If it is your first time using the query converter in your\nproject, click  Import From Database . If your project already has converted SQL code, click the\n Manage Database Objects  button on the left-hand\npane. Specify the connection details to your source database. For details, see  Relational Database Connection Strings . Click  Connect . On the  Import Database Objects  modal, click\nyour database. Click the   icon next to your schema. Click the   icon next to\n Views . To select the views to convert, click the\n  icon next to a view's name.\nBy default, all views are selected. Click  Save . Click a view's name from the left-hand pane under\n Views . The SQL code is displayed in the  Imported View \npane. Click the  Convert  button. Wait for the query\nconverter to convert your code. The converted MongoDB code\nis displayed in the  Converted MongoDB Query  pane. Click the   icon to copy the MongoDB code\nto your clipboard. Test and validate the generated MongoDB code. You can use the  Filter  text box to filter queries,\nstored procedures, triggers, and views based on object name and SQL\nsyntax. The examples below show PostgreSQL views from the\n example Northwind database \nconverted to MongoDB code. If you want to create a MongoDB view from the query: The following example shows an inner join view converted to MongoDB: The shell command to create this view in MongoDB is: The following example shows an aggregated group by view converted\nto MongoDB: The shell command to create this view in MongoDB is: Copy the aggregation pipeline syntax from the aggregate command. Use the aggregation pipeline syntax with the\n createView shell command . SQL Syntax MongoDB Syntax SQL Syntax MongoDB Syntax Convert Queries Convert Stored Procedures SQL to MongoDB Mapping Chart SQL to Aggregation Mapping Chart",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.createView(\"VW_OrderDetails\", \"orders\",\n   [\n    {\n      $lookup:\n       {\n         from: \"orderDetails\",\n         localField: \"orderId\",\n         foreignField: \"orderId\",\n         as: \"orderDetails\"\n       },\n    },\n    {\n       $unwind: \"$orderDetails\",\n    },\n    {\n       $project:\n          {\n            orderId: 1,\n            customerId: 1,\n            orderDate: 1,\n            unitPrice: \"$orderDetails.unitPrice\",\n            discount: \"$orderDetails.discount\"\n          }\n    }\n   ]\n )"
                },
                {
                    "lang": "javascript",
                    "value": "db.createView(\"VW_Customers\", \"customers\",\n   [\n      {\n         $group:\n         {\n            _id: \"$postal_code\",\n            customercount: { $sum: 1 }\n         }\n      },\n      {\n         $sort: { customercount: -1 }\n      }\n   ]\n)"
                },
                {
                    "lang": "sql",
                    "value": "SELECT\nO.ORDER_ID,\nO.CUSTOMER_ID,\nO.ORDER_DATE,\nOD.UNIT_PRICE,\nOD.DISCOUNT\n\nFROM ORDERS AS O\nINNER JOIN ORDER_DETAILS AS OD\n   ON O.ORDER_ID = OD.ORDER_ID;"
                },
                {
                    "lang": "javascript",
                    "value": "async function query(db) {\n  return await db.collection('orders').aggregate(\n  [\n   {\n      $lookup:\n      {\n         from: \"orderDetails\",\n         localField: \"orderId\",\n         foreignField: \"orderId\",\n         as: \"orderDetails\"\n      },\n   },\n   {\n      $unwind: \"$orderDetails\",\n   },\n   {\n      $project:\n         {\n            orderId: 1,\n            customerId: 1,\n            orderDate: 1,\n            unitPrice: \"$orderDetails.unitPrice\",\n            discount: \"$orderDetails.discount\"\n         }\n   }\n  ]\n  ).toArray();\n }"
                },
                {
                    "lang": "sql",
                    "value": "SELECT\nPOSTAL_CODE,\nCOUNT(*) AS CUSTOMERCOUNT\n\nFROM CUSTOMERS\nGROUP BY POSTAL_CODE\nORDER BY CUSTOMERCOUNT DESC;"
                },
                {
                    "lang": "javascript",
                    "value": "async function query(db) {\n   return db.collection('customers').aggregate(\n   [\n      {\n         $group:\n         {\n           _id: \"$postal_code\",\n           customercount: { $sum: 1 }\n         }\n      },\n      {\n         $sort: { customercount: -1 }\n      }\n   ]\n  ).toArray();\n}"
                }
            ],
            "preview": "The query converter takes the SQL (Structured Query Language)\nto create the view and converts it to the equivalent\nMQL (MongoDB Query Language). The query converter considers\nthe mapping rules and schema transformations defined in your project\nwhen converting your SQL code. For details on the conversion process,\nsee convert view examples.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "getting-started/overview",
            "title": "User Interface Overview",
            "headings": [
                "UI Elements"
            ],
            "paragraphs": "Review the UI element descriptions to understand how you can use the UI\nto manage the project appearance, functionality, and capabilities. UI Element Description Top Navigation Bar Switch between different contexts, including  Mapping ,\n Code Generation , and  Data Migration  views.\nYou can also navigate back to the project home screen,\nconfigure project settings, and access the help menu. Left Pane Manage  your relational connections. Filter and\ntoggle visibility of your database entities. Diagram Toolbar Select diagram layout options, add synthetic foreign keys, and\ncreate additional diagram tabs. Diagrams View relational and MongoDB diagrams, view field names, and data types.\nControl diagram zoom level and view the entity mini-map. Right Pane View, edit, delete, and add mapping rules. Select and rename fields\nincluded in a mapping rule. Add and remove table filters. Get Help Menu / Atlas Login View links for documentation, support, community forums, and\nproduct feedback. The menu also includes a\n Replay Product Tour  button to view the onscreen\ntutorial of the user interface. Use the  Login  button to\nset the credentials used to connect to your Atlas account.",
            "code": [],
            "preview": "Review the UI element descriptions to understand how you can use the UI\nto manage the project appearance, functionality, and capabilities.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "getting-started/migration-scenarios",
            "title": "Migration Scenarios and Use Cases",
            "headings": [
                "Migrate during Scheduled Downtime",
                "Migrate without Downtime",
                "Currently Unsupported Migration Scenarios"
            ],
            "paragraphs": "You can use Relational Migrator to migrate one legacy application at a\ntime to MongoDB. Depending on your application's needs, you can migrate\neither with or without downtime. If your application does not require constant uptime, such as in the\ncase of an internal application, you can have the migration occur during\nscheduled downtime. Migrating during downtime is the easiest way to\nconfigure and complete the migration process. When you start the migration process, Relational Migrator takes a\nsnapshot of the data on the legacy application and migrates the data\nfrom that point in time. During the migration process, your legacy\napplication can remain online to support incoming reads, but cannot\nsupport incoming writes. The length of the migration process depends on\nseveral factors, such as the amount of data being migrated and your\nconnection speed. After the migration completes, take your legacy application offline and\nlaunch your new application. If your application must remain online to support reads and writes\nduring the migration process, you can use Change Data Capture (CDC) to\nmigrate data without downtime. This process is called a  continuous\nsync migration . When you start a continuous sync migration, Relational Migrator takes a\nsnapshot of the data on the legacy application and tracks database\nupdates in near real time. During the migration process, your source and\ndestination databases remain in sync. After the continuous sync migration completes, you can transfer users to\nthe new application and shut down the legacy application. To learn more about sync jobs, see  Sync Jobs . Relational Migrator currently does not support the following migration\nscenarios: The preceding scenarios require long-running  CDC (Change Data\nCapture) , or in some cases involve  CDC (Change Data Capture) \nrunning indefinitely. Therefore, these scenarios are not recommended\nwith Relational Migrator. Relational Migrator will support more migration scenarios and use cases\nin future releases. Migrating multiple applications through a phased migration without\ndowntime. In this scenario, multiple legacy applications are\ndecommissioned and migrated to the new database while the original\ndatabase still supports writes. The migration uses  CDC (Change\nData Capture)  to keep the legacy application in sync with the\ndestination database. Migrating an operational data store. Depending on your workload, this\nscenario could involve  CDC (Change Data Capture)  running\nindefinitely without completing.",
            "code": [],
            "preview": "You can use Relational Migrator to migrate one legacy application at a\ntime to MongoDB. Depending on your application's needs, you can migrate\neither with or without downtime.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "getting-started/supported-databases",
            "title": "Supported Databases and Versions",
            "headings": [
                "Definition",
                "Source Databases and Versions",
                "MongoDB Databases and Versions",
                "Learn More"
            ],
            "paragraphs": "Relational Migrator supports migration from source databases to MongoDB. To create a Relational Migrator project, you can connect to a source\ndatabase to migrate to MongoDB. This page provides details on supported\nversions for both source and MongoDB databases. You might be able to use other versions or deployments, but they have not been tested\nwith Relational Migrator. Relational Migrator supports the following source databases: Database Supported Versions Deployments Oracle 12c and higher Self hosted, AWS RDS Microsoft SQL Server 2012 and higher (Enterprise or Developer edition required for\nversions before 2016) Self hosted, AWS RDS, Azure SQL Database PostgreSQL 10 and higher Self hosted, AWS RDS/Aurora, Azure Database MySQL 5.7 and higher Self hosted, AWS RDS/Aurora, Azure Database Sybase ASE 15 and higher (Sybase IQ not supported) Self hosted Relational Migrator supports the following MongoDB databases: Database Supported Versions Deployments MongoDB 4.4 and higher Self hosted, MongoDB Atlas Create a Project Migration Scenarios and Use Cases",
            "code": [],
            "preview": "Relational Migrator supports migration from source databases to MongoDB.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/file-location",
            "title": "Relational Migrator File Locations",
            "headings": [
                "Mac",
                "Windows",
                "Linux",
                "Learn More"
            ],
            "paragraphs": "Use Relational Migrator file locations when: modifying application configuration\nfiles, deploying additional JDBC drivers, or reviewing log files. The file locations for the Mac OS: Configuration file ~/Library/Application Support/MongoDB/Relational Migrator/user.properties Downloaded JDBC Drivers /Library/Application Support/MongoDB/Relational Migrator/Drivers Log files ~/Library/Application Support/MongoDB/Relational Migrator/Logs/migrator.log The file locations for the Windows OS: Configuration file c:\\Users\\<username>\\AppData\\Local\\MongoDB\\Relational\nMigrator\\Data\\user.properties Downloaded JDBC Drivers c:\\Users\\<username>\\AppData\\Local\\MongoDB\\Relational Migrator\\Data\\Drivers Log files c:\\Users\\<username>\\AppData\\Local\\MongoDB\\Relational\nMigrator\\Data\\Logs\\migrator.log The file locations for the Linux OS: Configuration file ~/Migrator/user.properties Downloaded JDBC Drivers /opt/mongodb-relational-migrator/lib/app/lib Log files ~/Migrator/Logs/migrator.log Installation on a Single Machine Installation on an Unattended Server",
            "code": [],
            "preview": "Use Relational Migrator file locations when: modifying application configuration\nfiles, deploying additional JDBC drivers, or reviewing log files.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-a-single-machine/install-mac",
            "title": "Install on Mac",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a single Mac machine. This\ninstallation method uses default settings and binds Relational Migrator to a single\nIP and port. Download the latest MacOS Relational Migrator binary from the\n release page . Double-click the  MongoDB.Relational.Migrator-X.X.X.dmg  file. Drag the  MongoDB Relational Migrator.app  icon into the  /Applications  folder. (Optional) To connect to Oracle or MySQL drivers, download and place the drivers into your Relational Migrator directory. To download and install MySQL or Oracle drivers, see the following: MySQL: latest 8.0.x version, Platform Independent Version Oracle: 21.6.0.0 of odjbc11.jar from the Oracle 21c Copy the driver files to  /Library/Application Support/MongoDB/Relational Migrator/Drivers . Relational Migrator installs the JDBC drivers for SQL Server and PostgreSQL\nby default. Open Launchpad and search for  MongoDB Relational Migrator . Double-click the Relational Migrator icon to start the application. Create a Project Import a Project Relational Migrator File Locations Install on RHEL/CentOS Install on Ubuntu/Debian Install on Windows",
            "code": [],
            "preview": "You can install Relational Migrator on a single Mac machine. This\ninstallation method uses default settings and binds Relational Migrator to a single\nIP and port.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-a-single-machine/install-ubuntu",
            "title": "Install on Ubuntu",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a single Ubuntu or Debian machine. This\ninstallation method uses default settings and binds Relational Migrator to a single\nIP and port. Download the latest  .deb  binary from the\n release page . Install Relational Migrator. Change the directory to the Relational Migrator  app/lib  location. (Optional) To connect to Oracle or MySQL drivers, download and place the drivers\ninto your Relational Migrator directory. To download and install MySQL or Oracle drivers, see the following: MySQL: latest 8.0.x version, Platform Independent Version Oracle: 21.6.0.0 of odjbc11.jar from the Oracle 21c Copy the driver files to  /opt/mongodb-relational-migrator/lib/app/lib . To copy the driver, use the following example: Change the directory to the Relational Migrator  /bin  location and start the application. Create a Project Import a Project Relational Migrator File Locations Install on Mac Install on RHEL/CentOS Install on Windows",
            "code": [
                {
                    "lang": "bash",
                    "value": "sudo apt install ./mongodb-relational-migrator_X.X.X-1_amd64.deb"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/lib/app/lib"
                },
                {
                    "lang": "bash",
                    "value": "curl https://download.oracle.com/otn-pub/otn_software/jdbc/216/ojdbc11.jar -O -L -b -o"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/bin\n\n./mongodb-relational-migrator"
                }
            ],
            "preview": "You can install Relational Migrator on a single Ubuntu or Debian machine. This\ninstallation method uses default settings and binds Relational Migrator to a single\nIP and port.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "getting-started/atlas-log-in",
            "title": "Log In with Atlas",
            "headings": [
                "Before you Begin",
                "About this Task",
                "Steps",
                "Select a login option",
                "Enter your Atlas account credentials",
                "(Optional) Log out of Atlas account",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can optionally sign in to your Atlas account inside Relational\nMigrator. If you log in, you can access the\n Query Converter  feature and you can choose\ndestination clusters from a list when creating sync jobs. To log in with Atlas, you must have an existing  Atlas account . To log in with your Atlas account, Relational Migrator must be running\non localhost on one of the following ports: 8278 8080 443 If you run Relational Migrator on any ports numbers other than the\nones listed above or if your accessing Relational Migrator from a\nremote client, you will not be able to sign in to Atlas. You must reauthenticate when your session token expires. To\nreauthenticate to your Atlas account, follow the same log in procedure\nbelow. Depending on your Atlas login status the top-right profile section of\nthe Relational Migrator UI can change: Login Status Profile Section UI Signed Out Section shows a  Log In  button. Logged In The section shows a button with the first letter of the\nuser's name. Session expired The section shows a button with the first letter of the\nuser's name with a  . On the top right of the Relational Migrator home screen, click\nthe profile icon or the  Log in  button. The account\nlogin modal displays. Click the  \n Log in with Atlas  button. You can also initiate the log in process from the\n Code Generation  tab by clicking the\n   Log in with Atlas  button on the\n Query Converter  pane. Enter your  Email Address  and  Password ,\nthen click  Log in . Click on the profile icon on the top right and click\n   Log Out  to log out of your Atlas\naccount. Enable Query Converter Convert Queries Create an Atlas Cluster",
            "code": [],
            "preview": "You can optionally sign in to your Atlas account inside Relational\nMigrator. If you log in, you can access the\nQuery Converter feature and you can choose\ndestination clusters from a list when creating sync jobs.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-a-single-machine/install-windows",
            "title": "Install on Windows",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a single Windows machine. This installation\nmethod uses default settings and binds Relational Migrator to a single\nIP and port. Download the latest Windows Relational Migrator binary from the\n release page . Double-click the  MongoDB Relational Migrator-X.X.X.msi  file. When you are prompted with the MongoDB  Relational Migrator Setup Wizard ,\nclick  Next . Accept the license agreement and click  Next  to continue. Click  Install  to start your Migrator installation. Click  Finish  to exit the installer. (Optional) To connect to Oracle or MySQL drivers, download and place the drivers\ninto your Relational Migrator directory. To download and install MySQL or Oracle drivers, see the following: MySQL: latest 8.0.x version, Platform Independent Version Oracle: 21.6.0.0 of odjbc11.jar from the Oracle 21c Copy the driver files to  c:\\Users\\<username>\\AppData\\Local\\MongoDB\\Relational Migrator\\Data\\Drivers . Relational Migrator installs the JDBC drivers for SQL Server and PostgreSQL by\ndefault. Create a Project Import a Project Relational Migrator File Locations Install on Mac Install on RHEL/CentOS Install on Ubuntu/Debian",
            "code": [],
            "preview": "You can install Relational Migrator on a single Windows machine. This installation\nmethod uses default settings and binds Relational Migrator to a single\nIP and port.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-a-single-machine/install-rhel",
            "title": "Install on RHEL",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a single RHEL/CentOS machine. This\ninstallation method uses default settings and binds Relational Migrator to a single\nIP and port. Download the latest  .rpm  binary from the\n release page . Install Relational Migrator. Change the directory to the Relational Migrator  app/lib  location. (Optional) To connect to Oracle or MySQL drivers, download and place the drivers\ninto your Relational Migrator directory. To download and install MySQL or Oracle drivers, see the following: MySQL: latest 8.0.x version, Platform Independent Version Oracle: 21.6.0.0 of odjbc11.jar from the Oracle 21c Copy the driver files to  /opt/mongodb-relational-migrator/lib/app/lib . To copy the driver, use the following example: Change the directory to the Relational Migrator  /bin  location and start the application. Create a Project Import a Project Relational Migrator File Locations Install on Mac Install on Ubuntu/Debian Install on Windows",
            "code": [
                {
                    "lang": "bash",
                    "value": "sudo yum install mongodb-relational-migrator-X.X.X-1.x86_64.rpm"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/lib/app/lib"
                },
                {
                    "lang": "bash",
                    "value": "curl https://download.oracle.com/otn-pub/otn_software/jdbc/216/ojdbc11.jar -O -L -b -o"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/bin\n\n./mongodb-relational-migrator"
                }
            ],
            "preview": "You can install Relational Migrator on a single RHEL/CentOS machine. This\ninstallation method uses default settings and binds Relational Migrator to a single\nIP and port.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-a-single-machine/install-on-a-single-machine",
            "title": "Installation on a Single Machine",
            "headings": [
                "Use Cases",
                "Behavior",
                "Get Started",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a single machine. The single machine\ninstallation provides a simplified installation process by using default settings.\nThis installation method is a \"local\" install because Relational Migrator\ncannot be externally accessed and is bound to a single IP and port. Installing Migrator on a single machine is ideal for small developmental projects\nthat do not require not external access. The JDBC drivers must be downloaded separately, and placed into a dedicated\ndirectory after Relational Migrator is installed. This is required to connect to\nyour relational database. The JDBC driver directory is operating system specific\nand included in the installation instructions below. If you are migrating from a MySQL database: If you are migrating from an Oracle database: Download the  latest 8.0.x version, Platform Independent Version . Unzip the downloaded file and copy the  .jar  file into the target folder. Download  21.6.0.0 of odjbc11.jar from the Oracle 21c . (Optional) To migrate tables that contain the  XMLType  type, you must also download the\n xdb.jar  driver. Install on Windows Install on Mac Install on Ubuntu Install on RHEL Install on an Unattended Server Relational Migrator File Locations",
            "code": [],
            "preview": "You can install Relational Migrator on a single machine. The single machine\ninstallation provides a simplified installation process by using default settings.\nThis installation method is a \"local\" install because Relational Migrator\ncannot be externally accessed and is bound to a single IP and port.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/install-on-an-unattended-server",
            "title": "Installation on an Unattended Server",
            "headings": [
                "Use Case",
                "Behavior",
                "Get Started",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on an unattended server on both Linux\nand Windows systems. The unattended server installation binds Relational\nMigrator to any IP and port on the server and exposes it as a web application. Installing Relational Migrator on an unattended server is ideal for larger\nproduction-scale migration projects. It is recommended that the unattended server installation is supplemented with\nTLS/SSL configuration because Relational Migrator can be bound to any IP and port on\nthe server. When you install Relational Migrator on an unattended server, you can set up\nRelational Migrator to run as a system service. As a system service, Relational\nMigrator automatically starts when the server starts. When you install Relational Migrator on an unattended server, you can enable\nexternal access to Relational Migrator on Windows. By enabling external access,\nincoming connections are allowed on the same port as Relational Migrator. Windows Server Installation RHEL/CentOS Server Installation Debian Server Installation Install on a Single Machine Relational Migrator File Locations",
            "code": [],
            "preview": "You can install Relational Migrator on an unattended server on both Linux\nand Windows systems. The unattended server installation binds Relational\nMigrator to any IP and port on the server and exposes it as a web application.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/rhel-centos-server-installation/rhel-system-service",
            "title": "Run Relational Migrator as a System Service on RHEL/CentOS",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "When you install Relational Migrator on a RHEL/CentOS server, you can also\nset up Relational Migrator to run as a system service. By running Relational Migrator as\na system service, Relational Migrator automatically starts when the server starts. Create a  /etc/systemd/system/migrator.service  file. Copy the text below into the  /etc/systemd/system/migrator.service  file.\nReplace the binary path as needed. Reload  systemd  to read the newly created service: Enable the Relational Migrator service to run on startup and start for the current session. You can manage the service with  systemctl  commands. To run on startup and\nstart the current session, run the following: Create a Project Import a Project Debian Systems Installation Windows Server Installation",
            "code": [
                {
                    "lang": null,
                    "value": "[Unit]\nDescription=MongoDB Relational Migrator\n\n[Service]\nExecStart=\"/opt/mongodb-relational-migrator/bin/MongoDB Relational Migrator\"\n\n[Install]\nWantedBy=multi-user.target"
                },
                {
                    "lang": null,
                    "value": "systemctl daemon-reload"
                },
                {
                    "lang": null,
                    "value": "systemctl enable migrator.service\n\nsystemctl start migrator.service"
                }
            ],
            "preview": "When you install Relational Migrator on a RHEL/CentOS server, you can also\nset up Relational Migrator to run as a system service. By running Relational Migrator as\na system service, Relational Migrator automatically starts when the server starts.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/rhel-centos-server-installation/rhel-centos-server-installation",
            "title": "RHEL/CentOS Systems Installation",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "Install Relational Migrator on an unattended server in a Linux systems. For instructions\non installation and configuration, see the installation tasks. Install on RHEL/CentOS Run Relational Migrator as a System Service on RHEL/CentOS",
            "code": [],
            "preview": "Install Relational Migrator on an unattended server in a Linux systems. For instructions\non installation and configuration, see the installation tasks.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/debian-server-installation/debian-server-installation",
            "title": "Debian Systems Installation",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "Install Relational Migrator on an unattended server in a Linux systems. For instructions\non installation and configuration, see the installation tasks. Install on Debian Run Relational Migrator as a System Service on Debian",
            "code": [],
            "preview": "Install Relational Migrator on an unattended server in a Linux systems. For instructions\non installation and configuration, see the installation tasks.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/debian-server-installation/debian-system-service",
            "title": "Run Relational Migrator as a System Service on Debian",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "When you install Relational Migrator on a Debian server, you can also set up\nRelational Migrator to run as a system service. By running Relational Migrator as\na system service, Relational Migrator automatically starts when the server starts. Create a  /etc/systemd/system/migrator.service  file. Copy the text below into the  /etc/systemd/system/migrator.service  file. Replace\nthe binary path as needed. Reload  systemd  to read the newly created service. Enable the Relational Migrator service to automatically start when the server starts. You can manage the service with the following  systemctl  commands: Create a Project Import a Project RHEL/CentOS Systems Installation Windows Server Installation",
            "code": [
                {
                    "lang": null,
                    "value": "[Unit]\nDescription=MongoDB Relational Migrator\n\n[Service]\nExecStart=\"/opt/mongodb-relational-migrator/bin/MongoDB Relational Migrator\n\n[Install]\nWantedBy=multi-user.target"
                },
                {
                    "lang": null,
                    "value": "systemctl daemon-reload"
                },
                {
                    "lang": null,
                    "value": "systemctl enable migrator.service\n\nsystemctl start migrator.service"
                }
            ],
            "preview": "When you install Relational Migrator on a Debian server, you can also set up\nRelational Migrator to run as a system service. By running Relational Migrator as\na system service, Relational Migrator automatically starts when the server starts.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/debian-server-installation/install-debian-server",
            "title": "Install On Debian",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a Debian server. This installation method\nallows Relational Migrator to run on an unattended server. By running on an\nunattended server, Relational Migrator binds to any IP and port on the server\nand is exposes it as a web application. Download the latest  .deb  binary from the  release page . Install Relational Migrator. Change the directory to the Relational Migrator  app/lib  location. (Optional) To connect to Oracle or MySQL drivers, download and place the drivers\ninto your Relational Migrator directory. For more information, see  Install on a Single Machine . To download and install MySQL or Oracle drivers, see the following: MySQL: latest 8.0.x version, Platform Independent Version Oracle: 21.6.0.0 of odjbc11.jar from the Oracle 21c Copy the driver files to  /opt/mongodb-relational-migrator/lib/app/lib . To copy the driver, use the following example: Change the directory to the Relational Migrator  /bin  location and start the application. Enable Relational Migrator to run as an unattended standalone server. In your  user.properties  file, uncomment  spring.profiles.active: unattended . (Optional) Update TLS/SSL configuration properties. In your  user.properties  file, uncomment and update TLS/SSL configuration\nproperties. It is recommended that the unattended server installation is supplemented with\nTLS/SSL configuration because Relational Migrator can be bound to any IP and port on\nthe server. For additional information, see  TLS/SSL Configuration Properties . (Optional) Update the port that Relational Migrator runs on. By default, Relational Migrator is configured to run on port 8278. To change\nthe port Relational Migrator runs on (for example to port 80 for HTTP or port 443 for\nHTTPS), update the  server.port  line in your  user.properties  file to specify\nyour preferred port. Run Relational Migrator using the binary. The  bin  directory can typically be found at  /opt/mongodb-relational-migrator/bin .\nTo run Relational Migrator using the binary, run the following: (Optional) Check logs for errors or other information. The logs are located in  ~/Migrator/Logs/migrator.log . When running Relational Migrator as a system service, the path is under\nthe service user\u2019s home directory. Run Relational Migrator as a System Service on Debian Create a Project Import a Project Relational Migrator File Locations RHEL/CentOS Systems Installation Windows Server Installation",
            "code": [
                {
                    "lang": "bash",
                    "value": "sudo apt install ./mongodb-relational-migrator_X.X.X-1_amd64.deb"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/lib/app/lib"
                },
                {
                    "lang": "bash",
                    "value": "curl https://download.oracle.com/otn-pub/otn_software/jdbc/216/ojdbc11.jar -O -L -b -o"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/bin\n\n./mongodb-relational-migrator"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/bin\n\n./mongodb-relational-migrator"
                }
            ],
            "preview": "You can install Relational Migrator on a Debian server. This installation method\nallows Relational Migrator to run on an unattended server. By running on an\nunattended server, Relational Migrator binds to any IP and port on the server\nand is exposes it as a web application.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/windows-server-installation/windows-external-access",
            "title": "Enable External Access to Relational Migrator on Windows",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "Enable external access to Relational Migrator on Windows. By enabling external\naccess, incoming connections are allowed on the same port as Relational Migrator. Open Windows Defender Firewall with Advanced Security. Select  Inbound Rules . Click  New Rule . Select  Port . Click  Next . Select  TCP, Specific Local Ports , and enter the port number. Click\n Next . Select  Allow the connection . Click  Next . Select the desired network profiles. Click  Next . Enter a name for the rule. Click  Finish . Run Relational Migrator as a System Service on Windows Create a Project Import a Project Debian Systems Installation RHEL/CentOS Systems Installation",
            "code": [],
            "preview": "Enable external access to Relational Migrator on Windows. By enabling external\naccess, incoming connections are allowed on the same port as Relational Migrator.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/rhel-centos-server-installation/install-rhel-server",
            "title": "Install On RHEL Server",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "You can install Relational Migrator on a RHEL/CentOS server. This installation\nmethod allows Relational Migrator to run on an unattended server. By running on an\nunattended server, Relational Migrator binds to any IP and port on the server\nand is exposes it as a web application. Download the latest  .deb  binary from the  release page . Install Relational Migrator. Change the directory to the Relational Migrator  app/lib  location. (Optional) To connect to Oracle or MySQL drivers, download and place the drivers\ninto your Relational Migrator directory. For more information, see  Install on a Single Machine . To download and install MySQL or Oracle drivers, see the following: MySQL: latest 8.0.x version, Platform Independent Version Oracle: 21.6.0.0 of odjbc11.jar from the Oracle 21c Copy the driver files to  /opt/mongodb-relational-migrator/lib/app/lib . To copy the driver, use the following example: Change the directory to the Relational Migrator  /bin  location and start the application. Enable Relational Migrator to run as an unattended standalone server. In your  user.properties  file, uncomment  spring.profiles.active: unattended . (Optional) Update TLS/SSL configuration properties. In your  user.properties  file, uncomment and update TLS/SSL configuration\nproperties. It is recommended that the unattended server installation is supplemented with\nTLS/SSL configuration because Relational Migrator can be bound to any IP and port on\nthe server. For additional information, see  SSL Configuration Properties . (Optional) Update the port that Relational Migrator runs on. By default, Relational Migrator is configured to run on port 8278.\nTo change the port Relational Migrator runs on, update the  server.port  line\nin your  user.properties  file to specify your preferred port. Run Relational Migrator using the binary. The  bin  directory can typically be found at  /opt/mongodb-relational-migrator/bin . To run Relational Migrator using the binary, run the following: (Optional) Check logs for errors or other information. The logs are located in  ~/Migrator/Logs/migrator.log . When running Relational Migrator as a system service, the path is under\nthe service user\u2019s home directory. Run Relational Migrator as a System Service on RHEL/CentOS Create a Project Import a Project Relational Migrator File Locations Debian Systems Installation Windows Server Installation",
            "code": [
                {
                    "lang": "bash",
                    "value": "sudo yum install mongodb-relational-migrator-X.X.X-1.x86_64.rpm"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/lib/app/lib"
                },
                {
                    "lang": "bash",
                    "value": "curl https://download.oracle.com/otn-pub/otn_software/jdbc/216/ojdbc11.jar -O -L -b -o"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/bin\n\n./mongodb-relational-migrator"
                },
                {
                    "lang": "bash",
                    "value": "cd /opt/mongodb-relational-migrator/bin\n\n./mongodb-relational-migrator"
                }
            ],
            "preview": "You can install Relational Migrator on a RHEL/CentOS server. This installation\nmethod allows Relational Migrator to run on an unattended server. By running on an\nunattended server, Relational Migrator binds to any IP and port on the server\nand is exposes it as a web application.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/windows-server-installation/windows-server-installation",
            "title": "Windows Server Installation",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "Install Relational Migrator on an unattended server in a Windows systems. For\ninstructions on installation and configuration, see the installation tasks. Install on Windows Run Relational Migrator as a System Service on Windows Enable External Access to Relational Migrator on Windows",
            "code": [],
            "preview": "Install Relational Migrator on an unattended server in a Windows systems. For\ninstructions on installation and configuration, see the installation tasks.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/windows-server-installation/install-windows-server",
            "title": "Install on Windows",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "Install Relational Migrator to run as an unattended server on Windows. By running\nas an unattended server, Relational Migrator binds to any IP and port on the server\nand is exposes it as a web application. Log in to the server. You can log into the server interactively or using Remote Desktop Protocol (RDP).\nFor more information on logging into the server using Remote Desktop Protocol (RDP),\nsee  Connect to your Windows Instances using RDP . Download the Relational Migrator  .msi  installer. Download the Relational Migrator  .msi  installer to the target machine or\nremotely copy it over to the instance. Find the latest Relational Migrator\ninstaller on the  release page . Launch the installer and follow the single machine  install instructions . Enable Relational Migrator to run as an unattended server. In your  user.properties  file, uncomment  spring.profiles.active: unattended .\nYour  user.properties  file is located in\n C:\\Users\\<Username>\\AppData\\Local\\mongodb\\Relational Migrator\\Data . (Optional) Update TLS/SSL configuration properties. In your  user.properties  file, uncomment and update TLS/SSL configuration properties. It is recommended that the unattended server installation is supplemented with\nTLS/SSL configuration because Relational Migrator can be bound to any IP and port on\nthe server. For additional information, see  TLS/SSL Configuration Properties . (Optional) Update the port that Relational Migrator runs on. By default, Relational Migrator is configured to run on port 8278.\nTo change the port Relational Migrator runs on, update the  server.port  line\nin your  user.properties  file to specify your preferred port. Run Relational Migrator from its installed location or any shortcuts that were\ncreated during the installation process. (Optional) Check logs for errors or other information. The logs are located in  C:\\Users\\<Username>\\AppData\\Local\\mongodb\\Relational Migrator\\Data\\Logs . When running Relational Migrator as a system service, the path is under the\nservice user\u2019s home directory. The local system user\u2019s profile is located\nat  C:\\Windows\\System32\\config\\systemprofile . Enable External Access to Relational Migrator on Windows Run Relational Migrator as a System Service Create a Project Import a Project Debian Systems Installation RHEL/CentOS Systems Installation Relational Migrator File Locations",
            "code": [],
            "preview": "Install Relational Migrator to run as an unattended server on Windows. By running\nas an unattended server, Relational Migrator binds to any IP and port on the server\nand is exposes it as a web application.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "installation/install-on-an-unattended-server/windows-server-installation/windows-system-service",
            "title": "Run Relational Migrator as a System Service on Windows",
            "headings": [
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "When you install Relational Migrator on a Windows server, you can set up Relational\nMigrator to run as a system service. By running Relational Migrator as a system\nservice, Relational Migrator automatically starts when the server starts. Launch the Service Manager of your choice. These steps use  NSSM  (a free service manager utility). From a command prompt, run  .\\nssm install RelationalMigrator . From the  Application  tab, choose the path and startup directory\nof the installed  MongoDB Relational Migrator.exe . From the  Details  tab, enter  MongoDB Relational Migrator \nas the service\u2019s display name. From the  Log on  tab, keep the default local system account or\nchoose a specific account to run the service under. Click  Install service . Launch  services.msc . Find the newly installed MongoDB Relational Migrator service and click\n Start Service . When the startup mode is  Automatic , the service starts automatically when\nthe computer next restarts. Enable External Access to Relational Migrator on Windows Create a Project Import a Project Debian Systems Installation RHEL/CentOS Systems Installation",
            "code": [],
            "preview": "When you install Relational Migrator on a Windows server, you can set up Relational\nMigrator to run as a system service. By running Relational Migrator as a system\nservice, Relational Migrator automatically starts when the server starts.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/manage-diagrams",
            "title": "Manage Diagrams",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "The following pages outline the details and specifics of how to manage\ndiagrams in Relational Migrator. Create a Diagram Clone a Diagram Rename a Diagram Delete a Diagram",
            "code": [],
            "preview": "The following pages outline the details and specifics of how to manage\ndiagrams in Relational Migrator.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/diagrams",
            "title": "Diagrams",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "Diagrams function as an Entity Relationship Diagram (ERD) tool to\nvisualize tables, foreign key relationships, and data types. Diagrams\nhelp you understand the relational database's schema, and show you how\nto best represent relational data in MongoDB. Diagrams also show how\nyour mapping rules shape the target MongoDB schema. When you finish  creating a migration project , Relational Migrator creates a new diagram\nbased on your project's mapping rules. The diagram is comprised of two\nviews: When you  edit mapping rules  for your\nproject, the MongoDB view automatically updates to reflect the new\nrules. The relational view is unaffected by mapping rules, and only changes\nwhen you update your project's data model. A Relational view, representing the tables in your relational\ndatabase A MongoDB view, representing the collections in your target MongoDB\ndatabase You can also use  Hackolade  to\nvisualize your schemas. Hackolade is a visual data modeling tool. You can explore\nschemas in Hackolade by importing a Relational Migrator\n.relmig file. For details, see  the Hackolade help article . Understand Diagrams Create a Diagram Navigate Diagrams and Entities Apply a Layout to a Diagram",
            "code": [],
            "preview": "Diagrams function as an Entity Relationship Diagram (ERD) tool to\nvisualize tables, foreign key relationships, and data types. Diagrams\nhelp you understand the relational database's schema, and show you how\nto best represent relational data in MongoDB. Diagrams also show how\nyour mapping rules shape the target MongoDB schema.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/apply-layout",
            "title": "Apply a Layout to a Diagram",
            "headings": [
                "About this Task",
                "Steps",
                "Layout Options"
            ],
            "paragraphs": "You can apply a preset layout to your diagram to organize its entities.\nUse diagram layouts to neatly arrange entities without needing to\nmanually click and drag them. When you apply a layout to a diagram, Relational Migrator applies the\nlayout to both the Relational and MongoDB views. The zoom level is\nautomatically adjusted to display your chosen layout. Click the tree diagram icon at the top-left of the  diagram  view. Choose your layout. Relational Migrator offers three layout options.\nExamples of each layout option are shown in the following tabs:",
            "code": [],
            "preview": "You can apply a preset layout to your diagram to organize its entities.\nUse diagram layouts to neatly arrange entities without needing to\nmanually click and drag them.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/navigate-diagrams",
            "title": "Navigate Diagrams and Entities",
            "headings": [
                "Change the Active Diagram",
                "Navigate Diagram Entities",
                "Pan Mode",
                "Multi-Select Mode",
                "Get Started"
            ],
            "paragraphs": "This page describes how to navigate your project's diagrams and\nentities. After you  create a project , Relational\nMigrator creates an initial diagram containing the entities and\nrelationships in the Relational and MongoDB models. If you have a large data model, you can create additional diagrams to\nseparate the model into smaller subsets. When you have multiple diagrams\nin your project, Relational Migrator lists the diagram names in tabs at\nthe top of the workspace. Diagram tabs appear in the order that the diagrams were created. You\ncannot reorder diagram tabs. The active diagram is the diagram currently displayed by Relational\nMigrator. To change the active diagram, click the tab for the diagram you want to\nview. Diagrams are made up of entities. An entity is either a Relational or\nMongoDB database object. Relational Migrator provides these modes for navigating entities in a\ndiagram: Pan Mode Multi-Select Mode In Pan Mode, you can click and drag the diagram to navigate to different\nareas. When you click a diagram entity, Relational Migrator shows\nmapping details for that entity in the right pane. Pan Mode is the default view mode. When you are in Pan Mode, Relational\nMigrator highlights the arrow icon at the top of the diagram. In Multi-Select Mode, you can select multiple diagram entities by\nclicking and dragging the diagram to create a select box. When you\nselect multiple entities, Relational Migrator shows the selected\nentities in the right pane. When multiple entities are selected, you\ncannot see any mapping details. To enter Multi-Select Mode, press and hold  Shift . When you are in\nMulti-Select Mode, Relational Migrator highlights the box icon at the\ntop of the diagram. When you release the shift key, Relational Migrator\nreturns to Pan Mode. Apply a Layout to a Diagram",
            "code": [],
            "preview": "This page describes how to navigate your project's diagrams and\nentities.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/working-with-entities/delete-entities",
            "title": "Delete Entities",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Select one or more entities to delete from your Relational or MongoDB\nmodel. Deleting entities allows you to: Customize the size of your diagram. Focus on entities you select. Visualize your relational database's schema to help determine how to best\nrepresent your data in MongoDB. You can revert any deletion. Deleting an entity on the  Relational Model  is the equivalent of removing a\ntable from the project's model. To revert this change, re-add the table to the  Manage Relational Model \ndialog. See  manage the relational model . Deleting an entity on the  MongoDB Model  is the equivalent of removing all\nmappings to that collection. To revert this change, re-add a  new documents mapping rule  from\nthe source table. Select the entities , and press\ndelete on your keyboard. Relational Migrator prompts removal commands that include either removing the\nentity from the model or hiding the entity from the diagram. You can also right-click the entities and select  Remove Entity  to prompt\nremoval commands. Specify where you want to delete the entity.\nSelect  Remove from relational model  or  Remove from MongoDB model . Click  Remove x tables  or  Remove x collections .\nThe button is modified to reflect what you have selected to delete. Move Entities Copy Entities Toggle Visibility of Entities",
            "code": [],
            "preview": "Select one or more entities to delete from your Relational or MongoDB\nmodel. Deleting entities allows you to:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/working-with-entities/copy-entities",
            "title": "Copy Entities",
            "headings": [
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Select one or more entities to copy to a different diagram. You\ncan copy the entities to a newly created diagram or to a different existing\ndiagram. Copying entities lets you customize diagrams to help you visualize\nthe different ways your data can be represented in MongoDB. From the  Diagram  view or  Schema model  pane,\n select the entities  you want to copy. Right click and select  Copy entities to . You can also click the ellipsis menu in the top-right pane and select  Copy entities to . Select one of the following options to copy your entities to: If you want to Then Result Copy entities to an existing diagram. Select the existing diagram name in the  Target diagram  drop-down. The copied entities are displayed with the other pre-existing entities in the diagram. Create a new diagram and copy entities to it. Select  Create new diagram  in the  Target diagram  drop-down. Only the copied entities are displayed in the new diagram. Click the green  Copy entities  button. Understand Diagrams Navigate Diagrams and Entities Move Entities Toggle Visibility of Entities Delete Entities",
            "code": [],
            "preview": "Select one or more entities to copy to a different diagram. You\ncan copy the entities to a newly created diagram or to a different existing\ndiagram. Copying entities lets you customize diagrams to help you visualize\nthe different ways your data can be represented in MongoDB.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/working-with-entities/hide-entities",
            "title": "Toggle Visibility of Entities",
            "headings": [
                "About this Task",
                "Changing Visibility Can Affect the Opposite View",
                "Hide Entities using the Schema Model Pane",
                "Hide Entities using a Diagram",
                "Showing Entities",
                "Learn More"
            ],
            "paragraphs": "You can show or hide entities in your diagrams. Showing and hiding entities only\naffects the current diagram and does not affect the model. By toggling the visibility\nof entities, you can focus your attention on specific entities and relationships\nand reduce clutter in your diagram. The visibility of an entity: Changing the visibility of an entity does not affect the placement of\nother entities in the diagram. Applies  per diagram . If you have multiple diagrams, toggling the\nvisibility of an entity in one diagram does not affect that entity in\nother diagrams. Persists as part of the diagram. For example, if you hide an entity,\nthat entity remains hidden when you reload the diagram. Changing the visibility of an entity in one view (either the Relational\nor MongoDB view) can affect the visibility of entities in the other\nview. Specifically: When you hide an entity, any entities from the opposite view that are\nlinked to the current entity with mapping rules are automatically\nhidden, provided those linked entities are not also linked to other\nvisible entities in the original view. When you revert the hiding of an entity, any entities from the opposite view\nthat are linked to the current entity with mapping rules are automatically\nunhidden. To hide an entity, hover over the entity in the  Schema Model  pane and click\nthe eye icon. An open eye icon indicates that the entity is visible. An eye icon with a line through it indicates that the entity is hidden. Select the entities  you want to hide. Press the  delete  key on your keyboard. Relational Migrator prompts\nremoval commands. Select  Hide from the diagram . Click the red  Hide  button. You can also right-click an entity and select  Hide entity \nto hide it. You can show hidden entities in both collections and tables. To show hidden entities, in the  Schema Model  pane, click they eye symbol next\nto the collection or table you want to be visible in your diagram. The open eye\nicon indicates that the entity is visible. Move Entities to Different Diagram Copy Entities to Different Diagrams Delete Entities",
            "code": [],
            "preview": "You can show or hide entities in your diagrams. Showing and hiding entities only\naffects the current diagram and does not affect the model. By toggling the visibility\nof entities, you can focus your attention on specific entities and relationships\nand reduce clutter in your diagram.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/working-with-entities/move-entities",
            "title": "Move Entities",
            "headings": [
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can select one or more entities and move them to a different diagram. You\ncan move the entities to a newly created diagram or to a different existing\ndiagram. Moving entities lets you customize diagrams to help you visualize\nthe different ways your data can be represented in MongoDB. Select the entities  you want to move. To view commands for your entities, click the ellipsis menu in the right pane. You can also right-click the entities to view commands. Click  Move entities to . Choose how to move the entities. You can choose to move your entities to an existing diagram  or  you can\nchoose to create a new diagram to move your entities to. Move the entities to the selected diagram. The selected entities are hidden in the original diagram and are displayed\nin the diagram they are moved to. If you selected an existing diagram, the moved entities are displayed\nwith the other pre-existing entities in the diagram. If you selected  Create new diagram , only the moved entities are displayed. Copy Entities to Different Diagrams Hide Entities Delete Entities",
            "code": [],
            "preview": "You can select one or more entities and move them to a different diagram. You\ncan move the entities to a newly created diagram or to a different existing\ndiagram. Moving entities lets you customize diagrams to help you visualize\nthe different ways your data can be represented in MongoDB.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/working-with-entities/select-entities",
            "title": "Select Entities",
            "headings": [
                "Select Entities in Diagram View",
                "Select Individual Entities",
                "Select Multiple Entities",
                "Select Entities in Schema Model Pane",
                "Select Individual Entities",
                "Select Multiple Entities",
                "Clear Selected Entities",
                "Learn More"
            ],
            "paragraphs": "You can select one or more entities. You can select entities either in the\n diagram view  or in the  schema model  pane.\nAfter you select your entities, you can move, copy, delete, or hide your selected\nentities. To select entities  individually  in the diagram view, click an entity to select\nit. To add entities to the existing selection, hold the  command  (Mac) key or the\n ctrl  (Windows/Linux) key. To select  multiple entities  at once in the diagram view, hold the  Shift \nkey and draw a box around all the entities you want to select. To select entities  individually  in the left pane, click an entity to select it. To add entities to the existing selection, hold the  command  (Mac) key or the\n ctrl  (Windows/Linux) key. To select  multiple entities  at once in the left pane, hold the  Shift  key\nand select two entities. All entities in between the two selected entities are\nadded to the selection. You can clear selected entities in the following ways: Hold down the  command  (Mac) key or the  ctrl  (Windows/Linux)\nkey and click an entity to remove. Press the  esc  key to clear all entities. Click the diagram background to clear all entities. Move Entities Copy Entities Toggle Visibility of Entities Delete Entities",
            "code": [],
            "preview": "You can select one or more entities. You can select entities either in the\ndiagram view or in the schema model pane.\nAfter you select your entities, you can move, copy, delete, or hide your selected\nentities.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/understand-diagrams",
            "title": "Understand Diagrams",
            "headings": [
                "Relational View",
                "MongoDB View",
                "Choose View Mode",
                "Color Coding",
                "Entity Links",
                "Relational and MongoDB View Links",
                "Example",
                "Relational View",
                "MongoDB View",
                "New Mapping Rules"
            ],
            "paragraphs": "This page explains how to interpret diagrams created in the Relational\nMigrator. Each diagram is comprised of two views, one for your\nrelational database and one for your MongoDB database. The views show\nthe relationships between entities in your databases. In the relational view, each box represents a table in your\nrelational database. The box title indicates the table name. Each box lists the columns in the corresponding table. For each column,\nthe box indicates the column name and its data type. Some columns have icons to indicate their role within the table: A key icon indicates the table's primary key. A link icon indicates a foreign key. In the MongoDB view, each box represents a collection in your\nMongoDB database. The box title indicates the collection name. Each box lists the fields in the corresponding collection. For each\nfield, the box indicates the field name and its data type. If a collection contains embedded documents or arrays, those fields are\nshown in-line in the same collection. Some fields have icons to indicate their role within the table: A key icon indicates the collection's  _id  field. When you use the\n wrapped  key handling strategy, the  _id  field contains\nsub-fields. In this case, the box contains multiple key icons which\napply to a single field. A link icon indicates that the field maps to a relational column used\nin a foreign key. The Relational Migrator provides different view modes for your diagrams:\nHorizontal Split, Vertical Split, Relational view, and MongoDB view. To switch view modes, click a view mode option in the left navigation\nbar: View Mode Description Horizontal Split Displays the relational view on top and the MongoDB view is on\nthe bottom. When you create a new project, Horizontal Split is\nthe default view mode. Vertical Split Displays the relational view on the left and the MongoDB view on\nthe right. Relational View Displays only your relational database diagram. MongoDB View Displays only your MongoDB database diagram. Entities in the diagram are color-coded based on whether they represent\nthe relational or MongoDB database: Entities with pink highlights are relational tables. Entities with green highlights are MongoDB collections. The lines between boxes represent the relationships that connect\ndatabase entities. If two boxes are connected, the corresponding\nentities are linked with a foreign key. The lines may show the following\nfeatures of relationships: A small bar across a relationship link indicates a one-to-one\nrelationship between entities. A prong (or \"crow's feet\") indicates \"many\" in the relationship. When you click a box in either the relational or MongoDB view, the\nRelational Migrator highlights the corresponding entity in the opposite\nview. This allows you to see how your relational tables and MongoDB\ncollections are mapped to one another. The following example shows a sample diagram for a database that\ntracks orders at a store. This relational view shows the relationship of several tables within a\nrelational database: The view shows the following relationships: In the  Order  table,  OrderID  is the primary key.  CustomerID  and\n OrderStatusID  are foreign keys. The  Customer  and  OrderStatus \ntables contain the references for these foreign keys, respectively. Order  to  Customer  and  Order  to  OrderStatus  are both\nmany-to-one relationships: A customer can have multiple orders, and each order only applies\nto a single customer. In this example, Order is the parent and\nCustomer is the child. An order status can apply to multiple orders, and each order only\nhas a single order status. In this example, Order is the parent\nand OrderStatus is the child. In the  OrderLine  table,  OrderLineID  is the primary key.  OrderID \nand  ProductID  are foreign keys. The  Order  and  Product  tables\ncontain the references for these foreign keys, respectively. OrderLine  to  Order  and  OrderLine  to  Product  are both\nmany-to-one relationships: An order line is an individual transaction within an order. An\norder can have multiple order lines, and each order line applies\nto a single order. In this example, OrderLine is the parent and\nOrder is the child. A product can apply to multiple order lines, and each order line\ncontains a single product. In this example, OrderLine is the parent\nand Product is the child. This MongoDB view corresponds to the previous Relational view: The collections and data types presented in the view reflect the\nmapping rules specified for the project. The link icons indicate fields which map to a relational column used in a\nforeign key. For example, in the  Order  collection, the  OrderStatusID \nfield represents a foreign key that links the  Order  and  OrderStatus \ntables. The following new mapping rules have been created to better utilize\nMongoDB's embedded data model: Both of the preceding mapping rules remove the ID fields from the\nmapping. Since the  OrderLines  and  Orders  fields are embedded in\ntheir parent fields rather than being referenced with a foreign key, the\nID fields are not required to link the fields together. The  Order  collection contains a rule that maps  OrderLines  as\nan  Embedded array . The\n OrderLine  table from the relational schema is mapped as an array\nof objects inside the  Order  documents, using the foreign key\nrelationship from the relational schema. The  Customer  collection contains a rule which maps  Orders  as\nan  Embedded array . The  Order \ntable from the relational schema is mapped as an array of objects\ninside the  Customer  documents, using the foreign key relationship\nfrom the relational schema.",
            "code": [],
            "preview": "This page explains how to interpret diagrams created in the Relational\nMigrator. Each diagram is comprised of two views, one for your\nrelational database and one for your MongoDB database. The views show\nthe relationships between entities in your databases.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/navigate-diagrams/working-with-entities/working-with-entities",
            "title": "Working with Entities",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "After you  create a project , Relational Migrator creates an\ninitial diagram containing the entities and relationships in\nthe Relational and MongoDB models. The term \"entity\" refers to either a table in\nthe relational model, or a collection in the MongoDB model. You can move and\nmodify entities to customize your initial diagram and create additional diagrams. Select Entities Move Entities Copy Entities Toggle Visibility of Entities Delete Entities",
            "code": [],
            "preview": "After you create a project, Relational Migrator creates an\ninitial diagram containing the entities and relationships in\nthe Relational and MongoDB models. The term \"entity\" refers to either a table in\nthe relational model, or a collection in the MongoDB model. You can move and\nmodify entities to customize your initial diagram and create additional diagrams.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/manage-diagrams/delete-diagrams",
            "title": "Delete a Diagram",
            "headings": [
                "About this Task",
                "Steps",
                "Navigate to the diagram you want to delete",
                "Open the Diagram Properties pane",
                "Click the  button in the Diagram Properties pane",
                "Click the Delete Diagram option",
                "Click the Delete Diagram button in the confirmation box.",
                "Learn More"
            ],
            "paragraphs": "You can delete diagrams on the  Mapping  screen. Relational Migrator requires at least one diagram in your project. You\nmust have at least two diagrams before you can delete a diagram. Click the name of the diagram in the Diagram Toolbar to display the\ndiagram. Click the   arrow button to open\nthe  Diagram Properties  pane. The  Diagram Properties  pane displays the active diagram name and\nnotes. A menu opens. A confirmation box opens. Once you confirm that you want to delete the selected diagram,\nRelational Migrator deletes the diagram. This step cannot be\nundone. Create a Diagram Rename a Diagram Clone a Diagram",
            "code": [],
            "preview": "You can delete diagrams on the Mapping screen.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/manage-diagrams/rename-diagrams",
            "title": "Rename a Diagram",
            "headings": [
                "About this Task",
                "Steps",
                "Navigate to the diagram you want to rename",
                "Open the Diagram Properties pane",
                "Enter your new diagram name in the Name box",
                "Learn More"
            ],
            "paragraphs": "You can rename diagrams on the  Mapping  screen. Relational\nMigrator displays diagram names on the Diagram Toolbar. You can rename diagrams to customize your diagram properties. Relational Migrator displays your diagram names on the Diagram Toolbar\nof the  Mapping  screen and in the  Diagram\nProperties  pane. In the Diagram Toolbar, click the name of the diagram to display the\ndiagram. Click the   arrow button to open\nthe  Diagram Properties  pane. The  Diagram Properties  pane displays the active\ndiagram name and notes. By default, Relational Migrator names\ndiagrams in the order they were created and leaves the notes field\nempty. When you click outside the Name box, Relational Migrator\nautomatically saves your new diagram name and updates the Diagram\nToolbar. Create a Diagram Clone a Diagram Delete a Diagram",
            "code": [],
            "preview": "You can rename diagrams on the Mapping screen. Relational\nMigrator displays diagram names on the Diagram Toolbar.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/manage-diagrams/create-diagrams",
            "title": "Create a Diagram",
            "headings": [
                "About this Task",
                "Steps",
                "Click the  button on the Diagram Toolbar",
                "Learn More"
            ],
            "paragraphs": "You can create new diagrams on the  Mapping  screen of\nRelational Migrator. You can also create multiple diagrams and navigate\nbetween them to view specific entities of your data model. By default,\nRelational Migrator creates the  Main Diagram  with a\nRelational view and a MongoDB view. Creating diagrams allows you to visualize tables, foreign key\nrelationships, and data types. After you create a diagram, you can\n clone ,  rename ,\nand  delete  your new diagram. You must have at least one digram on your Diagram Toolbar. Relational Migrator includes diagrams when you import and export\nprojects. A new blank diagram opens. By default, the diagram view pane hides\nall entities in the project. Relational Migrator displays the new\ndiagram on the  Mapping  screen. Diagram tabs appear in the order that the diagrams were created. You\ncannot reorder diagram tabs. Clone a Diagram Rename a Diagram Delete a Diagram",
            "code": [],
            "preview": "You can create new diagrams on the Mapping screen of\nRelational Migrator. You can also create multiple diagrams and navigate\nbetween them to view specific entities of your data model. By default,\nRelational Migrator creates the Main Diagram with a\nRelational view and a MongoDB view.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "diagrams/manage-diagrams/clone-diagrams",
            "title": "Clone a Diagram",
            "headings": [
                "About this Task",
                "Steps",
                "Navigate to the diagram you want to clone",
                "Open the Diagram Properties pane",
                "Click the  button in the Diagram Properties pane",
                "Click the Duplicate Diagram option"
            ],
            "paragraphs": "You can clone existing diagrams on the  Mapping  screen of\nRelational Migrator. You can clone one or more diagrams to create new diagrams that contain\nthe same entities as existing diagrams. Once you clone a diagram, you can edit,  rename , and  delete  your new\ndiagram. Click the name of the diagram in the Diagram Toolbar to display the\ndiagram. Click the   arrow button to open the\n Diagram Properties  pane. The  Diagram Properties  pane displays the active diagram name and\nnotes. A menu opens. A new diagram with the same entities as the duplicated diagram\nopens. The visibility of entities on your new diagram is identical\nto the duplicated diagram. Relational Migrator does not clone the duplicated diagram's\nname and notes to the new diagram.",
            "code": [],
            "preview": "You can clone existing diagrams on the Mapping screen of\nRelational Migrator.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/projects",
            "title": "Projects",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "To interact with Relational Migrator, you use a project. A project holds\nconfiguration settings, mapping rules, and migration-specific details.\nRelational Migrator allows you to  import ,\n export , and  delete  projects.\nYou can also  manage the relational model \nfrom a project. There are multiple options for you to create a project: Option Description Create a Project By Connecting to a Live Database Provide source and destination connection details and migrate data from a live relational system. Create a Project by Loading a Schema From a File Export a Data Definition Language (DDL) file from your relational system and import it into Relational Migrator. Create a Project by Using a Sample Schema Use a predefined sample schema even if you do not have a relational system to connect to.",
            "code": [],
            "preview": "To interact with Relational Migrator, you use a project. A project holds\nconfiguration settings, mapping rules, and migration-specific details.\nRelational Migrator allows you to import,\nexport, and delete projects.\nYou can also manage the relational model\nfrom a project.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/manage-relational-connection",
            "title": "Manage the Relational Model",
            "headings": [
                "Add or Remove Tables from a Project",
                "Refresh Schema Changes",
                "Connect to database",
                "Import DDL File"
            ],
            "paragraphs": "You can use the  Manage  button on the  Schema model \npane to make changes to the schemas or tables you want to include in\nyour migration project. You can also connect to the source database\nor use a  DDL (Data Definition Language)  file to refresh the list of available tables. To change the tables you're migrating from your relational database, use\nthe  Manage  button. From the  Mapping  screen, click the  Manage  button on the\n Schema model  pane. Click the check box next to the schema or schemas you are migrating. To expand the tables in a schema, click the  \nbutton. Select the tables you want to add or remove from your migration. Click  Save . Changes from your relational database are reflected in the main\nRelational Migrator diagram and included in future sync jobs. If your relational database table structure changes, use the\n Refresh Schema  button to let Relational Migrator know. From the  Mapping  screen, click the  Manage \nbutton on the  Schema model  pane. Click the  Refresh schema  button on the Manage\nrelational model modal. Select either  Connect to database  or\n Import DDL File . Connect to database  rescans the schema. Changes in foreign key\nrelations or data types for the underlying tables are read into Migrator. Input the  JDBC URI ,  Username  and\n Password  for the database instance you are connecting to. The account used can be different from the credentials you used when\ncreating the project. Relational Migrator remembers the MongoDB URI and the username but not\nthe password. When you refresh the schema, re-enter the password. Click  Connect . Click  Save . Any changes from your relational database are reflected in\nthe main Relational Migrator diagram and included in future\nsync jobs. Import DDL File  opens a file prompt that accepts a  DDL (Data Definition Language)  file of the\nrelational schema you are migrating. Any changes in the foreign key relations or\ndata types for the underlying tables are read into Migrator. Select your  Database type . Relational Migrator currently supports the following database types: MySQL Oracle PostgreSQL SQL Server Choose a file or drag and drop a  DDL (Data Definition Language)  statement file. Click  Import . Click  Save . Any changes from your relational database are reflected in the main\nRelational Migrator diagram and included in future sync jobs.",
            "code": [],
            "preview": "You can use the Manage button on the Schema model\npane to make changes to the schemas or tables you want to include in\nyour migration project. You can also connect to the source database\nor use a DDL (Data Definition Language) file to refresh the list of available tables.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/import-project",
            "title": "Import a Project",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "You can use Relational Migrator to import projects. Import a project when you\nwant to collaborate on a shared project. You can also duplicate a project by\n exporting  the project and then importing it. Be aware of the following information when you import projects: When you import projects, Relational Migrator only uses  .relmig  files. Relational Migrator rejects files for import and returns an error message in\nthe following conditions: The format of the file cannot be determined or if critical information is\nmissing. The file was exported from an unsupported version of Relational Migrator The version number of the file is older than a well-defined minimum version. On your  home page , select  New Project . Select  Import an existing project . Choose a file, or drag and drop the  .relmig  file. Click  Import . Import a Project Rename a Project Delete a Project",
            "code": [],
            "preview": "You can use Relational Migrator to import projects. Import a project when you\nwant to collaborate on a shared project. You can also duplicate a project by\nexporting the project and then importing it.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/renaming-projects",
            "title": "Rename a Project",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "To update the name of an existing project, use the  Rename  option. The new name must be 1-50 characters long and can't be in use by another project. From the project view, click the  Home  icon in the top-left corner. Open the menu next to your project of choice. Select  Rename . Enter a new project name. Click  Save . Create a Project Delete a Project Import a Project Export a Project",
            "code": [],
            "preview": "To update the name of an existing project, use the Rename option.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/deleting-projects",
            "title": "Delete a Project",
            "headings": [
                "About this Task",
                "Steps",
                "Next Steps",
                "Learn More"
            ],
            "paragraphs": "Delete a project to remove migration workloads that are no longer needed. You cannot recover a deleted project. If the last project on the  Recent Projects  page is deleted, the\n New Project  page is displayed. From the  project view , click the  Home  icon in the\ntop-left corner. Open the menu next to your project of choice. Select  Delete . Click  Delete  to confirm. Create a Project Import a Project Rename a Project Export a Project",
            "code": [],
            "preview": "Delete a project to remove migration workloads that are no longer needed.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/export-project",
            "title": "Export a Project",
            "headings": [
                "About this Task",
                "Steps",
                "Learn More"
            ],
            "paragraphs": "Export Relational Migrator projects to share a project with other users, duplicate\na project, or back up a project. Relational Migrator can only export  .relmig  files. Exported project files do not include the sync job history or passwords. Open your project commands. To open your project commands from the  home page , click the ellipses\nnext to the project. To open your project commands from your  open project page , click\nthe ellipses on the left pane. Select  Export . Click  Export  to confirm. Your project is exported as a  .relmig  file. Import a Project Rename a Project Delete a Project",
            "code": [],
            "preview": "Export Relational Migrator projects to share a project with other users, duplicate\na project, or back up a project.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/configure-settings",
            "title": "Configuring Project Settings",
            "headings": [
                "Open Project Settings Dialog",
                "Configurable Project Settings",
                "Key Handling Options",
                "Key Handling Behavior",
                "Global Casing",
                "Suggested Mappings"
            ],
            "paragraphs": "After you create a Relational Migrator project, you can configure settings for that\nproject. To learn how to create a Relational Migrator project, see\n Creating a Project . To open the  Project Settings  dialog: From the Relational Migrator home page, click the target project. From the project view, the gear icon next to your project's name. You can configure the following settings for your project: Specifies how the  _id  field is populated when new documents are\ninserted into a collection. You can choose one of the following options: Autogenerated ObjectId Your  _id  field is populated with an autogenerated random\n ObjectId . Autogenered ObjectId  is the default key handling strategy used\nwhen creating a new project. You may choose to keep the original primary key as a different field\nin the collection. For example, if your relational table row has a primary key of  personId = 1 ,\nafter migration your MongoDB  _id  field is  _id: ObjectId(\"62472f3d5849820a91d7b52f\") . Single Inherited Primary Key Your  _id  field is populated with the value of the primary key\nfield. The name of your primary key field is not included in the  _id . For example, if your relational table row has a primary key of  personId=1 ,\nafter migration your MongoDB  _id  field is  _id: 1 . Wrapped Inherited Primary Key Your  _id  field is populated with an object where the key is the\nname of your primary key field and the value is the value of your\nprimary key field. For example, if your relational table row has a primary key of\n personId = 1 , after  migration your MongoDB  _id``field is\n``_id: { personId: 1 } . If your relational table has more than one field in its primary key\nand you select the  single  strategy, collections receiving data\nfrom that table use the  wrapped  key handling strategy. The\n single  strategy only works for tables that have a single primary\nkey. If your relational table does not have a primary key, collections\nreceiving data from that table use the  generated  strategy even if\nyou select a different global strategy. You can choose one of the following options: Keep Original : Keep the original casing used in your relational\ndatabase table name. Override with Global Casing : Override the original table name\nwith a global casing convention. camelCase TitleCase kebab-case snake_case UPPER_SNAKE_CASE Changing this setting after creating a project only impacts mappings\ncreated after the setting change. Mappings created prior to changing\nthis setting are not affected. Enabling  Suggested mappings  allows Relational Migrator to automatically\nsuggest mapping rules based upon your relational schema.",
            "code": [],
            "preview": "After you create a Relational Migrator project, you can configure settings for that\nproject.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/create-project-sample-schema",
            "title": "Create a Project by Using a Sample Schema",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Next Steps"
            ],
            "paragraphs": "You can create a project using a pre-defined sample schema. The sample schema allows\nyou to try Relational Migrator even if you don't have a relational database to\nconnect to. If you want to run a sync job for your sample project you can deploy\na Docker image containing the schema and data. (Optional) Host a Docker PostgreSQL instance or load data to the  Northwind  database. Create a project with the  Use a sample schema  project option. Select the database, schema, and tables that are part of the migration. Creating a project with a sample schema is the quickest and easiest way\nto test drive Relational Migrator. Before finalizing the creation of your project, you have the choice to\nselect the initial mappings. These options include starting with a\nrecommended MongoDB schema, which is automatically suggested by\nRelational Migrator based on your relational database. Before you can run sync jobs from the sample schema you must either: Download  Docker  to pull and host a provided\nPostgreSQL database container. This container comes preloaded with the sample\nschema presented in Relational Migrator. Download and execute the\n Northwind.sql \ndatabase setup script on an existing PostgreSQL instance. This script loads\nthe sample schema. The following steps guide you through the process of connecting to a Docker container\nwith the intent of migrating data with sync jobs. This is not a requirement, you can\ncreate a project without running sync jobs. If you do not plan on running sync jobs,\nskip step one. (Optional) From a terminal window, run the following Docker command to launch\na PostgreSQL relational database instance: The connection credentials for this database instance are: Username:  postgres Password:  postgres Port:  5432 The PostgreSQL database is for demo uses only and should not be used for\nproduction purposes. In Relational Migrator, click  New Project  at the top-right of the\nRelational Migrator home screen. Click the  Create sample  button. From the  Select tables  screen, indicate the tables you want to\nmigrate, and click  Next . The following table explains the different ways you can select tables to migrate: Target Action All tables within a database Click the check mark for the target database. All tables within a schema Expand the target database and click the check mark for the target schema. Specific tables within a schema Expand the target database and schema. Select the target tables individually. Specific table names Use the  Filter  bar above the  Relational Schema  list. Choose a  Global casing  option for collection names. This option affects the names of your collections created from the\ntables in your relational database: Keep Original : Keep the original casing used in your relational\ndatabase table name. Override with Global Casing : Override the original table name\nwith a global casing convention. camelCase TitleCase kebab-case snake_case UPPER_SNAKE_CASE Choose an  Initial mappings  option for your MongoDB schema. Creates your initial project with a new document mapping rule for each table. Relational Migrator creates mapping rules for a suggested MongoDB schema.\nWhen you choose this option, a table appears showing the imported relational tables.\nRelational Migrator suggests which tables should be represented as\n top-level  or  embedded  collections.\nYou can use the checkboxes to modify which tables are mapped into\ncollections or embedded. Creates your initial project with no mapping rules. Regardless of the option you choose when starting your project,\nyou have the flexibility to manually add, remove, or modify mapping\nrules at any time. This allows you to customize the MongoDB schema\naccording to the specific requirements of your workload. Enter a name for your project. Click  Done . Create Mapping Rules From Relational Create Mapping Rules To MongoDB",
            "code": [
                {
                    "lang": null,
                    "value": "docker run -p 5432:5432 public.ecr.aws/v4d7k6c9/relational-migrator-sample-database"
                }
            ],
            "preview": "You can create a project using a pre-defined sample schema. The sample schema allows\nyou to try Relational Migrator even if you don't have a relational database to\nconnect to. If you want to run a sync job for your sample project you can deploy\na Docker image containing the schema and data.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/create-project-live-connection",
            "title": "Create a Project By Connecting to a Live Database",
            "headings": [
                "About this Task",
                "Steps",
                "Next Steps"
            ],
            "paragraphs": "You can create a project using a live database connection.\nCreating a project is the first step in the migration process.\nWhen creating a project with a live connection you: Provide the connection details for your source relational system. Provide the connection details for your destination MongoDB deployment. Select the database, schema, and tables that are part of the migration. Creating a project with a live connection is the recommended process for starting a new Relational Migrator project. Before finalizing the creation of your project, you have the choice to\nselect the initial mappings. These options include starting with a\nrecommended MongoDB schema, which is automatically suggested by\nRelational Migrator based on your relational database. Click  New Project  at the top-right of the Relational Migrator home screen. Click the  Connect database  button. Select a database type. Relational Migrator supports migrating from the following\ndatabase types: MySQL Oracle PostgreSQL SQL Server Enter the connection details to create the JDBC URI for your relational database. Enter a host IP or DNS name in the  Host  text box. Enter a port number in the  Port  text box. Enter a database name in the  Database  text field. Depending on your\nrelational database, this behavior varies: Database Type Behavior Oracle The database name is required. You also need to specify a  Service ID \nor  SID . SQL Server Leaving database name blank loads all databases. MySQL Leaving database name blank loads all databases. Postgres Leaving database name blank loads schemas from the default database. Enter a user name in the  Username  text box. Enter a password in the  Password  text box. (Optional) Click the  Save a password for this session  check box to\navoid reentering your password in the project. Click the  SSL  toggle switch to enable or disable SSL and select an SSL mode. Click  Connect . Connection and SSL details depend on the database type you are connecting to.\nIn addition to the generic connection properties listed above, you may also\nneed to select an  Identifier  for Oracle and  Authentication  for SQL Server. If you want to specify the JDBC URI manually, click the  Enter URI manually \ntoggle switch on the  Connect to the database screen . For\ndetails see,  Relational Database Connection Strings . From the  Select tables  screen, indicate the tables you want to migrate\nand click  Next . The following table explains the different ways you can select tables to migrate: Target Action All tables within a database Click the check mark for the target database. All tables within a schema Expand the target database and click the check mark for the target schema. Specific tables within a schema Expand the target database and schema. Select the target tables individually. Specific table names Use the  Filter  bar above the  Relational Schema  list. Choose a  Global casing  option for collection names. This option affects the names of your collections created from the tables in\nyour relational database: Keep Original : Keep the original casing used in your relational\ndatabase table name. Override with Global Casing : Override the original table name\nwith a global casing convention. camelCase TitleCase kebab-case snake_case UPPER_SNAKE_CASE Choose an  Initial mappings  option for your MongoDB schema. Creates your initial project with a new document mapping rule for each table. Relational Migrator creates mapping rules for a suggested MongoDB schema.\nWhen you choose this option, a table appears showing the imported relational tables.\nRelational Migrator suggests which tables should be represented as\n top-level  or  embedded  collections.\nYou can use the checkboxes to modify which tables are mapped into\ncollections or embedded. Creates your initial project with no mapping rules. Regardless of the option you choose when starting your project,\nyou have the flexibility to manually add, remove, or modify mapping\nrules at any time. This allows you to customize the MongoDB schema\naccording to the specific requirements of your workload. Enter a name for your project. Click  Done . Create Mapping Rules From Relational Create Mapping Rules To MongoDB",
            "code": [],
            "preview": "You can create a project using a live database connection.\nCreating a project is the first step in the migration process.\nWhen creating a project with a live connection you:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "connection-strings/connection-strings",
            "title": "Connection Strings",
            "headings": [
                "Get Started"
            ],
            "paragraphs": "Relational Migrator uses connection strings to connect to both\nthe relational and MongoDB databases. You can create connection strings: Using the UI when you create a project. Using the UI when you create a sync job. By manually providing the Uniform Resource Identifier (URI). Relational Database Connection Strings MongoDB Database Connection Strings",
            "code": [],
            "preview": "Relational Migrator uses connection strings to connect to both\nthe relational and MongoDB databases. You can create connection strings:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "projects/create-project-loading-schema-files",
            "title": "Create a Project by Loading a Schema From a File",
            "headings": [
                "About this Task",
                "Before you Begin",
                "Steps",
                "Next Steps"
            ],
            "paragraphs": "You can create a project by submitting schema files from your relational\nsystem. Creating a project is the first step in the migration process.\nWhen creating a project with schema files you: Export a Data Definition Language (DDL) file from your relational system. Import the DDL file into Relational Migrator. Select the database, schema, and tables that are part of the migration. Relational Migrator only parses statements related to table, keys, and indexes.\nAny other non-DDL statements are ignored. The following workbench tools are documented for exporting table DDL files: You can use DDL files for project creation when network connectivity or permissions\nto your relational database are a consideration. Although you can create a project and map schemas from a DDL file, Relational Migrator\nstill connects to the relational database to run sync jobs. Oracle SQL Developer SQL Server Management Studio MySQL Workbench pgAdmin Before finalizing the creation of your project, you have the choice to\nselect the initial mappings. These options include starting with a\nrecommended MongoDB schema, which is automatically suggested by\nRelational Migrator based on your relational database. To create a project from schema files, you must export your schema files\nfrom your source relational system. Follow the instructions below\nto generate DDL files from your relational system. Open  Oracle SQL Developer . In the main menu, select  Tools  then  Database Export . Select the database connection. Uncheck  Export Data . On the  Specify Data  page, click  Lookup  and choose the\ntables you want to include. Open  SQL Server Management Studio (SSMS) . Under  Server Explorer , right-click the database. Select  Tasks  then  Generate Scripts . Select  Save script as file  and specify a file path. Open  MySQL Workbench . In the main menu, select  Server  then  Data Export . Select the schema objects to export. Choose  Dump Structure Only ,  Export to Self-Contained File \nand  Include Create Schema  options. Open  pgAdmin . Right-click the  Database  then  Backup . Enter a path, a filename, and select  Plain  format. Select  Dump options  and enable  Only schema . Select  Options  and enable  Include CREATE DATABASE statement . Click  New Project  at the top-right of the Relational Migrator home\nscreen. Click the  Import .SQL file  button. Select a database type. The Relational Migrator currently supports migrating\nfrom these database types: MySQL Oracle PostgreSQL SQL Server Choose or drag and drop a DDL statement file and click  Import . From the  Select tables  screen, indicate the tables you want to migrate,\nand click  Next . The following table explains the different ways you can select tables to migrate: Target Action All tables within a database Click the check mark for the target database. All tables within a schema Expand the target database and click the check mark for the target schema. Specific tables within a schema Expand the target database and schema. Select the target tables individually. Specific table names Use the  Filter  bar above the  Relational Schema  list. Choose a  Global casing  option for collection names. This option affects the names of your collections created from the tables in\nyour relational database: Keep Original : Keep the original casing used in your relational\ndatabase table name. Override with Global Casing : Override the original table name\nwith a global casing convention. camelCase TitleCase kebab-case snake_case UPPER_SNAKE_CASE Choose an  Initial mappings  option for your MongoDB schema. Creates your initial project with a new document mapping rule for each table. Relational Migrator creates mapping rules for a suggested MongoDB schema.\nWhen you choose this option, a table appears showing the imported relational tables.\nRelational Migrator suggests which tables should be represented as\n top-level  or  embedded  collections.\nYou can use the checkboxes to modify which tables are mapped into\ncollections or embedded. Creates your initial project with no mapping rules. Regardless of the option you choose when starting your project,\nyou have the flexibility to manually add, remove, or modify mapping\nrules at any time. This allows you to customize the MongoDB schema\naccording to the specific requirements of your workload. Enter a name for your project. Click  Done . Create Mapping Rules From Relational Create Mapping Rules To MongoDB",
            "code": [],
            "preview": "You can create a project by submitting schema files from your relational\nsystem. Creating a project is the first step in the migration process.\nWhen creating a project with schema files you:",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "connection-strings/mongodb-database-connection-strings",
            "title": "MongoDB Database Connection Strings",
            "headings": [
                "About this Task",
                "Atlas",
                "Connect to Your Deployment",
                "Create a New User",
                "Connection URI",
                "On-Premises",
                "Connect to Your Deployment",
                "Create a New User",
                "Connection URI",
                "Results"
            ],
            "paragraphs": "To start a migration job, Relational Migrator must connect to your MongoDB\ndatabase. Relational Migrator requires a username and password which has  readWrite \naccess in the target database. This page describes\nthe procedure to make an authenticated user account and the Uniform Resource\nIdentifier (URI) formats for defining connections to your target\nMongoDB database. URIs in Relational Migrator are optional. You can use the connection\nstring forms to enter your connection details instead of manually\nproviding URIs. Relational Migrator supports all connection string options except\n appName . Relational Migrator overrides the  appName \nconnection string option when connecting to your MongoDB deployment.\nFor details on MongoDB connection string options, see\n Connection Strings . Relational Migrator can use both Atlas and on-premises URIs. This page\nprovides separate instructions for each deployment type. To provision user accounts in Atlas you need to be\n logged in to the Atlas GUI . In the  Security  section of the left navigation, click  Database Access . Click  Add New Database User . In the  Authentication Method  section of the  Add New Database User  modal window, select the box labeled  Password . Under  Password Authentication , enter the username  migrator-service  for the new user in the top text field. Enter the password  password  for the new user in the lower text field. Under  Database User Privileges , click  Built-in Role . Select  Read and write to any database . Click  Add User . Using the previously created account credentials, format the connection\nURI for the target database. In this case  MongoEnterprises . In this example, use  mongosh  to provision a user account that\nconnects to the  MongoEnterprises  database. This examples assume your deployment is running on  localhost  and the\ndefault port of  27017 . When connecting to your deployment, your user account requires the\n createRole \npermission in both the  admin  and  MongoEnterprises  databases.\nCopy the following code with your admin credentials into a terminal to\nconnect to your deployment with  mongosh . For details on  mongosh  connections see :\n Connecting to your MongoDB Deployment . In  mongosh , run the following command to create a\nuser in the  admin  database: Create the same user in the user in the  MongoEnterprises  database: These commands: Create a new user  migrator-service  with the password  password \nin the  admin  and  MongoEnterprises  databases. Apply the  readWrite  system role to the  MongoEnterprises \ndatabase for the user  migrator-service . Using the previously created account credentials, format the connection\nURI for the target database. In this case  MongoEnterprises . The MongoDB connection URI is optionally specified as part of the process for\ncreating a Relational Migrator project or when creating a sync job.",
            "code": [
                {
                    "lang": null,
                    "value": "mongodb+srv://migrator-service:password@sandbox.xxxxx.mongodb.net/MongoEnterprises"
                },
                {
                    "lang": null,
                    "value": "mongosh \"mongodb://myadminuser:myadminpassword@localhost:27017/admin\""
                },
                {
                    "lang": null,
                    "value": "use admin\n\ndb.createUser(\n   { user: \"migrator-service\",\n      pwd: \"password\",\n      roles:[{role: \"readWrite\" , db:\"MongoEnterprises\"}]\n   }\n)"
                },
                {
                    "lang": null,
                    "value": "use MongoEnterprises\ndb.createUser(\n   { user: \"migrator-service\",\n      pwd: \"password\",\n      roles:[{role: \"readWrite\" , db:\"MongoEnterprises\"}]\n   }\n)"
                },
                {
                    "lang": null,
                    "value": "mongodb://migrator-service:password@localhost:27017/MongoEnterprises"
                }
            ],
            "preview": "To start a migration job, Relational Migrator must connect to your MongoDB\ndatabase. Relational Migrator requires a username and password which has readWrite\naccess in the target database. This page describes\nthe procedure to make an authenticated user account and the Uniform Resource\nIdentifier (URI) formats for defining connections to your target\nMongoDB database.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        },
        {
            "slug": "connection-strings/relational-database-connection-strings",
            "title": "Relational Database Connection Strings",
            "headings": [
                "MySQL",
                "Oracle",
                "PostgreSQL",
                "SQL Server",
                "databaseName Property Behavior"
            ],
            "paragraphs": "To analyze a schema or start a migration job, Relational Migrator must connect\nto your relational database. To connect to your source database,\nRelational Migrator requires a JDBC-formatted connection string. This document\ndescribes the URI formats for defining connections to relational\ndatabase systems. Relational Migrator can connect to the following relational database systems: Relational Migrator's connection form contains fields where you can specify a\nusername and password for the connection. The form obscures passwords\nand is more secure than specifying plaintext credentials in the URI. URIs in Relational Migrator are optional. You can use the connection\nstring forms to enter your connection details instead of manually\nproviding URIs. MySQL Oracle PostgreSQL SQL Server The general form for a MySQL connection string is: For example, consider the following connection string: The preceding connection string specifies these connection\ndetails: Property Value Host host1 Port 3306 Database test To learn more about MySQL connection strings, see: MySQL Connection URL Syntax Connection Configuration Properties The general form for an Oracle connection string is: For example, consider the following connection string: The preceding connection string specifies these connection\ndetails: Property Value Host prodHost Port 1521 SID (System Identifier) ORCL To learn more about Oracle connection strings, see: Oracle JDBC Developer's Guide and Reference Connection String Attributes The general form for a PostgreSQL connection string is: For example, consider the following connection string: The preceding connection string specifies these connection details: Property Value Host localhost Port 5432 Database pg-demo To learn more about PostgreSQL connection strings, see: PostgreSQL Connection Configuration Properties The general form for a SQL Server connection string is: For example, consider the following connection string: The preceding connection string specifies these connection details: Using Windows Integrated Authentication To enable Windows Integrated Authentication, add  integratedSecurity=true;  to the URI options.\nLeave the  Username  and  Password  fields blank. Windows Integrated Authentication connects\nto the database using the credentials of the user who launched the Relational Migrator executable. Using TLS JDBC connections to SQL Server use Transport Layer Security (TLS) by default.\nThe encrypt property controls TLS. To disable it, set  encrypt=false; .\nWhen TLS is enabled, the driver tries to validate the server's certificate by default.\nTo implicitly trust the server certificate, set  trustServerCertificate=true; . Property Value Host localhost Port 1433 databaseName test To learn more about SQL Server connection strings, see: Setting Connection Properties SQL Docs: Building the Connection URL . Connecting to SQL Server with the JDBC Driver In a SQL Server connection string, use the  databaseName  property to\nspecify the database to connect to. If you omit the  databaseName \nproperty, the connection still succeeds but you can only see objects in\nthe default  dbo  schema in all databases. If you specify the  databaseName  property, you can see tables from\nall schemas within the specified database.",
            "code": [
                {
                    "lang": null,
                    "value": "jdbc:mysql://<host:port>/<database>?<properties>"
                },
                {
                    "lang": null,
                    "value": "jdbc:mysql://host1:3306/test"
                },
                {
                    "lang": null,
                    "value": "jdbc:oracle:thin:@<host:port>:SID"
                },
                {
                    "lang": null,
                    "value": "jdbc:oracle:thin:@prodHost:1521:ORCL"
                },
                {
                    "lang": null,
                    "value": "jdbc:postgresql://<host:port>/<database>?<properties>"
                },
                {
                    "lang": null,
                    "value": "jdbc:postgresql://localhost:5432/pg-demo"
                },
                {
                    "lang": null,
                    "value": "jdbc:sqlserver://[serverName[\\instanceName][:portNumber]][;property=value[;property=value]]"
                },
                {
                    "lang": null,
                    "value": "jdbc:sqlserver://localhost:1433;databaseName=test"
                }
            ],
            "preview": "To analyze a schema or start a migration job, Relational Migrator must connect\nto your relational database. To connect to your source database,\nRelational Migrator requires a JDBC-formatted connection string. This document\ndescribes the URI formats for defining connections to relational\ndatabase systems.",
            "tags": null,
            "facets": {
                "target_product": [
                    "docs-relational-migrator"
                ]
            }
        }
    ]
}